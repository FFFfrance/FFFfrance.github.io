<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文献阅读：AIOS</title>
      <link href="/2022/103112139.html"/>
      <url>/2022/103112139.html</url>
      
        <content type="html"><![CDATA[<h1 id="文献阅读："><a href="#文献阅读：" class="headerlink" title="文献阅读："></a>文献阅读：</h1><h1 id="Asynchronous-I-x2F-O-Stack-A-Low-latency-Kernel-I-x2F-O-Stack-for-Ultra-Low-Latency-SSDs"><a href="#Asynchronous-I-x2F-O-Stack-A-Low-latency-Kernel-I-x2F-O-Stack-for-Ultra-Low-Latency-SSDs" class="headerlink" title="Asynchronous I&#x2F;O Stack: A Low-latency Kernel I&#x2F;O Stack for Ultra-Low Latency SSDs"></a>Asynchronous I&#x2F;O Stack: A Low-latency Kernel I&#x2F;O Stack for Ultra-Low Latency SSDs</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h2><ul><li>随着ssd发展，内核I&#x2F;O堆栈内部的操作不再是可以忽略的部分，我们提出异步I&#x2F;O堆栈(AIOS)，本文提出如下措施：  </li><li>①异步操作：使CPU的I&#x2F;O操作与设备I&#x2F;O重叠。  </li><li>②轻量级块层：针对NVMe ssd，没有块I&#x2F;O调度和合并，lbio取代bio和request。<h2 id="一：介绍："><a href="#一：介绍：" class="headerlink" title="一：介绍："></a>一：介绍：</h2></li><li>硬件不断发展，对于延迟极低的ssd，内核I&#x2F;O堆栈在总I&#x2F;O延迟中占了很大一部分并成为瓶颈，主流解决方法如下：  </li><li>①用户进程直接访问存储设备：需要应用程序有自己的块管理层或文件系统。  </li><li>②优化内核堆栈：例子包括：Ⅰ使用轮询机制来避免上下文切换的开销，Ⅱ在中断处理中删除下半部分，Ⅲ提出分散I&#x2F;O命令，Ⅳ简单的块I&#x2F;O调度等。  </li><li>思想：当前的I&#x2F;O堆栈实现需要许多操作来服务一个I&#x2F;O请求：当应用程序发出读I&#x2F;O请求时，将分配一个页并在页缓存中建立索引，然后，进行DMA映射，并分配和操作几个辅助数据结构(例如，Linux中的bio、request、iod)，使用超低延迟ssd，执行这些操作所需的时间与实际的I&#x2F;O数据传输时间相当。将这些操作与数据传输重叠可以大大减少端到端I&#x2F;O延迟。  </li><li>本文核心——Ⅰ：仔细分析read和fsync，确定了可以与设备I&#x2F;O操作重叠的与I&#x2F;O相关的CPU操作。<br>Ⅱ：为了进一步减少CPU开销，还引入了专门用于基于NVMe的ssd的轻量级块I&#x2F;O层LBIO。(LBIO)。  </li><li>linux IO过程标准栈：  <img src="/2022/103112139/2.jpg" class>   <h2 id="二：背景与动机："><a href="#二：背景与动机：" class="headerlink" title="二：背景与动机："></a>二：背景与动机：</h2></li><li>2.1：存储设备比cpu慢得多，但超低时延ssd可以实现超低的I&#x2F;O时延。而在内核中花费的时间量不会随着不同的ssd而改变，内核花费时间比例变大。在本文中针对Linux内核和Ext4文件系统中基于nvme的ssd的两个延迟敏感I&#x2F;O路径(read()和write()+fsync())。  </li><li>2.2：read路径：  <img src="/2022/103112139/1.jpg" class>   </li><li>VFS层：函数buffered_read()，它是页面缓存层的入口点。  </li><li>page cache层：当缓存丢失时(第3-4行)调用Page_cache_sync_readahead()，将缺失的文件块读入页缓存。它识别请求文件范围内所有丢失的索引(第18-19行)，分配页面并将页面与丢失的索引关联起来(第20-21行)。最后请求文件系统读取缺少的页面(第25行)。</li><li>file system层：在Ext4中ext4_readpages()将每个页面插入到页面缓存中(第30-31行)，检索页面的逻辑块地址(第32行)，并向底层块层发出块请求(第33-34行)。当调用blk_start_plug()时(第29行)，块请求被收集到当前线程的插件列表中。Linux对线程发出的多个块请求进行批处理，以提高底层请求处理的效率(也称为队列插入)。当调用blk_finish_plug()(第36行)或当前线程进行上下文切换时，收集的请求将刷新到块I&#x2F;O调度器。在向存储设备发出I&#x2F;O请求后，线程返回其调用堆栈，并在函数lock_page()处阻塞(第10行)。当I&#x2F;O请求完成时，中断处理程序释放页面的锁，这将唤醒阻塞的线程。最后，将缓存的数据复制到用户缓冲区(第11-12行)。  <img src="/2022/103112139/3.jpg" class>   </li><li>blokc layer层：图3显示了多队列块层(这是Linux内核中NVMe ssd的默认块层)和设备驱动程序层的概述。在块层中，bio对象使用slab分配器进行分配，并初始化为包含单个块请求的信息(即，LBA、I&#x2F;O大小和要复制的页面)(第33行)。<br>然后，submit_bio()(第34行)将bio对象转换为请求对象并将请求对象插入到请求队列中，在请求队列中执行I&#x2F;O合并和调度。请求对象通过每个核心的软件队列(ctx)和硬件队列(hctx)，最终到达设备驱动程序层。</li><li>device driver层：使用nvme_queue_rq()将请求分发到设备驱动程序。它首先分配一个iod对象，这是一个具有分散&#x2F;收集列表的结构，并使用它执行DMA(直接内存访问)映射，从而为已分派请求中的页面分配I&#x2F;O虚拟地址(或DMA地址)。然后，分配一个包含NVMe协议中物理区域页(PRP)的prp_list，用分配的DMA地址填充。最后，使用发出给NVMe提交队列的request和prp_list创建一个NVMe命令。在I&#x2F;O完成后，中断处理程序解除页面的DMA地址映射，并调用完成函数，该函数最终唤醒被阻塞的线程。</li><li><img src="/2022/103112139/4.jpg" class>   </li><li>！！！！！虽然上面描述了读路径中的基本操作，但写路径中的块层和设备驱动层的角色是相同的。</li><li>2.3：write路径：  </li><li>当应用程序调用fsync()时，内核实际上执行写I&#x2F;O，将脏数据同步到存储设备。而缓冲写路径没有机会与I&#x2F;O重叠，因为它不执行任何I&#x2F;O操作。另一方面，由于脏数据的回写以及文件系统中的崩溃一致性机制(例如，文件系统日志)，fsync伴随着几个I&#x2F;O操作。由于fsync在写路径上对应用程序性能影响最大，因此详细地研究它。  </li><li>图5(a)显示了使用有序日志记录在Ext4文件系统上执行fsync调用时的操作及其执行时间。首先，应用程序线程为脏文件块发出写I&#x2F; o，并等待它们完成。然后，应用程序线程唤醒一个日志记录线程(Ext4中的jbd2)来提交文件系统事务。它首先准备将修改后的元数据(图中的日志块)写入日志区域，并发出写I&#x2F;O。然后，它等待写操作完成。一旦完成，它就准备写提交块，并发出写I&#x2F;O。在日志块写入和提交块写入之间强制执行一个flush命令，以强制执行写入的顺序。因此，对于一个fsync调用，总共会发生三个设备I&#x2F;O操作。  </li><li>在读取路径的情况下，也有机会将设备I&#x2F;O操作与fsync路径中的计算部分重叠。如图5(a)所示，日志线程同步执行I&#x2F;O准备和I&#x2F;O等待。每个I&#x2F;O准备包括在日志区域分配要写入的块，分配缓冲页，分配&#x2F;提交bio对象，分配DMA地址，等等。如果这些CPU操作与之前的设备I&#x2F;O时间重叠，那么fsync系统调用的总延迟可以大大降低，如图5(b)所示。<img src="/2022/103112139/5.jpg" class>   </li><li>2.4：轻量级块层的灵感：  </li><li>Linux内核默认使用NVMe ssd的多队列块层，以很好地扩展多命令队列和多核cpu。该块层提供了块I&#x2F;O提交&#x2F;完成、请求合并&#x2F;重排序、I&#x2F;O调度和I&#x2F;O命令标记等功能。<br>虽然块I&#x2F;O提交&#x2F;完成和I&#x2F;O命令标记是必要的功能，但请求合并&#x2F;重排序和I&#x2F;O调度并不重要。多队列块层支持各种I&#x2F;O调度器，但它的默认配置是noop，因为许多研究报告称，对于快速存储设备上的时延关键应用程序，I&#x2F;O调度对于降低I&#x2F;O时延无效。I&#x2F;O调度也可以由设备端I&#x2F;O调度功能代替。在超低延迟ssd中，请求合并&#x2F;重排序的有效性也值得怀疑，因为它们具有较高的随机访问性能，而且找到相邻或相同的块请求的概率较低。</li><li>所以基于这些直觉，建议简化块层的角色，使其专门用于异步I&#x2F;O堆栈，以最小化其I&#x2F;O提交延迟。  <h2 id="三：AIOS："><a href="#三：AIOS：" class="headerlink" title="三：AIOS："></a>三：AIOS：</h2></li><li>AIOS由两个组件组成:轻量级块I&#x2F;O层(LBIO)和将I&#x2F;O相关计算与设备I&#x2F;O操作重叠的修改I&#x2F;O堆栈。  </li><li>3.1：轻量级块I&#x2F;O层(LBIO)：  <img src="/2022/103112139/6.jpg" class>   </li><li>①LBIO专为低延迟NVMe ssd设计，只支持I&#x2F;O提交&#x2F;完成和I&#x2F;O命令标记。图7显示了我们提议的LBIO的概述。  </li><li>②与原始的多队列块层不同，LBIO使用单个内存对象lbio来表示单个块I&#x2F;O请求，从而消除了原块层中bio到request的转换。每个lbio对象包含LBA、I&#x2F;O长度、要复制的页面和页面的DMA地址。在lbio中包含DMA地址可以利用以下部分中解释的异步DMA映射特性。lbio只支持4kb对齐的DMA地址和多个扇区的I&#x2F;O长度，以简化代码初始化和提交块I&#x2F;O请求。假设使用页面缓存层，这种方法是可行的。与原始的块层类似，LBIO支持队列插入，以批量处理由单个线程发出的多个块I&#x2F;O请求。  </li><li>③LBIO有一个全局的LBIO二维数组，它的行专门用于每个核心，一组行被分配给每个NVMe队列对，如图7所示。例如，如果系统有8个核和4个NVMe队列对，则lbio数组的每一行与每个核一一对应，连续的两行对应一个NVMe队列对。当NVMe队列对的数量等于内核的数量时，就可以像现有的多队列块层一样，实现无锁lbio对象分配和NVMe命令提交。lbio对象在全局数组中的索引被用作NVMe命令中的标记。这消除了原始块层中耗时的标记分配。<br>一旦提交了一个lbio，线程直接调用nvme_queue_lbio()来调度一个NVMe I&#x2F;O命令。<br>注意，LBIO不执行I&#x2F;O合并或I&#x2F;O调度，因此可以显著降低I&#x2F;O提交延迟。在没有I&#x2F;O合并的情况下，两个或多个lbio可以访问同一个逻辑块。这可能发生在读路径中，并由页面缓存层解决(参见第3.2节)。但是，这不会发生在写路径中，因为页缓存会同步脏页的回写。  </li><li>3.2：read路径：  </li><li>预加载段树：<br>对于读操作，检索与丢失的文件块对应的LBAs是发出块请求的必要步骤，因此该操作应该位于关键路径中。我们的建议不是将这一步从关键路径上移开，而是将重点放在减少延迟本身。Linux Ext4文件系统的实现将逻辑到物理文件块映射缓存到内存中，这个缓存称为区段状态树。当可以在缓存中找到映射时，获取LBA所需的时间相对较短;然而，当没有找到映射时，系统必须发出一个I&#x2F;O请求来读取丢失的映射块，从而导致更长的延迟。<br>为了避免这种不必要的开销，我们采用了平面分离方法。在控制平面(例如，打开文件)，整个映射信息被预加载到内存中。通过这样做，数据平面(例如，读和写)可以避免映射缓存丢失造成的延迟延迟。缓存整个树的内存成本可能很高;在我们的评估中，最坏情况下的开销是文件大小的0.03%。然而，当空闲内存很少时，区段缓存会清除不太可能使用的树节点，以保护空闲内存。为了进一步减少空间开销，可以选择性地将该技术应用于需要低延迟访问的文件。  </li><li>异步页面分配&#x2F;DMA映射：<br>为每个页面分配一个DMA地址(DMA映射)需要大量的CPU周期，所以我们为每个核心维护了一小组dma映射的空闲页面(一个4 KB dma映射页面的链表)。使用这种结构，只需要少量内存指令就可以从池中获取空闲页面。在发生设备I&#x2F;O操作时，通过调用页面分配和DMA映射来重新填充所消耗的页面。  </li><li>延迟页缓存索引：<br>在普通内核中，页面缓存充当同步点，它决定是否可以发出文件的块I&#x2F;O请求。允许将其缓存页成功插入到页面缓存中的文件块发出块请求(图2中的第31行)，并且使用自旋锁来保护页面缓存不受并发更新的影响。<br>因此，同一个文件块不会发生重复的I&#x2F;O提交。但是，如果在向设备提交I&#x2F;O命令后将页面缓存插入操作延迟到一定程度，则有可能导致另一个线程错过同一文件块，从而发出重复的块请求。确切地说，如果另一个线程在I&#x2F;O请求提交之后但在页面缓存条目更新之前访问页面缓存，就会发生这种情况。<br>我们的解决方案是允许重复的块请求，但在请求完成阶段解决它们。尽管有多个块请求与同一个文件块相关联，但页缓存中只有一个页被索引。然后，我们的方案将其他页面标记为已废弃。如果被标记为废弃，中断处理程序将释放与已完成的块请求相关的页面。</li><li>延迟DMA解映射：<br>读路径中的最后一个长延迟操作是DMA解除映射，它发生在设备I&#x2F;O请求完成之后。普通读路径在中断处理程序中处理这个问题，中断处理程序也在关键路径中。我们的方案将此操作延迟到系统空闲或等待另一个I&#x2F;O请求时(图4(b)中的Lazy DMA unmap)。</li><li>3.3：write和fsync路径：<br>①具体来说，我们将日志线程中的计算部分与相同写路径中的前面I&#x2F;O操作重叠。如图5(a)所示，有两种I&#x2F;O准备操作:日志块准备和提交块准备。每个准备操作包括分配缓冲页，在日志区域分配块，计算校验和和块和设备驱动层内的计算操作。因为这些操作只修改内存中的数据结构，所以它们不依赖于同一写路径上的前一个I&#x2F;O操作。<br>②我们更改fsync路径，如图5(b)所示。在调用fsync系统时，应用程序线程首先发出脏数据页的回写。然后，它提前唤醒日志线程，使数据块I&#x2F; o与日志线程中的计算部分重叠。应用程序线程最后等待回写I&#x2F; o的完成以及日志提交的完成。当数据块I&#x2F;O操作发生时，日志线程准备日志块写并发出它们的写I&#x2F;O。然后，它准备提交块写，并等待完成与当前事务相关的所有前面的I&#x2F;O操作。一旦完成，它发送一个flush命令到存储设备，以使之前的所有I&#x2F;O持久，最后使用一个透写I&#x2F;O命令(例如，SATA中的FUA)发出提交块的写I&#x2F;O。</li><li>3.4：实现：  <h2 id="四：评估："><a href="#四：评估：" class="headerlink" title="四：评估："></a>四：评估：</h2></li><li>read性能：①随机读取延迟。②轮询在延迟方面优于中断（消除了上下文切换）。③随机读取的吞吐量。④顺序读取带宽。  </li><li>write性能：①fsync性能。②fdatasync性能。</li><li>性能分析：读，写，安全成本。  </li><li>现实应用：①键值存储。②存储基准和OLTP工作负载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文献阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2022/070955046.html"/>
      <url>/2022/070955046.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划步骤"><a href="#动态规划步骤" class="headerlink" title="动态规划步骤"></a>动态规划步骤</h2><ul><li>确定DP数组和下标含义。  </li><li>确定递推公式。  </li><li>初始化DP数组。   </li><li>确定遍历顺序。   </li><li>举例推导DP数组。   <h2 id="动态规划常用题型"><a href="#动态规划常用题型" class="headerlink" title="动态规划常用题型"></a>动态规划常用题型</h2></li><li>背包问题（n个数组成k）</li><li>数组中若干数和为k的方法数</li><li>背包问题中的组合与排列（内外循环顺序）</li><li>最长连续子序列（子序列连续，子序列不连续）</li><li>最长递增序列，最大和</li><li>字符串子串判定，转换步数</li><li>回文字符串<h3 id="leetcode：509"><a href="#leetcode：509" class="headerlink" title="leetcode：509"></a>leetcode：509</h3><img src="/2022/070955046/1.jpg" class>    <pre><code>class Solution &#123;public:int fib(int n) &#123;  if(n&lt;=1) return n;  vector&lt;int&gt;dp(n+1);  dp[0]=0;  dp[1]=1;  for(int i=2;i&lt;=n;i++) dp[i]=dp[i-1]+dp[i-2];  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：70"><a href="#leetcode：70" class="headerlink" title="leetcode：70"></a>leetcode：70</h3><img src="/2022/070955046/2.jpg" class>    <pre><code>class Solution &#123;public:int climbStairs(int n) &#123;  if(n&lt;=1) return n;  vector&lt;int&gt;dp(n+1);  dp[1]=1;  dp[2]=2;  for(int i=3;i&lt;=n;i++)&#123;      dp[i]=dp[i-1]+dp[i-2];  &#125;  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：746"><a href="#leetcode：746" class="headerlink" title="leetcode：746"></a>leetcode：746</h3><img src="/2022/070955046/3.jpg" class>    <pre><code>class Solution &#123;public:int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;  int n = cost.size();  vector&lt;int&gt;dp(n+1);  dp[0]=0;  dp[1]=0;  for(int i=2;i&lt;=n;i++)&#123;      dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1]);  &#125;  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：62"><a href="#leetcode：62" class="headerlink" title="leetcode：62"></a>leetcode：62</h3><img src="/2022/070955046/4.jpg" class>    <pre><code>class Solution &#123;public:int uniquePaths(int m, int n) &#123;  int dp[m][n];  for(int i=0;i&lt;m;i++)&#123;      dp[i][0]=1;  &#125;  for(int j=0;j&lt;n;j++)&#123;      dp[0][j]=1;  &#125;  for(int i=1;i&lt;m;i++)&#123;      for(int j=1;j&lt;n;j++)&#123;          dp[i][j]=dp[i][j-1]+dp[i-1][j];      &#125;  &#125;  return dp[m-1][n-1];&#125;&#125;;</code></pre><h3 id="leetcode：63"><a href="#leetcode：63" class="headerlink" title="leetcode：63"></a>leetcode：63</h3><img src="/2022/070955046/5.jpg" class>    <pre><code>class Solution &#123;public:int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;  int m=obstacleGrid.size();  int n=obstacleGrid[0].size();  int dp[m][n];  for(int i=0;i&lt;m;i++) fill(dp[i],dp[i]+n,0);  for(int i=0;i&lt;m;i++)&#123;      if(obstacleGrid[i][0]==1) break;      dp[i][0]=1;  &#125;  for(int i=0;i&lt;n;i++)&#123;      if(obstacleGrid[0][i]==1) break;      dp[0][i]=1;  &#125;  for(int i=1;i&lt;m;i++)&#123;      for(int j=1;j&lt;n;j++)&#123;          if(obstacleGrid[i][j]==1) continue;          dp[i][j]=dp[i-1][j]+dp[i][j-1];      &#125;  &#125;  return dp[m-1][n-1];&#125;&#125;;</code></pre><h3 id="leetcode：343"><a href="#leetcode：343" class="headerlink" title="leetcode：343"></a>leetcode：343</h3><img src="/2022/070955046/6.jpg" class>    <pre><code>class Solution &#123;public:int integerBreak(int n) &#123;  int dp[n+1];  fill(dp,dp+n+1,0);  dp[2]=1;  for(int i=3;i&lt;=n;i++)&#123;      for(int j=1;j&lt;i-1;j++)&#123;          dp[i]=max(&#123;dp[i],(i-j)*j,j*dp[i-j]&#125;);      &#125;  &#125;  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：96"><a href="#leetcode：96" class="headerlink" title="leetcode：96"></a>leetcode：96</h3><img src="/2022/070955046/7.jpg" class>    <pre><code>class Solution &#123;public:int numTrees(int n) &#123;  int dp[n+1];  fill(dp,dp+n+1,0);  dp[0]=1;  for(int i=1;i&lt;=n;i++)&#123;      for(int j=1;j&lt;=i;j++)      dp[i]+=dp[j-1]*dp[i-j];  &#125;  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：416"><a href="#leetcode：416" class="headerlink" title="leetcode：416"></a>leetcode：416</h3><img src="/2022/070955046/8.jpg" class>    <pre><code>class Solution &#123;public:bool canPartition(vector&lt;int&gt;&amp; nums) &#123;  int sum=0;  for(int i=0;i&lt;nums.size();i++) sum+=nums[i];  if(sum%2==1) return false;  int target=sum/2;  int n=nums.size();  int dp[target+1];  fill(dp,dp+target+1,0);  for(int i=0;i&lt;nums.size();i++)&#123;      for(int j=target;j&gt;=nums[i];j--)&#123;          dp[j]=max(dp[j-nums[i]]+nums[i],dp[j]);      &#125;  &#125;  if(dp[target]==target) return true;  else return false;&#125;&#125;;</code></pre><h3 id="leetcode：494"><a href="#leetcode：494" class="headerlink" title="leetcode：494"></a>leetcode：494</h3><img src="/2022/070955046/9.jpg" class>    <pre><code>class Solution &#123;public:int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;  int all = 0;  for(int i=0;i&lt;nums.size();i++) all+=nums[i];  if(abs(target)&gt;all) return 0;  if( (all+target)%2==1) return 0;  int res = (all+target)/2;  int dp[res+1];  fill(dp,dp+res+1,0);  dp[0]=1;  for(int i=0;i&lt;nums.size();i++)&#123;      for(int j=res;j&gt;=nums[i];j--)&#123;          dp[j]+=dp[j-nums[i]];      &#125;  &#125;  return dp[res];&#125;&#125;;</code></pre><h3 id="leetcode：474"><a href="#leetcode：474" class="headerlink" title="leetcode：474"></a>leetcode：474</h3><img src="/2022/070955046/10.jpg" class>    <pre><code>class Solution &#123;public:int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;  int dp[m+1][n+1];  for(int i=0;i&lt;m+1;i++) fill(dp[i],dp[i]+n+1,0);  for(int i=0;i&lt;strs.size();i++)&#123;      int zeronum=0,onenum=0;      string temp = strs[i];      for(int j=0;j&lt;temp.size();j++)&#123;          if(temp[j]==&#39;0&#39;) zeronum++;          else onenum++;      &#125;      for(int u=m;u&gt;=zeronum;u--)      &#123;          for(int v=n;v&gt;=onenum;v--)&#123;              dp[u][v]=max(dp[u-zeronum][v-onenum]+1,dp[u][v]);          &#125;      &#125;  &#125;  return dp[m][n];&#125;&#125;;</code></pre><h3 id="leetcode：518"><a href="#leetcode：518" class="headerlink" title="leetcode：518"></a>leetcode：518</h3><img src="/2022/070955046/11.jpg" class>    <pre><code>class Solution &#123;public:int change(int amount, vector&lt;int&gt;&amp; coins) &#123;  int dp[amount+1];  fill(dp,dp+amount+1,0);  dp[0]=1;  for(int i=0;i&lt;coins.size();i++)&#123;      for(int j=coins[i];j&lt;=amount;j++)&#123;          dp[j]+=dp[j-coins[i]];      &#125;  &#125;  return dp[amount];&#125;&#125;;</code></pre><h3 id="leetcode：377"><a href="#leetcode：377" class="headerlink" title="leetcode：377"></a>leetcode：377</h3><img src="/2022/070955046/12.jpg" class>    <pre><code>class Solution &#123;public:int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;  int dp[target+1];  fill(dp,dp+target+1,0);  dp[0]=1;  for(int i=0;i&lt;=target;i++)&#123;      for(int j=0;j&lt;nums.size();j++)&#123;          if(i&gt;=nums[j]&amp;&amp;dp[i]&lt;INT_MAX-dp[i-nums[j]]) &#123;              dp[i]+=dp[i-nums[j]];          &#125;      &#125;  &#125;  return dp[target];&#125;&#125;;</code></pre><h3 id="leetcode：322"><a href="#leetcode：322" class="headerlink" title="leetcode：322"></a>leetcode：322</h3><img src="/2022/070955046/13.jpg" class>    <pre><code>class Solution &#123;public:int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;  int dp[amount+1];  //求最少金币数，则初始化最大，dp[0]为0  //若是求最多金币数，则初始化0，dp[0]为1  fill(dp,dp+amount+1,INT_MAX);  dp[0]=0;  for(int i=0;i&lt;coins.size();i++)&#123;      for(int j=coins[i];j&lt;=amount;j++)&#123;          //判断是不是初始情况，不是则使用，是则跳过          if(dp[j-coins[i]]!=INT_MAX)          dp[j]=min(dp[j],dp[j-coins[i]]+1);      &#125;  &#125;  if(dp[amount]==INT_MAX) return -1;  else return dp[amount];&#125;&#125;;</code></pre><h3 id="leetcode：279"><a href="#leetcode：279" class="headerlink" title="leetcode：279"></a>leetcode：279</h3><img src="/2022/070955046/14.jpg" class>    <pre><code>class Solution &#123;public:int numSquares(int n) &#123;  int dp[n+1];  fill(dp,dp+n+1,INT_MAX);  dp[0]=0;  //物品从1开始  for(int i=1;i*i&lt;=n;i++)&#123;      //背包从1开始      for(int j=1;j&lt;=n;j++)&#123;          if(j-i*i&gt;=0)&#123;              dp[j]=min(dp[j],dp[j-i*i]+1);          &#125;      &#125;  &#125;  return dp[n];&#125;&#125;;</code></pre><h3 id="leetcode：139"><a href="#leetcode：139" class="headerlink" title="leetcode：139"></a>leetcode：139</h3>    <pre><code>class Solution &#123;public:  bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;      unordered_set&lt;string&gt; wordSet(wordDict.begin(), wordDict.end());      vector&lt;bool&gt; dp(s.size() + 1, false);      dp[0] = true;      for (int i = 1; i &lt;= s.size(); i++) &#123;             // 遍历背包          for (int j = 0; j &lt; i; j++) &#123;                     // 遍历物品              string word = s.substr(j, i - j);               //substr(起始位置，截取的个数)              if (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123;                  dp[i] = true;              &#125;          &#125;      &#125;      return dp[s.size()];  &#125;&#125;;</code></pre><h3 id="leetcode：121"><a href="#leetcode：121" class="headerlink" title="leetcode：121"></a>leetcode：121</h3><img src="/2022/070955046/16.jpg" class>    <pre><code>class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123;  int n = prices.size();  int dp[n][2];  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+2,0);  dp[0][0]=-prices[0];  dp[0][1]=0;  for(int i=1;i&lt;n;i++)&#123;      dp[i][0]=max(dp[i-1][0],-prices[i]);      dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);  &#125;  return dp[n-1][1];&#125;&#125;;</code></pre><h3 id="leetcode：122"><a href="#leetcode：122" class="headerlink" title="leetcode：122"></a>leetcode：122</h3><img src="/2022/070955046/17.jpg" class>    <pre><code>class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123;  int n = prices.size();  int dp[n][2];  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+2,0);  dp[0][0]=-prices[0];  dp[0][1]=0;  for(int i=1;i&lt;n;i++)&#123;      dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i]);      dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);  &#125;  return dp[n-1][1];&#125;&#125;;</code></pre><h3 id="leetcode：123"><a href="#leetcode：123" class="headerlink" title="leetcode：123"></a>leetcode：123</h3><img src="/2022/070955046/18.jpg" class>    <pre><code>class Solution &#123;public:int maxProfit(vector&lt;int&gt;&amp; prices) &#123;  int n = prices.size();  int dp[n][4];  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+4,0);  dp[0][0]=-prices[0];  dp[0][1]=0;  dp[0][2]=-prices[0];  dp[0][3]=0;  for(int i=1;i&lt;n;i++)&#123;      dp[i][0]=max(dp[i-1][0],-prices[i]);      dp[i][1]=max(dp[i-1][1],dp[i-1][0]+prices[i]);      dp[i][2]=max(dp[i-1][2],dp[i-1][1]-prices[i]);      dp[i][3]=max(dp[i-1][3],dp[i-1][2]+prices[i]);  &#125;  return dp[n-1][3];&#125;&#125;;</code></pre><h3 id="leetcode：188"><a href="#leetcode：188" class="headerlink" title="leetcode：188"></a>leetcode：188</h3><img src="/2022/070955046/19.jpg" class>    <pre><code>class Solution &#123;public:int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123;  int n = prices.size();  if(n==0||k==0) return 0;  int dp[n][2*k];  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+2*k,0);  for(int i=0;i&lt;2*k;i+=2) dp[0][i]=-prices[0];  for(int i=1;i&lt;n;i++)&#123;      for(int j=0;j&lt;=2*k-1;j++)&#123;          if(j==0)&#123;              dp[i][j]=max(dp[i-1][j],-prices[i]);              continue;          &#125;          if(j%2==1) dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+prices[i]);          else dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]-prices[i]);      &#125;  &#125;  return dp[n-1][2*k-1];&#125;&#125;;</code></pre><h3 id="leetcode：300"><a href="#leetcode：300" class="headerlink" title="leetcode：300"></a>leetcode：300</h3><img src="/2022/070955046/20.jpg" class>    <pre><code>class Solution &#123;public:int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;  int n=nums.size();  int dp[n];  fill(dp,dp+n,1);  for(int i=1;i&lt;n;i++)&#123;      for(int j=0;j&lt;i;j++)&#123;          if(nums[j]&lt;nums[i]) dp[i]=max(dp[i],dp[j]+1);      &#125;  &#125;  int result=0;  for(int i=0;i&lt;n;i++)&#123;      result=max(result,dp[i]);  &#125;  return result;&#125;&#125;;</code></pre><h3 id="leetcode：674"><a href="#leetcode：674" class="headerlink" title="leetcode：674"></a>leetcode：674</h3><img src="/2022/070955046/21.jpg" class>    <pre><code>class Solution &#123;public:int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;  int n=nums.size();  if(n==0) return 0;  if(n==1) return 1;  int dp[n];  fill(dp,dp+n,1);  for(int i=1;i&lt;n;i++)&#123;      if(nums[i]&gt;nums[i-1])&#123;          dp[i]=max(dp[i],dp[i-1]+1);      &#125;  &#125;  int ans=0;  for(int i=1;i&lt;n;i++)&#123;      ans=max(ans,dp[i]);  &#125;  return ans;&#125;&#125;;</code></pre><h3 id="leetcode：718"><a href="#leetcode：718" class="headerlink" title="leetcode：718"></a>leetcode：718</h3><img src="/2022/070955046/22.jpg" class>    <pre><code>class Solution &#123;public:int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;  int x=nums1.size();  int y=nums2.size();  int dp[x+1][y+1];  for(int i=0;i&lt;=x;i++) fill(dp[i],dp[i]+y+1,0);  int res=0;  for(int i=1;i&lt;=x;i++)&#123;      for(int j=1;j&lt;=y;j++)&#123;          if(nums1[i-1]==nums2[j-1])&#123;              dp[i][j]=dp[i-1][j-1]+1;          &#125;          if(dp[i][j]&gt;res) res=dp[i][j];      &#125;  &#125;  return res;&#125;&#125;;</code></pre><h3 id="leetcode：1143"><a href="#leetcode：1143" class="headerlink" title="leetcode：1143"></a>leetcode：1143</h3><img src="/2022/070955046/23.jpg" class>    <pre><code>class Solution &#123;public:int longestCommonSubsequence(string text1, string text2) &#123;  int n=text1.size();  int m=text2.size();  int dp[n+1][m+1];  for(int i=0;i&lt;n+1;i++) fill(dp[i],dp[i]+m+1,0);  int res=0;  for(int i=1;i&lt;=n;i++)&#123;      for(int j=1;j&lt;=m;j++)&#123;          if(text1[i-1]==text2[j-1])&#123;              dp[i][j]=dp[i-1][j-1]+1;          &#125;else &#123;              dp[i][j]=max(dp[i-1][j],dp[i][j-1]);          &#125;          res=max(res,dp[i][j]);      &#125;  &#125;  return res;&#125;&#125;;</code></pre><h3 id="leetcode：1135"><a href="#leetcode：1135" class="headerlink" title="leetcode：1135"></a>leetcode：1135</h3><img src="/2022/070955046/24.jpg" class>    <pre><code>class Solution &#123;public:int maxUncrossedLines(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;  int n=nums1.size();  int m=nums2.size();  int dp[n+1][m+1];  for(int i=0;i&lt;=n;i++) fill(dp[i],dp[i]+m+1,0);  int res=0;  for(int i=1;i&lt;=n;i++)&#123;      for(int j=1;j&lt;=m;j++)&#123;          if(nums1[i-1]==nums2[j-1])&#123;              dp[i][j]=dp[i-1][j-1]+1;          &#125;else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);          res=max(res,dp[i][j]);      &#125;  &#125;  return res;&#125;&#125;;</code></pre><h3 id="leetcode：53"><a href="#leetcode：53" class="headerlink" title="leetcode：53"></a>leetcode：53</h3><img src="/2022/070955046/25.jpg" class>    <pre><code>class Solution &#123;public:int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;  int n=nums.size();  int dp[n];  dp[0]=nums[0];  int res=nums[0];  for(int i=1;i&lt;n;i++)&#123;      dp[i]=max(nums[i],dp[i-1]+nums[i]);      res=max(res,dp[i]);  &#125;  return res;&#125;&#125;;</code></pre><h3 id="leetcode：392"><a href="#leetcode：392" class="headerlink" title="leetcode：392"></a>leetcode：392</h3><img src="/2022/070955046/26.jpg" class>    <pre><code>class Solution &#123;public:bool isSubsequence(string s, string t) &#123;  int n=s.size();  int m=t.size();  int dp[n+1][m+1];  for(int i=0;i&lt;=n;i++) fill(dp[i],dp[i]+m+1,0);  for(int i=1;i&lt;=n;i++)  &#123;      for(int j=1;j&lt;=m;j++)      &#123;          if(s[i-1]==t[j-1])&#123;              dp[i][j]=dp[i-1][j-1]+1;          &#125;else dp[i][j]=dp[i][j-1];      &#125;  &#125;  if(dp[n][m]==s.size()) return true;  else return false;&#125;&#125;;</code></pre><h3 id="leetcode：115"><a href="#leetcode：115" class="headerlink" title="leetcode：115"></a>leetcode：115</h3><img src="/2022/070955046/27.jpg" class>    <pre><code>class Solution &#123;public:int numDistinct(string s, string t) &#123;  int n=s.size();  int m=t.size();  unsigned long long dp[n+1][m+1];  for(int i=0;i&lt;n+1;i++) dp[i][0]=1;  for(int i=1;i&lt;m+1;i++) dp[0][i]=0;  for(int i=1;i&lt;=n;i++)  &#123;      for(int j=1;j&lt;=m;j++)      &#123;          if(s[i-1]==t[j-1])&#123;              dp[i][j]=dp[i-1][j-1]+dp[i-1][j];          &#125;else dp[i][j]=dp[i-1][j];      &#125;  &#125;  return dp[n][m];&#125;&#125;;</code></pre><h3 id="leetcode：583"><a href="#leetcode：583" class="headerlink" title="leetcode：583"></a>leetcode：583</h3><img src="/2022/070955046/28.jpg" class>    <pre><code>class Solution &#123;public:int minDistance(string word1, string word2) &#123;  int n=word1.size();  int m=word2.size();  int dp[n+1][m+1];  for(int i=0;i&lt;=n;i++) dp[i][0]=i;  for(int i=0;i&lt;=m;i++) dp[0][i]=i;  for(int i=1;i&lt;=n;i++)  &#123;      for(int j=1;j&lt;=m;j++)      &#123;          if(word1[i-1]==word2[j-1])          &#123;              dp[i][j]=dp[i-1][j-1];          &#125;else          &#123;              dp[i][j]=min(&#123;dp[i-1][j-1]+2,dp[i-1][j]+1,dp[i][j-1]+1&#125;);          &#125;      &#125;  &#125;  return dp[n][m];&#125;&#125;;</code></pre><h3 id="leetcode：72"><a href="#leetcode：72" class="headerlink" title="leetcode：72"></a>leetcode：72</h3><img src="/2022/070955046/29.jpg" class>    <pre><code>class Solution &#123;public:int minDistance(string word1, string word2) &#123;  int n=word1.size();  int m=word2.size();  int dp[n+1][m+1];  for(int i=0;i&lt;=n;i++) dp[i][0]=i;  for(int i=0;i&lt;=m;i++) dp[0][i]=i;  for(int i=1;i&lt;=n;i++)  &#123;      for(int j=1;j&lt;=m;j++)      &#123;          if(word1[i-1]==word2[j-1])          &#123;              dp[i][j]=dp[i-1][j-1];          &#125;else &#123;              dp[i][j]=min(&#123;dp[i-1][j],dp[i][j-1],dp[i-1][j-1]&#125;)+1;          &#125;      &#125;  &#125;  return dp[n][m];&#125;&#125;;</code></pre><h3 id="leetcode：647"><a href="#leetcode：647" class="headerlink" title="leetcode：647"></a>leetcode：647</h3><img src="/2022/070955046/30.jpg" class>    <pre><code>class Solution &#123;public:int countSubstrings(string s) &#123;  int n=s.size();  bool dp[n][n];  int res=0;  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+n,false);  for(int i=n-1;i&gt;=0;i--)  &#123;      for(int j=i;j&lt;n;j++)      &#123;          if(s[i]==s[j])          &#123;              if(j-i&lt;=1)&#123;                  res++;                  dp[i][j]=true;              &#125;else if(dp[i+1][j-1])&#123;                  res++;                  dp[i][j]=true;              &#125;          &#125;      &#125;  &#125;  return res;&#125;&#125;;</code></pre><h3 id="leetcode：516"><a href="#leetcode：516" class="headerlink" title="leetcode：516"></a>leetcode：516</h3><img src="/2022/070955046/31.jpg" class>    <pre><code>class Solution &#123;public:int longestPalindromeSubseq(string s) &#123;  int n=s.size();  int dp[n][n];  for(int i=0;i&lt;n;i++) fill(dp[i],dp[i]+n,0);  for(int i=0;i&lt;n;i++) dp[i][i]=1;  for(int i=n-1;i&gt;=0;i--)  &#123;      for(int j=i+1;j&lt;n;j++)      &#123;          if(s[i]==s[j])&#123;              dp[i][j]=dp[i+1][j-1]+2;          &#125;else &#123;              dp[i][j]=max(dp[i+1][j],dp[i][j-1]);          &#125;      &#125;  &#125;  return dp[0][n-1];&#125;&#125;;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/070860033.html"/>
      <url>/2022/070860033.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h2 id="回溯算法适用题目"><a href="#回溯算法适用题目" class="headerlink" title="回溯算法适用题目"></a>回溯算法适用题目</h2><ul><li>组合问题：N个数找K个数的集合。  </li><li>切割问题：字符串切割N个子串。  </li><li>子集问题：N个数的集合中有多少个子集。   </li><li>排列问题：N个数全排列。   </li><li>棋盘问题：数独与N皇后等。   <h3 id="leetcode：77"><a href="#leetcode：77" class="headerlink" title="leetcode：77"></a>leetcode：77</h3><img src="/2022/070860033/1.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(int n,int k,int index)&#123;  if(path.size()==k)&#123;      result.push_back(path);      return;  &#125;  for(int i=index;i&lt;=n;i++)&#123;      path.push_back(i);      bt(n,k,i+1);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;  result.clear();  path.clear();  bt(n,k,1);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：215"><a href="#leetcode：215" class="headerlink" title="leetcode：215"></a>leetcode：215</h3><img src="/2022/070860033/2.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(int sum,int index,int k,int n)&#123;  if(sum&gt;n) return;  if(sum==n&amp;&amp;path.size()==k)&#123;      result.push_back(path);      return;  &#125;  for(int i=index;i&lt;=9;i++)&#123;      path.push_back(i);      bt(sum+i,i+1,k,n);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;  result.clear();  path.clear();  bt(0,1,k,n);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：17"><a href="#leetcode：17" class="headerlink" title="leetcode：17"></a>leetcode：17</h3><img src="/2022/070860033/3.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;string&gt;path;string temp;string mz[10]=&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;;void bt(string digits,int num,int n)&#123;  if(num==n)&#123;      path.push_back(temp);      return;  &#125;  int number=digits[num]-&#39;0&#39;;  for(int i=0;i&lt;mz[number].size();i++)&#123;      temp.push_back(mz[number][i]);      bt(digits,num+1,n);      temp.pop_back();  &#125;&#125;vector&lt;string&gt; letterCombinations(string digits) &#123;  if(digits.size()==0) return path;  bt(digits,0,digits.size());  return path;&#125;&#125;;</code></pre><h3 id="leetcode：39"><a href="#leetcode：39" class="headerlink" title="leetcode：39"></a>leetcode：39</h3><img src="/2022/070860033/4.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(vector&lt;int&gt; candidates, int target,int sum,int index)&#123;  if(sum&gt;target) return;  if(sum==target)&#123;      result.push_back(path);      return;  &#125;  for(int i=index;i&lt;candidates.size();i++)&#123;      path.push_back(candidates[i]);      bt(candidates,target,sum+candidates[i],i);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;  result.clear();  path.clear();  bt(candidates,target,0,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：40"><a href="#leetcode：40" class="headerlink" title="leetcode：40"></a>leetcode：40</h3><img src="/2022/070860033/5.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(vector&lt;int&gt; candidates, int target,int sum,int index)&#123;  if(sum&gt;target) return;  if(sum==target)&#123;      result.push_back(path);      return;  &#125;  for(int i=index;i&lt;candidates.size();i++)&#123;      if(i&gt;index&amp;&amp;candidates[i]==candidates[i-1]) continue;      path.push_back(candidates[i]);      bt(candidates,target,sum+candidates[i],i+1);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;  result.clear();  path.clear();  sort(candidates.begin(),candidates.end());  bt(candidates,target,0,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：113"><a href="#leetcode：113" class="headerlink" title="leetcode：113"></a>leetcode：113</h3><img src="/2022/070860033/6.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;string&gt;&gt;result;vector&lt;string&gt;path;void bt(string s,int index)&#123;  if(s.size()&lt;=index) &#123;      result.push_back(path);      return;  &#125;  for(int i=index;i&lt;s.size();i++)&#123;      if(isPar(s,index,i))&#123;          string str = s.substr(index,i-index+1);          path.push_back(str);      &#125;else continue;      bt(s,i+1);      path.pop_back();  &#125;&#125;bool isPar(string s,int left,int right)&#123;  for(int i=left,j=right;i&lt;j;i++,j--)&#123;      if(s[i]!=s[j])&#123;          return false;      &#125;  &#125;  return true;&#125;vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;  bt(s,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：93"><a href="#leetcode：93" class="headerlink" title="leetcode：93"></a>leetcode：93</h3><img src="/2022/070860033/7.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;string&gt;path;void bt(string &amp;s,int index,int num)&#123;  if(num==3)&#123;      if(isValid(s,index,s.size()-1))&#123;          path.push_back(s);      &#125;      return;  &#125;  for(int i=index;i&lt;s.size();i++)&#123;      if(isValid(s,index,i))&#123;          s.insert(s.begin()+i+1,&#39;.&#39;);          bt(s,i+2,num+1);          s.erase(s.begin()+i+1);      &#125;else break;  &#125;&#125;bool isValid(string s,int st,int ed)&#123;  if(st&gt;ed) return false;  if(s[st]==&#39;0&#39;&amp;&amp;st!=ed)&#123;      return false;  &#125;  int num=0;  for(int i=st;i&lt;=ed;i++)&#123;      if(s[i]&gt;&#39;9&#39;||s[i]&lt;&#39;0&#39;) return false;      num=num*10+(s[i]-&#39;0&#39;);      if(num&gt;255) return false;  &#125;  return true;&#125;vector&lt;string&gt; restoreIpAddresses(string s) &#123;  if(s.size()&gt;12) return path;  bt(s,0,0);  return path;&#125;&#125;;</code></pre><h3 id="leetcode：78"><a href="#leetcode：78" class="headerlink" title="leetcode：78"></a>leetcode：78</h3><img src="/2022/070860033/8.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(vector&lt;int&gt;&amp; nums,int index)&#123;  result.push_back(path);  if(index&gt;=nums.size()) return;  for(int i=index;i&lt;nums.size();i++)&#123;      path.push_back(nums[i]);      bt(nums,i+1);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;  result.clear();  path.clear();  bt(nums,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：90"><a href="#leetcode：90" class="headerlink" title="leetcode：90"></a>leetcode：90</h3><img src="/2022/070860033/9.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(vector&lt;int&gt;&amp; nums,int index)&#123;  result.push_back(path);  if(index&gt;=nums.size()) return;  for(int i=index;i&lt;nums.size();i++)&#123;      if(i&gt;index&amp;&amp;nums[i]==nums[i-1]) continue;      path.push_back(nums[i]);      bt(nums,i+1);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;  result.clear();  path.clear();  sort(nums.begin(),nums.end());  bt(nums,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：491"><a href="#leetcode：491" class="headerlink" title="leetcode：491"></a>leetcode：491</h3><img src="/2022/070860033/10.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;void bt(vector&lt;int&gt;&amp; nums,int index)&#123;  if(path.size()&gt;=2)&#123;      result.push_back(path);  &#125;  int used[201]=&#123;0&#125;;  for(int i=index;i&lt;nums.size();i++)&#123;      if((!path.empty()&amp;&amp;nums[i]&lt;path.back())||used[nums[i]+100]==1)           continue;      used[nums[i]+100]=1;      path.push_back(nums[i]);      bt(nums,i+1);      path.pop_back();  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;  result.clear();  path.clear();  bt(nums,0);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：46"><a href="#leetcode：46" class="headerlink" title="leetcode：46"></a>leetcode：46</h3><img src="/2022/070860033/11.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;bool vis[100]=&#123;false&#125;;void bt(vector&lt;int&gt;&amp; nums)&#123;  if(path.size()==nums.size())&#123;      result.push_back(path);      return;  &#125;  for(int i=0;i&lt;nums.size();i++)&#123;      if(vis[i]==true) continue;      vis[i]=true;      path.push_back(nums[i]);      bt(nums);      path.pop_back();      vis[i]=false;  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;  result.clear();  path.clear();  bt(nums);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：47"><a href="#leetcode：47" class="headerlink" title="leetcode：47"></a>leetcode：47</h3><img src="/2022/070860033/12.jpg" class>   <pre><code>class Solution &#123;public:vector&lt;vector&lt;int&gt;&gt;result;vector&lt;int&gt;path;bool vis[100]=&#123;false&#125;;void bt(vector&lt;int&gt;&amp; nums)&#123;  if(path.size()==nums.size())&#123;      result.push_back(path);      return;  &#125;  for(int i=0;i&lt;nums.size();i++)&#123;      if(vis[i]==true||(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;vis[i-1]==true)) continue;      vis[i]=true;      path.push_back(nums[i]);      bt(nums);      path.pop_back();      vis[i]=false;  &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;  result.clear();  path.clear();  sort(nums.begin(),nums.end());  bt(nums);  return result;&#125;&#125;;</code></pre><h3 id="leetcode：51"><a href="#leetcode：51" class="headerlink" title="leetcode：51"></a>leetcode：51</h3><img src="/2022/070860033/13.jpg" class>   <pre><code>class Solution &#123;private:vector&lt;vector&lt;string&gt;&gt; result;// n 为输入的棋盘大小// row 是当前递归到***的第几行了void backtracking(int n, int row, vector&lt;string&gt;&amp; chessboard) &#123;  if (row == n) &#123;      result.push_back(chessboard);      return;  &#125;  for (int col = 0; col &lt; n; col++) &#123;      if (isValid(row, col, chessboard, n)) &#123; // 验证合法就可以放          chessboard[row][col] = &#39;Q&#39;; // 放置皇后          backtracking(n, row + 1, chessboard);          chessboard[row][col] = &#39;.&#39;; // 回溯，撤销皇后      &#125;  &#125;&#125;bool isValid(int row, int col, vector&lt;string&gt;&amp; chessboard, int n) &#123;  int count = 0;  // 检查列  for (int i = 0; i &lt; row; i++) &#123; // 这是一个剪枝      if (chessboard[i][col] == &#39;Q&#39;) &#123;          return false;      &#125;  &#125;  // 检查 45度角是否有皇后  for (int i = row - 1, j = col - 1; i &gt;=0 &amp;&amp; j &gt;= 0; i--, j--) &#123;      if (chessboard[i][j] == &#39;Q&#39;) &#123;          return false;      &#125;  &#125;  // 检查 135度角是否有皇后  for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;      if (chessboard[i][j] == &#39;Q&#39;) &#123;          return false;      &#125;  &#125;  return true;&#125;public:  vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;      result.clear();      std::vector&lt;std::string&gt; chessboard(n, std::string(n, &#39;.&#39;));      backtracking(n, 0, chessboard);      return result;  &#125;&#125;;</code></pre><h3 id="leetcode：37"><a href="#leetcode：37" class="headerlink" title="leetcode：37"></a>leetcode：37</h3><img src="/2022/070860033/14.jpg" class>   <pre><code>class Solution &#123;public:bool bt(vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123;  for(int i=0;i&lt;board.size();i++)&#123;      for(int j=0;j&lt;board[0].size();j++)&#123;          if(board[i][j]!=&#39;.&#39;) continue;          for(char k=&#39;1&#39;;k&lt;=&#39;9&#39;;k++)&#123;              if(isValid(i,j,k,board))&#123;                  board[i][j]=k;                  if(bt(board)) return true;                  board[i][j]=&#39;.&#39;;              &#125;          &#125;          return false;      &#125;  &#125;  return true;&#125;bool isValid(int row,int col,char val,vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123;  for(int i=0;i&lt;9;i++)&#123;      if(board[row][i]==val) return false;  &#125;  for(int i=0;i&lt;9;i++)&#123;      if(board[i][col]==val) return false;  &#125;  int startrow=(row/3)*3;  int startcol=(col/3)*3;  for(int i=startrow;i&lt;startrow+3;i++)&#123;      for(int j=startcol;j&lt;startcol+3;j++)&#123;          if(board[i][j]==val) return false;      &#125;  &#125;  return true;&#125;void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;  bt(board);&#125;&#125;;</code></pre><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2></li><li>树层去重需要排序。</li><li>排列选数从0开始，维护vis数组。而组合从index开始。   </li><li>字符串的回溯函数中，index就是当前位置，从index-i来表示判定子串的范围。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象思想</title>
      <link href="/2022/070226837.html"/>
      <url>/2022/070226837.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。         </p><ul><li><p>优点：<br>减少耦合：可以独立地开发、测试、优化、使用、理解和修改<br>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块<br>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能<br>提高软件的可重用性<br>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的      </p></li><li><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。<br>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。<br>&#96;&#96;&#96;<br>public class Person {</p><p>  private String name;<br>  private int gender;<br>  private int age;</p><p>  public String getName() {<br>  return name;<br>  }</p><p>  public String getGender() {<br>  return gender &#x3D;&#x3D; 0 ? “man” : “woman”;<br>  }</p><p>  public void work() {<br>  if (18 &lt;&#x3D; age &amp;&amp; age &lt;&#x3D; 50) {<br>      System.out.println(name + “ is working very hard!”);<br>  } else {<br>      System.out.println(name + “ can’t work any more!”);<br>  }<br>  }</p></li></ul><p>}</p><pre><code>### 继承继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。     继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。       Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。       </code></pre><p>Animal animal &#x3D; new Cat();</p><pre><code>### 多态多态分为编译时多态和运行时多态：     编译时多态主要指方法的重载      运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定        - 运行时多态有三个条件：继承     覆盖（重写）       向上转型          下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。      </code></pre><p>public class Instrument {</p><pre><code>public void play() &#123;    System.out.println(&quot;Instument is playing...&quot;);&#125;</code></pre><p>}</p><pre><code></code></pre><p>public class Wind extends Instrument {</p><pre><code>public void play() &#123;    System.out.println(&quot;Wind is playing...&quot;);&#125;</code></pre><p>}</p><pre><code></code></pre><p>public class Percussion extends Instrument {</p><pre><code>public void play() &#123;    System.out.println(&quot;Percussion is playing...&quot;);&#125;</code></pre><p>}</p><pre><code></code></pre><p>public class Music {</p><pre><code>public static void main(String[] args) &#123;    List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();    instruments.add(new Wind());    instruments.add(new Percussion());    for(Instrument instrument : instruments) &#123;        instrument.play();    &#125;&#125;</code></pre><p>}</p><p>&#96;&#96;&#96;<br>结果是：<br>Wind is playing…<br>Percussion is playing…      </p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li>泛化关系Generalization<br>用来描述继承关系，在 Java 中使用 extends 关键字。     <img src="/2022/070226837/1.jpg" class>    </li><li>实现关系Realization<br>用来实现一个接口，在 Java 中使用 implements 关键字。   <img src="/2022/070226837/2.jpg" class>    </li><li>聚合关系Aggregation<br>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。       <img src="/2022/070226837/3.jpg" class>    </li><li>组合关系Composition<br>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。       <img src="/2022/070226837/4.jpg" class>    </li><li>关联关系Association<br>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。      <img src="/2022/070226837/5.jpg" class>    </li><li>依赖关系Dependency<br>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：<br>A 类是 B 类方法的局部变量；<br>A 类是 B 类方法的参数；<br>A 类向 B 类发送消息，从而影响 B 类发生变化。        <img src="/2022/070226837/6.jpg" class>    <h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><img src="/2022/070226837/7.jpg" class></li></ul><ol><li>单一责任原则————修改一个类的原因应该只有一个。<br>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。<br>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。     </li><li>开放封闭原则————类应该对扩展开放，对修改关闭。<br>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。<br>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</li><li>里氏替换原则————子类对象必须能够替换掉所有父类对象。<br>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。<br>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。      </li><li>接口分离原则————不应该强迫客户依赖于它们不用的方法。<br>因此使用多个专门的接口比使用单一的总接口要好。       </li><li>依赖倒置原则————高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。<br>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面向对象思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java</title>
      <link href="/2022/063020128.html"/>
      <url>/2022/063020128.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>基本类型：<br>byte&#x2F;8<br>char&#x2F;16<br>short&#x2F;16<br>int&#x2F;32<br>float&#x2F;32<br>long&#x2F;64<br>double&#x2F;64<br>boolean&#x2F;~  </p></li><li><p>包装类型：<br>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。     </p><pre><code>Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)int y = x;         // 拆箱 调用了 X.intValue()</code></pre></li><li><p>缓存池：<br>new Integer(123) 与 Integer.valueOf(123) 的区别在于：<br>new Integer(123) 每次都会新建一个对象；<br>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。       </p><pre><code>Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y);    // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k);   // true</code></pre><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。    </p><pre><code>public static Integer valueOf(int i) &#123;  if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)      return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i);&#125;</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2></li><li><p>概览：<br>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）<br>在 Java 8 中，String 内部使用 char 数组存储数据。       </p><pre><code>public final class String  implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;  /** The value is used for character storage. */  private final char value[];&#125;</code></pre><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。<br>&#96;&#96;&#96;<br>public final class String<br>  implements java.io.Serializable, Comparable<String>, CharSequence {<br>  &#x2F;** The value is used for character storage. *&#x2F;<br>  private final byte[] value;</String></p><p>  &#x2F;** The identifier of the encoding used to encode the bytes in {@code value}. *&#x2F;<br>  private final byte coder;</p></li></ul><p>}</p><pre><code>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。- 不可变的好处：     1. 可以缓存 hash 值：        因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。        2. String Pool 的需要：         如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。       3. 安全性：        String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。           4. 线程安全：         String 不可变性天生具备线程安全，可以在多个线程中安全地使用。            - String, StringBuffer and StringBuilder：         1. 可变性：        String 不可变         StringBuffer 和 StringBuilder 可变     2. 线程安全：         String 不可变，因此是线程安全的         StringBuilder 不是线程安全的           StringBuffer 是线程安全的，内部使用 synchronized 进行同步      ## 运算- 参数传递：   Java 的参数是以值传递的形式传入方法中，而不是引用传递。     以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。        </code></pre><p>public class Dog {</p><pre><code>String name;Dog(String name) &#123;    this.name = name;&#125;String getName() &#123;    return this.name;&#125;void setName(String name) &#123;    this.name = name;&#125;String getObjectAddress() &#123;    return super.toString();&#125;</code></pre><p>}</p><pre><code>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。     </code></pre><p>class PassByValueExample {<br>    public static void main(String[] args) {<br>        Dog dog &#x3D; new Dog(“A”);<br>        func(dog);<br>        System.out.println(dog.getName());          &#x2F;&#x2F; B<br>    }</p><pre><code>private static void func(Dog dog) &#123;    dog.setName(&quot;B&quot;);&#125;</code></pre><p>}</p><pre><code>## 关键字- final：  1. 数据：    声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。        对于基本类型，final 使数值不变；      对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。            2. 方法：     声明方法不能被子类重写。        private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。      3. 类：    声明类不允许被继承。        - static：  1. 静态变量：    静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。    实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。     </code></pre><p>public class A {</p><pre><code>private int x;         // 实例变量private static int y;  // 静态变量public static void main(String[] args) &#123;    // int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context    A a = new A();    int x = a.x;    int y = A.y;&#125;</code></pre><p>}</p><pre><code>2. 静态方法：        静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。     </code></pre><p>public abstract class A {<br>    public static void func1(){<br>    }<br>    &#x2F;&#x2F; public abstract static void func2();  &#x2F;&#x2F; Illegal combination of modifiers: ‘abstract’ and ‘static’<br>}</p><pre><code>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。  </code></pre><p>public class A {</p><pre><code>private static int x;private int y;public static void func1()&#123;    int a = x;    // int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context    // int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context&#125;</code></pre><p>}</p><pre><code>3. 静态语句块：    静态语句块在类初始化时运行一次。      </code></pre><p>public class A {<br>    static {<br>        System.out.println(“123”);<br>    }</p><pre><code>public static void main(String[] args) &#123;    A a1 = new A();    A a2 = new A();&#125;</code></pre><p>}</p><pre><code>4. 静态内部类：        非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。     </code></pre><p>public class OuterClass {</p><pre><code>class InnerClass &#123;&#125;static class StaticInnerClass &#123;&#125;public static void main(String[] args) &#123;    // InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context    OuterClass outerClass = new OuterClass();    InnerClass innerClass = outerClass.new InnerClass();    StaticInnerClass staticInnerClass = new StaticInnerClass();&#125;</code></pre><p>}</p><pre><code>## Object 通用方法- 概览：  </code></pre><p>public native int hashCode()</p><p>public boolean equals(Object obj)</p><p>protected native Object clone() throws CloneNotSupportedException</p><p>public String toString()</p><p>public final native Class&lt;?&gt; getClass()</p><p>protected void finalize() throws Throwable {}</p><p>public final native void notify()</p><p>public final native void notifyAll()</p><p>public final native void wait(long timeout) throws InterruptedException</p><p>public final void wait(long timeout, int nanos) throws InterruptedException</p><p>public final void wait() throws InterruptedException</p><p>&#96;&#96;&#96;</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>访问权限：<br>public：<br>具有最大的访问权限，可以访问任何一个在classpath下的类、接口、异常等。它往往用于对外的情况，也就是对象或类对外的一种接口的形式。<br>protected：<br>主要的作用就是用来保护子类的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。<br>default：<br>有时候也称为friendly，它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问，即使是父类没有用protected修饰的成员也可以。<br>private：<br>访问权限仅限于类的内部，是一种封装的体现，例如，大多数成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。        <img src="/2022/063020128/1.jpg" class>    </li><li>抽象类与接口：</li></ul><ol><li>抽象类：<br>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。<br>抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。    </li><li>接口：<br>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。<br>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。<br>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。<br>接口的字段默认都是 static 和 final 的。         </li><li>比较：<br>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。<br>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。<br>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。<br>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。        <h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。<br>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。<br>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。<br>Java 支持自动垃圾回收，而 C++ 需要手动回收。<br>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。<br>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。<br>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。      <h2 id="JRE-or-JDK"><a href="#JRE-or-JDK" class="headerlink" title="JRE or JDK"></a>JRE or JDK</h2>JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。<br>JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。         <h2 id="Java中实现多态的方式"><a href="#Java中实现多态的方式" class="headerlink" title="Java中实现多态的方式"></a>Java中实现多态的方式</h2>1、接口实现；<br>2、继承父类进行方法重写；<br>3、同一个类中进行方法重载。<br>多态存在的必要条件：<br>1、要有继承；<br>2、要有重写；<br>3、父类引用指向子类对象。<br>多态的好处：<br>1、可替换性（substitutability）。<br>多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。<br>2、可扩充性（extensibility）。<br>多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。<br>3、接口性（interface-ability）。<br>多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。<br>4、灵活性（flexibility）。<br>它在应用中体现了灵活多样的操作，提高了使用效率。<br>5、简化性（simplicity）。<br>多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用代码</title>
      <link href="/2022/063057443.html"/>
      <url>/2022/063057443.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[10]= &#123;1,8,5,7,2,6,3,4,11,9&#125;;    int j;    for(int i  = 1;i&lt;10;i++)&#123;        if(a[i]&gt;a[i-1]) continue;        int temp = a[i];        for( j = i-1;a[j]&gt;temp;j--)&#123;            a[j+1] = a[j];        &#125;        a[j+1]=temp;    &#125;    for(int i  = 0;i&lt;10;i++)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（1），时间效率O（n2），稳定。    </p><h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[10]= &#123;1,8,5,7,2,6,3,4,11,9&#125;;    int j;    for(int i  = 1;i&lt;10;i++)&#123;        if(a[i]&gt;a[i-1]) continue;        int temp = a[i];        int low=0,high=i-1;        int mid ;        while(low&lt;=high)&#123;            mid = (low+high)/2;            if(a[mid]&gt;temp)&#123;                high = mid-1;            &#125;            else low=  mid+ 1 ;        &#125;        for( j =i-1;j&gt;=low;j--)&#123;            a[j+1] =a[j];        &#125;        a[j+1] = temp;    &#125;    for(int i  = 0;i&lt;10;i++)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（1），时间效率O（n2），稳定。   </p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[10]= &#123;1,8,5,7,2,6,3,4,11,9&#125;;    for(int i  = 0;i&lt;9;i++)&#123;        for(int j = 0;j&lt;9-i;j++)&#123;            if(a[j]&gt;a[j+1]) swap(a[j],a[j+1]);        &#125;    &#125;    for(int i  = 0;i&lt;10;i++)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（1），时间效率O（n2），稳定。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int findPivot(int a[],int left ,int right)&#123;    int temp = a[left];    while(left&lt;right)&#123;        while(a[right]&gt;temp&amp;&amp;left&lt;right) right--;        a[left] = a[right];        while(a[left]&lt;temp&amp;&amp;left&lt;right) left++;        a[right]=a[left];    &#125;    a[left]  = temp;    return left;&#125;void QuickSort(int a[],int left ,int right)&#123;    if(left&lt;right)&#123;        int pivot = findPivot(a,left,right);        QuickSort(a,left,pivot-1);        QuickSort(a,pivot+1,right);    &#125;&#125;int main()&#123;    int a[10]= &#123;1,8,5,7,2,6,3,4,11,9&#125;;    QuickSort(a,0,9);    for(int i = 0;i&lt;10;i++)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（logN），时间效率O（n*logN），不稳定。</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[10]= &#123;1,8,5,7,2,6,3,4,11,9&#125;;    for(int i = 0;i&lt;9;i++)&#123;        int minIndex=i;        for(int j=i+1;j&lt;10;j++)&#123;            if(a[minIndex]&gt;a[j]) minIndex = j;        &#125;        swap(a[i],a[minIndex]);    &#125;    for(int i = 0;i&lt;10;i++)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（1），时间效率O（n2），不稳定。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;void adjust(int a[],int k,int len)&#123;    a[0]=a[k];    for(int i = 2*k;i&lt;=len;i*=2)&#123;        if(a[i]&lt;a[i+1]&amp;&amp;i&lt;len) i++;        if(a[0]&gt;=a[i]) break;        else &#123;            a[k]=a[i];            k=i;        &#125;    &#125;    a[k] = a[0];&#125;void BuildHeap(int a[],int len)&#123;    for(int i = len/2;i&gt;0;i--)&#123;        adjust(a,i,len);    &#125;&#125;void HeapSort(int a[],int len)&#123;    BuildHeap(a,len);    for(int i=len;i&gt;1;i--)&#123;        swap(a[i],a[1]);        adjust(a,1,i-1);    &#125;&#125;int main()&#123;    int a[100]= &#123;0,1,8,5,7,2,6,3,4,11,9&#125;;    HeapSort(a,10);    for(int i = 10;i&gt;0;i--)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（1），时间效率O（n*logN），不稳定。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;void Merge(int a[],int low,int mid,int high)&#123;    int b[100];    for(int i= low;i&lt;=high;i++) b[i]=a[i];    int i,j,k;    for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;)&#123;        if(b[i]&lt;b[j]) &#123;            a[k++]=b[i++];        &#125;else &#123;            a[k++]=b[j++];        &#125;    &#125;    while(i&lt;=mid) a[k++]=b[i++];    while(j&lt;=high) a[k++]=b[j++];&#125;void MergeSort(int a[],int low,int high)&#123;    if(low&lt;high)&#123;        int mid= (low+high)/2;        MergeSort(a,low,mid);        MergeSort(a,mid+1,high);        Merge(a,low,mid,high);    &#125;&#125;int main()&#123;    int a[100]= &#123;0,1,8,5,7,2,6,3,4,11,9&#125;;    MergeSort(a,0,10);    for(int i = 10;i&gt;0;i--)&#123;        printf(&quot;%d  &quot;,a[i]);    &#125;    return 0;&#125;</code></pre><p>空间效率O（n），时间效率O（n*logN），稳定。</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;bool isPrim(int n )&#123;    if(n&lt;=1) return false;    for(int i = 2;i&lt;=sqrt(n);i++)&#123;        if(n%i==0) return false;    &#125;    return true;&#125;int main()&#123;    int n = 13;    cout&lt;&lt;isPrim(n);    return 0;&#125;</code></pre><h2 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int a,int b)&#123;    return b==0?a:gcd(b,a%b);&#125;int gbs(int a,int b)&#123;    return a*b/gcd(a,b);&#125;int main()&#123;    int a = 12,b = 8;    cout&lt;&lt;gcd(a,b)&lt;&lt;endl&lt;&lt;gbs(a,b);    return 0;&#125;</code></pre><p>进一步可以打印素数表&#x2F;使用素数筛（埃式筛）</p><h2 id="质因子分解"><a href="#质因子分解" class="headerlink" title="质因子分解"></a>质因子分解</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100100;struct factor&#123;    int x;    int num;&#125;fac[10];bool isPrim(int n)&#123;    if(n&lt;=1) return false;    for(int i=2;i&lt;=sqrt(n);i++)&#123;        if(n%i==0) return false;    &#125;    return true;&#125;int prims[maxn];int cnt = 0;void findPrim()&#123;    for(int i = 1;i&lt;maxn;i++)&#123;        if(isPrim(i)==true)&#123;            prims[cnt++] = i;        &#125;    &#125;&#125;int main()&#123;    findPrim();    int n;    int facNum = 0;    cin&gt;&gt;n;    if(n==1) printf(&quot;1=1&quot;);    else &#123;        printf(&quot;%d=&quot;,n);        for(int i = 0;i&lt;cnt;i++)&#123;            if(n%prims[i]==0)&#123;                fac[facNum].x=prims[i];                fac[facNum].num=0;                while(n%prims[i]==0)&#123;                    n=n/prims[i];                    fac[facNum].num++;                &#125;                facNum++;            &#125;            //已经除尽就跳出循环            if(n==1) break;        &#125;        //最后余数不为1，则就是最后一个质因数        if(n!=1)&#123;            fac[facNum].x=n;            fac[facNum].num=1;            facNum++;        &#125;        for(int i = 0;i&lt;facNum;i++)&#123;            if(i&gt;0) printf(&quot;*&quot;);            printf(&quot;%d&quot;,fac[i].x);            if(fac[i].num&gt;1)&#123;                printf(&quot;^%d&quot;,fac[i].num);            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//求a的b次方，对m取余long long binaryPow(long long a,long long b,long long m)&#123;    if(b==0) return 1;    if(b%2==1)&#123;        return binaryPow(a,b-1,m)%m;    &#125;else&#123;        long long temp = binaryPow(a,b/2,m);        return temp*temp%m;    &#125;&#125;int main()&#123;    return 0;&#125;</code></pre><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    vector&lt;int&gt;vi;    vi.push_back(1);    vi.push_back(2);    vi.push_back(3);    vi.push_back(4);    vi.push_back(5);    //访问方式    for(int i = 0;i&lt;vi.size();i++) printf(&quot;%d  &quot;,vi[i]);    cout&lt;&lt;endl;    for(auto it = vi.begin();it!=vi.end();it++)  printf(&quot;%d  &quot;,*it);    //各种操作    vi.push_back(6);    vi.pop_back();    cout&lt;&lt;vi.size();    vi.insert(vi.begin()+1,100);    vi.erase(vi.begin()+3);    vi.erase(vi.begin(),vi.begin()+1);    vi.clear();    return 0;&#125;</code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    //自动排序和去重    set&lt;int&gt;si;    si.insert(10);    si.insert(10);    si.insert(1);    si.insert(9);    si.insert(6);    //访问方式    for(auto it=si.begin();it!=si.end();it++)&#123;        printf(&quot;%d  &quot;,*it);    &#125;    //各种操作    si.insert(7);    printf(&quot;\n%d&quot;,*(si.find(9)));    si.erase(si.find(9));    si.erase(1);    si.erase(si.find(6),si.end());    cout&lt;&lt;si.size()&lt;&lt;endl;    si.clear();    return 0;&#125;</code></pre><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string str=&quot;adwe&quot;;    //访问方式    for(int i =0;i&lt;str.size();i++)&#123;        cout&lt;&lt;str[i];    &#125;    cout&lt;&lt;endl;    for(auto it=str.begin();it!=str.end();it++)&#123;        cout&lt;&lt;*it;    &#125;    //各种操作    string a = &quot;   qqqq&quot;;    cout&lt;&lt;a+str&lt;&lt;endl;    bool temp = a&gt;=str;    cout&lt;&lt;temp&lt;&lt;endl;    cout&lt;&lt;str.length()&lt;&lt;endl;    str.insert(3,&quot;wd&quot;);    str.erase(str.begin()+2);    str.erase(str.begin()+2,str.end()-1);    str.substr(3,5);    str.clear();    str.find(&quot;ww&quot;);    str.replace(10,4,&quot;w&quot;);    str.replace(str.begin(),str.begin()+1,&quot;www&quot;);    return 0;&#125;</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;string,int&gt;mp;    mp[&quot;w&quot;]=1;    mp[&quot;e&quot;]=2;    mp[&quot;r&quot;]=3;    mp[&quot;q&quot;]=4;    //访问方式    for(auto it=mp.begin();it!=mp.end();it++)&#123;        cout&lt;&lt; it-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;    &#125;    //各种操作    cout&lt;&lt; mp.find(&quot;w&quot;)-&gt;first&lt;&lt;&quot;   &quot;&lt;&lt;mp.find(&quot;w&quot;)-&gt;second&lt;&lt;endl;    mp.erase(mp.find(&quot;w&quot;));    mp.erase(&quot;w&quot;);    mp.erase(mp.begin(),mp.end());    mp.size();    mp.clear();    return 0;&#125;</code></pre><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    queue&lt;int&gt;q;    q.push(1);    q.push(3);    q.push(2);    q.push(4);    //访问方式    cout&lt;&lt;q.front()&lt;&lt;&quot;    &quot;&lt;&lt;q.back()&lt;&lt;endl;    //各种操作    q.push(12);    cout&lt;&lt;q.front()&lt;&lt;&quot;    &quot;&lt;&lt;q.back()&lt;&lt;endl;    q.pop();    cout&lt;&lt;q.empty()&lt;&lt;endl;    cout&lt;&lt;q.size()&lt;&lt;endl;    return 0;&#125;</code></pre><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;struct fruit&#123;    string name;    int price;    friend bool operator &lt;(fruit a,fruit b)&#123;        return a.price&gt;b.price;    &#125;&#125;f1,f2,f3,f4;int main()&#123;    priority_queue&lt;fruit&gt;pq;    f1.name=&quot;苹果&quot;;    f1.price=25;    f2.name=&quot;香蕉&quot;;    f2.price=12;    f3.name=&quot;桃子&quot;;    f3.price=19;    pq.push(f1);    pq.push(f2);    pq.push(f3);    //访问方式    cout &lt;&lt; pq.top().price &lt;&lt; &quot; &quot;&lt;&lt; pq.top().name &lt;&lt;endl;    //各种操作    f4.name=&quot;KK&quot;;    f4.price=13;    pq.push(f4);    cout &lt;&lt; pq.top().price &lt;&lt; &quot; &quot;&lt;&lt; pq.top().name &lt;&lt;endl;    pq.pop();    pq.empty();    pq.size();    return 0;&#125;</code></pre><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    stack&lt;int&gt;si;    si.push(1);    si.push(9);    si.push(6);    si.push(3);    //访问方式    cout&lt;&lt;si.top()&lt;&lt;endl;    //各种操作    si.push(20);    cout&lt;&lt;si.top()&lt;&lt;endl;    si.pop();    si.empty();    si.size();    return 0;&#125;</code></pre><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp (int a,int b)&#123;    return a&gt;b;&#125;int main()&#123;    int a=8,b = -10;    cout&lt;&lt;max(a,b)&lt;&lt;&quot;  &quot;&lt;&lt;min(a,b)&lt;&lt;&quot;   &quot;&lt;&lt;abs(b)&lt;&lt;endl;    swap(a,b);    //对于数组，vector，string都可以进行排序    int q[10]=&#123;4,1,2,6&#125;;    reverse(q,q+4);    for(int i  =0;i&lt;4;i++) printf(&quot;%d  &quot;,q[i]);    cout&lt;&lt;endl;    //全排列，按从小到大顺序    int y[3]=&#123;1,2,3&#125;;    do&#123;        printf(&quot;%d %d %d\n&quot;,y[0],y[1],y[2]);    &#125;while(next_permutation(y,y+3));    //填充数组    int dis[5][5];    fill(dis[0],dis[0]+5*5,1);    for(int i = 0;i&lt;5;i++)&#123;        for(int j = 0;j&lt;5;j++)&#123;            printf(&quot;%d &quot;,dis[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    //sort排序    int p[10]=&#123;4,1,2,6&#125;;    sort(p,p+4,cmp);    for(int i  =0;i&lt;4;i++) printf(&quot;%d  &quot;,p[i]);    return 0;&#125;</code></pre><h1 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h1><h2 id="二叉树（增删改查遍历，多种序列遍历求原树）"><a href="#二叉树（增删改查遍历，多种序列遍历求原树）" class="headerlink" title="二叉树（增删改查遍历，多种序列遍历求原树）"></a>二叉树（增删改查遍历，多种序列遍历求原树）</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//结构定义struct node&#123;    int data;    node* left;    node* right;&#125;;//新建结点node* newNode(int v)&#123;    node* root =  new node;    root-&gt;data=v;    root-&gt;left=root-&gt;right=NULL;    return root;&#125;//修改/查找void searchNode(node* root,int x,int v)&#123;    if(root==NULL) return;    if(root-&gt;data==x)&#123;        root-&gt;data= v;    &#125;    searchNode(root-&gt;left,x,v);    searchNode(root-&gt;right,x,v);&#125;//插入，需要&amp;改变原rootvoid insertNode(node* &amp;root,int x)&#123;    if(root==NULL) &#123;        root=newNode(x);        return;    &#125;    if(root-&gt;data&gt;x)&#123;        insertNode(root-&gt;left,x);    &#125;else insertNode(root-&gt;right,x);&#125;//建树node* creatTree(int data[],int n)&#123;    node* root=NULL;    for(int i = 0;i&lt;n;i++)&#123;        insertNode(root,data[i]);    &#125;    return root;&#125;//先序遍历void preOrder(node* root)&#123;    if(root==NULL)&#123;        return ;    &#125;    printf(&quot;%d  &quot;,root-&gt;data);    preOrder(root-&gt;left);    preOrder(root-&gt;right);&#125;//中序遍历void inOrder(node* root)&#123;    if(root==NULL)&#123;        return ;    &#125;    inOrder(root-&gt;left);    printf(&quot;%d  &quot;,root-&gt;data);    inOrder(root-&gt;right);&#125;//后序遍历void postOrder(node* root)&#123;    if(root==NULL)&#123;        return ;    &#125;    postOrder(root-&gt;left);    postOrder(root-&gt;right);    printf(&quot;%d  &quot;,root-&gt;data);&#125;//层序遍历void traversal(node * root)&#123;    queue&lt;node*&gt;q;    q.push(root);    while(q.empty()==false)&#123;        node * temp   =q.front();        q.pop();        printf(&quot;%d  &quot;,temp-&gt;data);        if(temp-&gt;left!=NULL) q.push(temp-&gt;left);        if(temp-&gt;right!=NULL) q.push(temp-&gt;right);    &#125;&#125;//中序和任意序遍历求原序列，其他同理//举例：中序后序求层序遍历int n=7;int postorder[7]=&#123;2,3,1,5,7,6,4&#125;;int inorder[7]=&#123;1,2,3,4,5,6,7&#125;;node* create(int postleft,int postright,int inleft,int inright)&#123;    if(postleft&gt;postright) return NULL;    node* root = new node;    root-&gt;data=postorder[postright];    int rootPos;    for(int i = inleft;i&lt;=inright;i++)&#123;        if(inorder[i]==postorder[postright])&#123;            rootPos=i;        &#125;    &#125;    int leftNum = rootPos-inleft;    root-&gt;left=create(postleft,postleft+leftNum-1,inleft,rootPos-1);    root-&gt;right=create(postleft+leftNum,postright-1,rootPos+1,inright);&#125;int main()&#123;    int data[10]=&#123;4,1,0,3,10,5,7,2,9,6&#125;;    reverse(data,data+10);    node* root = creatTree(data,10);    preOrder(root);    cout&lt;&lt;endl;    inOrder(root);    cout&lt;&lt;endl;    postOrder(root);    cout&lt;&lt;endl;    traversal(root);    //得到原树之后求层序遍历    cout&lt;&lt;endl;    node* root2 = create(0,6,0,6);    traversal(root2);    return 0;&#125;</code></pre><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;//结构定义struct node&#123;    int data;    vector&lt;int&gt; child;&#125;Node[maxn];//先根遍历void preOrder(int root)&#123;    printf(&quot;%d  &quot;,Node[root].data);    for(int i = 0;i&lt;Node[root].child.size();i++)&#123;        preOrder(Node[root].child[i]);    &#125;&#125;//后根遍历void postOrder(int root)&#123;    for(int i = 0;i&lt;Node[root].child.size();i++)&#123;        postOrder(Node[root].child[i]);    &#125;    printf(&quot;%d  &quot;,Node[root].data);&#125;//层次遍历void layerOrder(int root)&#123;    queue&lt;int&gt;q;    q.push(root);    while(!q.empty())&#123;        int top = q.front();        q.pop();        printf(&quot;%d  &quot;,Node[top].data);        for(int i = 0;i&lt;Node[top].child.size();i++)&#123;            q.push(Node[top].child[i]);        &#125;    &#125;&#125;//例题PAT A1053int n,m,s;int weight[maxn];int cnt = 0;vector&lt;int&gt;path;vector&lt;int&gt;paths[maxn];void DFS(int id,int sum)&#123;    if(sum&gt;s) return;    if(sum==s)&#123;        if(Node[id].child.size()!=0) return;        paths[cnt++]=path;        return;    &#125;    for(int i=0;i&lt;Node[id].child.size();i++)&#123;        path.push_back(Node[id].child[i]);        DFS(Node[id].child[i],sum+weight[Node[id].child[i]]);        path.pop_back();    &#125;&#125;bool cmp(int a,int b)&#123;    return weight[a]&gt;weight[b];&#125;int main()&#123;    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;s);    for(int i = 0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;weight[i]);    for(int i = 0;i&lt;m;i++)&#123;        int id,num;        scanf(&quot;%d %d&quot;,&amp;id,&amp;num);        for(int j=0;j&lt;num;j++)&#123;            int temp;            scanf(&quot;%d&quot;,&amp;temp);            Node[id].child.push_back(temp);        &#125;        //直接这里进行排序，顺序dfs之后就是有序从大到小的序列        sort(Node[id].child.begin(),Node[id].child.end(),cmp);    &#125;    path.push_back(0);    DFS(0,weight[0]);    for(int i = 0;i&lt;cnt;i++)&#123;        vector&lt;int&gt;temp = paths[i];        for(int j = 0;j&lt;temp.size();j++)&#123;            printf(&quot;%d&quot;,weight[temp[j]]);            if(j!=temp.size()-1) printf(&quot; &quot;);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h2 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;//结构定义struct node&#123;    int data;    node* left;    node* right;&#125;;//新建结点node* newNode(int x)&#123;    node * root=new node;    root-&gt;data=x;    root-&gt;left=root-&gt;right=NULL;    return root;&#125;//插入结点void insertNode(node* &amp;root,int x)&#123;    if(root==NULL)&#123;        root=newNode(x);        return;    &#125;    if(root-&gt;data&gt;x)&#123;        insertNode(root-&gt;left,x);    &#125;else insertNode(root-&gt;right,x);&#125;//建树node* create(int data[],int n)&#123;    node *root=NULL;    for(int i =0;i&lt;n;i++)&#123;        insertNode(root,data[i]);    &#125;    return root;&#125;//找前驱node* findMax(node* root)&#123;    while(root-&gt;right!=NULL)&#123;        root=root-&gt;right;    &#125;    return root;&#125;//找后继node* findMin(node* root)&#123;    while(root-&gt;left!=NULL)&#123;        root=root-&gt;left;    &#125;    return root;&#125;//删除结点void deleteNode(node* &amp;root,int x)&#123;    if(root==NULL) return;    if(root-&gt;data==x)&#123;        if(root-&gt;left==NULL&amp;&amp;root-&gt;right==NULL) root=NULL;        else if(root-&gt;left!=NULL)&#123;            node* pre=findMax(root-&gt;left);            root-&gt;data = pre-&gt;data;            deleteNode(root-&gt;left,pre-&gt;data);        &#125;else&#123;            node* next = findMin(root-&gt;right);            root-&gt;data=next-&gt;data;            deleteNode(root-&gt;right,next-&gt;data);        &#125;    &#125;else if(root-&gt;data&gt;x)&#123;        deleteNode(root-&gt;left,x);    &#125;else deleteNode(root-&gt;right,x);&#125;//先序遍历void preOrder(node* root)&#123;    if(root==NULL) return;    printf(&quot;%d  &quot;,root-&gt;data);    preOrder(root-&gt;left);    preOrder(root-&gt;right);&#125;//中序遍历void inOrder(node* root)&#123;    if(root==NULL) return;    inOrder(root-&gt;left);    printf(&quot;%d  &quot;,root-&gt;data);    inOrder(root-&gt;right);&#125;//后序遍历void postOrder(node* root)&#123;    if(root==NULL) return;    postOrder(root-&gt;left);    postOrder(root-&gt;right);    printf(&quot;%d  &quot;,root-&gt;data);&#125;int main()&#123;    int data[10]=&#123;5,3,7,4,2,8,6&#125;;    node* root=create(data,7);    preOrder(root);    cout&lt;&lt;endl;    deleteNode(root,5);    preOrder(root);    return 0;&#125;</code></pre><h2 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//结构定义struct node&#123;    int data;    int height;    node* left;    node* right;&#125;;//新建结点node* newNode(int x)&#123;    node* root = new node;    root-&gt;data=x;    root-&gt;height=1;    root-&gt;left=root-&gt;right=NULL;    return root;&#125;//求结点高度int getHeight(node* root)&#123;    if(root==NULL) return 0;    return root-&gt;height;&#125;//求结点平衡因子int getBalanceFactor(node *root)&#123;    return getHeight(root-&gt;left)-getHeight(root-&gt;right);&#125;//更新结点高度void updateHeight(node *root)&#123;    root-&gt;height= max(getHeight(root-&gt;left),getHeight(root-&gt;right))+1;&#125;//左旋void L(node* &amp;root)&#123;    node* temp = root-&gt;right;    root-&gt;right=temp-&gt;left;    temp-&gt;left=root;    updateHeight(root);    updateHeight(temp);    root=temp;&#125;//右旋void R(node* &amp;root)&#123;    node* temp = root-&gt;left;    root-&gt;left=temp-&gt;right;    temp-&gt;right=root;    updateHeight(root);    updateHeight(temp);    root=temp;&#125;//插入结点void insertNode(node* &amp;root,int x)&#123;    if(root==NULL)&#123;        root=newNode(x);        return;    &#125;    if(root-&gt;data&gt;x)&#123;        insertNode(root-&gt;left,x);        updateHeight(root);        if(getBalanceFactor(root)==2)&#123;            if(getBalanceFactor(root-&gt;left)==1)&#123;                R(root);            &#125;else if(getBalanceFactor(root-&gt;left)==-1)&#123;                L(root-&gt;left);                R(root);            &#125;        &#125;    &#125;else&#123;        insertNode(root-&gt;right,x);        updateHeight(root);        if(getBalanceFactor(root)==-2)&#123;            if(getBalanceFactor(root-&gt;right)==-1)&#123;                L(root);            &#125;else if(getBalanceFactor(root-&gt;right)==1)&#123;                R(root-&gt;right);                L(root);            &#125;        &#125;    &#125;&#125;//建树node* create(int data[],int n)&#123;    node* root=NULL;    for(int i=0;i&lt;n;i++)&#123;        insertNode(root,data[i]);    &#125;    return root;&#125;//前序遍历void preOrder(node* root)&#123;    if(root==NULL) return;    printf(&quot;%d  &quot;,root-&gt;data);    preOrder(root-&gt;left);    preOrder(root-&gt;right);&#125;int main()&#123;    int data[10]=&#123;5,3,7,4,2,8,6&#125;;    node* root=create(data,7);    preOrder(root);    return 0;&#125;</code></pre><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10010;int father[maxn];int n;//初始化void init()&#123;    for(int i = 1;i&lt;=n;i++)&#123;        father[i]=i;    &#125;&#125;//找到所在集合根节点int findFather(int x)&#123;    while(x!=father[x])&#123;        x=father[x];    &#125;    return x;&#125;//找到所在集合根节点，使用路径压缩O(1)int findFather2(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        a=father[a];        father[z]=x;    &#125;    return x;&#125;//合并两个集合void unionAll(int a,int b)&#123;    int fa=findFather(a);    int fb=findFather(b);    if(fa!=fb)&#123;        father[fa]=fb;    &#125;&#125;int main()&#123;    return 0;&#125;</code></pre><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//堆常用来实现优先队列const int maxn = 1010;int heap[maxn];int n = 10;//向下调整void adjust(int low,int high)&#123;    int i=low,j=i*2;    while(j&lt;=high)&#123;        if(j+1&lt;=high&amp;&amp;heap[j+1]&gt;heap[j])&#123;            j=j+1;        &#125;        if(heap[j]&gt;heap[i])&#123;            swap(heap[j],heap[i]);            i=j;            j=2*i;        &#125;else&#123;            break;        &#125;    &#125;&#125;//建堆，从n/2开始向1调整void createHeap()&#123;    for(int i=n/2;i&gt;=1;i--)&#123;        adjust(i,n);    &#125;&#125;void deleteTop()&#123;    heap[1]=heap[n];    n--;    adjust(1,n);&#125;//添加结点时向上调整void upAdjust(int low,int high)&#123;    int i=high,j=i/2;    while(j&gt;=low)&#123;        if(heap[j]&lt;heap[i])&#123;            swap(heap[j],heap[i]);            i=j;            j=i/2;        &#125;else break;    &#125;&#125;//添加结点void insert(int x)&#123;    heap[n++]=x;    upAdjust(1,n);&#125;//堆排序，堆顶与最后一个元素交换，再从上往下调整堆void heapSort()&#123;    createHeap();    for(int i=n;i&gt;1;i--)&#123;        swap(heap[i],heap[1]);        adjust(1,i-1);    &#125;&#125;int main()&#123;    return 0;&#125;</code></pre><h1 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h1><h2 id="图遍历DFS"><a href="#图遍历DFS" class="headerlink" title="图遍历DFS"></a>图遍历DFS</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;//邻接矩阵int n,G[maxn][maxn]；bool vis[maxn]=&#123;false&#125;;void DFS(int u,int depth)&#123;    vis[u]=true;    for(int i=0;i&lt;n;i++)&#123;        if(vis[i]==false &amp;&amp; G[u][i]!=INF)&#123;            DFS(i,depth+1);        &#125;    &#125;&#125;void DFSG()&#123;    for(int i=0;i&lt;n;i++)&#123;        if(vis[i]==false)&#123;            DFS(i,1);        &#125;    &#125;&#125;//邻接表实现vector&lt;int&gt;adj[maxn];void DFS2(int u,int depth)&#123;    vis[u]=true;    for(int i=0;i&lt;adj[u].size();i++)&#123;        int temp = adj[u][i];        if(vis[temp]==false &amp;&amp; G[u][temp]!=INF)&#123;            DFS(temp,depth+1);        &#125;    &#125;&#125;void DFSG2()&#123;    for(int i=0;i&lt;n;i++)&#123;        if(vis[i]==false)&#123;            DFS(i,1);        &#125;    &#125;&#125;int main()&#123;    return 0;&#125;</code></pre><p>PAT A1034例题</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;const int INF=1000000000;int n,k,id=0;int G[maxn][maxn]=&#123;0&#125;,weight[maxn]=&#123;0&#125;;bool vis[maxn]= &#123;false&#125;;map&lt;string,int&gt;sti;map&lt;int,string&gt;its;map&lt;string,int&gt;GANG;int stringtoint(string x)&#123;    if(sti.find(x)!=sti.end())    &#123;        return sti[x];    &#125;else    &#123;        sti[x] = id;        its[id] = x;        return id++;    &#125;&#125;void DFS(int index,int &amp;totaltime,int &amp;membernum,int &amp;head)&#123;    membernum++;    vis[index]=true;    if(weight[index]&gt;weight[head]) head=index;    for(int i=0; i&lt;id; i++)    &#123;        if(G[index][i]&gt;0)        &#123;            totaltime+=G[index][i];            G[index][i]=G[i][index]=0;            if(vis[i]==false) DFS(i,totaltime,membernum,head);        &#125;    &#125;&#125;void DFSG()&#123;    for(int i=0; i&lt;id; i++)    &#123;        if(vis[i]==false)        &#123;            int totaltime=0,membernum=0,head=i;            DFS(i,totaltime,membernum,head);            if(membernum&gt;2&amp;&amp;totaltime&gt;k)            &#123;                GANG[its[head]] = membernum;            &#125;        &#125;    &#125;&#125;int main(int argc, const char * argv[])&#123;    string a,b;    int time;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0; i&lt;n; i++)    &#123;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;time;        int persona = stringtoint(a);        int personb = stringtoint(b);        G[persona][personb]+=time;        G[personb][persona]+=time;        weight[persona]+=time;        weight[personb]+=time;    &#125;    DFSG();    printf(&quot;%d\n&quot;,GANG.size());    for(auto it = GANG.begin(); it != GANG.end(); it++)        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    return 0;&#125;</code></pre><h2 id="图遍历BFS"><a href="#图遍历BFS" class="headerlink" title="图遍历BFS"></a>图遍历BFS</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;//邻接矩阵int n,G[maxn][maxn]；bool vis[maxn]=&#123;false&#125;;void BFS(int u)&#123;    queue&lt;int&gt;q;    q.push(u);    vis[u]=true;    while(!q.empty())&#123;        int top = q.front();        q.pop();        for(int i=0;i&lt;n;i++)&#123;            if(vis[i]==false &amp;&amp; G[top][i]!=INF)&#123;                q.push(i);                vis[i]=true;            &#125;        &#125;    &#125;&#125;void BFSG()&#123;    for(int i=0;i&lt;n;i++)&#123;        if(vis[i]==false)&#123;            BFS(i);        &#125;    &#125;&#125;//邻接表实现vector&lt;int&gt;adj[maxn];void BFS2(int u)&#123;    queue&lt;int&gt;q;    q.push(u);    vis[u]=true;    while(!q.empty())&#123;        int top = q.front();        q.pop();        for(int i=0;i&lt;adj[top].size();i++)&#123;            int temp = adj[top][i];            if(vis[temp]==false)&#123;                q.push(temp);                vis[temp]=true;            &#125;        &#125;    &#125;&#125;void BFSG2()&#123;    for(int i=0;i&lt;n;i++)&#123;        if(vis[i]==false)&#123;            BFS(i);        &#125;    &#125;&#125;int main()&#123;    return 0;&#125;</code></pre><p>PAT A1076</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;struct Node&#123;    int id;    int layer;&#125;;vector&lt;Node&gt;adj[maxn];bool vis[maxn] = &#123;false&#125;;int BFS(int st,int maxl)&#123;    int cnt=0;    queue&lt;Node&gt;q;    Node start;    start.id=st;    start.layer = 0;    q.push(start);    vis[start.id]=true;    while(!q.empty())    &#123;        Node top = q.front();        q.pop();        int u=top.id;        for(int i=0;i&lt;adj[u].size();i++)        &#123;            Node next = adj[u][i];            next.layer = top.layer+1;            if(vis[next.id]==false &amp;&amp; next.layer&lt;=maxl)            &#123;                q.push(next);                vis[next.id] = true;                cnt++;            &#125;        &#125;    &#125;    return cnt;&#125;int main()&#123;    Node user;    int n, L, numFollow, idFollow;    cin &gt;&gt; n &gt;&gt; L;//结点个数，层数上限    for(int i = 1; i &lt;= n; i++)&#123;        user.id = i;  //用户编号为i        cin &gt;&gt; numFollow;//i号用户关注的人数        for(int j = 0; j &lt; numFollow; j++)&#123;            cin &gt;&gt; idFollow;//i号用户关注的用户编号            adj[idFollow].push_back(user);//边idFollow-&gt;i        &#125;    &#125;    int numQuery, s;    cin &gt;&gt; numQuery;//查询个数    for(int i = 0; i &lt; numQuery; i++)&#123;        memset(vis, false, sizeof(vis));        cin &gt;&gt; s;//起始结点编号        int numForward = BFS(s, L);        cout &lt;&lt; numForward &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;//邻接矩阵int n,G[maxn][maxn];int d[maxn];bool vis[maxn];void dijkstra(int s)&#123;    fill(vis,vis+maxn,false);    fill(d,d+maxn,INF);    d[s]=0;    for(int i = 0;i&lt;n;i++)&#123;        int u=-1,MIN=INF;        for(int j = 0;j&lt;n;j++)&#123;            if(vis[j]==false &amp;&amp; d[j]&lt;MIN)&#123;                u=j;                MIN=d[j];            &#125;        &#125;        if(u==-1) return;        vis[u]=true;        for(int v=0;v&lt;n;v++)&#123;            if(vis[v]==false &amp;&amp;G[u][v]!=INF)&#123;                if(d[u]+G[u][v]&lt;d[v])&#123;                    d[v]=d[u]+G[u][v];                &#125;            &#125;        &#125;    &#125;&#125;//邻接表实现struct node&#123;    int v,dis;&#125;;vector&lt;node&gt;adj[maxn];void dijkstra2(int s)&#123;    fill(vis,vis+maxn,false);    fill(d,d+maxn,INF);    d[s]=0;    for(int i = 0;i&lt;n;i++)&#123;        int u = -1,MIN=INF;        for(int j=0;j&lt;n;j++)&#123;            if(vis[j]==false &amp;&amp;d[j]&lt;MIN)&#123;                MIN=d[j];                u=j;            &#125;        &#125;        if(u==-1) return;        vis[u]=true;        for(int i =0;i&lt;adj[u].size();i++)&#123;            int v=adj[u][i].v;            if(vis[v]==false)&#123;                if(d[u]+adj[u][i].dis&lt;d[v])&#123;                    d[v]=d[u]+adj[u][i].dis;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    int u,v,w;    int m,s;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);    fill(G[0],G[0]+maxn*maxn,INF);    for(int i=0;i&lt;m;i++)&#123;        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);        G[u][v]=w;        G[v][u]=w;    &#125;    dijkstra(s);    for(int i=0;i&lt;n;i++) printf(&quot;%d  &quot;,d[i]);    return 0;&#125;</code></pre><p>例题PAT A1003（加入点权，路径数等第二衡量标准）</p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;//邻接矩阵int n,m,st,ed,G[maxn][maxn];int d[maxn];int w[maxn];int num[maxn];int weight[maxn];bool vis[maxn];void Dijkstra(int s)&#123;    fill(d,d+maxn,INF);    fill(w,w+maxn,0);    fill(num,num+maxn,0);    fill(vis,vis+maxn,false);    d[s]=0;    w[s]=weight[s];    num[s]=1;    for(int i=0;i&lt;n;i++)&#123;        int u=-1,MIN=INF;        for(int j=0;j&lt;n;j++)&#123;            if(vis[j]==false &amp;&amp;d[j]&lt;MIN)&#123;                MIN=d[j];                u=j;            &#125;        &#125;        if(u==-1) return;        vis[u]=true;        for(int v=0;v&lt;n;v++)&#123;            if(vis[v]==false&amp;&amp;G[u][v]!=INF)&#123;                if(d[u]+G[u][v]&lt;d[v])&#123;                    d[v]=d[u]+G[u][v];                    w[v]=w[u]+weight[v];                    num[v]=num[u];                &#125;else if(d[u]+G[u][v]==d[v])&#123;                    if(w[u]+weight[v]&gt;w[v])&#123;                        w[v]=w[u]+weight[v];                    &#125;                    num[v]+=num[u];                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;st,&amp;ed);    for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;weight[i]);    fill(G[0],G[0]+maxn*maxn,INF);    for(int i=0;i&lt;m;i++)&#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        G[a][b]=G[b][a]=c;    &#125;    Dijkstra(st);    printf(&quot;%d %d&quot;,num[ed],w[ed]);    return 0;&#125;</code></pre><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;int n,m;int dis[maxn][maxn];void Floyd()&#123;    for(int k=0;k&lt;n;k++)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                if(dis[i][k]!=INF&amp;&amp;dis[k][j]!=INF&amp;&amp;dis[i][k]+dis[k][j]&lt;dis[i][j])&#123;                    dis[i][j]=dis[i][k]+dis[k][j];                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    int u,v,w;    fill(dis[0],dis[0]+maxn*maxn,INF);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;m;i++)&#123;        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);        dis[u][v]=w;    &#125;    Floyd();    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            printf(&quot;%d &quot;,dis[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1000;//设置为最大数const int INF = 1000000000;int n,G[maxn][maxn];int d[maxn];//顶点到集合S最短距离bool vis[maxn];int Prim()&#123;    fill(d,d+maxn,INF);    d[0]=0;    int ans=0;    for(int i=0;i&lt;n;i++)&#123;        int u=-1,MIN=INF;        for(int j=0;j&lt;n;j++)&#123;            if(vis[j]==false &amp;&amp;d[j]&lt;MIN)&#123;                u=j;                MIN=d[j];            &#125;        &#125;        if(u==-1) return;        vis[u]=true;        ans+=d[u];        for(int v=0;v&lt;n;v++)&#123;            if(vis[v]==false &amp;&amp; G[u][v]!=INF&amp;&amp;G[u][v]&lt;d[v])&#123;                d[v]=G[u][v];            &#125;        &#125;    &#125;    return ans;&#125;int main()&#123;    int u,v,w;    fill(G[0],G[0]+maxn*maxn,INF);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;m;i++)&#123;        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);        G[u][v]=G[v][u]=w;    &#125;    printf(&quot;%d\n&quot;,Prim());    return 0;&#125;</code></pre><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 110;const int maxe= 10010;//设置为最大数const int INF = 1000000000;struct edge&#123;    int u,v;    int cost;&#125;E[maxe];bool cmp(edge a,edge b)&#123;    return a.cost&lt;b.cost;&#125;int father[maxn];int findFather(int x)&#123;    int a=x;    while(x!=father[x])&#123;        x=father[x];    &#125;    while(a!=father[a])&#123;        int z=a;        a=father[a];        father[z]=x;    &#125;    return x;&#125;int kruskal(int n,int m)&#123;    int ans=0,edgeNum=0;    for(int i=0;i&lt;n;i++)&#123;        father[i]=i;    &#125;    sort(E,E+m,cmp);    for(int i=0;i&lt;m;i++)&#123;        int fu=findFather(E[i].u);        int fv=findFather(E[i].v);        if(fu!=fv)&#123;            father[fu]=fv;            ans+=E[i].cost;            edgeNum++;            if(edgeNum==n-1) break;        &#125;    &#125;    if(edgeNum!=n-1) return -1;    else return ans;&#125;int main()&#123;    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;m;i++)&#123;        scanf(&quot;%d%d%d&quot;,&amp;E[i].u,&amp;E[i].v,&amp;E[i].cost);    &#125;    printf(&quot;%d\n&quot;,kruskal(n,m));    return 0;&#125;</code></pre><h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;//最大顶点数const int maxn = 1010;vector&lt;int&gt;G[maxn];int n,m,inDegree[maxn];bool topologicalSort()&#123;    int num=0;    queue&lt;int&gt;q;    for(int i=0;i&lt;n;i++)&#123;        if(inDegree[i]==0) q.push(i);    &#125;    while(!q.empty())&#123;        int u=q.front();        q.pop();        for(int i=0;i&lt;G[u].size();i++)&#123;            int v=G[u][i];            inDegree[v]--;            if(inDegree[v]==0)&#123;                q.push(v);            &#125;        &#125;        G[u].clear();        num++;    &#125;    if(num==n) return true;    else return false;&#125;int main()&#123;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/062941682.html"/>
      <url>/2022/062941682.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h1><h2 id="软件设计模式的产生背景"><a href="#软件设计模式的产生背景" class="headerlink" title="软件设计模式的产生背景"></a>软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。<br>1997年，美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造（A Pattern Language: Towns Building Construction）中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。<br>直到 1990 年，软件工程界才开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。<br>1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件。<br>GoF反复向你强调一个宗旨：要让你的程序尽可能的可重用。      </p><h2 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h2><p>设计模式（Design Pattern）是一种模式，是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案，它是思想的体现，而非具体的实现。<br>这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解（即包含了面向对象的精髓）。       </p><h2 id="我们为什么要学习设计模式"><a href="#我们为什么要学习设计模式" class="headerlink" title="我们为什么要学习设计模式"></a>我们为什么要学习设计模式</h2><p>事实上，我们可能很多情况下都是在不了解设计模式或者了解的不多的情况下作为程序员工作了多年。也在不经意间实现了一些设计模式。<br>那么我们为什么还要学习设计模式？<br>一方面，设计模式教我们如何使用面向对象设计的原则解决各种问题；<br>另一方面，设计模式定义了一种通用语言（跟框架一样，统一一个标准），让大家在做系统设计的时候，能更有效的交流。<br>我们学习设计模块的核心思想是解耦合，并不是消除耦合，而是把耦合控制在一定范围，保证这个范围的整洁。<br>使用设计模式的步骤可以总结成两句话：<br>1）设计模式中提到一句很精髓的话：找到稳定点和变化点，运用抽象，把变化点隔离起来。<br>2）先满足设计原则，再迭代出设计模式。    </p><h2 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h2><p>在学习设计模式前，我们先来复习一下什么是接口、什么是抽象类。<br>在面向对象的设计领域里，有时候会用is-a、has-a、like-a来描述他们之间的关系。例如：A is-a B,代表B是A的父类；A has-a B,那么B就是A的组成部分。A like-a B,则代表B就是A的接口。<br>设计模式并非只针对于java,而是所有面向对象语言的设计模式，在接下来的设计模式讲解中，我们以java为例。为什么选择java？java作为一门集大成的语言，博纳众多语言之所长，是最优秀的面向对象语言之一。    </p><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>接口通常代表一种承诺或者规范，是对象必须遵守的承诺，即使实现类发生再大的变化，也能保证所有的实现类都有相关的方法可供调用；也就是说，实现类有责任去编写实现我接口中的方法，即使是一个空方法。<br>java将接口的概念升为独立的结构，体现了接口与实现的分离。     </p><h3 id="什么是抽象类"><a href="#什么是抽象类" class="headerlink" title="什么是抽象类"></a>什么是抽象类</h3><p>在面向对象的概念中，我们所有的对象都是通过类来描述的。而反过来确不是这样的，并不是所以的类都是用来描绘对象的，如果一个类中没有足够的信息来描绘一个具体的对象，那么这样的类就是抽象的。<br>抽象类除了不能实例化对象之外，类的其它功能依然存在。抽象类更多的是对通用的、基础的方法封装，让子类复用，避免在子类开发重复的代码。子类只需实现抽象方法，也可以有选择的覆盖抽象父类的方法。        </p><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><p>一个类可以实现多个接口，但是只能继承一个抽象类；<br>接口都是抽象方法，而抽象类中既可以有抽象方法，也可以有实例（具体）方法；<br>接口中的变量都是public static final；而抽象类中的变量可以被任何通用修饰符修饰；<br>接口的方法都是public;抽象类中的方法可以是public、protected、private或者默认的package；<br>接口不能定义构造函数，但抽象类可以。     </p><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>GoF中一共收录了23个设计模式，每个设计模式都旨在解决不同场景的问题。     </p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p>​所有模式都可以按其意图或目的进行分类。     </p><h3 id="按意图划分"><a href="#按意图划分" class="headerlink" title="按意图划分"></a>按意图划分</h3><img src="/2022/062941682/1.jpg" class>     <h3 id="按目的划分"><a href="#按目的划分" class="headerlink" title="按目的划分"></a>按目的划分</h3><p>​设计模式按目的来划分可以分为三大类，分为创建型模式、结构型模式和行为型模式 3 种。<br>​如果还需要分的更细，根据模式是主要用于类上还是主要用于对象上来分，又可分为类模式和对象模式两种。     </p><img src="/2022/062941682/3.jpg" class>   <h2 id="单例模式Singleton"><a href="#单例模式Singleton" class="headerlink" title="单例模式Singleton"></a>单例模式Singleton</h2><p>单例模式：是一种创建型设计模式，一个类只有一个实例，同时提供对该实例的全局访问点。<br>单例模式的应用场景：<br>​1）需要频繁实例化或被共享的场合。比如：日志记录、缓存和线程池；<br>​2）控制硬件级别的操作。比如：驱动程序对象。<br>​3）单例模式也可以用于其他设计模式：比如抽象工厂模式、建造者模式、原型模式即门面模式都可以作为单例实现。     </p><h2 id="原型模式Prototype"><a href="#原型模式Prototype" class="headerlink" title="原型模式Prototype"></a>原型模式Prototype</h2><p>原型设计模式是创建模式的一种，因此它提供了一种对象创建机制。它允许用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。<br>原型模式的应用场景：<br>1）创建对象成本比较大(比如：初始化时间比较长，占用 太多的CPU资源等)，新的对象可以通过原型模式对已有对象进行赋值来获取，如果相似对象，则可以对其成员变量稍作修改即可。<br>2）系统想保存对象的状态，而对象的状态变化很小，或者对象占用内存较少的，可以使用原型模式配合备忘录模式来实现。<br>​3）逃避构造函数的约束。     </p><h2 id="建造者模式Builder"><a href="#建造者模式Builder" class="headerlink" title="建造者模式Builder"></a>建造者模式Builder</h2><p>建造者模式是一种创建型模式，可让您逐步构建复杂的对象。将一个复杂的对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。建造者（Builder）模式由抽象建造者、具体建造者、产品、导向器等 4 个要素构成。    </p><img src="/2022/062941682/2.jpg" class>    <p>应用场景：<br>相同的方法，不同的执行顺序，产生不同的结果。<br>产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。<br>初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。        </p><h2 id="适配器模式Adapter"><a href="#适配器模式Adapter" class="headerlink" title="适配器模式Adapter"></a>适配器模式Adapter</h2><p>适配器模式，也称为包装器模式，是一种结构型设计模式，它允许具有不兼容接口的对象进行协作。适配器模式分为类适配器模式、对象适配器模式两种。<br>技术源于生活，也服务于生活。现实生活中就有很多这样的例子，比如：用直流电的笔记本电脑接交流电源时需要一个电源适配器，安卓耳机接苹果手机时需要一个转接头等等，都是适配器的应用。<br>适用场景：<br>1）以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>2）使用第三方提供的组件，但组件接口定义和系统要求的接口定义不同。     </p><h2 id="工厂模式Factory"><a href="#工厂模式Factory" class="headerlink" title="工厂模式Factory"></a>工厂模式Factory</h2><p>①简单工厂，是工厂方法的一种特例，简单工厂模式也叫静态工厂模式，就是工厂类（一般使用静态方法）通过接收的参数来区分并返回不同的对象实例。<br>简单工厂的弊端：每增加一个产品就要增加一个具体产品类和修改工厂类，这增加了系统的复杂度，违背了“开闭原则”。<br>总之，简单工厂就是一个工厂接收不同参数返回不同对象实体。<br>②工厂方法模式，虽然简单工厂模式解决了调用者和创建者之间的耦合，但是工厂和创建者之间依然存在着耦合。这样的设计违背了我们的“开闭原则”，未来新产品的扩展并不灵活。而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码（比如工厂类）的情况下引进新的产品，即满足开闭原则。我们的工厂方法模式就是做这个的。<br>总时，工厂方法就是针对一个对象提供一个工厂类，不同工厂类创建不同的产品实例。<br>③抽象工厂模式，是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。<br>简单的说：就是用来生产不同产品族的全部产品的，抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。<br>总之，抽象工厂就是对于一个产品族都有一个工厂类，但产品族内增加其他新产品需要修改代码。     </p><h2 id="代理模式Proxy"><a href="#代理模式Proxy" class="headerlink" title="代理模式Proxy"></a>代理模式Proxy</h2><p>代理模式是一种结构型设计模式，可以让你为另一个对象提供替代或占位符。代理控制对原始对象的访问，允许您在请求到达原始对象之前或之后执行某些操作。<br>当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。<br>应用场景：<br>1）安全代理：屏蔽对真实角色的直接访问；<br>2）远程代理：通过代理类处理远程方法调用（RMI）；<br>3）延迟加载：先加载轻量级的代理对象，真正需要时再加载真实对象。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。<br>4）记录请求：想要保留对服务对象的请求历史记录的时候可以使用。      </p><h2 id="桥接模式Bridge"><a href="#桥接模式Bridge" class="headerlink" title="桥接模式Bridge"></a>桥接模式Bridge</h2><p>桥接模式是一种结构型设计模式，它允许您将一个大类或一组密切相关的类拆分为两个独立的层次结构——抽象和实现——使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br>其中一个层次结构（通常称为抽象）将获得对第二层次结构（实现）的对象的引用。<br>应用场景：<br>1）当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时，可以使用桥接模式可以解耦这些变化的维度；<br>2）当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时，可以使用桥接模式。       </p><h2 id="组合模式Composite"><a href="#组合模式Composite" class="headerlink" title="组合模式Composite"></a>组合模式Composite</h2><p>组合模式：是一种结构型设计模式，有时也叫合成模式。它允许您将对象组合成树结构，用来表示“整体-部分”的关系，从而使客户端可以使用统一的方式处理部分对象和整体对象（这些对象具体一致的访问性）。<br>什么意思呢？就是当我们的应用程序的核心模型可以表示为树时，用组合模式才有意义。比如，大多数国家的军队都是按等级划分的，一支军队由几个师组成、一个师是一组旅、…一个连由排组成，排可以分解为班；最后，一个班是一小群真正的士兵，命令在层次结构的顶部下达，并传递到每个级别，直到每个士兵都知道需要做什么。<br>组合模式的意图在于：为了保证客户端用单个对象与组合对象的一致性。<br>组合模式的核心角色：<br>抽象构件（Component）角色：定义了叶子构件和容器构件的公共特点，即声明公共接口。<br>叶子构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于继承或实现抽象构件。<br>容器构件（Composite）角色：有容器的特征，可以包含子节点，主要作用是存储和管理子部件，通常包含 add()、remove()、getChild() 等方法。<br>在组合模式中，整个树形结构中的对象都属于同一种类型，最大好处是您不需要关心构成树的对象的具体类（不需要辨别是容器构件（分支节点）还是叶子节点）对象本身会将请求向下传递到树中，给用户的使用带来极大的便利。</p><img src="/2022/062941682/4.jpg" class>     <p>应用场景：<br>一般涉及到数据结构方面的内容且符合树型结构的首先可以想到组合模式。<br>当您需要实现树状结构时，请使用组合模式。比如：操作系统资源管理器、OA系统的组织结构、XML文件解析等；    </p><h2 id="外观模式Facade"><a href="#外观模式Facade" class="headerlink" title="外观模式Facade"></a>外观模式Facade</h2><p>外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。<br>外观（Facade）模式是“迪米特法则”的典型应用，在日常编码工作中，我们都在有意无意的大量使用外观模式。<br>只要是高层模块需要调度多个子系统（这里的子系统可以是一个完整的系统，也可以是模块或者更细粒度的类的对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口（只暴露有限的必要接口），让高层模块可以更加容易地间接调用这些子系统的功能，说白了就是封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如：我们平时写的一些Utils类（DButils）可以理解为Facade；Linux 系统调用函数，它封装了底层更基础的 Linux 内核调用。<br>外观模式更像是客户端应用程序的助手，其本质就是整合接口，封装低层实现细节，为客户端提供一个更简洁的接口，实现了子系统与客户端间的松耦合关系。<br>应用场景：<br>1）当您需要一个有限但直接的接口来连接复杂的子系统时，可以使用外观模式；<br>2）当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。<br>3）防止客户端将对象转换为更底层的真实对象，隐藏底层不必要暴露给客户端的一些方法或属性。             </p><h2 id="装饰器模式Decorater"><a href="#装饰器模式Decorater" class="headerlink" title="装饰器模式Decorater"></a>装饰器模式Decorater</h2><p>装饰器（Decorator）模式一种结构型设计模式，是一种用于代替继承的技术，指在不改变现有对象结构的情况下，动态地给当前对象添加一些额外的功能。<br>装饰器模式的意图在于：运行时修改对象的功能,比生成子类更加灵活。<br>装饰器提供运行时修改能力，因此更加灵活。当可供选择的数量越多时，使用装饰器模式会更加灵活。<br>应用场景：<br>1）当您需要能够在运行时为对象分配额外的行为而不破坏使用这些对象的代码时，请使用装饰器模式。<br>2）当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时（生成子类会产生大量子类），请使用装饰器模式。<br>3）对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰器模式却很好实现时。        </p><h2 id="享元模式Flyweight"><a href="#享元模式Flyweight" class="headerlink" title="享元模式Flyweight"></a>享元模式Flyweight</h2><p>享元模式：“享元”，顾名思义就是被共享的单元，是一种结构型设计模式。以共享的方式高效的支持大量细粒度的对象的重用。<br>享元模式的定义提出了两个要求，细粒度和共享对象。因为要求细粒度，所以不可避免地会使对象数量多且性质相近，此时我们就将这些对象的信息分为两个部分：内部状态和外部状态。<br>内部状态：可以共享，不会随环境变化而改变。<br>外部状态：不可以共享，会随环境变化而改变。<br>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、URL等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些为内部状态，而不需要把这些数据保留在每个对象中。而当每个连接要被回收利用时，我们需要将它标记为不可用状态，这些为外部状态。<br>享元模式的意图在于：通过共享来缓存对象，降低内存消耗，前提是享元的对象是不可变对象。<br>享元模式可以使你共享地访问那些大量出现的细粒度的对象，有人会觉得这不是和单例模式很像吗？只不过是享元模式有多个对象共享。但是他们的设计意图两个不同的出发点，享元模式是为了对象复用，节省内存；而单例模式则是为了限制对象的个数，享元对象不可变，而单例对象是可变的。<br>应用场景：<br>1）应用程序需要产生大量类似的对象，包含可以在多个对象之间提取和共享的重复状态时可以使用享元模式。      </p><h2 id="命令模式Command"><a href="#命令模式Command" class="headerlink" title="命令模式Command"></a>命令模式Command</h2><p>命令模式是一种行为设计模式，它将请求转换为包含有关请求信息的独立对象，将请求和与执行请求的职责分离，方便对请求进行储存、传递、调用的管理，使其可以对请求进行排队、存储请求历史记录或撤销请求等操作。<br>命令模式可以存储请求对象信息，这些对象可以作为方法参数传递、延迟或排队去执行，所以也可以定位到之前的操作。举个例子：<br>去餐馆吃饭，顾客找服务员点菜，每一个顾客的点菜都是一个请求，服务员将点菜信息传递给厨师，服务员并不关心菜如何做、谁来做，当顾客一多，就会出现排队的现象，这时候服务员（顾客点菜）和厨师（做菜）各司其职，井井有条才能控制整体的效率。<br>命令模式的意图在于：将一个请求封装为一个对象，将请求和与执行请求的职责分离，方便对请求进行储存、传递、调用的管理。<br>使用命令模式，可以将任何操作转换为对象。这种转换使得我们可以推迟操作的执行、对其进行排队、存储命令的历史记录、将命令发送到远程服务等。<br>应用场景：<br>1）当你想要将操作参数化对象时，可以使用命令模式将特定的方法调用变成一个独立的对象；<br>2）当你想要实现可逆操作时，可以使用命令模式。比如：数据库的事务机制就是命令模式的应用；<br>3）当系统要执行一组操作时，命令模式可以定义宏命令来实现该功能。     </p><h2 id="责任链模式ChainOfResponsibility"><a href="#责任链模式ChainOfResponsibility" class="headerlink" title="责任链模式ChainOfResponsibility"></a>责任链模式ChainOfResponsibility</h2><p>责任链模式是一种行为设计模式，为了避免发送者与多个请求处理者耦合在一起，将能够处理同一类请求的对象连成一条链，所提交的请求沿着处理程序链传递,如果能处理则处理，如果不能处理则传递给链上的下一个对象。<br>责任链模式的意图在于：将特定行为转换为处理程序的独立对象，以解除请求的发送者与接受者之间的耦合。也就是说请求只需要发送到责任链上，无须关心请求的处理细节和请求的传递过程，请求会自动处理。<br>    在运用责任链模式时，客户端不必事先知道对象集合中的哪个对象可以提供自己需要的服务。当客户端发出请求后，该请求会沿着职责链转发请求，直到找到能够提供该服务的对象为止。这就实现了请求者与执行者间的解耦。<br>应用场景：<br>1）如果希望以各种方式处理不同类型的请求，并且不知道请求的确切类型时，可以使用责任链模式；<br>2）当以特定顺序执行多个处理程序时，可以使用 模式；（由于你可以按某种顺序链组合，所有的请求都会按你指定的计划执行）；<br>3）当你的应用程序可能需要动态指定一组对象处理请求时，或者希望添加新的处理者时，可以使用责任链模式；       </p><h2 id="状态模式State"><a href="#状态模式State" class="headerlink" title="状态模式State"></a>状态模式State</h2><p>状态模式是一种行为设计模式，它允许对象在其内部状态发生变化时改变其行为，即把复杂的“判断逻辑”转移到独立的类中，以表示对象的状态。<br>状态模式的意图在于：将表示对象状态的逻辑分散到代表状态的不同类中，用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。<br>状态模式，可以看作是策略模式的延伸。两种模式都是基于组合的，它们通过将一些工作委托给辅助对象来改变上下文的行为，但是策略模式对Strategy的具体实现类有绝对的控制权，即Context要感知Strategy具体类型。而状态模式，Context不需要感知State的具体实现，只需要调用自己的方法，然后委托给State来完成，State会在相应的方法调用时，自动设置状态，这个过程对Context来说是透明的。<br>应用场景：<br>1）当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，可以考虑使用状态模式；<br>2）一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时，可以使用状态模式。        </p><h2 id="观察者模式Observer"><a href="#观察者模式Observer" class="headerlink" title="观察者模式Observer"></a>观察者模式Observer</h2><p>观察者模式是一种行为设计模式，指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>这种模式和发布-订阅模式很像，不同的是，发布-订阅模式，一般有一个调度中心，调度中心有拉模式和推模式来推送消息。<br>观察者模式的意图在于：主要解决多个对象间存在一对多的依赖关系，当一个对象状态改变给其他对象通知的问题，让主题和观察者之间松耦合。<br>观察者模式的在对象间定义一对多的依赖，当一个对象改变状态，依赖的对象都会收到通知，并自动更新。Swing、JavaBeans、RMI中都有观察者模式的应用。<br>应用场景：<br>1）对象间存在一对多关系，一个对象的状态发生改变会影响其他对象时，可以使用观察者模式；<br>2）当应用程序中的某些对象必须观察其他对象时，可以使用观察者模式。        </p><h2 id="中介者模式Mediator"><a href="#中介者模式Mediator" class="headerlink" title="中介者模式Mediator"></a>中介者模式Mediator</h2><p>中介者模式又叫调停模式，是一种行为设计模式，中介者使各个对象不需要显示的相互引用，而是通过一个特殊的中介者对象使程序组件间接通信，从而减少程序组件之间的耦合，它是迪米特法则的典型应用。<br>该模式限制了对象之间的直接通信，并迫使它们仅通过中介对象进行协作，类似于MVC模式中的 Controller 部分，控制器（C）就是模型（M）和视图（V）的中介者。<br>中介者模式的意图在于：减少对象之间的混乱关系（大量多对多的关系）时，通过中介者统一管理这些对象，将对象之间的交互封装在中介者的对象中，从而减少对象间的耦合。<br>中介者模式的主要目的就是消除一组系统组件之间的相互依赖关系，而变成依赖于单个中介对象，它集中了系统组件之间的通信，组件只知道中介对象，而很难直接与真正的组件（房东）通信。<br>应用场景：<br>1）许多对象以复杂的方式交互时的依赖关系使得系统难以理解和维护时，可以使用中介者模式；<br>2）一个对象引用其他很多对象，导致难以复用该对象时，可以使用中介者模式。       </p><h2 id="迭代器模式Iterator"><a href="#迭代器模式Iterator" class="headerlink" title="迭代器模式Iterator"></a>迭代器模式Iterator</h2><p>迭代器模式是一种行为设计模式，提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示（列表、堆栈、树…）的情况下遍历集合的元素。<br>迭代器模式不仅仅是遍历一个集合，我们可以根据我们的需求提供不同类型的迭代器。不过我们很少会自己实现一个迭代器，java API中提供的迭代器完全够用了。<br>迭代器模式的意图在于：提供一种在不暴露其底层表示的情况下访问聚合对象的元素的方法。<br>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。<br>应用场景：<br>1）如果希望提供一种标准方法来迭代集合并隐藏客户端程序的实现逻辑时，可以使用迭代器模式；<br>2）当需要为遍历不同的聚合结构提供一个统一的接口时，可以使用迭代器模式。       </p><h2 id="访问者模式Visitor"><a href="#访问者模式Visitor" class="headerlink" title="访问者模式Visitor"></a>访问者模式Visitor</h2><p>访问者模式是一种行为设计模式，在GoF的《Design Pattern》中的定义是：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。<br>简单的说，访问者模式就是把作用于元素（数据结构&#x2F;算法）的操作分离出来封装成独立的类，使得操作集可以相对自由的实现，新增操作时不违背开闭原则。<br>访问者模式的意图在于：将数据结构与作用于结构上的操作进行解耦，使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。<br>是不是觉得访问者模式有点像模板方法模式，都是封装了固定不变的东西，开放了可变的东西。模板方法模式为可变部分预留扩展点，而访问者模式，将可变点分离出来由访问者来决定做一些处理，但是它们还是有一点区别的，访问者模式在变化（访问者）与固定（被访问者）之间，是组合关系，而模板方法模式的变化与固定之间是继承关系。<br>访问者模式在迭代器模式下做了进一步的分离，它是对迭代器模式的扩充，可以遍历不同的对象，也可以在遍历的同时执行一些其他的操作。<br>应用场景：<br>1）如果需要对复杂对象结构或对象结构比较稳定，但需要对所有元素执行操作时，可以使用访问者模式；<br>2）可以将所有其他行为提取到一组访问者类中，使您的应用程序的主要类更加专注于它们的主要工作；<br>3）可以充当拦截器角色。    </p><h2 id="备忘录模式Memento"><a href="#备忘录模式Memento" class="headerlink" title="备忘录模式Memento"></a>备忘录模式Memento</h2><p>备忘录模式是一种行为设计模式，又叫快照模式，是指在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后需要时能将该对象恢复到原先保存的状态。<br>通俗地说，备忘录模式就是一个对象的备份模式，提供了一种程序数据的备份方法，具体采用哪种方法来存储对象状态，取决于对象需要保存时间的长短。<br>备忘录模式的意图在于：为对象状态提供存储和恢复功能，对象的已保存状态数据在对象外部不可访问。<br>借助备忘录模式，可以捕获对象的状态，对象的已保存状态数据在对象外部是不可访问，这保护了已保存状态数据的完整性，这也是备忘录模式的优势所在。<br>我们可能用的比较多的就是把对象的状态存储在另外一个对象中或者是为了支持对象跨多个会话的持久性存储，使用对象序列化来存储对象信息，也就是我们前面学习的原型模式，原型模式可以是备忘录模式的替代。所以备忘录模式并不常用。<br>应用场景：<br>1）当您想要生成对象状态的快照以便能够恢复对象的先前状态时，可以使用备忘录模式；<br>2）当直接访问对象的字段getter、setter 违反其封装时，可以使用备忘录模式。        </p><h2 id="解释器模式Interpreter"><a href="#解释器模式Interpreter" class="headerlink" title="解释器模式Interpreter"></a>解释器模式Interpreter</h2><p>解释器模式是一种行为设计模式，指给定一种语言，定义其语法的表示形式，以及使用该表示形式来解释该语言中句子。<br>解释器模式的意图在于：让你根据实现定义好的一些语法规则，组合成和执行的对象。<br>在软件构建过程中，如果某一特定领域的问题比较复杂且类似的情况不断的重复出现，但是使用普通的编程方式来实现可能非常繁琐且不是那么灵活，面临非常频繁的修改，这种情况下使用解释器模式可能会是一种更好的选择。<br>其实，以前在开发中也用过这种模式去处理打印数据，将一些打印数据的转换、截取、换行写在配置文件中，用一串规则写在配置文件中作为一种通用的处理（只不过没有按解释器模式这种套路去写的那么规范），实在是处理不了的，才会去单独在代码中重写打印方法去处理打印数据，所以在写代码时设计模式并不是要完全套用的。<br>应用场景：<br>当一个语言需要解释执行时，并且你可以将该语言中的句子表达为一个抽象的语法树时，可以使用解释器模式。     </p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构排序</title>
      <link href="/2022/062757485.html"/>
      <url>/2022/062757485.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构排序"><a href="#数据结构排序" class="headerlink" title="数据结构排序"></a>数据结构排序</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>评价排序算法的评价指标：<br>时间复杂度，空间复杂度，算法稳定性<br>分类：    </p><img src="/2022/062757485/1.jpg" class>   <h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="/2022/062757485/2.jpg" class>   <h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序对于基本有序序列的排序性能比较优秀，所以希尔排序就是分组把序列变为基本有序。   </p><img src="/2022/062757485/3.jpg" class>   <img src="/2022/062757485/4.jpg" class>   <h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><img src="/2022/062757485/5.jpg" class>   <h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><img src="/2022/062757485/6.jpg" class>   <img src="/2022/062757485/7.jpg" class>   <h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><img src="/2022/062757485/8.jpg" class>   <h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><img src="/2022/062757485/9.jpg" class>   <img src="/2022/062757485/10.jpg" class>   <img src="/2022/062757485/11.jpg" class>   <img src="/2022/062757485/12.jpg" class>   <h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><img src="/2022/062757485/13.jpg" class>   <h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><img src="/2022/062757485/14.jpg" class>   <img src="/2022/062757485/15.jpg" class>   <img src="/2022/062757485/17.jpg" class>   <h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><img src="/2022/062757485/18.jpg" class>   <p>为了优化速度，减少磁盘读取次数：   </p><img src="/2022/062757485/19.jpg" class>   <img src="/2022/062757485/20.jpg" class>   <img src="/2022/062757485/21.jpg" class>   <ul><li>总结：  <img src="/2022/062757485/22.jpg" class>   <h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><img src="/2022/062757485/23.jpg" class>   <h2 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h2><h2 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h2></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2022/062757485/24.jpg" class>    ]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构查找</title>
      <link href="/2022/062445914.html"/>
      <url>/2022/062445914.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构查找"><a href="#数据结构查找" class="headerlink" title="数据结构查找"></a>数据结构查找</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/2022/062445914/1.jpg" class>   <img src="/2022/062445914/2.jpg" class>   <img src="/2022/062445914/3.jpg" class>   <h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><img src="/2022/062445914/4.jpg" class>   <h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>只适用有序顺序表    </p><img src="/2022/062445914/5.jpg" class>   <h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><img src="/2022/062445914/6.jpg" class>   <p>先查找分块，再块内顺序查找。<br>也可以对分块进行折半查找，索引表不包括目标关键字，则折半查找索引表停留在low&gt;high，要在low所指分块中查找。    </p><img src="/2022/062445914/7.jpg" class>   <h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树又称多路平衡查找树，是一种组织和维护外存文件系统非常有效的数据结构。   </p><img src="/2022/062445914/8.jpg" class>   <img src="/2022/062445914/9.jpg" class>   <img src="/2022/062445914/10.jpg" class>   <ul><li>插入和删除：   <img src="/2022/062445914/11.jpg" class>   <img src="/2022/062445914/12.jpg" class>   <h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2>类似于分块查找，块关键字最大值为父节点关键字。<br>无论查找成功&#x2F;失败，都需要查找到叶子结点。也可以进行顺序查找。<br>经典应用于关系型数据库的索引如MySQL。      <img src="/2022/062445914/13.jpg" class>   </li><li>区别：<br>B+树中n给关键字对应n个子树，而B树对应n+1个子树。<br>B+树关键字限制和B树关键字限制不同。<br>B+树中叶子结点包括了所有的关键字（非叶子结点的关键字也会出现在叶子结点中），而B树结点关键字不重复。<br>B+树中叶子结点包含信息，所有非叶子结点仅仅起到索引作用，不含有该关键字对应记录的存储地址，而B树结点都包含了关键字对应的记录的存储地址。    <img src="/2022/062445914/14.jpg" class>   <h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><img src="/2022/062445914/15.jpg" class>     常见散列函数：    <img src="/2022/062445914/18.jpg" class>   <img src="/2022/062445914/19.jpg" class>   <img src="/2022/062445914/20.jpg" class>   <img src="/2022/062445914/21.jpg" class>   处理冲突：      </li><li>开放定址法：    <img src="/2022/062445914/22.jpg" class>   </li><li>拉链法：<img src="/2022/062445914/16.jpg" class>   <img src="/2022/062445914/17.jpg" class>   </li><li>再散列法：   <img src="/2022/062445914/23.jpg" class>   </li><li>总结：    <img src="/2022/062445914/24.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构图</title>
      <link href="/2022/062242585.html"/>
      <url>/2022/062242585.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h1><h2 id="图基本概念"><a href="#图基本概念" class="headerlink" title="图基本概念"></a>图基本概念</h2><img src="/2022/062242585/1.jpg" class>   <img src="/2022/062242585/2.jpg" class>   <img src="/2022/062242585/3.jpg" class>   <img src="/2022/062242585/4.jpg" class>   <img src="/2022/062242585/5.jpg" class>   <img src="/2022/062242585/6.jpg" class>   <img src="/2022/062242585/7.jpg" class>   <img src="/2022/062242585/8.jpg" class>   <img src="/2022/062242585/9.jpg" class>   <img src="/2022/062242585/10.jpg" class>   <img src="/2022/062242585/11.jpg" class>   <img src="/2022/062242585/12.jpg" class>   <img src="/2022/062242585/13.jpg" class>   <img src="/2022/062242585/14.jpg" class>   <ul><li>总结：   <img src="/2022/062242585/15.jpg" class>    <h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2></li><li>邻接矩阵法：  <img src="/2022/062242585/16.jpg" class>    <img src="/2022/062242585/17.jpg" class>    <img src="/2022/062242585/18.jpg" class>    </li><li>邻接表法：   <img src="/2022/062242585/19.jpg" class>    </li><li>比较：   <img src="/2022/062242585/20.jpg" class>    </li><li>十字链表法：（只存储有向图）   <img src="/2022/062242585/21.jpg" class>    </li><li>邻接多重表：（只存储无向图）     <img src="/2022/062242585/22.jpg" class>    </li><li>总结：    <img src="/2022/062242585/23.jpg" class>    <h2 id="图的广度优先遍历BFS"><a href="#图的广度优先遍历BFS" class="headerlink" title="图的广度优先遍历BFS"></a>图的广度优先遍历BFS</h2>对比树的层序遍历：   <img src="/2022/062242585/24.jpg" class>    遍历所有连通分量，每个分量BFS：<img src="/2022/062242585/25.jpg" class>    根据BFS遍历得出序列-&gt;广度优先生成树，广度优先生成森林：     <img src="/2022/062242585/26.jpg" class>    <img src="/2022/062242585/27.jpg" class>    <h2 id="图的深度优先遍历DFS"><a href="#图的深度优先遍历DFS" class="headerlink" title="图的深度优先遍历DFS"></a>图的深度优先遍历DFS</h2>对比图的先根遍历。     <img src="/2022/062242585/28.jpg" class>    根据DFS遍历得出序列-&gt;深度优先生成树，深度优先生成森林：     <img src="/2022/062242585/29.jpg" class>    <img src="/2022/062242585/30.jpg" class>   <h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><img src="/2022/062242585/31.jpg" class>   </li><li>Prim算法（加入顶点）   </li><li>Kruskal算法（加入边）</li><li>每个图的最小生成树的最小边权唯一，而树不唯一（不同起点和不同走法都会产生不同树），非连通图产生最小连通森林。   <img src="/2022/062242585/32.jpg" class>   <h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><img src="/2022/062242585/34.jpg" class>   分为单源，各顶点间最短路径。</li><li>BFS法：（不适用带权图）  <img src="/2022/062242585/33.jpg" class>   </li><li>Dijkstra法：（不适用负权图）    <img src="/2022/062242585/35.jpg" class>   </li><li>Floyd法：<img src="/2022/062242585/36.jpg" class>   </li><li>总结：    <img src="/2022/062242585/37.jpg" class>   <h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><img src="/2022/062242585/38.jpg" class>   描述表达式：<img src="/2022/062242585/39.jpg" class>   <h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2>DAG的另一个应用。<br>拓扑排序，和逆拓扑排序可能不唯一，图中有环则不存在。         <img src="/2022/062242585/40.jpg" class>   <img src="/2022/062242585/41.jpg" class>   <img src="/2022/062242585/42.jpg" class>   <img src="/2022/062242585/43.jpg" class>   </li><li>逆拓扑排序：   <img src="/2022/062242585/44.jpg" class>   也可以用DFS直接实现。   <h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><img src="/2022/062242585/45.jpg" class>   <img src="/2022/062242585/46.jpg" class>   源点到汇点路径可能有多条，最大路径长度的路径为关键路径，该条路径上的活动称为关键活动。整个工程最短时间就说关键路径的长度。    <img src="/2022/062242585/47.jpg" class>   <img src="/2022/062242585/48.jpg" class>   <img src="/2022/062242585/49.jpg" class>   <img src="/2022/062242585/50.jpg" class>   <img src="/2022/062242585/51.jpg" class>    特性：     <img src="/2022/062242585/52.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构树与二叉树</title>
      <link href="/2022/062126551.html"/>
      <url>/2022/062126551.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构树与二叉树"><a href="#数据结构树与二叉树" class="headerlink" title="数据结构树与二叉树"></a>数据结构树与二叉树</h1><h2 id="树定义"><a href="#树定义" class="headerlink" title="树定义"></a>树定义</h2><img src="/2022/062126551/1.jpg" class>   <img src="/2022/062126551/2.jpg" class>   <img src="/2022/062126551/3.jpg" class>   <p>有序树vs无序树：  </p><img src="/2022/062126551/4.jpg" class>   <img src="/2022/062126551/5.jpg" class>   <h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><img src="/2022/062126551/6.jpg" class>   <img src="/2022/062126551/7.jpg" class>   <img src="/2022/062126551/8.jpg" class>   <img src="/2022/062126551/9.jpg" class>   <img src="/2022/062126551/10.jpg" class>   <img src="/2022/062126551/11.jpg" class>   <h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><img src="/2022/062126551/12.jpg" class>   <p>特殊二叉树：  </p><img src="/2022/062126551/13.jpg" class>   <img src="/2022/062126551/14.jpg" class>   <img src="/2022/062126551/15.jpg" class>   <h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><img src="/2022/062126551/16.jpg" class>   <img src="/2022/062126551/17.jpg" class>   <img src="/2022/062126551/18.jpg" class>   <p>完全二叉树：  </p><img src="/2022/062126551/19.jpg" class>   <img src="/2022/062126551/20.jpg" class>   <h2 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h2><p>使用数组顺序存储，只适合存储完全二叉树（非完全会浪费很多空间，i的左右孩子为2i和2i+1）<br>使用链式存储，n个结点二叉链表有n+1个空链表域，智能从根开始查找结点，也可以建立三叉链表（带parent指针）。    </p><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>先中后序遍历，层次遍历。<br>算数表达式进行三种遍历对应三种表达式：   </p><img src="/2022/062126551/21.jpg" class>   <h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><img src="/2022/062126551/22.jpg" class>   <h2 id="线索二叉树（二叉链表）"><a href="#线索二叉树（二叉链表）" class="headerlink" title="线索二叉树（二叉链表）"></a>线索二叉树（二叉链表）</h2><p>所有遍历序列其实就是一个线性表，每个结点有前驱&#x2F;后继。而二叉树中很难找前驱后继，所以线索二叉树就是为了查找前驱后继而创立出来。<br>则把n+1空链域存放其他的前驱&#x2F;后继。   </p><img src="/2022/062126551/24.jpg" class>   <p>分为中序线索二叉树，先序线索二叉树，后序线索二叉树，需要对二叉树分别进行线索化。    </p><img src="/2022/062126551/23.jpg" class>   <ul><li>寻找前驱和后继：   <img src="/2022/062126551/25.jpg" class>   <h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2>双亲表示法：找双亲简单，找孩子困难。     <img src="/2022/062126551/26.jpg" class>   孩子表示法：找孩子简单，找双亲困难。      <img src="/2022/062126551/27.jpg" class>   孩子兄弟表示法：（二叉树和树相互转换）     <img src="/2022/062126551/28.jpg" class>   同时也可以使用这种存储结构来进行森林和二叉树的转换：     <img src="/2022/062126551/29.jpg" class>   <h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><img src="/2022/062126551/35.jpg" class>   树的先根遍历：    <img src="/2022/062126551/30.jpg" class>   树的后根遍历：    <img src="/2022/062126551/31.jpg" class>   树的层次遍历：    <img src="/2022/062126551/33.jpg" class>   森林的先序遍历：    <img src="/2022/062126551/32.jpg" class>   （效果相当于对每个子树先根遍历，把森林转化为二叉树相当于二叉树的先序遍历）<br>森林的中序遍历：    <img src="/2022/062126551/34.jpg" class>   （效果相当于对每个子树后根遍历，把森林转化为二叉树相当于二叉树的中序遍历）<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><img src="/2022/062126551/36.jpg" class>   需要懂得BST的查找，插入，删除，构造（不同的关键字序列可能得到同款BST，也可能不同BST）。<br>删除：①叶子结点直接删除。②只有左子树&#x2F;右子树，直接替代。③：左右子树都有，利用前驱&#x2F;后继来替代，如图：    <img src="/2022/062126551/37.jpg" class>   </li><li>查找效率：   <img src="/2022/062126551/38.jpg" class>   <img src="/2022/062126551/39.jpg" class>   尽量让左右子树保持平衡<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><img src="/2022/062126551/40.jpg" class>   插入结点可能会导致不平衡：  <img src="/2022/062126551/41.jpg" class>   调整的四种策略：   <img src="/2022/062126551/42.jpg" class>   <img src="/2022/062126551/43.jpg" class>   <img src="/2022/062126551/44.jpg" class>   <img src="/2022/062126551/45.jpg" class>   查找效率：    <img src="/2022/062126551/46.jpg" class>   <h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2>红黑树是一种自平衡二叉排序树，它属于平衡树，但是却没有平衡二叉树那么“平衡”。<br>红黑树的规则：<br>规则1: 每个节点不是黑色就是红色<br>规则2： 根节点为黑色<br>规则3：红色节点的父节点和子节点不能为红色<br>规则4：所有的叶子节点都是黑色（空节点视为叶子节点NIL）<br>规则5：每个节点到叶子节点的每个路径黑色节点的个数相等。       </li><li>跟AVL区别：<br>平衡二叉树的左右子树的高度差绝对值不超过1，但是红黑树在某些时刻可能会超过1，只要符合红黑树的五个条件即可。<br>二叉树只要不平衡就会进行旋转，而红黑树不符合规则时，有些情况只用改变颜色不用旋转，就能达到平衡。         </li><li>通过改变颜色&#x2F;旋转来维持红黑树的平衡。<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><img src="/2022/062126551/47.jpg" class>   在含有n个带权叶结点的二叉树中，带权路径长度WPL最小的二叉树为哈夫曼树，也叫最优二叉树。</li><li>构造：   <img src="/2022/062126551/48.jpg" class>   </li><li>哈夫曼编码：  <img src="/2022/062126551/49.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构串</title>
      <link href="/2022/062021265.html"/>
      <url>/2022/062021265.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构串"><a href="#数据结构串" class="headerlink" title="数据结构串"></a>数据结构串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><img src="/2022/062021265/1.jpg" class>   <p>跟线性表关系：串就是一种线性表。<br>串的操作:  </p><img src="/2022/062021265/2.jpg" class>   <p>存在顺序存储和链式存储。   </p><h2 id="串的朴素模式匹配"><a href="#串的朴素模式匹配" class="headerlink" title="串的朴素模式匹配"></a>串的朴素模式匹配</h2><img src="/2022/062021265/3.jpg" class>   <h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p><a href="https://blog.csdn.net/dark_cy/article/details/88698736">https://blog.csdn.net/dark_cy/article/details/88698736</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构栈队列数组</title>
      <link href="/2022/061945929.html"/>
      <url>/2022/061945929.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构栈队列数组"><a href="#数据结构栈队列数组" class="headerlink" title="数据结构栈队列数组"></a>数据结构栈队列数组</h1><h2 id="栈基本概念"><a href="#栈基本概念" class="headerlink" title="栈基本概念"></a>栈基本概念</h2><img src="/2022/061945929/1.jpg" class>   <p>卡特兰数：  </p><img src="/2022/061945929/2.jpg" class>   <h2 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h2><p>顺序：<br>栈顶指针两种方式（指向栈顶元素，指向栈顶元素+1），共享栈。   </p><img src="/2022/061945929/3.jpg" class>   <img src="/2022/061945929/4.jpg" class>   <p>链式：<br>也就是单链表的头插法和头删法。   </p><img src="/2022/061945929/5.jpg" class>   <h2 id="队列基本概念"><a href="#队列基本概念" class="headerlink" title="队列基本概念"></a>队列基本概念</h2><img src="/2022/061945929/6.jpg" class>   <h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><p>顺序：  </p><img src="/2022/061945929/7.jpg" class>   <p>链式：  </p><img src="/2022/061945929/8.jpg" class>   <p>双端队列：  </p><img src="/2022/061945929/9.jpg" class>   <h2 id="栈应用"><a href="#栈应用" class="headerlink" title="栈应用"></a>栈应用</h2><ul><li>括号匹配：  <img src="/2022/061945929/10.jpg" class>   </li><li>表达式求值：<br>前中后缀表达式的相互转换<br>前后缀表达式的求值：<br>前缀：从右往左<br>后缀：从左往右<img src="/2022/061945929/11.jpg" class>   中缀表达式计算：就是中缀转后缀，然后计算后缀。    <img src="/2022/061945929/12.jpg" class>   </li><li>递归：    <img src="/2022/061945929/13.jpg" class>   <img src="/2022/061945929/14.jpg" class>   <h2 id="队列应用"><a href="#队列应用" class="headerlink" title="队列应用"></a>队列应用</h2></li><li>树的层次遍历</li><li>图的广度优先遍历BFS</li><li>进程申请CPU资源FCFS<h2 id="矩阵存储"><a href="#矩阵存储" class="headerlink" title="矩阵存储"></a>矩阵存储</h2><img src="/2022/061945929/15.jpg" class>   <img src="/2022/061945929/16.jpg" class>   <img src="/2022/061945929/17.jpg" class>   <img src="/2022/061945929/18.jpg" class>   <img src="/2022/061945929/19.jpg" class>   </li><li>总结：  <img src="/2022/061945929/20.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构线性表</title>
      <link href="/2022/06184610.html"/>
      <url>/2022/06184610.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构线性表"><a href="#数据结构线性表" class="headerlink" title="数据结构线性表"></a>数据结构线性表</h1><h2 id="定义和基本操作"><a href="#定义和基本操作" class="headerlink" title="定义和基本操作"></a>定义和基本操作</h2><ul><li>逻辑结构：   <img src="/2022/06184610/1.jpg" class>   </li><li>线性表实现：  <img src="/2022/06184610/2.jpg" class>   </li><li>线性表特点：  <img src="/2022/06184610/3.jpg" class>   </li><li>线性表查找：  <img src="/2022/06184610/4.jpg" class>   </li><li>物理结构：<br>顺序表和链表。<br>单链表：   <img src="/2022/06184610/5.jpg" class>   双链表：  <img src="/2022/06184610/6.jpg" class>   循环链表：<br>循环单链表：   <img src="/2022/06184610/7.jpg" class>   循环双链表：  <img src="/2022/06184610/8.jpg" class>   静态链表：  <img src="/2022/06184610/9.jpg" class>   </li><li>顺序表和链表比较：<br>逻辑结构：   <img src="/2022/06184610/10.jpg" class>   物理结构：   <img src="/2022/06184610/11.jpg" class>   数据的操作：<br>创建，销毁，增删改查。<br>创建：  <img src="/2022/06184610/12.jpg" class>   销毁：  <img src="/2022/06184610/13.jpg" class>   增删：  <img src="/2022/06184610/14.jpg" class>   查找：  <img src="/2022/06184610/15.jpg" class>   总结：  <img src="/2022/06184610/16.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构绪论</title>
      <link href="/2022/061733107.html"/>
      <url>/2022/061733107.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/2022/061733107/1.jpg" class>   <img src="/2022/061733107/2.jpg" class>   <img src="/2022/061733107/3.jpg" class>   <p>数据结构三要素：<br>逻辑结构：集合，线性结构，树，图。<br>物理结构：顺序存储，链式存储，索引存储，散列存储。（影响数据的运算速度）<br>数据运算：    </p><img src="/2022/061733107/4.jpg" class>   <ul><li>小结：  <img src="/2022/061733107/5.jpg" class>   <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><img src="/2022/061733107/6.jpg" class>   算法特性：（缺一不可）<br>有穷性，确定性，可行性，输入，输出。<br>评价算法：<br>正确性，可读性，健壮性，高效率和低存储量需求。<br>算法效率度量：<br>时间复杂度：  <img src="/2022/061733107/7.jpg" class>   空间复杂度：（定义变量，函数递归调用）  <img src="/2022/061733107/8.jpg" class></li></ul><h1 id="学习算法参考网站："><a href="#学习算法参考网站：" class="headerlink" title="学习算法参考网站："></a>学习算法参考网站：</h1><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/061627273.html"/>
      <url>/2022/061627273.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>基于内存的key-value数据库</p></li><li><p>基于c语言编写的，可以支持多种语言的api &#x2F;&#x2F;set每秒11万次，取get 81000次</p></li><li><p>支持数据持久化</p></li><li><p>value可以是string，hash， list， set, sorted set</p></li><li><p>应用场景</p></li></ol><img src="/2022/061627273/798174-20190321203330649-499029266.png" class title="img"><h2 id="基本服务器管理"><a href="#基本服务器管理" class="headerlink" title="基本服务器管理"></a>基本服务器管理</h2><ol><li><p>使用redis客户端连接redis本机服务：<br>[root@CentOs bin]# .&#x2F;redis-cli</p></li><li><p>使用redis客户端连接redis远程服务（使用本机模拟）：<br>[root@CentOs bin]# .&#x2F;redis-cli -h 192.168.25.128 -p 6379</p></li><li><p>健康检查命令：<br>192.168.25.128:6379&gt; ping<br>PONG</p></li><li><p>重启redis服务：<br>[root@CentOs bin]# .&#x2F;redis-server redis.conf</p></li><li><p>使用redis客户端关闭redis服务<br>[root@CentOs bin]# .&#x2F;redis-cli shutdown</p></li><li><p>重启redis服务：<br>[root@CentOs bin]# .&#x2F;redis-server redis.conf</p></li></ol><h2 id="Redis的五种数据类型"><a href="#Redis的五种数据类型" class="headerlink" title="Redis的五种数据类型"></a>Redis的五种数据类型</h2><p>对于Redis 来说，他只能存储五种基本数据类型</p><p>在之前的版本中都是String,Hash,List,SortedSet(zSet),Map</p><p>而现在的新版本中String,Hash,List,SortedSet(zSet),Set</p><p>一、字符串String —–String Key-Value</p><p>　　字符串是Redis中最常用的类型，是一个由字节组成的序列，他在Redis中是二进制安全的</p><p>这意味着该类型可以接受任何格式的数据。</p><p>Value最多可以容纳的数据长度为512MB</p><p>set key value</p><p>往key 中存入一个值(value)</p><p>获取键为key的值</p><p>　　注意：redis中的Key和Value时区分大小写，命令不区分大小写，redis是单线程不适合储存大容量的数据</p><p>自增的value是可以转成数字的</p><p>二、散列Hash——key-filed-value</p><p>　　相当于是一个key中存在多个map.Redis中的散列可以看成具有String key和String value的map</p><p>容器，可以将多个key-value存储到一个key钟。每一个Hash可以存储4294967295个键值对。</p><img src="/2022/061627273/2064607-20200623084300564-1806876841.png" class title="img"><p>三、集合Set</p><p>　　Redis的集合是无序不可重复的，此处的无序是数据不能重复。和列表一样，在执行插入和删除</p><p>以及判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集，差集操作。</p><p>Set可包含的最大元素数量是4294967295.</p><p>　　应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立Ip。</p><p>3.好友推荐的时候根据tag求交集，大于某个threshold(临界值)就可以推荐。</p><p>四、列表List</p><p>　　Redis的列表允许用户从序列的两端推入或者弹出元素，列表有多个字符串值组成的有序可重复的序列，</p><p>是链表结构，所以向列表两端添加元素的时间复杂度为O(1），获取越接近两端的元素速度就越</p><p>快。这意味着即使是一个有几千万个元素的列表，获取头部活尾部的10条记录也是极快的。List中可以</p><p>包含最大的元素数量是4294967295.</p><p>五、SortedSet(zSet)</p><p>　　有顺序，不能重复！！此处的不能重复是索引为唯一的，数据却可以重复。和Set很像</p><p>都是字符串的集合，都不允许重复的成员出现在一个Set中。他们之间差别在于有序集合中每一个成员都会有一个</p><p>分数与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的</p><p>成员必须是唯一的，但是分数却可以重复。</p><p>　　应用场景：可以用于一个大型的在线游戏的积分排行榜，每当玩家的分数发生变化是，可以执行zadd</p><p>更新玩家的分数，此后在通过zrange获取积分top n的用户信息</p><h2 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h2><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）</p><p>键空间和用户所见的数据库是直接对应的</p><p>键空间的键也就是数据库的键，每个键都是一个字符串对象<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象</p><img src="/2022/061627273/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODkyMjE1NA==,size_16,color_FFFFFF,t_70.png" class title="在这里插入图片描述"><img src="/2022/061627273/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODkyMjE1NA==,size_16,color_FFFFFF,t_70-16551816665784.png" class title="在这里插入图片描述"><p>读写键空间的维护操作</p><ul><li><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定读写操作，还会执行一些额外的维护操作</p></li><li><p>在读取一个键之后（包括读操作和写操作），服务器会根据键是否存在，来更新服务器的键命中和不命中次数，可以通过INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性查看</p></li><li><p>在读取一个键之后，服务器会更新键的LRU（最后一次使用时间），这个值可以用于计算键的限制时间，使用OBJECT idletime &lt; key &gt; 命令查看</p></li><li><p>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作</p></li><li><p>如果有客户端使用WATCH命令监视某个key，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改过</p></li><li><p>服务器每次修改一个键之后，都会对脏键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作（例如自动BGSAVE操作，就是查看在多少时间内对键进行了多少次修改，达到设定值则进行RDB持久化）</p></li><li><p>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</p></li></ul><h2 id="Redis的数据的基本操作"><a href="#Redis的数据的基本操作" class="headerlink" title="Redis的数据的基本操作"></a>Redis的数据的基本操作</h2><pre><code>1.set str1 abc：添加键str1，其值为：abc2.get str1：得到键为str1的值3.incr key1：key1加1，如果key1不存在，自动创建一个key1的键，其值为0，加一，key1的值为14.keys * :显示所有的key5.decr key1：key1减一    说明：不论是incr还是decr，保存的数据都是字符串，执行incr或decr命令时候，把字符串转换为整数，再进行加减，           如果转换失败，则报错6.del key1:删除键和值7.hset hash1 field1 1:键为Hash1，值为hash，键为field1，值为1    同一个hash中可以放入多个值，如：        hset hash1 field2 2        hset hash1 field3 38.hget hash1 field1：取hash1中field1的值9.hkeys hash1:查看hash1的所有键10.hvals hash1:查看hash1的所有值11.hgetall hash1：查看hash1的所有键和值12.hdel hash1 field1:删除hash1的field1</code></pre><pre><code>以下了解:13.lpush list1 1 2 3 4 5 6:从左边压入，后压入的在最左边14.rpush list1 a b c d：从右边压入，后压入的在最右边15.lrange list1 0 -1:查看list1 的范围值，0表示第一个元素索引，-1表示所有16.lpop list1：从list1左边取出第一个元素（相当于出栈，取出后，list1中移除该元素）17.rpop list1：从list1右边取出第一个元素（相当于出栈）18.sadd set1 a b a b d c：向set1中添加一个set，值为a b a b d c（会去掉重复的元素）19.srem set1 a：从set1中移除一个元素a（可以一次移除多个元素）20.smembers set1:显示set1中的元素21：集合相减：    sadd seta a b c d e     sadd setb c d e f g     sdiff seta setb :seta - setb =&gt;a b    sdiff setb seta :setb - seta =&gt; f g22.sinter seta setb :seta和setb的交集=》a b c23.sunion seta setb:seta 和set的并集合=》a b c d e f g24.zadd zset1 1 a 3 b 2 c 5 d :向zset1中添加元素，并且根据分数（权重）排序25.zrange zset1 0 -1：查看zset1中的所有元素（排序后的结果）26.zrem zset1 a：删除zset1中的a元素27.zrevrange zset1 0 -1：降序排序输出28.zrevrange zset1 0 -1 withscores：降序排序输出，并输出权重29.expire key1 100:设置key1的过期时间为100秒（key1必须先存在，没有设置过期时间，就是永久保存的）30.ttl key1：查看key1的剩余过期时间    值为整数：表示该键正在过期倒计时    值为-2：表示该键已经过期（不存在的）    值为-1：表示该键永久保存，已经持久化了31.persist key1:持久化key1(设置了过期时间后，还没有到过期时间的时候使用)</code></pre><h2 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h2><p>通过 <strong>EXPIRE</strong> 命令或者 <strong>PEXPIRE</strong> 命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键</p><p>Time命令返回值是一个包含两个字符串的列表： 第一个字符串是当前时间(以 UNIX 时间戳格式表示)，而第二个字符串是当前这一秒钟已经逝去的微秒数</p><p>1秒&#x3D;1000毫秒(ms), 1毫秒&#x3D;1／1000秒(s)；<br>1秒&#x3D;1000000 微秒(μs), 1微秒&#x3D;1／1000000秒(s)；<br>1秒&#x3D;1000000000 纳秒(ns),1纳秒&#x3D;1／1000000000秒(s)；<br>1秒&#x3D;1000000000000皮秒 1皮秒&#x3D;&#x3D;1&#x2F;1000000000000秒。</p><img src="/2022/061627273/20210621145432307.png" class title="在这里插入图片描述"><p>通过 <strong>EXPIREAT</strong> 和 <strong>PEXPIREAT</strong> 命令，可以设定一个时间戳，该过期时间是一个UNIX时间戳，当键的过期时间来临时，服务器就会自动从数据库中删除这个键，可以通过TIME命令查看UNIX的时间</p><img src="/2022/061627273/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODkyMjE1NA==,size_16,color_FFFFFF,t_70-16551819661559.png" class title="在这里插入图片描述"><p>TTL命令和PTTL命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间，也就是，返回距离这个键被服务器自动删除还有多长时间</p><h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>通过上面的例子，可以看出Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）</p><ul><li>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl<strong>秒</strong></li><li>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl<strong>毫秒</strong></li><li>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的<strong>秒数时间戳</strong></li><li>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的<strong>毫秒数时间戳</strong></li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的</p><img src="/2022/061627273/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODkyMjE1NA==,size_16,color_FFFFFF,t_70-165518201197212.png" class title="在这里插入图片描述"><h3 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h3><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典</p><p>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）<br>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳</p><img src="/2022/061627273/image-20220614124802056.png" class title="image-20220614124802056"><h3 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h3><p><strong>PERSIST</strong>命令可以移除一个键的过期时间</p><p><strong>PERSIST</strong>命令就是<strong>PEXPIREAT</strong>命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联</p><h3 id="计算并返回剩余时间和过期键的判定"><a href="#计算并返回剩余时间和过期键的判定" class="headerlink" title="计算并返回剩余时间和过期键的判定"></a>计算并返回剩余时间和过期键的判定</h3><p>计算并返回剩余生存时间</p><p>TTL命令以秒为单位返回键的剩余生存时间，而PTTL命令则以毫秒为单位返回键的剩余生存时间。这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的</p><p><strong>过期键的判定</strong></p><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期</p><ul><li>检查给定键是否存在于过期字典<ul><li>如果存在，那么取得键的过期时间</li></ul></li><li>检查当前UNIX时间戳是否大于键的过期时间<ul><li>是的话，那么键已经过期</li><li>不是的话，键未过期</li></ul></li></ul><h2 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h2><ol><li><p>Redis的所有数据都是保存到内存中的。<br>1）Rdb：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案。<br>2）aof形式：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。</p></li><li><p>查看redis.conf文件<br>1）rdb形式：（看redis.conf中的注释说明）<br>    save 900 1&#x2F;&#x2F;15分钟有一次变化，则保存<br>    save 300 10  &#x2F;&#x2F;5分钟有10次变化，保存<br>    save 60 10000 &#x2F;&#x2F;在60秒中有10000次变化了，则保存一次<br>2）开启aof形式：<br>    修改appendonly no为appendonly yes即可<br>    a）修改后，使用客户端关闭redis服务<br>        .&#x2F;redis-cli shutdown<br>    b）重启redis服务<br>        .&#x2F;redis-server redis.conf<br>    c）开启服务后，在bin目录中多了一个文件：appendonly.aof<br>    d）添加几个key，测试，在查看appendonly.aof文件大小和内容变化（cat appendonly.aof）</p></li></ol><h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是Redis官方推出的一款面向Java的客户端，提供了很多接口供Java语言调用。可以在Redis官网下载，当然还有一些开源爱好者提供的客户端，如Jredis、SRP等等，推荐使用Jedis。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><p>Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。</p><p><strong>spring-data-redis针对jedis提供了如下功能：</strong></p><ol><li>连接池自动管理，提供了一个高度封装的“RedisTemplate”类</li><li>针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</li></ol><ul><li>ValueOperations：简单K-V操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：针对map类型的数据操作</li><li>ListOperations：针对list类型的数据操作</li></ul><ol start="3"><li>提供了对key的“bound”(绑定)便捷化操作API，可以通过bound封装指定的key，然后进行一系列的操作而无须“显式”的再次指定Key，即BoundKeyOperations：</li></ol><ul><li>BoundValueOperations</li><li>BoundSetOperations</li><li>BoundListOperations</li><li>BoundSetOperations</li><li>BoundHashOperations</li></ul><ol start="4"><li><p>将事务操作封装，有容器控制。</p></li><li><p>针对数据的“序列化&#x2F;反序列化”，提供了多种可选择策略(RedisSerializer)</p><ul><li><p>JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream&#x2F;ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是目前最常用的序列化策略。</p><ul><li><p>StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。</p></li><li><p>JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】</p></li></ul></li></ul></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h3 id="1、pom-xml依赖"><a href="#1、pom-xml依赖" class="headerlink" title="1、pom.xml依赖"></a>1、pom.xml依赖</h3><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>Redis<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>dependency<span class="token operator">></span>    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><h3 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h3><pre class=" language-perl"><code class="language-perl"><span class="token comment" spellcheck="true"># Redis服务器连接端口</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>port<span class="token operator">=</span><span class="token number">6379</span><span class="token comment" spellcheck="true"># Redis服务器地址</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>host<span class="token operator">=</span><span class="token vstring string">127.0.0.1</span><span class="token comment" spellcheck="true"># Redis数据库索引（默认为0）</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>database<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true"># Redis服务器连接密码（默认为空）</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>password<span class="token operator">=</span><span class="token comment" spellcheck="true"># 连接池最大连接数（使用负值表示没有限制）</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>jedis<span class="token operator">.</span>pool<span class="token operator">.</span>max<span class="token operator">-</span>active<span class="token operator">=</span><span class="token number">8</span><span class="token comment" spellcheck="true"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>jedis<span class="token operator">.</span>pool<span class="token operator">.</span>max<span class="token operator">-</span>wait<span class="token operator">=</span><span class="token operator">-</span>1ms<span class="token comment" spellcheck="true"># 连接池中的最大空闲连接</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>jedis<span class="token operator">.</span>pool<span class="token operator">.</span>max<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">8</span><span class="token comment" spellcheck="true"># 连接池中的最小空闲连接</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>jedis<span class="token operator">.</span>pool<span class="token operator">.</span>min<span class="token operator">-</span>idle<span class="token operator">=</span><span class="token number">0</span><span class="token comment" spellcheck="true"># 连接超时时间（毫秒）</span>spring<span class="token operator">.</span>redis<span class="token operator">.</span>timeout<span class="token operator">=</span>5000ms</code></pre><h3 id="3、RedisTemplate的直接方法"><a href="#3、RedisTemplate的直接方法" class="headerlink" title="3、RedisTemplate的直接方法"></a>3、RedisTemplate的直接方法</h3><p><strong>首先使用@Autowired注入RedisTemplate（后面直接使用，就不特殊说明）</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span></code></pre><p>1、删除单个key</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    删除key</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>2、删除多个key</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    删除多个key</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteKey</span> <span class="token punctuation">(</span>String <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>keys<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>3、指定key的失效时间</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    指定key的失效时间</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">expire</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span><span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>time<span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>4、根据key获取过期时间</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    根据key获取过期时间</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Long expire <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">getExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> expire<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>5、判断key是否存在</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    判断key是否存在</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4、String类型相关操作"><a href="#4、String类型相关操作" class="headerlink" title="4、String类型相关操作"></a>4、String类型相关操作</h3><h5 id="1-、添加缓存"><a href="#1-、添加缓存" class="headerlink" title="1)、添加缓存"></a>1)、添加缓存</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringValue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringValue"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations设置值</span>BoundValueOperations stringKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stringKey<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>stringKey<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringValue"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations设置值</span>ValueOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ops<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">,</span> <span class="token string">"StringVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ops<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"StringValue"</span><span class="token punctuation">,</span><span class="token string">"StringVaule"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-、设置过期时间-单独设置"><a href="#2-、设置过期时间-单独设置" class="headerlink" title="2)、设置过期时间(单独设置)"></a>2)、设置过期时间(单独设置)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-、获取缓存值"><a href="#3-、获取缓存值" class="headerlink" title="3)、获取缓存值"></a>3)、获取缓存值</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>String str1 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundValueOperations stringKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> stringKey<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>ValueOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String str3 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> ops<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-、删除key"><a href="#4-、删除key" class="headerlink" title="4)、删除key"></a>4)、删除key</h5><pre class=" language-java"><code class="language-java">Boolean result <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="5-、顺序递增"><a href="#5-、顺序递增" class="headerlink" title="5)、顺序递增"></a>5)、顺序递增</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>3L<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-、顺序递减"><a href="#6-、顺序递减" class="headerlink" title="6)、顺序递减"></a>6)、顺序递减</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"StringKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token operator">-</span>3L<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5、Hash类型相关操作"><a href="#5、Hash类型相关操作" class="headerlink" title="5、Hash类型相关操作"></a>5、Hash类型相关操作</h3><h5 id="1-、添加缓存-1"><a href="#1-、添加缓存-1" class="headerlink" title="1)、添加缓存"></a>1)、添加缓存</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">,</span> <span class="token string">"HashVaue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations设置值</span>BoundHashOperations hashKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hashKey<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">,</span> <span class="token string">"HashVaue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations设置值</span>HashOperations hashOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hashOps<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">,</span> <span class="token string">"SmallKey"</span><span class="token punctuation">,</span> <span class="token string">"HashVaue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-、设置过期时间-单独设置-1"><a href="#2-、设置过期时间-单独设置-1" class="headerlink" title="2)、设置过期时间(单独设置)"></a>2)、设置过期时间(单独设置)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-、添加一个Map集合"><a href="#3-、添加一个Map集合" class="headerlink" title="3)、添加一个Map集合"></a>3)、添加一个Map集合</h5><pre class=" language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> hashMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>hashMap <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-、设置过期时间-单独设置"><a href="#4-、设置过期时间-单独设置" class="headerlink" title="4)、设置过期时间(单独设置)"></a>4)、设置过期时间(单独设置)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="5-、提取所有的key"><a href="#5-、提取所有的key" class="headerlink" title="5)、提取所有的key"></a>5)、提取所有的key</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate获取值</span>Set keys1 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundHashOperations hashKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set keys2 <span class="token operator">=</span> hashKey<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>HashOperations hashOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set keys3 <span class="token operator">=</span> hashOps<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-、提取所有的value值"><a href="#6-、提取所有的value值" class="headerlink" title="6)、提取所有的value值"></a>6)、提取所有的value值</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate获取值</span>List values1 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundHashOperations hashKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List values2 <span class="token operator">=</span> hashKey<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>HashOperations hashOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List values3 <span class="token operator">=</span> hashOps<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="7-、根据key提取value值"><a href="#7-、根据key提取value值" class="headerlink" title="7)、根据key提取value值"></a>7)、根据key提取value值</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate获取</span>String value1 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundHashOperations hashKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String value2 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> hashKey<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>HashOperations hashOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String value3 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> hashOps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">,</span> <span class="token string">"SmallKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="8-、获取所有的键值对集合"><a href="#8-、获取所有的键值对集合" class="headerlink" title="8)、获取所有的键值对集合"></a>8)、获取所有的键值对集合</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate获取</span>Map entries <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundHashOperations hashKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map entries1 <span class="token operator">=</span> hashKey<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>HashOperations hashOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map entries2 <span class="token operator">=</span> hashOps<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="9-、删除"><a href="#9-、删除" class="headerlink" title="9)、删除"></a>9)、删除</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//删除小key</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除大key</span>redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="10-、判断Hash中是否含有该值"><a href="#10-、判断Hash中是否含有该值" class="headerlink" title="10)、判断Hash中是否含有该值"></a>10)、判断Hash中是否含有该值</h5><pre class=" language-java"><code class="language-java">Boolean isEmpty <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundHashOps</span><span class="token punctuation">(</span><span class="token string">"HashKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span><span class="token string">"SmallKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="6、Set类型相关操作"><a href="#6、Set类型相关操作" class="headerlink" title="6、Set类型相关操作"></a>6、Set类型相关操作</h3><h5 id="1-、添加Set缓存-值可以是一个，也可是多个"><a href="#1-、添加Set缓存-值可以是一个，也可是多个" class="headerlink" title="1)、添加Set缓存(值可以是一个，也可是多个)"></a>1)、添加Set缓存(值可以是一个，也可是多个)</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"setValue1"</span><span class="token punctuation">,</span> <span class="token string">"setValue2"</span><span class="token punctuation">,</span> <span class="token string">"setValue3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations设置值</span>BoundSetOperations setKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>setKey<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"setValue1"</span><span class="token punctuation">,</span> <span class="token string">"setValue2"</span><span class="token punctuation">,</span> <span class="token string">"setValue3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations设置值</span>SetOperations setOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>setOps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">,</span> <span class="token string">"SetValue1"</span><span class="token punctuation">,</span> <span class="token string">"setValue2"</span><span class="token punctuation">,</span> <span class="token string">"setValue3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-、设置过期时间-单独设置-2"><a href="#2-、设置过期时间-单独设置-2" class="headerlink" title="2)、设置过期时间(单独设置)"></a>2)、设置过期时间(单独设置)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span></code></pre><h5 id="3-、根据key获取Set中的所有值"><a href="#3-、根据key获取Set中的所有值" class="headerlink" title="3)、根据key获取Set中的所有值"></a>3)、根据key获取Set中的所有值</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate获取值</span>Set set1 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations获取值</span>BoundSetOperations setKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set set2 <span class="token operator">=</span> setKey<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations获取值</span>SetOperations setOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set set3 <span class="token operator">=</span> setOps<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12345678910</span></code></pre><h5 id="4-、根据value从一个set中查询-是否存在"><a href="#4-、根据value从一个set中查询-是否存在" class="headerlink" title="4)、根据value从一个set中查询,是否存在"></a>4)、根据value从一个set中查询,是否存在</h5><pre class=" language-java"><code class="language-java">Boolean isEmpty <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span><span class="token string">"setValue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1</span></code></pre><h5 id="5-、获取Set缓存的长度"><a href="#5-、获取Set缓存的长度" class="headerlink" title="5)、获取Set缓存的长度"></a>5)、获取Set缓存的长度</h5><pre class=" language-java"><code class="language-java">Long size <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1</span></code></pre><h5 id="6-、移除指定的元素"><a href="#6-、移除指定的元素" class="headerlink" title="6)、移除指定的元素"></a>6)、移除指定的元素</h5><pre class=" language-java"><code class="language-java">Long result1 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundSetOps</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"setValue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1</span></code></pre><h5 id="7-、移除指定的key"><a href="#7-、移除指定的key" class="headerlink" title="7)、移除指定的key"></a>7)、移除指定的key</h5><pre class=" language-java"><code class="language-java">Boolean result2 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token string">"setKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1</span></code></pre><h3 id="7、-LIST类型相关操作"><a href="#7、-LIST类型相关操作" class="headerlink" title="7、 LIST类型相关操作"></a>7、 LIST类型相关操作</h3><h5 id="1-、添加缓存（2-x2F-3是1的递进值）"><a href="#1-、添加缓存（2-x2F-3是1的递进值）" class="headerlink" title="1)、添加缓存（2&#x2F;3是1的递进值）"></a>1)、添加缓存（2&#x2F;3是1的递进值）</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span><span class="token string">"listLeftValue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span><span class="token string">"listRightValue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations设置值</span>BoundListOperations listKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>listKey<span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span><span class="token string">"listLeftValue3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>listKey<span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span><span class="token string">"listRightValue4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations设置值</span>ListOperations opsList <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>opsList<span class="token punctuation">.</span><span class="token function">leftPush</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">,</span> <span class="token string">"listLeftValue5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>opsList<span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">,</span> <span class="token string">"listRightValue6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-、将List放入缓存"><a href="#2-、将List放入缓存" class="headerlink" title="2)、将List放入缓存"></a>2)、将List放入缓存</h5><pre class=" language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">leftPushAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-、设置过期时间-单独设置"><a href="#3-、设置过期时间-单独设置" class="headerlink" title="3)、设置过期时间(单独设置)"></a>3)、设置过期时间(单独设置)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-、获取List缓存全部内容（起始索引，结束索引）"><a href="#4-、获取List缓存全部内容（起始索引，结束索引）" class="headerlink" title="4)、获取List缓存全部内容（起始索引，结束索引）"></a>4)、获取List缓存全部内容（起始索引，结束索引）</h5><pre class=" language-java"><code class="language-java">List listKey1 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h5 id="5-、从左或从右弹出一个元素"><a href="#5-、从左或从右弹出一个元素" class="headerlink" title="5)、从左或从右弹出一个元素"></a>5)、从左或从右弹出一个元素</h5><pre class=" language-java"><code class="language-java">String listKey2 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">leftPop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//从左侧弹出一个元素</span>String listKey3 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从右侧弹出一个元素</span></code></pre><h5 id="6-、根据索引查询元素"><a href="#6-、根据索引查询元素" class="headerlink" title="6)、根据索引查询元素"></a>6)、根据索引查询元素</h5><pre class=" language-java"><code class="language-java">String listKey4 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="7-、获取List缓存的长度"><a href="#7-、获取List缓存的长度" class="headerlink" title="7)、获取List缓存的长度"></a>7)、获取List缓存的长度</h5><pre class=" language-java"><code class="language-java">Long size <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="8-、根据索引修改List中的某条数据-key，索引，值"><a href="#8-、根据索引修改List中的某条数据-key，索引，值" class="headerlink" title="8)、根据索引修改List中的某条数据(key，索引，值)"></a>8)、根据索引修改List中的某条数据(key，索引，值)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span><span class="token string">"listLeftValue3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="9-、移除N个值为value-key-移除个数，值"><a href="#9-、移除N个值为value-key-移除个数，值" class="headerlink" title="9)、移除N个值为value(key,移除个数，值)"></a>9)、移除N个值为value(key,移除个数，值)</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundListOps</span><span class="token punctuation">(</span><span class="token string">"listKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="8、Zset类型的相关操作"><a href="#8、Zset类型的相关操作" class="headerlink" title="8、Zset类型的相关操作"></a>8、Zset类型的相关操作</h3><h5 id="1-、向集合中插入元素，并设置分数"><a href="#1-、向集合中插入元素，并设置分数" class="headerlink" title="1)、向集合中插入元素，并设置分数"></a>1)、向集合中插入元素，并设置分数</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//1、通过redisTemplate设置值</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">,</span> <span class="token number">100D</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2、通过BoundValueOperations设置值</span>BoundZSetOperations zSetKey <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zSetKey<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">,</span> <span class="token number">100D</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3、通过ValueOperations设置值</span>ZSetOperations zSetOps <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForZSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>zSetOps<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">,</span> <span class="token string">"zSetVaule"</span><span class="token punctuation">,</span> <span class="token number">100D</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-、向集合中插入多个元素-并设置分数"><a href="#2-、向集合中插入多个元素-并设置分数" class="headerlink" title="2)、向集合中插入多个元素,并设置分数"></a>2)、向集合中插入多个元素,并设置分数</h5><pre class=" language-java"><code class="language-java">DefaultTypedTuple<span class="token operator">&lt;</span>String<span class="token operator">></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTypedTuple</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"zSetVaule1"</span><span class="token punctuation">,</span> <span class="token number">2.1D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DefaultTypedTuple<span class="token operator">&lt;</span>String<span class="token operator">></span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTypedTuple</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"zSetVaule2"</span><span class="token punctuation">,</span> <span class="token number">3.3D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="3-、按照排名先后-从小到大-打印指定区间内的元素-1为打印全部"><a href="#3-、按照排名先后-从小到大-打印指定区间内的元素-1为打印全部" class="headerlink" title="3)、按照排名先后(从小到大)打印指定区间内的元素, -1为打印全部"></a>3)、按照排名先后(从小到大)打印指定区间内的元素, -1为打印全部</h5><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> range <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="4-、获得指定元素的分数"><a href="#4-、获得指定元素的分数" class="headerlink" title="4)、获得指定元素的分数"></a>4)、获得指定元素的分数</h5><pre class=" language-java"><code class="language-java">Double score <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">score</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="5-、返回集合内的成员个数"><a href="#5-、返回集合内的成员个数" class="headerlink" title="5)、返回集合内的成员个数"></a>5)、返回集合内的成员个数</h5><pre class=" language-java"><code class="language-java">Long size <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="6-、返回集合内指定分数范围的成员个数（Double类型）"><a href="#6-、返回集合内指定分数范围的成员个数（Double类型）" class="headerlink" title="6)、返回集合内指定分数范围的成员个数（Double类型）"></a>6)、返回集合内指定分数范围的成员个数（Double类型）</h5><pre class=" language-java"><code class="language-java">Long COUNT <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">0D</span><span class="token punctuation">,</span> <span class="token number">2.2D</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="7-、返回集合内元素在指定分数范围内的排名（从小到大）"><a href="#7-、返回集合内元素在指定分数范围内的排名（从小到大）" class="headerlink" title="7)、返回集合内元素在指定分数范围内的排名（从小到大）"></a>7)、返回集合内元素在指定分数范围内的排名（从小到大）</h5><pre class=" language-java"><code class="language-java">Set byScore <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rangeByScore</span><span class="token punctuation">(</span><span class="token number">0D</span><span class="token punctuation">,</span> <span class="token number">2.2D</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="8-、带偏移量和个数，-key，起始分数，最大分数，偏移量，个数"><a href="#8-、带偏移量和个数，-key，起始分数，最大分数，偏移量，个数" class="headerlink" title="8)、带偏移量和个数，(key，起始分数，最大分数，偏移量，个数)"></a>8)、带偏移量和个数，(key，起始分数，最大分数，偏移量，个数)</h5><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>String<span class="token operator">></span> ranking2 <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForZSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rangeByScore</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">,</span> <span class="token number">0D</span><span class="token punctuation">,</span> <span class="token number">2.2D</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="9-、返回集合内元素的排名，以及分数（从小到大）"><a href="#9-、返回集合内元素的排名，以及分数（从小到大）" class="headerlink" title="9)、返回集合内元素的排名，以及分数（从小到大）"></a>9)、返回集合内元素的排名，以及分数（从小到大）</h5><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>TypedTuple<span class="token operator">&lt;</span>String<span class="token operator">>></span> tuples <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rangeWithScores</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span> 3L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>TypedTuple<span class="token operator">&lt;</span>String<span class="token operator">></span> tuple <span class="token operator">:</span> tuples<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tuple<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span> tuple<span class="token punctuation">.</span><span class="token function">getScore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>ss</code></pre><h5 id="10-、返回指定成员的排名"><a href="#10-、返回指定成员的排名" class="headerlink" title="10)、返回指定成员的排名"></a>10)、返回指定成员的排名</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//从小到大</span>Long startRank <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rank</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从大到小</span>Long endRank <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverseRank</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="11-、从集合中删除指定元素"><a href="#11-、从集合中删除指定元素" class="headerlink" title="11)、从集合中删除指定元素"></a>11)、从集合中删除指定元素</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="12-、删除指定索引范围的元素（Long类型）"><a href="#12-、删除指定索引范围的元素（Long类型）" class="headerlink" title="12)、删除指定索引范围的元素（Long类型）"></a>12)、删除指定索引范围的元素（Long类型）</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeRange</span><span class="token punctuation">(</span>0L<span class="token punctuation">,</span>3L<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="13-、删除指定分数范围内的元素（Double类型）"><a href="#13-、删除指定分数范围内的元素（Double类型）" class="headerlink" title="13)、删除指定分数范围内的元素（Double类型）"></a>13)、删除指定分数范围内的元素（Double类型）</h5><pre class=" language-java"><code class="language-java">redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeRangeByScorssse</span><span class="token punctuation">(</span><span class="token number">0D</span><span class="token punctuation">,</span><span class="token number">2.2D</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="14-、为指定元素加分（Double类型）"><a href="#14-、为指定元素加分（Double类型）" class="headerlink" title="14)、为指定元素加分（Double类型）"></a>14)、为指定元素加分（Double类型）</h5><pre class=" language-java"><code class="language-java">Double score <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundZSetOps</span><span class="token punctuation">(</span><span class="token string">"zSetKey"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">incrementScore</span><span class="token punctuation">(</span><span class="token string">"zSetVaule"</span><span class="token punctuation">,</span><span class="token number">1.1D</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="配置-RedisTemplate"><a href="#配置-RedisTemplate" class="headerlink" title="配置 RedisTemplate"></a>配置 RedisTemplate</h3><p>修改 RedisTemplate 中键和值的序列化方式（默认key的序列化方式是：JdkSerializationRedisSerializer）</p><pre><code>package com.neu.springdemo;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.ListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.SetOperations;import org.springframework.data.redis.core.ValueOperations;import org.springframework.data.redis.core.ZSetOperations;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator; @Configuration@EnableCaching //开启注解public class RedisConfig extends CachingConfigurerSupport &#123;     /**     * retemplate相关配置     */    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;         RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 配置连接工厂        template.setConnectionFactory(factory);         //使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）        Jackson2JsonRedisSerializer&lt;Object&gt; jacksonSeial = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);         ObjectMapper om = new ObjectMapper();        // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);        jacksonSeial.setObjectMapper(om);         // 值采用json序列化        template.setValueSerializer(jacksonSeial);        //使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(new StringRedisSerializer());         // 设置hash key 和value序列化模式        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(jacksonSeial);        template.afterPropertiesSet();         return template;    &#125;&#125;</code></pre><h3 id="Redis-缓存工具类"><a href="#Redis-缓存工具类" class="headerlink" title="Redis 缓存工具类"></a>Redis 缓存工具类</h3><pre><code>package com.neu.springdemo;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.BoundSetOperations;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.ListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;/** * spring redis 工具类 *  * @author ruoyi **/@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)@Componentpublic class RedisCache&#123;    @Autowired    public RedisTemplate redisTemplate;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key 缓存的键值     * @param value 缓存的值     * @return 缓存的对象     */    public &lt;T&gt; ValueOperations&lt;String, T&gt; setCacheObject(String key, T value)    &#123;        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();        operation.set(key, value);        return operation;    &#125;    /**     * 缓存基本的对象，Integer、String、实体类等     *     * @param key 缓存的键值     * @param value 缓存的值     * @param timeout 时间     * @param timeUnit 时间颗粒度     * @return 缓存的对象     */    public &lt;T&gt; ValueOperations&lt;String, T&gt; setCacheObject(String key, T value, Integer timeout, TimeUnit timeUnit)    &#123;        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();        operation.set(key, value, timeout, timeUnit);        return operation;    &#125;    /**     * 获得缓存的基本对象。     *     * @param key 缓存键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; T getCacheObject(String key)    &#123;        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();        return operation.get(key);    &#125;    /**     * 删除单个对象     *     * @param key     */    public void deleteObject(String key)    &#123;        redisTemplate.delete(key);    &#125;    /**     * 删除集合对象     *     * @param collection     */    public void deleteObject(Collection collection)    &#123;        redisTemplate.delete(collection);    &#125;    /**     * 缓存List数据     *     * @param key 缓存的键值     * @param dataList 待缓存的List数据     * @return 缓存的对象     */    public &lt;T&gt; ListOperations&lt;String, T&gt; setCacheList(String key, List&lt;T&gt; dataList)    &#123;        ListOperations listOperation = redisTemplate.opsForList();        if (null != dataList)        &#123;            int size = dataList.size();            for (int i = 0; i &lt; size; i++)            &#123;                listOperation.leftPush(key, dataList.get(i));            &#125;        &#125;        return listOperation;    &#125;    /**     * 获得缓存的list对象     *     * @param key 缓存的键值     * @return 缓存键值对应的数据     */    public &lt;T&gt; List&lt;T&gt; getCacheList(String key)    &#123;        List&lt;T&gt; dataList = new ArrayList&lt;T&gt;();        ListOperations&lt;String, T&gt; listOperation = redisTemplate.opsForList();        Long size = listOperation.size(key);        for (int i = 0; i &lt; size; i++)        &#123;            dataList.add(listOperation.index(key, i));        &#125;        return dataList;    &#125;    /**     * 缓存Set     *     * @param key 缓存键值     * @param dataSet 缓存的数据     * @return 缓存数据的对象     */    public &lt;T&gt; BoundSetOperations&lt;String, T&gt; setCacheSet(String key, Set&lt;T&gt; dataSet)    &#123;        BoundSetOperations&lt;String, T&gt; setOperation = redisTemplate.boundSetOps(key);        Iterator&lt;T&gt; it = dataSet.iterator();        while (it.hasNext())        &#123;            setOperation.add(it.next());        &#125;        return setOperation;    &#125;    /**     * 获得缓存的set     *     * @param key     * @return     */    public &lt;T&gt; Set&lt;T&gt; getCacheSet(String key)    &#123;        Set&lt;T&gt; dataSet = new HashSet&lt;T&gt;();        BoundSetOperations&lt;String, T&gt; operation = redisTemplate.boundSetOps(key);        dataSet = operation.members();        return dataSet;    &#125;    /**     * 缓存Map     *     * @param key     * @param dataMap     * @return     */    public &lt;T&gt; HashOperations&lt;String, String, T&gt; setCacheMap(String key, Map&lt;String, T&gt; dataMap)    &#123;        HashOperations hashOperations = redisTemplate.opsForHash();        if (null != dataMap)        &#123;            for (Map.Entry&lt;String, T&gt; entry : dataMap.entrySet())            &#123;                hashOperations.put(key, entry.getKey(), entry.getValue());            &#125;        &#125;        return hashOperations;    &#125;    /**     * 获得缓存的Map     *     * @param key     * @return     */    public &lt;T&gt; Map&lt;String, T&gt; getCacheMap(String key)    &#123;        Map&lt;String, T&gt; map = redisTemplate.opsForHash().entries(key);        return map;    &#125;    /**     * 获得缓存的基本对象列表     *      * @param pattern 字符串前缀     * @return 对象列表     */    public Collection&lt;String&gt; keys(String pattern)    &#123;        return redisTemplate.keys(pattern);    &#125;&#125;</code></pre><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><pre><code>package com.neu.springdemo;import java.util.Date;import javax.annotation.Resource;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;@SpringBootTestclass SpringdemoRedisDemo1ApplicationTests &#123;    @Autowired    private RedisCache redisCache;    @Test    void contextLoads() &#123;        Student stu = new Student();        stu.setAge(18);        stu.setId(10);        stu.setName(&quot;marry&quot;);        stu.setBirthday(new Date());                //缓存对象        redisCache.setCacheObject(&quot;stu3&quot;, stu);        //得到缓存对象        Student stu3 = redisCache.getCacheObject(&quot;stu3&quot;);        System.out.println(stu3);    &#125;&#125;</code></pre><h1 id="命令附录"><a href="#命令附录" class="headerlink" title="命令附录"></a>命令附录</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>keys * 获取所有的key<br>select 0 选择第一个库<br>move myString 1 将当前的数据库key移动到某个数据库,目标库有，则不能移动<br>flush db      清除指定库<br>randomkey     随机key<br>type key      类型<br>set key1 value1 设置key<br>get key1    获取key<br>mset key1 value1 key2 value2 key3 value3<br>mget key1 key2 key3<br>del key1   删除key<br>exists key      判断是否存在key<br>expire key 10   10秒过期<br>pexpire key 1000 毫秒<br>persist key     删除过期时间</p><p>TTL key 获取key的过期时间。</p><p>​如果key存在过期时间，返回剩余生存时间(秒)；如果key是永久的，返回-1；如果key不存在或者已过期，返回-2</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>​    set name cxx<br>​    get name<br>​    getrange name 0 -1        字符串分段<br>​    getset name new_cxx       设置值，返回旧值<br>​    mset key1 key2            批量设置<br>​    mget key1 key2            批量获取<br>​    setnx key value           不存在就插入（not exists）<br>​    setex key time value      过期时间（expire）<br>​    setrange key index value  从index开始替换value<br>​    incr age        递增<br>​    incrby age 10   递增<br>​    decr age        递减<br>​    decrby age 10   递减<br>​    incrbyfloat     增减浮点数<br>​    append          追加<br>​    strlen          长度<br>​    getbit&#x2F;setbit&#x2F;bitcount&#x2F;bitop    位操作<br>​    </p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>​    hset myhash name cxx<br>​    hget myhash name<br>​    hmset myhash name cxx age 25 note “i am notes”<br>​    hmget myhash name age note<br>​    hgetall myhash               获取所有的<br>​    hexists myhash name          是否存在<br>​    hsetnx myhash score 100      设置不存在的<br>​    hincrby myhash id 1          递增<br>​    hdel myhash name             删除<br>​    hkeys myhash                 只取key<br>​    hvals myhash                 只取value<br>​    hlen myhash                  长度</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>​    lpush mylist a b c  左插入<br>​    rpush mylist x y z  右插入<br>​    lrange mylist 0 -1  数据集合（查询）<br>​    lpop mylist  弹出元素<br>​    rpop mylist  弹出元素<br>​    llen mylist  长度<br>​    lrem mylist count value  删除<br>​    lindex mylist 2          指定索引的值<br>​    lset mylist 2 n          索引设值<br>​    ltrim mylist 0 4         删除key<br>​    linsert mylist before a  插入<br>​    linsert mylist after a   插入<br>​    rpoplpush list list2     转移列表的数据<br>​    </p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>​    sadd myset redis<br>​    smembers myset       数据集合<br>​    srem myset set1         删除<br>​    sismember myset set1 判断元素是否在集合中<br>​    scard key_name       个数<br>​    sdiff | sinter | sunion 操作：集合间运算：差集 | 交集 | 并集<br>​    srandmember          随机获取集合中的元素<br>​    spop                 从集合中弹出一个元素<br>​    </p><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>​    zadd zset 1 one<br>​    zadd zset 2 two<br>​    zadd zset 3 three<br>​    zincrby zset 1 one              增长分数<br>​    zscore zset two                 获取分数<br>​    zrange zset 0 -1 withscores     范围值<br>​    zrangebyscore zset 10 25 withscores 指定范围的值<br>​    zrangebyscore zset 10 25 withscores limit 1 2 分页<br>​    Zrevrangebyscore zset 10 25 withscores  指定范围的值<br>​    zcard zset  元素数量<br>​    Zcount zset 获得指定分数范围内的元素个数<br>​    Zrem zset one two        删除一个或多个元素<br>​    Zremrangebyrank zset 0 1  按照排名范围删除元素<br>​    Zremrangebyscore zset 0 1 按照分数范围删除元素<br>​    Zrank zset 0 -1    分数最小的元素排名为0<br>​    Zrevrank zset 0 -1  分数最大的元素排名为0<br>​    Zinterstore<br>​    zunionstore rank:last_week 7 rank:20150323 rank:20150324 rank:20150325  weights 1 1 1 1 1 1 1<br>​<br>​    </p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>​    sort mylist  排序<br>​    sort mylist alpha desc limit 0 2 字母排序<br>​    sort list by it:* desc           by命令<br>​    sort list by it:* desc get it:*  get参数<br>​    sort list by it:* desc get it:* store sorc:result  sort命令之store参数：表示把sort查询的结果集保存起来</p><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>​    订阅频道：subscribe chat1<br>​    发布消息：publish chat1 “hell0 ni hao”<br>​    查看频道：pubsub channels<br>​    查看某个频道的订阅者数量: pubsub numsub chat1<br>​    退订指定频道： unsubscrible chat1   , punsubscribe java.*<br>​    订阅一组频道： psubscribe java.*<br>​    </p><h2 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>​     隔离性，原子性，<br>​     步骤：  开始事务，执行命令，提交事务<br>​             multi  &#x2F;&#x2F;开启事务<br>​             sadd myset a b c<br>​             sadd myset e f g<br>​             lpush mylist aa bb cc<br>​             lpush mylist dd ff gg</p><p>​exec &#x2F;&#x2F;提交事务</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2022/061415691.html"/>
      <url>/2022/061415691.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>是一个免费使用和自由传播的类Unix操作系统</li><li>是多用户、多任务、支持多线程和多CPU的操作系统</li><li>Linux有多个版本，但是它们都使用了Linux内核，流行版本有：Ubuntu、Red Hat、CentOS等</li></ol><h2 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h2><p>链接：<a href="https://pan.baidu.com/s/1VwiJauCw0INAMKHqrG_wbQ">https://pan.baidu.com/s/1VwiJauCw0INAMKHqrG_wbQ</a><br>提取码：9u90 </p><ol><li><p>VMWare：虚拟机</p></li><li><p>CentOS7：Linux操作系统</p><p>下载地址：<a href="https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso">https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso</a></p></li><li><p>Putty：远程登录</p></li><li><p>Filezilla：文件传输</p></li><li><p>Editplus：文件编辑</p></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>查看目录结构：<code>ls /</code></p><img src="/2022/061415691/image-20210619153339734.png" class><p>以下是对这些目录的解释：</p><ul><li><p><strong>&#x2F;bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>&#x2F;boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>&#x2F;dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>&#x2F;etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>&#x2F;home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p><strong>&#x2F;lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>&#x2F;lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>&#x2F;media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>&#x2F;mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>&#x2F;opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>&#x2F;proc</strong>：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li><li><p><strong>&#x2F;root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>&#x2F;sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>&#x2F;selinux</strong>：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>&#x2F;srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>&#x2F;sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>&#x2F;tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>&#x2F;usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>&#x2F;usr&#x2F;bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>&#x2F;usr&#x2F;sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>&#x2F;usr&#x2F;src：</strong><br>内核源代码默认的放置目录。</p></li><li><p><strong>&#x2F;var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>&#x2F;run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></li></ul><h2 id="使用-PuTTY-远程登录"><a href="#使用-PuTTY-远程登录" class="headerlink" title="使用 PuTTY 远程登录"></a>使用 PuTTY 远程登录</h2><h3 id="PuTTY-创建-SSH-会话连接"><a href="#PuTTY-创建-SSH-会话连接" class="headerlink" title="PuTTY 创建 SSH 会话连接"></a>PuTTY 创建 SSH 会话连接</h3><p>运行 putty.exe，在程序界面内输入服务器 IP 地址和端口（22 是 SSH 默认端口），选中 SSH 连接类型，设置连接会话名称及点击保存，然后点击 Open 按钮开始连接登录。</p><img src="/2022/061415691/putty-tutorial-1.png" class><p>如果需要注销连接会话，使用 <code>exit</code> 命令或 <code>Ctrl+d</code> 快捷键。</p><h3 id="PuTTY-修改保存设置"><a href="#PuTTY-修改保存设置" class="headerlink" title="PuTTY 修改保存设置"></a>PuTTY 修改保存设置</h3><p>估计不少人遇到过这个问题，不知道怎么保存 PuTTY 设置。正确方法是先选中 SSH 会话，然后点击 Load 加载设置，这时就可以开始修改设置，之后点击保存会话设置。</p><p>如果需要修改 PuTTY 默认设置，就选中修改 Default Setting 会话。</p><p><a href="https://www.hostarr.com/wp-content/uploads/putty-tutorial-4.png"><img src="/Linux/putty-tutorial-4.png"></a></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li><p>pwd：查看当前所在目录名（当前工作目录名）</p></li><li><p>ls：查看当前目录内容<br>ls -a:查看当前目录的所有内容，包括隐藏文件<br>ls -l:查看当前目录的详细信息(简写为ll)</p></li><li><p>cd：目录切换命令<br>cd usr切换到该目录下usr目录<br>cd ..&#x2F;切换到上一层目录<br>cd &#x2F;切换到系统根目录<br>cd ~切换到用户主目录<br>cd -切换到上一个所在目录</p></li><li><p>mkdir:新增目录<br>mkdir test:在当前目录下创建文件夹test<br>mkdir &#x2F;test&#x2F;xxx:在&#x2F;test目录下创建文件夹test<br>​           -p:创建父目录</p></li><li><p>clear：清屏</p></li></ol><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><ol><li><p>修改目录的名称（改）<br>命令：mv 目录名称 新目录名称<br>示例：test目录下有一个oldTest目录，使用mv oldTest newTest命令修改<br>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行重命名的操作</p></li><li><p>移动目录的位置—剪切（改）<br>命令：mv 目录名称 目录的新位置<br>示例：在test下将newTest目录剪切到 &#x2F;usr下面，使用mv newTest &#x2F;usr<br>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p></li><li><p>拷贝目录（改）<br>命令：cp -r 目录名称 目录拷贝的目标位置 —–r代表递归拷贝<br>示例：将&#x2F;usr下的newTest拷贝到根目录下的test中，使用cp -r &#x2F;usr&#x2F;newTest &#x2F;test<br>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</p></li><li><p>删除目录（删）<br>命令：rm [-rf] 目录<br>示例：删除&#x2F;usr下的newTest，进入&#x2F;usr下使用rm -r newTest</p><p>示例：删除&#x2F;test下的newTest而不需要询问强制删除，在&#x2F;test下使用rm -rf newTest</p><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，无论删除任何目录或文件，都直接使用rm -rf 目录&#x2F;文件&#x2F;压缩包</p></li></ol><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ol><li><p>文件的创建（增）<br>命令：touch 文件名称  —– 空文件<br>示例：在test目录下创建一个空文件 touch aaa.txt</p></li><li><p>文件的查看（查）<br>命令：cat&#x2F;more&#x2F;less&#x2F;tail 文件<br>示例：使用cat查看&#x2F;etc&#x2F;sudo.conf文件，只能显示最后一屏内容</p><p>示例：使用more查看&#x2F;etc&#x2F;sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看</p><p>示例：使用less查看&#x2F;etc&#x2F;sudo.conf文件，可以使用键盘上的PgUp和PgDn向上和向下翻页，q结束查看</p><p>示例：使用tail -10 查看&#x2F;etc&#x2F;sudo.conf文件的后10行，Ctrl+C结束<br>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控文件的变化 </p></li><li><p>修改文件的内容（改）<br>命令：vim 文件<br>示例：编辑&#x2F;test下的aaa.txt文件，使用vim aaa.txt<br>但此时并不能编辑，因为此时处于命令模式，点击键盘i&#x2F;a&#x2F;o进入编辑模式，可以编辑文件</p><p>编辑完成后，按下Esc，退回命令模式</p><p>此时文件虽然已经编辑完成，但是没有保存，需输入冒号：进入底行模式，在底行模式下输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。</p><p>vim的模式<br>基本上vim可以分为三种模式:命令模式，插入模式和底行模式，其实vim有多种模式，我们只需要掌握这三种即可。<br>1.命令模式<br>    用vim 打开一个文件刚开始进入的就是命令模式，在这个模式下我们可以控制光标的移动，字符，字或者行的删除，移动复制某段区域，在该模式下可以进入插入模式也可以进入底行模式。<br> 2.插入模式<br>     在插入模式下才可以插入文字，按Esc进入底行模式.<br> 3.底行模式<br>     在底行模式下保存文件或者退出vim，也可以在底行模式下使用man查找函数等。。。<br>总结：<br>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><p>关于vim使用过程：<br>在实际开发中，使用vim编辑器主要作用就是修改配置文件<br>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件——-&gt;按Esc进入底行模式—–&gt;输入:wq&#x2F;q!</p><p>在命令模式下，输入file，后跟路径和文件名，即可在保存。如将此文件命名为welcome.txt，并保存在当前目录下。<br>命令：file welcome.txt</p></li><li><p>删除文件（删）<br>同目录删除：熟记 rm -rf 文件 即可</p></li></ol><h2 id="压缩文件的操作命令"><a href="#压缩文件的操作命令" class="headerlink" title="压缩文件的操作命令"></a>压缩文件的操作命令</h2><p>打包和压缩：<br>    打包是指将一大堆文件或目录变成一个总的文件；<br>    压缩则是将一个大的文件通过一些压缩算法变成一个小文件。</p><ol><li><p>打包并压缩文件<br>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件(或 -create)<br>  v：显示运行过程<br>  f：指定文件名<br>示例：打包并压缩&#x2F;test下的所有文件 压缩后的压缩包指定名称为xxx.tar.gz</p><pre><code>tar -zcvf xxx.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf xxx.tar.gz /test/*</code></pre></li><li><p>解压压缩包（重点）<br>命令：tar [-xvf] 压缩文件<br>其中：x：代表解压<br>示例：将&#x2F;test下的xxx.tar.gz解压到当前目录下</p><pre><code>tar -xvf xxx.tar.gz</code></pre><p>示例：将&#x2F;test下的xxx.tar.gz解压到根目录&#x2F;usr下</p><pre><code>tar -xvf xxx.tar.gz -C /usr ----- -C代表指定解压的位置</code></pre></li><li><p>查看tar包中的内容<br>命令：</p><pre><code>tar -tvf xxx.tar.gz</code></pre></li></ol><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol><li><p>搜索命令<br>命令：grep 要搜索的字符串 要搜索的文件<br>示例：搜索&#x2F;etc&#x2F;sudo.conf文件中包含字符串to的行</p><pre><code>grep to /etc/sudo.conf</code></pre></li><li><p>管道命令<br>命令：|   将前一个命令的输出作为本次目录的输入<br>示例：查看当前系统中所有的进程中包括system字符串的进程<br>ps -ef | grep system </p></li><li><p>查看进程<br>命令：ps -ef<br>示例：查看当前系统中运行的进程 </p></li><li><p>杀死进程<br>命令：kill -9 进程的pid</p></li><li><p>网络通信命令<br>查看当前系统的网卡信息：ifconfig （ip addr）</p><p>查看与某台机器的连接情况：ping</p><p>查看当前系统的端口使用：netstat -an</p></li></ol><h2 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h2><p>权限是Linux中的重要概念，每个文件&#x2F;目录等都具有权限，通过ls -l命令我们可以查看某个目录下的文件或目录的权限<br>示例：在随意某个目录下ls -l</p><p>第一列的内容的信息解释如下：</p><p>文件的类型：<br>d：代表目录<br>-：代表文件<br>l：代表链接（可以认为是window中的快捷方式）<br>后面的9位分为3组，每3位置一组，分别代表所属用户的权限，与当前用户同组的用户的权限，其他用户的权限<br>r：代表权限是可读，r也可以用数字4表示<br>w：代表权限是可写，w也可以用数字2表示<br>x：代表权限是可执行，x也可以用数字1表示</p><p>属主（user）属组（group）其他用户<br>rwxrwxrwx<br>421421421</p><p>修改文件&#x2F;目录的权限的命令：chmod<br>示例：修改&#x2F;test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限<br><code>chmod u=rwx,g=rw,o=r aaa.txt</code></p><p>上述示例还可以使用数字表示：<br><code>chmod 764 aaa.txt</code></p><h2 id="添加用户和组"><a href="#添加用户和组" class="headerlink" title="添加用户和组"></a>添加用户和组</h2><p><code>useradd testuser</code> 创建用户testuser<br><code>passwd testuser</code> 给已创建的用户testuser设置密码<br>说明：新创建的用户会在&#x2F;home下创建一个用户目录testuser<br><code>usermod --help</code> 修改用户这个命令的相关参数<br><code>userdel testuser</code> 删除用户testuser<br><code>rm -rf testuser</code> 删除用户testuser所在目录</p><p>上面的几个命令只有root账号才可以使用，如果你不知道自己的系统上面的命令在什么位置可以使用如下命令查找其路径：</p><p><code>locate useradd</code></p><p><a href="https://www.linuxidc.com/upload/2017_06/170618075833851.png"><img src="/Linux/170618075833851.png"></a></p><p>创建新用户后，同时会在etc目录下的passwd文件中添加这个新用户的相关信息<br>说明：为了截图，此处我使用了<code>tail -3 passwd</code>命令，只将该文件的最后3行信息（也是我关注的信息）显示出来</p><p><a href="https://www.linuxidc.com/upload/2017_06/170618075964621.png"><img src="/Linux/170618075964621.png"></a></p><p>命令行窗口下用户的相互切换：<br>su 用户名<br>说明：su是switch user的缩写，表示用户切换<br>从新的用户状态下输入“exit”即可退回到刚才的用户状态</p><p><a href="https://www.linuxidc.com/upload/2017_06/170618075964622.png"><img src="/Linux/170618075964622.png"></a></p><p>用户组的添加和删除：<br><code>groupadd testgroup</code>  组的添加<br><code>groupdel testgroup</code>  组的删除<br>说明：组的增加和删除信息会在etc目录的group文件中体现出来。</p><p><a href="https://www.linuxidc.com/upload/2017_06/170618075964623.png"><img src="/Linux/170618075964623.png"></a></p><p>添加用户到已经存在的组</p><p>将一个已有用户 cnzhx 增加到一个已有用户组 apache 中，使此用户组成为该用户的附加用户组，可以使用带 -a 参数的 <code>usermod</code> 指令。-a 代表 append， 也就是将用户添加到新用户组中而不必离开原有的其他用户组。不过需要与 -G 选项配合使用：</p><pre><code>usermod -a -G apache cnzhx</code></pre><p>如果要将一个用户从某个组中删除，则</p><pre><code>gpasswd -d user group</code></pre><p>查看自己用户名</p><p><code>whoami</code></p><h2 id="Filezilla使用教程"><a href="#Filezilla使用教程" class="headerlink" title="Filezilla使用教程"></a>Filezilla使用教程</h2><p><strong>注意：要使用SFTP连接CentOS7</strong>，默认端口号：22</p><p>FileZilla是一款免费开源的FTP客户端软件，虽然它是免费软件，可性能却一点也不含糊，比起那些共享软件来有过之而无不及，具备大多数的FTP软件功能。其可控性、有条理的界面和管理多站点的简化方式、特别是它的传输速度，简直是出神入化，也是它最大的特色。总的来说是它一款出类拔萃的免费FTP客户端软件(Filezilla下载)。下面是FileZilla的使用教程：FileZilla是一款免费开源的FTP客户端软件，虽然它是免费软件，可性能却一点也不含糊，比起那些共享软件来有过之而无不及，具备大多数的FTP软件功能。其可控性、有条理的界面和管理多站点的简化方式、特别是它的传输速度，简直是出神入化，也是它最大的特色。总的来说是它一款出类拔萃的免费FTP客户端软件(Filezilla下载)。下面是FileZilla的使用教程：FileZilla是一款免费开源的FTP客户端软件，虽然它是免费软件，可性能却一点也不含糊，比起那些共享软件来有过之而无不及，具备大多数的FTP软件功能。其可控性、有条理的界面和管理多站点的简化方式、特别是它的传输速度，简直是出神入化，也是它最大的特色。总的来说是它一款出类拔萃的免费FTP客户端软件(Filezilla下载)。下面是FileZilla的使用教程：</p><p>快速连接</p><p>快速连接就是不需通过站点设置，直接输入IP地址、用户名及密码进行连接。所以它适合用在需要临时性连接的站点，并且快速连信息接会被保存，如果下次还想使用，就可以直接选择进行连接了，非常方便。通过快速连接工具栏输入相关信息，点击快速连接按钮就可以了</p><img src="/2022/061415691/70.jpeg" class><p>连接成功后，在左边看到的就是您电脑上的文件，右边就是空间上的文件，选中您要上传的文件，然后右击，选上传(如果是上传到空间上某个特定的文件夹，请先在右边打开那个文件夹，再上传)。</p><p>下面给您详细的介绍一下Filezilla经常会用到的一些功能，有兴趣的可以了解下：</p><p>一、站点设置</p><p>要使用FTP工具来上传（下载）文件，首先必须要设定好FTP服务器的地址（IP地址）、授权访问的用户名及密码。下面我们将演示具体的参数设置：</p><p>通过菜单【文件】—&gt;【站点管理器】或者CTRL+S键我们可以对要连接的FTP服务器进行具体的设置。</p><p>第一步：我们可以点击【新站点】按钮，输入站点的名称（它只是对FTP站点的一个说明）。</p><p>第二步：按照界面所示，先输入主机（FTP服务器的IP地址），登陆类型选择“一般”，不要选择匿名选项（匿名的意思就是不需要用户名和密码可以直接访问FTP服务器，但很多FTP服务器都禁止匿名访问)，然后分别输入用户和密码。另外对于端口号我们在没有特别要求的情况下不用管它，或者输入“21”也可以。</p><p>第三步：在高级选项卡我们可以设置默认的远程及本地目录，远程目录其实就是连上FTP服务器后默认打开的目录；而本地目录就是每次进入FTP软件后默认显示的本地文件目录（当然了，如果大家不太清楚或者感觉麻烦的话也可以先不设置远程及本地路径，系统将会使用自己的默认路径）。</p><p>以上这些参数都设置好之后，便可使用FTP进行文件上传下载了。</p><img src="/2022/061415691/70-16547799793411.jpeg" class><p>二、连接FTP&#x2F;上传（下载）文件</p><p>1)连接</p><p>通过上面的设置之后现在就可以连接服务器上传文件了。我们可以通过菜单【文件】—&gt;【站点管理器】或者CTRL+S4键进入站点管理器选择要连接的FTP服务器，点击【连接】按钮就可以了或者点击工具栏中的第一个按钮，打开站点管理器，进行选择。连接之后，便可选择目录或文件进行上传下载了。</p><p>2)上传下载</p><p>我们不仅可以传输单个文件，还可以传输多个文件甚至整个目录，主要有四种方法。</p><p>第一种：选中所要传输的文件或目录，直接拖拽到目的主机中就可以了；</p><p>第二种：在选中所要传输的文件或目录后，单击鼠标右键选择【传输】就可以了；</p><p>第三种：双击想要传输的文件就可以了；</p><p>第四种：将选中的文件或文件夹加入到传输<a href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>中（可以直接拖放也使用鼠标右键），然后在进行传输。使用传输队列最大的好处是可以随时加入或删除传输的文件，并且对于需要经常更新的内容，允许你把它们放到队列中导出，等以后要传输的时候还可以通过导入功能调出之前保存的队列进行文件更新，就是有点复杂了，哈哈。不过要注意的是不同的文件上传到不同目录时，必须先将该目录打开之后再添加到要传的文件到队列之中。</p><p>三、其它功能及设置</p><p>1)站点导入</p><p>站点导入就是将之前版本的站点信息或其它FTP软件的站点信息导入进来，而不需要再进行重复的设置，这给广大的用户节省了时间，也减少了麻烦。通过菜单【站点】—&gt;【导入】及【导出】我们就可以进行站点导入、导出操作了。</p><img src="/2022/061415691/70-16547799793432.jpeg" class><p>FileZilla站点导入(只支持XML格式文件的导入)</p><p>FileZilla站点导出(支持管理器数据、设置数据及队列的导出)</p><img src="/2022/061415691/70-16547799793433.jpeg" class><p>2)队列管理</p><p>队列管理就是对所传输的文件及目录进行的一些功能设置，包括队列的保存，载入、清除、恢复和传输等，可以说是比较重要的功能。FileZilla的队列功能比较简单，其中队列的保存及载入功能，可以通过菜单【文件】—&gt;【导入】及【导出】来实现，就是麻烦了一些。</p><img src="/2022/061415691/70-16547799793444.jpeg" class><p>FileZilla队列导出画面</p><p>3)文件夹内容比较</p><p>文件夹内容比较就是对两台不同的机器上的相关目录下的内容进行比较，然后把不相同的内容显示出来，这对于保持版本一致性非常有用。通过菜单【查看】—&gt;【比较目录】我们就可以比较出两个目录下不同的内容。</p><img src="/2022/061415691/70-16547799793445.jpeg" class><p>FileZilla文件目录比较功能</p><p>4)断点续传</p><p>断点续传功能可以说几乎是每个FTP软件必备的功能，也可以说是最基本和重要的功能了。它的实质就是当传输文件过程中，由于各种原因使得传输过程发生异常，产生中断，在系统恢复正常后，FTP软件能够在之前发生中断的位置继续传输文件，直到数据传送完毕为止。通过菜单【编辑】—&gt;【设置】的对已存在文件的操作选项我们就可以设置断点续传。</p><img src="/2022/061415691/70-16547799793446.jpeg" class><p>FileZilla断点续传设置画面</p><p>5)速度限制</p><p>速度限制功能就是当网络比较拥挤或FTP站点有特定要求的时候，对文件的上传和下载的速度进行具体的限制。通过菜单【编辑】—&gt;【设置】的对已存在文件的操作选项，我们就可以设置速度限制了。</p><img src="/2022/061415691/70-16547799793447.jpeg" class><p>FileZilla速度限制画面（0表示没有限制）</p><p>6)文件过滤器</p><p>过滤器功能简单的说就是将符合条件的待传输文件及目录进行传输，我们可以通过设置扩展名、优先级类表等来控制文件的传输。通过菜单【查看】—&gt;【文件过滤器】我们就可以对传输的文件进行选择。（但是感觉好像不起作用）</p><img src="/2022/061415691/70-16547799793448.jpeg" class><p>FileZilla过滤器画面</p><p>7)快速拖放</p><p>快速拖放功能是大多数FTP软件都支持的功能，它主要就是为了用户操作的方便。</p><p>8)多语言支持</p><p>FileZilla3.0标准版支持包括中文简体在内的多语言界面。通过菜单【编辑】—&gt;【设置】的语言选项，我们就可以设置使用的语言。</p><img src="/2022/061415691/70-16547799793449.jpeg" class><p>FileZilla语言设置画面</p><p>9)备份恢复功能</p><p>备份恢复功能是针对FTP软件的设置、站点列表等信息内容的备份及恢复。通过菜单【文件】—&gt;【导入】及【导出】功能我们就可以进行信息的备份和恢复。</p><p>10)文件关联</p><p>许多用户在使用FTP软件传输文件的时候，突然发现了一些错误想要修改，但是如果要在调用相关的软件打开，又比较麻烦，所以很多FTP软件就通过文件关联来让用户直接调用相关软件打开要修改的文件，方便了用户的操作。通过菜单【编辑】—&gt;【设置】的正在编辑文件选项，我们就可以设置关联程序。</p><img src="/2022/061415691/70-165477997934510.jpeg" class><p>FileZilla文件关联画面</p><p>11)防掉线（反空闲、闲置保护）</p><p>所谓防掉线或者说反空闲、闲置保护功能就是让计算机在空闲状态下每隔一段时间向FTP服务器发送一段特定信息，以便让FTP服务器知道自己还是活动的，从而并且FTP服务器断开对自己的连接。通过菜单【编辑】—&gt;【设置】的FTP选项，我们就可以设置相关的参数。</p><img src="/2022/061415691/70-165477997934511.jpeg" class><p>FileZilla反空闲设置画面</p><p>12)远程管理</p><p>远程管理简单的说就是在远程FTP服务器上也可以自由的新建、删除、打开文件或目录等操作。这都是方便性的体现。</p><p>13)分组管理</p><p>分组管理就是将多个不同的FTP服务器放在同一个组（就相当于目录）中，这样可以更加便于用户的管理。在新建站点的时候，我们就可以先建组，然后再建立新的站点保存在组中。</p><img src="/2022/061415691/70-165477997934512.jpeg" class><p>FileZilla组管理画面</p><p>14)文件存在处理</p><p>文件存在处理就是当传输文件过程中，如果遇到相同文件名的文件怎么处理?FileZilla共提供了七种方。通过菜单【传输】—&gt;【对已存在文件的默认操作】我们就可以进行相关的设置。</p><img src="/2022/061415691/70-165477997934513.jpeg" class><p>FileZilla文件存在处理</p><h2 id="开启FTP服务"><a href="#开启FTP服务" class="headerlink" title="开启FTP服务"></a>开启FTP服务</h2><p>vsftpd 是Linux系统中比较好用的一款FTP服务端软件</p><p><strong>1.</strong> 运行图示命令确认本机是否已经安装了 vsftpd </p><img src="/2022/061415691/image-20210620154601326.png" class><p><strong>2.</strong> 如果没有安装，运行图示命令进行安装</p><img src="/2022/061415691/image-20210620154654079.png" class><ol start="3"><li>修改配置文件，禁止匿名登录</li></ol><p>vsftpd默认允许匿名登录，通常被视为不安全的做法，需要通过修改配置文件来禁止匿名登录，默认配置文件的路径是：&#x2F;etc&#x2F;vsftpd&#x2F;vsftpd.conf , 修改图示配置项即可。</p><pre><code>vim /etc/vsftpd/vsftpd.conf</code></pre><img src="/2022/061415691/image-20210620154746359.png" class><ol start="4"><li><p>启动 vsftpd 服务，停止安全控制相关服务 </p><pre><code>#启动ftp服务systemctl start vsftpd#设置开启启动ftp服务systemctl enable vsftpd.service</code></pre><img src="/2022/061415691/image-20210620154948141.png" class></li><li><p>运行图示命令停止安全控制相关服务（<strong>图2示</strong>），因为 ftp 是不安全的协议，所以如果开启该服务，无法进行连接</p><pre><code>#临时关闭防火墙systemctl stop firewalld#永久关闭防火墙systemctl disable firewalld.service</code></pre><img src="/2022/061415691/image-20210620155132021.png" class></li><li><p>修改配置文件中的userlist_enable的值改为NO</p><pre><code>vim /etc/vsftpd/vsftpd.conf</code></pre><img src="/2022/061415691/image-20210620155753642.png" class></li><li><p>修改vsftpd禁止名单，删除root（该步骤可以不做）</p><pre><code>vim /etc/vsftpd/ftpusers</code></pre><img src="/2022/061415691/image-20210620155654754.png" class></li><li><p>重启 ftp服务</p><pre><code>systemctl restart vsftpd</code></pre></li><li><p>FTP客户端登录</p><p>打开一款客户端软件（比如filezilla）,配置FTP连接的主机信息和登陆用户及密码，即可连接成功，FTP连接后，就可以向 Linux 上传输文件了。</p><p><strong>注意：不要使用 root 账号</strong></p></li></ol><img src="/2022/061415691/image-20210620213156349.png" class><h2 id="配置Editplus的ftp功能打开远程文件"><a href="#配置Editplus的ftp功能打开远程文件" class="headerlink" title="配置Editplus的ftp功能打开远程文件"></a>配置Editplus的ftp功能打开远程文件</h2><ol><li><p>打开EditPlus，点击“文件-&gt;FTP(F)-&gt;FTP设置”</p><p><img src="https://exp-picture.cdn.bcebos.com/e996472ae3efe078458abf02b96c576698cf6513.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/quality,q_80" alt="配置Editplus的ftp功能打开远程文件"></p></li><li><p>在弹出的“FTP设置”窗口中点击“添加(A)”，产生新“新FTP账号”项目</p><p><img src="https://exp-picture.cdn.bcebos.com/562787cf02532f637b3e8082699147e832e05c13.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/quality,q_80" alt="配置Editplus的ftp功能打开远程文件"></p></li><li><p>设置“新FTP账号”信息，其中“描述”可以更改为你喜欢的任何名字（本例中更改为“labsite”），并填写“FTP服务器”、“用户名(U)”、“密码(P)”，然后点击“确定”就可以了。</p><p><img src="https://exp-picture.cdn.bcebos.com/32a127723d03bbea5e3d50fcea43d7d449315413.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/quality,q_80" alt="配置Editplus的ftp功能打开远程文件"></p></li><li><p>然后点击 “高级设置”</p><img src="/2022/061415691/image-20210622054928245.png" class><p>选择 加密方式 为 “sftp”</p><img src="/2022/061415691/image-20210622055158834.png" class></li><li><p>然后在EditPlus侧边栏的“快速目录路径”中可以找到已设置好的FTP，点击即可打开远程文件</p><img src="/2022/061415691/d695563104ebf6a738b4e29fffee1c324a184f13.jpg" class></li></ol><h2 id="Linux的软件安装"><a href="#Linux的软件安装" class="headerlink" title="Linux的软件安装"></a>Linux的软件安装</h2><ol><li><p>通常Linux应用软件的安装包有两种：<br>1） tar包，如software-1.2.3-1.tar.gz。它是使用UNIX系统的打包工具tar打包的。<br>2） rpm包，如software-1.2.3-1.i386.rpm。它是RedHat Linux提供的一种包封装格式。</p><p>而且，大多数Linux应用软件包的命名也有一定的规律，它遵循：<br>名称-版本-修正版-类型<br>例如：<br>1）software-1.2.3-1.tar.gz 意味着：<br>软件名称：software<br>版本号：1.2.3<br>修正版本：1<br>类型：tar.gz，说明是一个tar包。<br>2）sfotware-1.2.3-1.i386.rpm<br>软件名称：software<br>版本号：1.2.3<br>修正版本：1<br>可用平台：i386，适用于Intel 80x86平台。<br>类型：rpm，说明是一个rpm包。<br>注：由于rpm格式的通常是已编译的程序，所以需指明平台</p></li><li><p>了解包里的内容<br>一个Linux应用程序的软件包中可以包含两种不同的内容：<br>1）一种就是可执行文件，也就是解开包后就可以直接运行的。在Windows中所有的软件包都是这种类型。安装完这个程序后，你就可以使用，但你看不到源程序。而且下载时要注意这个软件是否是你所使用的平台，否则将无法正常安装。<br>2）另一种则是源程序，也就解开包后，你还需要使用编译器将其编译成为可执行文件。这在Windows系统中是几乎没有的，因为Windows的思想是不开放源程序的。<br>通常，用tar打包的，都是源程序；而用rpm打包的则常是可执行程序。一般来说，自己动手编译源程序能够更具灵活性，但也容易遇到各种问题和困难。而相对来说，下载那些可执行程序包，反而是更容易完成软件的安装，当然那样灵活性就差多了。所以一般一个软件总会提供多种打包格式的安装程序的。你可以根据自己的情况来选择。</p></li><li><p>Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理 依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p></li></ol><h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>​注意：rpm与软件相关命令 相当于window下的软件助手 管理软件<br>​步骤：<br>​1. 查看当前Linux系统是否已经安装java<br>​    输入<br>​<br>​<code> ​ rpm -qa | grep java ​</code><br>​<br>​<img src="/2022/061415691/image-20210620060426938.png" class></p><ol start="2"><li><p>卸载两个openJDK<br>  输入</p><pre><code>rpm -e --nodeps 要卸载的软件名</code></pre></li><li><p>上传jdk到linux</p></li><li><p>安装jdk运行需要的插件yum install glibc.i686（特殊情况下可选做，一般还是要安装的）</p></li><li><p>解压jdk到&#x2F;usr&#x2F;local下</p><pre><code>tar -xvf jdk-8u181-linux-x64.tar.gz -C /usr/local</code></pre></li><li><p>配置jdk环境变量，打开&#x2F;etc&#x2F;profile配置文件，将下面配置拷贝进去</p><pre><code>#set java environmentJAVA_HOME=/usr/local/jdk1.8.0_181CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH </code></pre></li><li><p>重新加载&#x2F;etc&#x2F;profile配置文件 </p><pre><code>source /etc/profile</code></pre></li><li><p>使用命令测试，是否安装成功</p><pre><code>java -version</code></pre></li></ol><h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><p>​步骤：</p><ol><li><p>上传Tomcat到linux上</p></li><li><p>解压Tomcat到&#x2F;usr&#x2F;local下</p><pre><code>tar -xvf apache-tomcat-9.0.30.tar.gz -C /usr/local</code></pre></li><li><p>开放Linux的对外访问的端口8080</p></li></ol><p></p><pre><code>/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code></pre><ol start="4"><li><p>启动关闭Tomcat<br>进入tomcat的bin下启动：.&#x2F;startup.sh<br>进入tomcat的bin下关闭：.&#x2F;shutdown.sh</p></li><li><p>测试：<br><a href="http://linux服务器ip:8080/">http://linux服务器ip:8080</a><br>显示tomcat主页，验证成功！</p></li></ol><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><h3 id="1-下载mysql5-7的rpm安装包"><a href="#1-下载mysql5-7的rpm安装包" class="headerlink" title="1.下载mysql5.7的rpm安装包"></a>1.下载mysql5.7的rpm安装包</h3><p>   rpm的mysql包,安装起来简单,解压版的mysql还需要做许多配置，稍有不慎就会出错！！！</p><ul><li>下载地址：<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a></li></ul><img src="/2022/061415691/1419795-20190725154212674-340577749.png" class title="image_thumb1"><ul><li>下载后的安装包是这个样子的</li></ul><img src="/2022/061415691/1419795-20190725154227433-854603804.png" class title="image_thumb3"><h3 id="2-上传mysql安装包到centos7的系统下"><a href="#2-上传mysql安装包到centos7的系统下" class="headerlink" title="2.上传mysql安装包到centos7的系统下"></a>2.上传mysql安装包到centos7的系统下</h3><h3 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3.安装依赖"></a>3.安装依赖</h3><h4 id="3-1-查看linux上是否已经安装了mysql-有则卸载。"><a href="#3-1-查看linux上是否已经安装了mysql-有则卸载。" class="headerlink" title="3.1 查看linux上是否已经安装了mysql,有则卸载。"></a>3.1 查看linux上是否已经安装了mysql,有则卸载。</h4><p>一般centos7默认安装了mariadb,这里把它卸载。</p><blockquote><p>查看：[root@localhost bin]# rpm -qa|grep mariadb</p><p>卸载：[root@localhost bin]# rpm -e –nodeps mariadb-libs-5.5.56-2.el7.x86_64</p></blockquote><h4 id="3-2-安装mysql5-7所需要的依赖"><a href="#3-2-安装mysql5-7所需要的依赖" class="headerlink" title="3.2 安装mysql5.7所需要的依赖"></a>3.2 安装mysql5.7所需要的依赖</h4><blockquote><p>[root@localhost src]# yum install libaio</p><p>[root@localhost src]# yum install perl</p><p>[root@localhost src]# yum install net-tools</p></blockquote><p>安装依赖时会询问你是下载并安装还是下载或者不下载。(输入y回车，下载并安装即可。)</p><img src="/2022/061415691/1419795-20190725154258146-1333597514.png" class title="image_thumb9"><h3 id="4-安装mysql5-7"><a href="#4-安装mysql5-7" class="headerlink" title="4.安装mysql5.7"></a>4.安装mysql5.7</h3><h4 id="4-1-解压mysql5-7安装包"><a href="#4-1-解压mysql5-7安装包" class="headerlink" title="4.1 解压mysql5.7安装包"></a>4.1 解压mysql5.7安装包</h4><blockquote><p>mkdir &#x2F;usr&#x2F;local&#x2F;mysql</p><p>[root@localhost src]#tar -xvf mysql-5.7.34-1.el7.x86_64.rpm-bundle.tar -C &#x2F;usr&#x2F;local&#x2F;mysql</p></blockquote><p>   解压完后会有很过rpm文件,这些就是我们需要安装的。</p><img src="/2022/061415691/1419795-20190725154318153-1948589555.png" class title="image_thumb12"><h4 id="4-2-安装mysql5-7"><a href="#4-2-安装mysql5-7" class="headerlink" title="4.2 安装mysql5.7"></a>4.2 安装mysql5.7</h4><blockquote><p>[root@localhost src]# rpm -ivh mysql-community-common-5.7.34-1.el7.x86_64.rpm</p><p>[root@localhost src]# rpm -ivh mysql-community-libs-5.7.34-1.el7.x86_64.rpm</p><p>[root@localhost src]# rpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm</p><p>[root@localhost src]# rpm -ivh mysql-community-server-5.7.34-1.el7.x86_64.rpm</p></blockquote><h4 id="4-3-查看mysql5-7的状态-没有启动则把mysql启动"><a href="#4-3-查看mysql5-7的状态-没有启动则把mysql启动" class="headerlink" title="4.3 查看mysql5.7的状态,没有启动则把mysql启动"></a>4.3 查看mysql5.7的状态,没有启动则把mysql启动</h4><p>出现下面这个death就是没有启动,新装的第一次是没有启动的。</p><img src="/2022/061415691/1419795-20190725154339966-584125135.png" class title="image_thumb17"><blockquote><p>查看mysql启动状态</p><p>[root@localhost src]# service mysqld status</p></blockquote><blockquote><p>启动mysql    active(running)代表启动成功</p><p>[root@localhost src]# service mysqld start</p></blockquote><img src="/2022/061415691/1419795-20190725154359951-1294954345.png" class title="image_thumb19"><h4 id="4-4-修改密码"><a href="#4-4-修改密码" class="headerlink" title="4.4 修改密码"></a>4.4 修改密码</h4><blockquote><p>查看临时密码：得知临时密码就是如图</p><p>[root@localhost src]# grep password &#x2F;var&#x2F;log&#x2F;mysqld.log</p></blockquote><img src="/2022/061415691/1419795-20190725154417320-433555237.png" class title="image_thumb33"><blockquote><p>用临时密码登录mysql<br>[root@localhost src]# mysql -uroot –p</p><p>或(上面命令不好用的话) &#x2F;usr&#x2F;bin&#x2F;mysql -uroot -p</p><p>修改成新的密码<br>mysql&gt; set password &#x3D; password(“Szfore_68638”);</p></blockquote><h4 id="4-5-开启远程连接-允许远程连接数据库"><a href="#4-5-开启远程连接-允许远程连接数据库" class="headerlink" title="4.5 开启远程连接,允许远程连接数据库"></a>4.5 开启远程连接,允许远程连接数据库</h4><blockquote><p>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’%’ IDENTIFIED BY ‘Szfore_68638’ WITH GRANT OPTION;</p></blockquote><h4 id="4-6-配置mysql的配置文件my-cnf-用默认的也行-个人觉得配置一下好一些"><a href="#4-6-配置mysql的配置文件my-cnf-用默认的也行-个人觉得配置一下好一些" class="headerlink" title="4.6 配置mysql的配置文件my.cnf(用默认的也行,个人觉得配置一下好一些)"></a>4.6 配置mysql的配置文件my.cnf(用默认的也行,个人觉得配置一下好一些)</h4><blockquote><p>打开配置文件my.cnf</p><p>[root@localhost src]# vi &#x2F;etc&#x2F;my.cnf</p><p>在[mysqld]下面配置几行</p><p>lower_case_table_names&#x3D;1    #配置表名不区分大小写 1：不区分大小写 0：区分大小写 这行必须配置 默认表名是区分大小写的，不利于开发</p><p>character-set-server&#x3D;utf8     #设置为默认编码为utf8</p><p>init_connect&#x3D;’SET NAMES utf8’</p><p>max_connections&#x3D;1024       #设置最大连接数</p><p>重启mysql 重启配置才能生效</p><p>[root@localhost src]# service mysqld restart</p></blockquote><h4 id="4-7-防火墙开启端口"><a href="#4-7-防火墙开启端口" class="headerlink" title="4.7 防火墙开启端口"></a>4.7 防火墙开启端口</h4><p>到这其实mysql已经安装和配置好,但是centos7的开了防火墙,外面还是访问不到mysql的，所以还要开端口3306(或者把防火墙关掉也行,生产环境勿用)</p><blockquote><p>关闭防火墙</p><p>[root@localhost src]# systemctl stop firewalld</p></blockquote><p>至此，centos7下安装mysql5.7完毕.可以使用windows中的mysql工具连接测试是否可用。</p><p><strong>注意：</strong>centos7的防火墙变成了firewalld,centos7以前的版本是iptables</p><h2 id="springboot项目打包"><a href="#springboot项目打包" class="headerlink" title="springboot项目打包"></a>springboot项目打包</h2><h3 id="打jar包"><a href="#打jar包" class="headerlink" title="打jar包"></a>打jar包</h3><ol><li>关闭其他的项目</li><li>修改数据库连接密码、删除测试代码</li><li>run as&#x3D;》maven build &#x3D;》 clean package</li><li>上传 jar 包文件到linux上</li><li>运行：java -jar jar包路径</li><li>测试：<a href="http://192.168.136.134:8089/emp/getPaged">http://192.168.136.134:8089/emp/getPaged</a></li></ol><h3 id="vue-cli打包"><a href="#vue-cli打包" class="headerlink" title="vue-cli打包"></a>vue-cli打包</h3><ol><li><p>修改后端地址为虚拟机ip及端口号</p><ul><li>main.js</li><li>Login.vue</li></ul></li><li><p>在终端中运行：</p><pre><code>npm run build</code></pre></li><li><p>把生成的 dist 目录中的内容 拷贝到 linux中的tomcat 的 webapps 的ROOT目录中（原ROOT目录中内容删除）</p></li><li><p>启动虚拟机的tomcat服务</p><pre><code>./startup.sh</code></pre></li><li><p>测试:</p><pre><code>http://192.168.136.134:8080</code></pre></li></ol><h2 id="centos7图形界面与命令界面的切换"><a href="#centos7图形界面与命令界面的切换" class="headerlink" title="centos7图形界面与命令界面的切换"></a>centos7图形界面与命令界面的切换</h2><ol><li>输入ctrl+alt+F2切换到dos界面</li><li>在dos界面输入： init 5 切换回图形界面（启动图形界面非常慢，甚至死机,如死机，关闭虚拟机电源重启虚拟机）</li></ol><h2 id="从CentOS7虚拟机回到主机"><a href="#从CentOS7虚拟机回到主机" class="headerlink" title="从CentOS7虚拟机回到主机"></a>从CentOS7虚拟机回到主机</h2><p>ctrl+alt</p><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>su - 用户名</p><p>如:</p><pre><code>su - admin//直接输入su命令，即使用root用户名登录su</code></pre><p>在创建用户时，系统会在&#x2F;home目录下自动生成一个目录作为该用户的“家目录”，该用户在登录后会首先进入家目录。家目录可以在添加用户时指定，如果不指定，默认会以用户名来命名。例如，用户bob的家目录默认是&#x2F;home&#x2F;bob，他在登录linux系统后，会首先进入&#x2F;home&#x2F;bob。</p><h2 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h2><ul><li>查看状态：systemctl status firewalld</li><li>关闭防火墙：systemctl stop firewalld</li></ul><h2 id="获取IP"><a href="#获取IP" class="headerlink" title="获取IP"></a>获取IP</h2><pre><code>dhclient释放获取IPdhclient -r //release ip 释放IPdhclient //获取IP</code></pre><h2 id="开放及查看端口"><a href="#开放及查看端口" class="headerlink" title="开放及查看端口"></a>开放及查看端口</h2><p>1、开放端口</p><p><strong>firewall-cmd –zone&#x3D;public –add-port&#x3D;5672&#x2F;tcp –permanent</strong>  # 开放5672端口</p><p><strong>firewall-cmd –zone&#x3D;public –remove-port&#x3D;5672&#x2F;tcp –permanent</strong> #关闭5672端口</p><p><strong>firewall-cmd –reload</strong>  # 配置立即生效</p><p>2、查看防火墙所有开放的端口</p><p><strong>firewall-cmd –zone&#x3D;public –list-ports</strong> </p><p>3.、关闭防火墙</p><p>如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估</p><p><strong>systemctl stop firewalld.service</strong></p><p>4、查看防火墙状态</p><p> <strong>firewall-cmd –state</strong></p><p>5、查看监听的端口</p><p><strong>netstat -lnpt</strong></p><img src="/2022/061415691/1336432-20190302110949754-1765820036.png" class title="img"><p><em>PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</em></p><p>6、检查端口被哪个进程占用</p><p><strong>netstat -lnpt |grep 5672</strong></p><img src="/2022/061415691/1336432-20190302104128381-1210567174.png" class title="img"><p>7、查看进程的详细信息</p><p><strong>ps 6832</strong></p><img src="/2022/061415691/1336432-20190302104342651-779103690.png" class title="img"><p>8、中止进程</p><p><strong>kill -9 6832</strong></p><h2 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h2><p><a href="https://www.runoob.com/linux/linux-tutorial.html">https://www.runoob.com/linux/linux-tutorial.html</a></p><h2 id="Linux命令su和sudo的区别在哪？各有什么用途？"><a href="#Linux命令su和sudo的区别在哪？各有什么用途？" class="headerlink" title="Linux命令su和sudo的区别在哪？各有什么用途？"></a>Linux命令su和sudo的区别在哪？各有什么用途？</h2><p>什么是su?</p><p>　　su的全称并不是super user，而是switch user，是不是就突然明白了？是切换用户的意思。su的一般使用方法是su 或者su - ，两种方法虽然只差了1个字符，但也是有比较大的差异的。</p><p>　　加入了-参数，就是login-shell的方式，也就是说切换到另一个用户之后，当前的shell会加载对应的环境变量和各种设置；</p><p>　　如果没有加入-参数，就是non-login-shell的方式，也就是说当前的shell还是加载切换之前的那个用户的环境变量以及各种设置。</p><p>　　如果不想因为切换到另一个用户导致自己在当前用户下的设置不可用，那么就可以用non-login-shell的方式；如果切换用户后，需要用到该用户的各种环境变量，那么使用login-shell方式即可。</p><p>　　什么是sudo?</p><p>　　全称为super user do，即以超级用户的方式执行命令，这里的超级用户指的就是root用户，我们在Linux中有时会遇到permission denied的情况，如以ubuntu用户的身份查看&#x2F;etc&#x2F;shadow的内容，因为它是只有root用户才能查看的，这个时候就可以使用sudo。</p><p>　　两者的区别在于：</p><p>　　使用su - 提供root账号的密码，可以切换到root用户；</p><p>　　使用sudo su -，提供当前用户的密码，也可以切换到root用户。</p><p>　　如果我们的Linux系统有很多用户需要使用的话，前者要求所有用户都知道root用户的密码，显然是非常危险的；后者是不需要暴露root账户密码的，用户只需要输入自己的账户密码就可以。</p><h2 id="修改CentOS7编码"><a href="#修改CentOS7编码" class="headerlink" title="修改CentOS7编码"></a>修改CentOS7编码</h2><ol><li>查看编码</li></ol><pre><code>echo $LANG$LANGUAGE</code></pre><ol start="2"><li><p>修改</p><pre><code>修改为英文字符集：vi /etc/locale.conf LANG=en_US.UTF-8修改为中文字符集：LANG=zh_CN.UTF-8</code></pre></li><li><p>使配置生效</p><pre><code>source /etc/locale.conf </code></pre></li></ol><h2 id="putty支持中文编码"><a href="#putty支持中文编码" class="headerlink" title="putty支持中文编码"></a>putty支持中文编码</h2><ol><li><p>选择支持中文的字体</p><img src="/2022/061415691/image-20220613062111019.png" class></li><li><p>设置编码</p><img src="/2022/061415691/image-20220613062147584.png" class title="image-20220613062147584"></li></ol><h1 id="Linux补充"><a href="#Linux补充" class="headerlink" title="Linux补充"></a>Linux补充</h1><h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><p>1）是Red Hat Package Manager的缩写，由Red Hat公司开发。<br>2）它是以一种数据库记录的方式将我们所需要的套件安装到Linux主机的一套管理程序。也就是说，你的Linux系统中存在着一个关于RPM的数据库，它记录了安装的包以及包与包之间的依赖关系。<br>3）RPM包是预先在Linux机器上编译并打包的文件，安装非常快捷。但它也有一些缺点，比如安装环境必须与变异时的环境一致或者相当，包与包之间存在着相互依赖的情况，卸载包时，需要先把依赖的包卸载。如果依赖的包是系统所必需的，就不能卸载这个包，否则系统会崩溃。<br>4）挂载光驱<br>先检查一下VMware右下角的小光驱图标是否点亮，如果没有，点击一下，再点击“连接”就可以点亮它。如果没有，点击一下，再点击“连接”就可以点亮它。当挂载光驱后，会在&#x2F;mnt&#x2F;Packages目录下看到很多后缀为.rpm的文件，这些文件就是RPM包<br>挂载光驱：<br>mount &#x2F;dev&#x2F;cdrom &#x2F;mnt<br>5)每个RPM包的名称都由”-“和”.”分成了若干部分。比如在abrt-2.1.11-45.el7.centos.x86_64.rpm包中，abrt为包名，2.1.11为版本信息，45.el7.centos为发布版本号，x86_64为运行平台。常见的运行平台有i386、i586、i686和x86_64。需要注意的是，CPU目前分32位和64位，i386、i586和i686都为32位平台，x86_64则为64位平台。另外，有些RPM包并没有写具体的平台而是noarch（如ant-1.9.2-9.el7.noarch.rpm）,这说明在这个RPM包没有硬件平台限制.<br>6)安装RPM包:</p><pre><code>rpm -ivh libject-turbo-devel-1.2.90-5.el7.x86_64.rpm</code></pre><p>其中各个选项的含义如下：<br>-i:表示安装<br>-v：表示可视化<br>-h:表示显示安装进度<br>另外，在安装RPM包时，常用的附带参数还包括如下几项：<br>–force:表示强制安装，即使覆盖属于其他包的文件也要安装<br>–nodeps:表示当要安装的RPM包依赖于其他包时，即使其他包没有安装，也要安装这个包。<br>7）升级RPM包</p><pre><code>rpm -Uvh filename，其中-U选项表示升级</code></pre><p>8）卸载RPM包<br>rpm -e filename,这里的filename是通过rpm的查询功能所查询到的<br>如：</p><pre><code>rpm -qa lbjpeg-turbo-devel</code></pre><pre><code>rpm -e libjpeg-turbo-devel</code></pre><p>卸载时，-e选项后面的filename和安装时是有区别的。安装时，是把一个存在的文件作为参数，而卸载时只需要包名即可<br>9）rpm -qa ：查询当前系统所有已安装的RPM包<br>10）rpm -qi 包名 ：得到已安装RPM包的相关信息<br>11）rpm -ql 包名 :列出一个RPM包的安装文件列表<br>12）rpm -qf 文件的绝对路径  ：列出某个文件属于哪个RPM包</p><h2 id="yum工具"><a href="#yum工具" class="headerlink" title="yum工具"></a>yum工具</h2><ol><li><p>yum工具最大的优势在于可以联网去下载所需要的RPM包，然后自动安装。如果要安装的RPM包邮依赖关系，yum工具会帮我们依次安装所有相关的RPM包。</p></li><li><p>yum list:列出所有的RPM包资源</p><pre><code>yum list | head -20   ：使用管道列出前20个</code></pre><img src="/2022/061415691/image-20210623054604488.png" class title="image-20210623054604488"> <p>显示的信息中，最左侧是RPM包名，中间是版本信息，最右侧是安装信息。如果已经安装，最右侧就显示@base、@updates或者@anaconda,它们前面都会有一个@符号。如果未安装，则显示base或者anaconda。如果RPM包已安装但需要升级，则显示updates。yum list命令会先列出已经安装的包，再列出可以安装的包</p></li><li><p>yum search [相关关键词] :搜索RMP包<br>如：</p><pre><code>yum search vim</code></pre><p>或者可以使用：</p><pre><code>yum list | grep &#39;vim&#39;</code></pre></li><li><p>yum install [-y][RMP包名]：安装RPM包，如果不加-y选项，则会以与用户交互的方式安装。<br>   在安装过程中，它首先会把需要安装的RPM包列出来，如果有依赖关系，也会把所有依赖的包列出来。<br>如：</p><pre><code>yum install -y protobuf-vim</code></pre></li><li><p>yum remove RPM包名：卸载RPM包</p><pre><code>yum remove protobuf-vim   ：可以加-y选项（不建议）</code></pre></li><li><p>yum update [-y] [RPM包]:升级RPM包</p><pre><code>yum update bash</code></pre></li><li><p>利用yum工具下载RPM包<br>i）yum install 包名 -y –downloadonly –downloaddir&#x3D;路径<br>如：</p><pre><code>yum install -y ypbind --downloadonly --downloaddir=/tmp/</code></pre><p>ii)如果包已经安装过了，上面的命令就不起作用了，改用：</p><pre><code>yum reinstall -y bash --downloadonly --downloaddir=/tmp/</code></pre></li></ol><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 代理服务器。</p><p>在高连接并发的情况下，Nginx是Apache服务器不错的替代品。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol><li>添加Nginx到YUM源</li></ol><pre><code>rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</code></pre><ol start="2"><li>安装Nginx</li></ol><pre><code>yum install -y nginx</code></pre><ol start="3"><li>启动Nginx</li></ol><pre><code>systemctl start nginx.service</code></pre><p>如果一切进展顺利的话，现在你可以通过你的域名或IP来访问你的Web页面来预览一下Nginx的默认页面；</p><img src="/2022/061415691/17023-b8bd8cdcfa37c42b.png" class title="img"><ol start="4"><li>CentOS 7 开机启动Nginx</li></ol><pre><code>systemctl enable nginx.service</code></pre><ol start="5"><li>开放80端口</li></ol><pre><code>##Addfirewall-cmd --permanent --zone=public --add-port=80/tcp##Reloadfirewall-cmd --reload</code></pre><h3 id="Nginx配置信息"><a href="#Nginx配置信息" class="headerlink" title="Nginx配置信息"></a>Nginx配置信息</h3><ul><li>网站文件存放默认目录，拷贝vue-cli构建之后的dist目录内容到该目录下（删除该目录原来所有文件）</li></ul><pre><code>/usr/share/nginx/html</code></pre><ul><li>网站默认站点配置</li></ul><pre><code>/etc/nginx/conf.d/default.conf</code></pre><ul><li>自定义Nginx站点配置文件存放目录</li></ul><pre><code>/etc/nginx/conf.d/</code></pre><ul><li>Nginx全局配置</li></ul><pre><code>/etc/nginx/nginx.conf</code></pre><ul><li>Nginx启动</li></ul><pre><code>nginx -c nginx.conf</code></pre><h3 id="Nginx-其他命令"><a href="#Nginx-其他命令" class="headerlink" title="Nginx 其他命令"></a>Nginx 其他命令</h3><p>以下包含了 Nginx 常用的几个命令：</p><pre><code>/usr/sbin/nginx -s reload            # 重新载入配置文件/usr/sbin/nginx -s reopen            # 重启 Nginx/usr/sbin/nginx -s stop              # 停止 Nginx/usr/sbin/nginx                      # 启动 Nginx</code></pre><h2 id="which：用户查找某个命令的绝对路径"><a href="#which：用户查找某个命令的绝对路径" class="headerlink" title="which：用户查找某个命令的绝对路径"></a>which：用户查找某个命令的绝对路径</h2><pre><code>which nginx</code></pre><h2 id="环境变量PATH"><a href="#环境变量PATH" class="headerlink" title="环境变量PATH"></a>环境变量PATH</h2><pre><code>echo $PATH     //显示环境变量，区分大小写，PATH前面的$是变量的前缀符号</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/061325246.html"/>
      <url>/2022/061325246.html</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="源代码管理工具"><a href="#源代码管理工具" class="headerlink" title="源代码管理工具"></a>源代码管理工具</h2><ol><li>CVS</li><li>SVN</li><li>Git</li><li>VSS</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>主要功能</p><ul><li>记录历史信息</li><li>团队协作</li></ul></li><li><p>三个区域</p><ul><li><p>版本库：已提交到git仓库中的数据</p></li><li><p>暂存区：下一次要提交的文件快照</p></li><li><p>工作目录：编写代码的目录</p><img src="/2022/061325246/image-20201016103153310.png" class title="image-20201016103153310"></li></ul></li></ol><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>在某个文件夹中，使用如下命令，将在当前目录下创建一个 gittest 文件夹，并在该文件夹中初始化git本地仓库</p><pre><code>git init gittest</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>git config --global user.name &quot;pcbhyy&quot;git config --global user.email &quot;pcbhyy@163.com&quot; --global ：针对当前用户--system:针对当前系统所有用户不加选项：针对当前项目</code></pre><h2 id="创建并添加文件到暂存区中"><a href="#创建并添加文件到暂存区中" class="headerlink" title="创建并添加文件到暂存区中"></a>创建并添加文件到暂存区中</h2><pre><code>//先创建 1.txt文件git add 1.txt</code></pre><h2 id="查看git状态"><a href="#查看git状态" class="headerlink" title="查看git状态"></a>查看git状态</h2><p>显示 暂存区 与 工作区 状态不同的文件。这其中包含了已修改但未暂存， 或已经暂存但没有提交的文件。   </p><pre><code>git status</code></pre><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>将暂存区中内容提交到本地仓库中</p><pre><code>git commit -m &quot;提交说明&quot;//打开一个文件，在其中添加注释，适合于注释比较多和需要换行的情况git commit</code></pre><h2 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h2><pre><code>git --help 命令名如：git --help commit</code></pre><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>默认不用任何参数的话， git log 会按提交时间列出所有的更新， 最近的更新排在最上面。  </p><pre><code>git log//n:显示的提交数git log -n//-p ， 用来显示每次提交的内容差异git log -p//--stat:查看每次提交的简略的统计信息 git log --stat</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><ol><li><p>舍弃工作目录中对一个文件的修改 （修改的文件未被暂存或提交），命令： checkout –filename</p><pre><code> git checkout test.txt</code></pre><blockquote><p>注意：请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p></blockquote></li><li><p>舍弃工作目录中所有未保存的变更 （文件可能已暂存也可能没有，但未被提交），命令： reset –hard</p><img src="/2022/061325246/image-20201013144708354.png" class title="image-20201013144708354"><blockquote><p>注意：git reset 确实是个危险的命令，如果加上了 –hard 选项则更是如此。 然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。</p></blockquote></li><li><p>从工作目录中删除未跟踪（新添加未缓存或提交过）的文件</p><pre><code>git clean -fd</code></pre><p>-d：删除未跟踪文件夹</p><p>-f：强制删除</p></li><li><p>修补最后一次提交</p><pre><code>git commit -m &#39;init commit&#39;//修改最后一次提交的注释git commit -m &#39;change common&#39; --amendgit commit -m &#39;init commit&#39;//增加一个暂存文件git add 3.txt//修改最后一次提交的内容git commit --amend</code></pre><blockquote><p>当你在修补最后的提交时，并不是通过用改进后的提交 <strong>原位替换</strong> 掉旧有提交的方式来修复的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出现在仓库的历史中。</p><p>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p></blockquote></li><li><p>恢复到某次提交</p><pre><code>//e5c3f2ce79fc005c5208ceb95b170b614d0a63e3：为提交Idgit reset --hard e5c3f2ce79fc005c5208ceb95b170b614d0a63e3</code></pre></li><li><p>显示所有提交历史</p><pre><code>//该命令分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交  git reflog</code></pre></li></ol><h2 id="重要目录结构"><a href="#重要目录结构" class="headerlink" title="重要目录结构"></a>重要目录结构</h2><p>HEAD 文件、 （ 尚待创建的） index 文件， 和 objects 目录、 refs 目录。 这些条目是 Git 的核心组成部分。</p><ol><li>objects 目录存储所有数据内容； </li><li>refs 目录存储指向数据（ 分支） 的提交对象的指针；</li><li>HEAD 文件指示目前被检出的分支； </li><li>index 文件保存暂存区信息。</li></ol><h2 id="提交过程"><a href="#提交过程" class="headerlink" title="提交过程"></a>提交过程</h2><p>我们假设现在有一个工作目录， 里面包含了三个将要被暂存和提交的文件。 暂存操作<br>会为每一个文件计算校验和（ 使用我们在 Chapter 1 中提到的 SHA-1 哈希算法） ， 然后会把当前版本的<br>文件快照保存到 Git 仓库中（ Git 使用 blob 对象来保存它们） ， 最终将校验和加入到暂存区域等待提交：  </p><pre><code>$ git add README test.rb LICENSE$ git commit -m &#39;The initial commit of my project&#39;</code></pre><p>当使用 git commit 进行提交操作时， Git 会先计算每一个子目录（ 本例中只有项目根目录） 的校验<br>和， 然后在 Git 仓库中这些校验和保存为树对象。 随后， Git 便会创建一个提交对象， 它除了包含上面提<br>到的那些信息外， 还包含指向这个树对象（ 项目根目录） 的指针。 如此一来， Git 就可以在需要的时候重<br>现此次保存的快照。<br>现在， Git 仓库中有五个对象： 三个 blob 对象（ 保存着文件快照） 、 一个树对象（ 记录着目录结构和<br>blob 对象索引） 以及一个提交对象（ 包含着指向前述树对象的指针和所有提交信息） 。  </p><img src="/2022/061325246/image-20201016151815452.png" class title="image-20201016151815452"><p>做些修改后再次提交， 那么这次产生的提交对象会包含一个指向上次提交对象（ 父对象） 的指针。  </p><img src="/2022/061325246/image-20201016152229190.png" class title="image-20201016152229190"><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>Git 的分支， 其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master 。 在多次提交<br>操作之后， 你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向<br>前移动。<br>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都<br>有 master 分支， 是因为 git init 命令默认创建它， 并且大多数人都懒得去改动它。  </p><img src="/2022/061325246/image-20201016152447869.png" class title="image-20201016152447869"><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><pre><code>git branch testing</code></pre><p>这会在当前所在的提交对象上创建一个指针。  </p><img src="/2022/061325246/image-20201016153329285.png" class title="image-20201016153329285"><h3 id="当前工作分支"><a href="#当前工作分支" class="headerlink" title="当前工作分支"></a>当前工作分支</h3><p>那么， Git 又是怎么知道当前在哪一个分支上呢？ 也很简单， 它有一个名为 HEAD 的特殊指针。 请注意<br>它和许多其它版本控制系统（ 如 Subversion 或 CVS） 里的 HEAD 概念完全不同。 在 Git 中， 它是一个<br>指针， 指向当前所在的本地分支（ 译注： 将 HEAD 想象为当前分支的别名） 。 在本例中， 你仍然在<br>master 分支上。 因为 git branch 命令仅仅 创建 一个新分支， 并不会自动切换到新分支中去。  </p><img src="/2022/061325246/image-20201016154219293.png" class title="image-20201016154219293"><p>你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是–decorate 。  </p><pre><code>$ git log --oneline --decoratef30ab (HEAD-&gt;master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project</code></pre><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支， 你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：  </p><pre><code>git checkout testing</code></pre><img src="/2022/061325246/image-20201016155045816.png" class title="image-20201016155045816"><blockquote><p>分支切换会改变你工作目录中的文件<br>在切换分支时， 一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支， 你的工作<br>目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务， 它将禁止切换<br>分支。  </p></blockquote><h3 id="切换分支后提交"><a href="#切换分支后提交" class="headerlink" title="切换分支后提交"></a>切换分支后提交</h3><img src="/2022/061325246/image-20201017133254590.png" class title="image-20201017133254590"><p>如图所示， 你的 testing 分支向前移动了， 但是 master 分支却没有， 它仍然指向运行 git checkout 时所指的对象。 这就有意思了， 现在我们切换回 master 分支看看：  </p><pre><code>git checkout master</code></pre><img src="/2022/061325246/image-20201017145248415.png" class title="image-20201017145248415"><p>这条命令做了两件事。 一是使 HEAD 指回 master 分支， 二是将工作目录恢复成 master 分支所指向<br>的快照内容。 也就是说， 你现在做修改的话， 项目将始于一个较旧的版本。 本质上来讲， 这就是忽略<br>testing 分支所做的修改， 以便于向另一个方向进行开发。  </p><p>我们不妨再稍微做些修改并提交：  </p><pre><code>$ vim test.rb$ git commit -a -m &#39;made other changes&#39;</code></pre><p>现在， 这个项目的提交历史已经产生了分叉（ 参见 Figure 3-9） 。 因为刚才你创建了一个新分支， 并切换<br>过去进行了一些工作， 随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分<br>支： 你可以在不同分支间不断地来回切换和工作， 并在时机成熟时将它们合并起来。 而所有这些工作， 你<br>需要的命令只有 branch 、 checkout 和 commit 。  </p><img src="/2022/061325246/image-20201017145544382.png" class title="image-20201017145544382"><p>你可以简单地使用 git log 命令查看分叉历史。 运行<br>git log –oneline –decorate –graph –all ， 它会输出你的提交历史、 各个分支的指向以<br>及项目的分支分叉情况。  </p><pre><code>$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project</code></pre><p><strong>创建分支实质上就是向一个文件中写入一个对象校验和</strong></p><p>由于 Git 的分支实质上仅是包含所指对象校验和（ 长度为 40 的 SHA-1 值字符串） 的文件， 所以它的创建<br>和销毁都异常高效。 创建一个新分支就像是往一个文件中写入 41 个字节（ 40 个字符和 1 个换行符） ， 如<br>此的简单能不快吗？  </p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><h4 id="快进"><a href="#快进" class="headerlink" title="快进"></a>快进</h4><p>在合并的时候， 你应该注意到了”快进（ fast-forward） “这个词。 由于当前 master 分支所指向的提交<br>是你当前提交（ 有关 hotfix 的提交） 的直接上游， 所以 Git 只是简单的将指针向前移动。 换句话说， 当你<br>试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支， 那么 Git 在合并两者的时候， 只会<br>简单的将指针向前推进（ 指针右移） ， 因为这种情况下的合并操作没有需要解决的分歧——这就叫做<br>“快进（ fast-forward） ” 。  </p><pre><code>git checkout mastergit merge hotfix</code></pre><img src="/2022/061325246/image-20210222071315943.png" class title="image-20210222071315943"><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><pre><code>git branch -d hotfix</code></pre><h4 id="合并提交"><a href="#合并提交" class="headerlink" title="合并提交"></a>合并提交</h4><p>这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下， 你的开发历史从一个更早的<br>地方开始分叉开来（ diverged） 。 因为， master 分支所在提交并不是 iss53 分支所在提交的直接祖<br>先， Git 不得不做一些额外的工作。 出现这种情况的时候， Git 会使用两个分支的末端所指的快照（ C4<br>和 C5 ） 以及这两个分支的工作祖先（ C2 ） ， 做一个简单的三方合并。  </p><img src="/2022/061325246/image-20210222071640080.png" class title="image-20210222071640080"><p>和之间将分支指针向前推进所不同的是， Git 将此次三方合并的结果做了一个新的快照并且自动创建一个<br>新的提交指向它。 这个被称作一次合并提交， 它的特别之处在于他有不止一个父提交。  </p><img src="/2022/061325246/image-20210222071723379.png" class title="image-20210222071723379"><h4 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h4><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中， 对同一个文件的同一个部分进行了不同的修<br>改， Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件<br>的同一处， 在合并它们的时候就会产生合并冲突：  </p><p>此时 Git 做了合并， 但是没有自动地创建一个新的合并提交。 Git 会暂停下来， 等待你去解决合并产生的<br>冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并<br>（ unmerged） 状态的文件：  </p><img src="/2022/061325246/image-20210222071918884.png" class title="image-20210222071918884"><p>任何因包含合并冲突而有待解决的文件， 都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准<br>的冲突解决标记， 这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特<br>殊区段， 看起来像下面这个样子：  </p><img src="/2022/061325246/image-20210222071957893.png" class title="image-20210222071957893"><pre><code>//解决冲突后，添加冲突文件到缓冲区中，标记冲突解决git add index.html//提交冲突文件到本地仓库git commit -m &#39;解决合并冲突&#39;</code></pre><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>Git 通过储存一个称为远程（remote）的连接来联系远方的朋友。本地仓库可以有零个、一个或多个远程连接。通常情况下， Git 仓库只有一个远程连接，即 origin（源）。你可能已经见过了这个术语。分配给远程仓库的这个别名，从中下载或克隆了你的本地副本。你可以使用任何你喜欢的名称来命名你的远程连接。在你第一次启动一个新项目时，可能还没有现成的代码，也可能有了一些代码。（这显而易见，不是么？）如果你还没有代码，那么可以遵循代码托管系统中的指示，将这个空项目克隆到你本地的开发环境中。然而，如果你在本地已经有了一些代码，那么将会想要上传你已有的代码。要想这么做，你需要建立一个从你的本地仓库到项目托管服务的新连接。在项目仓库的本地副本中，检查你是否已经设置好一个远程连接，如下所示。<br><code>$ git remote --verbose</code><br>如果你从本地启动项目，就不会看到任何远程连接，因此，如果现在什么都没有显示也没关系。如果你为这个仓库设置了一个远程连接，将会看到如下内容。</p><pre><code>origin https://github.com:emmajane/gitforteams.git (fetch)origin https://github.com:emmajane/gitforteams.git (push)</code></pre><p>每行都以远程连接（origin）的别名开头，后跟远程仓库的原地址。这些行总是会成对出现：每一对的第一行表明你将从哪里获取新的工作（fetch），而第二行表明你会将新的工作上传到哪里（push）</p><h3 id="添加一个远程仓库连接"><a href="#添加一个远程仓库连接" class="headerlink" title="添加一个远程仓库连接"></a>添加一个远程仓库连接</h3><p><code>git remote add nickname project-url  </code></p><h3 id="移除一个远程连接"><a href="#移除一个远程连接" class="headerlink" title="移除一个远程连接"></a>移除一个远程连接</h3><p><code>git remote remove nickname  </code></p><h3 id="将仓库的本地副本上传到远程服务器"><a href="#将仓库的本地副本上传到远程服务器" class="headerlink" title="将仓库的本地副本上传到远程服务器"></a>将仓库的本地副本上传到远程服务器</h3><p><code>git push nickname branch_name  </code></p><h3 id="如果你希望与别人共享所有的本地分支，可以修改这个命令，如下所示"><a href="#如果你希望与别人共享所有的本地分支，可以修改这个命令，如下所示" class="headerlink" title="如果你希望与别人共享所有的本地分支，可以修改这个命令，如下所示"></a>如果你希望与别人共享所有的本地分支，可以修改这个命令，如下所示</h3><p><code>git push --all nickname  </code></p><h3 id="fatal-refusing-to-merge-unrelated-histories"><a href="#fatal-refusing-to-merge-unrelated-histories" class="headerlink" title="fatal: refusing to merge unrelated histories"></a>fatal: refusing to merge unrelated histories</h3><p>允许不相关历史提，强制合并</p><pre><code>git pull origin master --allow-unrelated-histories</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts</title>
      <link href="/2022/061240101.html"/>
      <url>/2022/061240101.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue中使用Echarts"><a href="#Vue中使用Echarts" class="headerlink" title="Vue中使用Echarts"></a>Vue中使用Echarts</h1><p>Echarts官网：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a></p><p>ECharts: 一个基于 JavaScript 的开源可视化图表库。</p><h2 id="安装-echarts"><a href="#安装-echarts" class="headerlink" title="安装 echarts"></a>安装 echarts</h2><pre><code>npm install echarts --save</code></pre><h2 id="main-js-中引入"><a href="#main-js-中引入" class="headerlink" title="main.js 中引入"></a>main.js 中引入</h2><pre><code>// 部分代码展示import * as echarts from &#39;echarts&#39;  const app = createApp(App);// vue3 给原型上挂载属性app.config.globalProperties.$echarts = echarts;app.use(store).use(router).use(ElementPlus).mount(&#39;#app&#39;);</code></pre><h2 id="组件中使用"><a href="#组件中使用" class="headerlink" title="组件中使用"></a>组件中使用</h2><pre><code>&lt;template&gt;  &lt;div id=&quot;myChart&quot; :style=&quot;&#123;  width:&#39;600px&#39;, height: &#39;300px&#39; &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      option: &#123;&#125;,    &#125;;  &#125;,  mounted() &#123;    //this.$root =&gt; app    console.log(this.echarts)    let myChart = this.$echarts.init(document.getElementById(&quot;myChart&quot;));    // 绘制图表    myChart.setOption(&#123;      title: &#123; text: &quot;总用户量&quot; &#125;,      tooltip: &#123;&#125;,      xAxis: &#123;        data: [&quot;12-3&quot;, &quot;12-4&quot;, &quot;12-5&quot;, &quot;12-6&quot;, &quot;12-7&quot;, &quot;12-8&quot;],      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          name: &quot;用户量&quot;,          type: &quot;line&quot;,          data: [5, 20, 36, 10, 10, 20],        &#125;,      ],    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.chart &#123;  height: 400px;&#125;&lt;/style&gt;</code></pre><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><img src="/2022/061240101/image-20220613204122997.png" class title="image-20220613204122997"><pre><code>myChart.setOption(&#123;      xAxis: &#123;        data: [&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          type: &#39;bar&#39;,          data: [23, 24, 18, 25, 27, 28, 25]        &#125;      ]    &#125;);</code></pre><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><img src="/2022/061240101/image-20220613204346504.png" class title="image-20220613204346504"><pre><code>myChart.setOption(&#123;      series: [        &#123;          type: &#39;pie&#39;,          data: [            &#123;              value: 335,              name: &#39;直接访问&#39;            &#125;,            &#123;              value: 234,              name: &#39;联盟广告&#39;            &#125;,            &#123;              value: 1548,              name: &#39;搜索引擎&#39;            &#125;          ]        &#125;      ]    &#125;);</code></pre><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><img src="/2022/061240101/image-20220613204558053.png" class title="image-20220613204558053"><pre><code>myChart.setOption(&#123;      xAxis: &#123;        data: [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;]      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          type: &#39;scatter&#39;,          data: [220, 182, 191, 234, 290, 330, 310]        &#125;      ]    &#125;);</code></pre><h2 id="异步加载数据"><a href="#异步加载数据" class="headerlink" title="异步加载数据"></a>异步加载数据</h2><p>前端</p><pre><code>&lt;template&gt;  &lt;div :style=&quot;&#123;  width:&#39;600px&#39;, height: &#39;300px&#39; &#125;&quot; ref=&quot;chart&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      myChart:&#123;&#125;    &#125;;  &#125;,  mounted() &#123;    this.myChart = this.$echarts.init(this.$refs.chart);    // 绘制图表    this.myChart.setOption(&#123;      title: &#123;        text: &#39;异步数据加载示例&#39;      &#125;,      tooltip: &#123;&#125;,      legend: &#123;        data: [&#39;销量&#39;]      &#125;,      xAxis: &#123;        data: []      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          name: &#39;销量&#39;,          type: &#39;bar&#39;,          data: []        &#125;      ]    &#125;);    this.$http.get(&#39;echarts&#39;).then(resp=&gt;&#123;      this.myChart.setOption(&#123;        xAxis: &#123;          data: resp.data.categories        &#125;,        series: [          &#123;            // 根据名字对应到相应的系列            name: &#39;销量&#39;,            data: resp.data.data          &#125;        ]      &#125;);    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.chart &#123;  height: 400px;&#125;&lt;/style&gt;</code></pre><p>ECharts 中在更新数据的时候需要通过<code>name</code>属性对应到相应的系列，上面示例中如果<code>name</code>不存在也可以根据系列的顺序正常更新，但是更多时候推荐更新数据的时候加上系列的<code>name</code>数据。</p><p>后端</p><pre><code>@RestController@RequestMapping(&quot;echarts&quot;)public class EchartController &#123;    @GetMapping    public Map&lt;String,Object&gt; getData()&#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        String[] categories = new String[]&#123;&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;&#125;;        map.put(&quot;categories&quot;,categories);        int[] data = new int[]&#123;5, 20, 36, 10, 10, 20&#125;;        map.put(&quot;data&quot;,data);        return map;    &#125;&#125;</code></pre><h2 id="loading-动画"><a href="#loading-动画" class="headerlink" title="loading 动画"></a>loading 动画</h2><p>如果数据加载时间较长，一个空的坐标轴放在画布上也会让用户觉得是不是产生 bug 了，因此需要一个 loading 的动画来提示用户数据正在加载。</p><p>ECharts 默认有提供了一个简单的加载动画。只需要调用 <a href="https://echarts.apache.org//api.html#echartsInstance.showLoading">showLoading</a> 方法显示。数据加载完成后再调用 <a href="https://echarts.apache.org//api.html#echartsInstance.hideLoading">hideLoading</a> 方法隐藏加载动画。</p><pre><code>myChart.showLoading();$.get(&#39;data.json&#39;).done(function (data) &#123;    myChart.hideLoading();    myChart.setOption(...);&#125;);</code></pre><p>案例：</p><p>前端：</p><pre><code>&lt;template&gt;  &lt;div :style=&quot;&#123;  width:&#39;600px&#39;, height: &#39;300px&#39; &#125;&quot; ref=&quot;chart&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      myChart:&#123;&#125;    &#125;;  &#125;,  mounted() &#123;    // let myChart = this.$echarts.init(document.getElementById(&quot;myChart&quot;));    this.myChart = this.$echarts.init(this.$refs.chart);    // 绘制图表    this.myChart.setOption(&#123;      title: &#123;        text: &#39;异步数据加载示例&#39;      &#125;,      tooltip: &#123;&#125;,      legend: &#123;        data: [&#39;销量&#39;]      &#125;,      xAxis: &#123;        data: []      &#125;,      yAxis: &#123;&#125;,      series: [        &#123;          name: &#39;销量&#39;,          type: &#39;bar&#39;,          data: []        &#125;      ]    &#125;);    this.myChart.showLoading();    this.$http.get(&#39;echarts&#39;).then(resp=&gt;&#123;      this.myChart.hideLoading();      this.myChart.setOption(&#123;        xAxis: &#123;          data: resp.data.categories        &#125;,        series: [          &#123;            // 根据名字对应到相应的系列            name: &#39;销量&#39;,            data: resp.data.data          &#125;        ]      &#125;);    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.chart &#123;  height: 400px;&#125;&lt;/style&gt;</code></pre><p>后端</p><pre><code>@RestController@RequestMapping(&quot;echarts&quot;)public class EchartController &#123;    @GetMapping    public Map&lt;String,Object&gt; getData() throws InterruptedException &#123;        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();        String[] categories = new String[]&#123;&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;&#125;;        map.put(&quot;categories&quot;,categories);        int[] data = new int[]&#123;5, 20, 36, 10, 10, 20&#125;;        map.put(&quot;data&quot;,data);        Thread.sleep(3000);        return map;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Echarts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理输入输出系统</title>
      <link href="/2022/061152378.html"/>
      <url>/2022/061152378.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理输入输出系统"><a href="#计算机组成原理输入输出系统" class="headerlink" title="计算机组成原理输入输出系统"></a>计算机组成原理输入输出系统</h1><img src="/2022/061152378/IO%E7%B3%BB%E7%BB%9F.jpg" class>   <h2 id="IO系统基本概念"><a href="#IO系统基本概念" class="headerlink" title="IO系统基本概念"></a>IO系统基本概念</h2><ul><li>IO系统演变过程：  <img src="/2022/061152378/1.jpg" class>  </li><li>IO系统基本组成：  <img src="/2022/061152378/2.jpg" class>  </li><li>IO方式间接：  <img src="/2022/061152378/3.jpg" class>  <img src="/2022/061152378/4.jpg" class>  <h2 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h2></li><li>外部设备：  <img src="/2022/061152378/5.jpg" class>  ①输入设备：<br>鼠标，键盘。<br>②输出设备：<br>显示器：  <img src="/2022/061152378/6.jpg" class>  <img src="/2022/061152378/7.jpg" class>  其中CRT显示器根据显示内容不同又分为字符显示器，图形显示器，图像显示器。<br>打印机：  <img src="/2022/061152378/8.jpg" class>  <img src="/2022/061152378/9.jpg" class>  ③外存储器：  <img src="/2022/061152378/10.jpg" class>  磁盘存储器：  <img src="/2022/061152378/11.jpg" class>  <img src="/2022/061152378/12.jpg" class>  <img src="/2022/061152378/13.jpg" class>  磁盘阵列：  <img src="/2022/061152378/14.jpg" class>  光盘存储器：<img src="/2022/061152378/15.jpg" class>  固态硬盘：<img src="/2022/061152378/16.jpg" class>  <h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2></li><li>定义：  <img src="/2022/061152378/17.jpg" class>  </li><li>功能：  <img src="/2022/061152378/18.jpg" class>  </li><li>基本结构：  <img src="/2022/061152378/19.jpg" class>  <img src="/2022/061152378/20.jpg" class>   </li><li>接口和端口：  <img src="/2022/061152378/21.jpg" class>   IO端口和编址：  <img src="/2022/061152378/22.jpg" class>   </li><li>接口类型：  <img src="/2022/061152378/23.jpg" class>   <h2 id="IO方式"><a href="#IO方式" class="headerlink" title="IO方式"></a>IO方式</h2><img src="/2022/061152378/24.jpg" class>   </li><li>程序查询方式：<br>①流程：  <img src="/2022/061152378/25.jpg" class>   ②接口结构：  <img src="/2022/061152378/26.jpg" class>   </li><li>中断方式：<br>①中断系统：  <img src="/2022/061152378/27.jpg" class>   根据中断进行分类：   <img src="/2022/061152378/28.jpg" class>   也可以把内中断分为：  <img src="/2022/061152378/29.jpg" class>   为了分辨是哪个类型的中断，设置中断请求标记：  <img src="/2022/061152378/30.jpg" class>   中断判优：  <img src="/2022/061152378/31.jpg" class>   <img src="/2022/061152378/32.jpg" class>   ②中断处理过程：  <img src="/2022/061152378/33.jpg" class>   <img src="/2022/061152378/34.jpg" class>   <img src="/2022/061152378/36.jpg" class>   单重中断与多重中断：   <img src="/2022/061152378/35.jpg" class>   中断屏蔽技术：  <img src="/2022/061152378/37.jpg" class>   </li><li>DMA方式：  <img src="/2022/061152378/38.jpg" class>   DMA控制器：  <img src="/2022/061152378/39.jpg" class>   DMA传送过程：  <img src="/2022/061152378/43.jpg" class>   DMA传送方式：  <img src="/2022/061152378/40.jpg" class>   特点：  <img src="/2022/061152378/41.jpg" class>   <img src="/2022/061152378/42.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2022/061040991.html"/>
      <url>/2022/061040991.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的<a href="https://baike.baidu.com/item/%E9%95%9C%E5%83%8F/1574">镜像</a>中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>操作系统的机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318">沙箱</a>机制，相互之间不会有任何接口。</p><p><strong>Docker为什么出现？</strong></p><p>一款产品：开发-上线 两套环境，各不相同,维护麻烦！</p><p>开发–运维 开发在自己的电脑上运行良好，然后把项目打成jar包或是war包，丢给运维，运维需要配置各种环境，各种集群，压力超大，而且还很有可能失败！</p><p>版本更新，导致服务不可用！</p><p>Docker可以把项目和它所依赖的环境整合打包，非常方便！</p><p>Docker的思想就来自于集装箱，应用之间相互隔离，隔离的思想</p><p>Docker通过隔离机制，将服务器利用到极致</p><img src="/2022/061040991/960a304e251f95caa3e7fe4a6c703737660952a8.jpeg" class title="img"><p><strong>docker架构</strong></p><img src="/2022/061040991/a6efce1b9d16fdfa01ae7674e7f0855d96ee7bf6.png" class title="img"><img src="/2022/061040991/image-20210320160948248.png" class title="image-20210320160948248"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>安装docker引擎</p><ul><li><strong>CentOS中安装Docker 引擎</strong></li></ul><p>地址：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><ul><li>设置存储库</li></ul><p>安装<code>yum-utils</code>包（提供<code>yum-config-manager</code> 实用程序）并设置<strong>稳定</strong>存储库。</p><pre><code> sudo yum install -y yum-utils sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>Another app is currently holding the yum lock解决方法</p><pre><code>rm -f /var/run/yum.pid</code></pre><ul><li><strong>安装 Docker 引擎</strong></li></ul><ol><li><p>安装<em>最新版本</em>的 Docker Engine 和 containerd</p><pre><code>yum install docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>启动 Docker</p><pre><code>systemctl start docker</code></pre></li><li><p>通过运行<code>hello-world</code> 映像验证 Docker Engine 是否已正确安装。</p><pre><code>docker run hello-world</code></pre><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p></li></ol></li><li><p>启动docker服务</p><pre><code>systemctl start docker</code></pre></li><li><p>查找镜像</p><pre><code>docker search mysql</code></pre><p>docker search的输出是按评星数量排序的</p></li><li><p>下载镜像</p><p>一旦选择了一个镜像，就可以通过对其名称执行docker pull命令来下载它：</p><pre><code>docker pull mysql</code></pre></li><li><p>启动容器</p><p>接着，可以使用-t和-i标志以交互方式运行它。-t标志指明创建一个TTY设备（一个终端），而-i标志指明该Docker会话是交互式的：</p><pre><code>docker run -e MYSQL_ROOT_PASSWORD=root --name mysql -it -d -p 5001:3306  mysql:5.7-p 5001:3306  //宿主机使用5001端口，容器使用3306端口-d 守护进程，后台运行--name mysql：给容器命名为：mysql</code></pre></li><li><p>在启动的容器中执行命令</p><pre><code>docker exec  -it mysql /bin/bash</code></pre></li></ol><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>前言：</p><p> 在生产环境中使用Docker，往往需要对数据进行持久化，或者需要再多个容器之间进行数据共享，而这个必然涉及到容器的数据管理操作</p><p> 在容器中对数据进行管理的方式主要有两种：</p><p> <strong>数据卷</strong> Data Volume：容器内部的数据直接映射到本地主机环境中</p><p> <strong>数据卷容器</strong> Data Volume Container：指定一个容器进行管理管理维护数据卷</p><h3 id="什么是数据卷"><a href="#什么是数据卷" class="headerlink" title="什么是数据卷"></a>什么是数据卷</h3><p> <strong>数据卷 Data Volumes</strong></p><p> 简单来讲的话，数据卷就是在本地主机中可以在容器之间进行共享和重用的一些文件或者文件夹，通过docker run -v 的形式进行对数据卷挂载到对应的容器目录空间，进行文件读取</p><p> <strong>它可以提供有很多的有用的特性</strong>：</p><ol><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会即刻生效</li><li>对数据卷进行升级，不会影响到镜像</li><li>数据卷默认情况下会一直存在，即使是容器被删除</li></ol><p>数据卷的操作方式类似于linux中对目录或者文件进行mount的方式，将一个容器或者多个容器中的目录进行以挂载的形式挂载到宿主机</p><h3 id="为什么要使用数据卷"><a href="#为什么要使用数据卷" class="headerlink" title="为什么要使用数据卷"></a>为什么要使用数据卷</h3><p>在创建容器的时候不使用数据卷的时候一般会遇到一下几个问题：</p><ol><li>当创建一个容器的时候，容器在运行的时候，数据能不能持久化？</li><li>如果能持久化，数据存储在哪里？由于Docker是个例的，数据能否存储在容器外部？</li><li>如果部署很多的容器，每次都需要进入到容器中进行配置吗？能不能在外部进行部署？</li></ol><p>Docker数据卷在呈现给Docker容器的形式就是一个目录，而且，该目录支持多个容器间进行共享，修改数值并不会对镜像产生影响。上面也说了，使用Docker数据卷，类似于系统中使用mount进行挂载一个文件系统来修改差不多</p><p>Volume的作用恰巧就能尽量的解决这些问题：</p><p><strong>Volume的作用</strong></p><ol><li>通过数据卷可以在容器之间实现共享和重用</li><li>对数据卷的修改会直接生效，非常适合作为开发环境</li><li>数据卷在更新的时候，并不会去修改容器镜像中的数值</li><li>数据卷本身会一直存在，并不会因为某个连接的容器挂到或者删除而消失</li></ol><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><p>创建容器并且挂载到数据卷</p><pre><code>docker run -it -p 8808:80 --name nginx_1 -v /opt/test:/opt nginx:1.12 /bin/bash#创建一个nginx容器，映射端口是8808，名字为nginx_1，将容器中opt目录以挂载的形式到宿主机目录中的opt下的test目录</code></pre><p>挂载完成之后，进行测试</p><pre><code>容器    #先到容器中到达共享的目录中，上面我们测试的就是opt目录     cd /opt/     #到opt下先查看当前目录下有什么文件     ls     #当前还没有进行创建文件或者目录，所以是空的 宿主机    #到宿主机中，同样是到指定好的目录中     pwd     /opt/test    #到达之后先随便创建一个文件    touch 1.txt    #创建之后，再去容器中查看一下，就可以看到已经有了一个相同的文件    容器    ls    1.txt    #并且，在宿主机找那个对这个文件进行管理的话，会实时同步到容器中</code></pre><p>上面，将一个容器添加到数据卷中已经完成了，上面也说了，可以在一个数据卷中可以添加多个容器</p><pre><code>docker run -it -p 8809:80 --name nginx_2 -v /opt/test:/opt nginx:1.12 /bin/bash</code></pre><p>创建第二个容器之后，不用再进行在数据卷中常见新的文件，因为现在已经存在有文件。直接到容器中的共享目录中查看即可</p><pre><code>容器中    cd /opt/    ls    1.txt#就可以看到上面我们创建的文件</code></pre><p><strong>最后再试试，将两个容器都关闭之后，数据卷是否还存在</strong></p><pre><code>docker rm -f `docker ps -qa`#批量删除容器，因为我这就是测试使用的，所以只运行了更改创建的两个，可以直接无脑全清cd /opt/test/ &amp;&amp; ls1.txt#查看之后，刚刚创建的文件还是正常存在，当创建新的容器的时候，指定该目录，可以直接将其目录下文件给共享过去</code></pre><p><strong>注：容器在共享目录到主机中的时候，数据是双向的也就是，容器中创建文件的时候，主机中也会多一个文件，删除的时候，主机中也会少一个文件。</strong></p><p>如果只想要容器中拥有只读权限，可以在-v指定路径的最后，添加上:ro即可，例如：</p><pre><code>docker run -it --name nginx_1 -v /opt/test:/opt:ro nginx:1.12 /bin/bash#在容器中的目录后添加ro，设置为只读则不能对文件进行更改动作rm -f 1.txt#结果如下rm: cannot remove &#39;1.txt&#39;: Read-only file systemvi 1.txt#对内容进行修改之后保存的结果如下E45: &#39;readonly&#39; option is set (add ! to override)</code></pre><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol><li><p>运行mysql</p><pre><code>docker run \-p 5001:3306 \--name mysql \-v /docker/mysql/conf:/etc/mysql/conf.d \-v /docker/mysql/logs:/logs \-v /docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=root \-d mysql:5.7</code></pre></li><li><p>使用navicat连接mysql</p></li></ol><img src="/2022/061040991/image-20220611053744048.png" class title="image-20220611053744048"><ol start="2"><li><p>进入docker mysql</p><pre><code>docker exec -it mysql /bin/bash</code></pre></li><li><p>在mysql容器中执行命令</p><pre><code>mysql -uroot -proot</code></pre></li><li><p>对挂载数据卷解释</p><p>在宿主机上面简历挂在的数据卷，防止数据丢失</p><p>1.1创建本地数据库目录、配置文件以及日志目录（方便进行容器数据卷挂载）<br>注：因为mysql容器一旦销毁，数据库也就随之销毁，为了解决这个问题，docker官方提出了容器数据卷技术，就是在宿主机上新建一些目录与容器内的目录映射，当容器销毁时，宿主机上的目录文件不会消失，依然存在.<br>新建目录命令：</p><pre><code># 建立宿主机数据库目录mkdir /root/mysql/datadir# 建立宿主机数据库配置文件mkdir /root/mysql/conf# 建立宿主机数据库日志目录mkdir /root/mysql/log</code></pre><p>1.2启动容器并挂载数据卷</p><pre><code>docker run --name mysql -p 3306:3306 -v /root/mysql/datadir:/var/lib/mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre><p>对应的参数解释如下：</p><p>-p 3306:3306<br>端口映射，将宿主机3306端口与容器3306端口做映射，这样就可以通过宿主机IP+端口访问容器的3306端口了<br>格式：-p 宿主机端口:容器端口<br>–name mysql:<br>指定容器名字为mysql，也可以不指定，不指定会给容器默认制定一个名字</p><p>-v &#x2F;root&#x2F;mysql&#x2F;datadir:&#x2F;var&#x2F;lib&#x2F;mysql -v &#x2F;root&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;root&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql<br>数据容器卷挂载:<br>-v &#x2F;root&#x2F;mysql&#x2F;datadir:&#x2F;var&#x2F;lib&#x2F;mysql：对宿主机数据库目录与容器数据库目录进行映射挂载<br>-v &#x2F;root&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d：对宿主机数据库配置文件与容器数据库配置文件进行映射挂载<br>-v &#x2F;root&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql：对宿主机数据库日志与容器数据库日志进行映射挂载<br>-e MYSQL_ROOT_PASSWORD&#x3D;123456<br>配置mysql的root账号的密码为123456（可以根据需要自行修改密码）<br>-d:后台执行<br>mysql:5.7.32 ：镜像id，容器第一次启动要根据镜像来启动，所以镜像id必不可少。可以通过明林docker iamges查看镜像id</p><p>最后，使用Navicat连接mysql测试，测试成功！</p></li></ol><h2 id="Docker-安装-Nginx-容器"><a href="#Docker-安装-Nginx-容器" class="headerlink" title="Docker 安装 Nginx 容器"></a>Docker 安装 Nginx 容器</h2><p><a href="https://blog.csdn.net/BThinker/article/details/123507820">https://blog.csdn.net/BThinker/article/details/123507820</a></p><p>Docker 安装 (完整详细版)</p><p>Docker 日常命令大全(完整详细版)</p><p>说明：<br>Docker如果想安装软件 , 必须先到 Docker 镜像仓库下载镜像。</p><p>Docker官方镜像 </p><p>1、寻找Nginx镜像 </p><img src="/2022/061040991/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVG91Y2gm,size_20,color_FFFFFF,t_70,g_se,x_16.png" class title="img"><p> 2、下载Nginx镜像<br>命令描述</p><pre><code>docker pull nginx下载最新版Nginx镜像 (其实此命令就等同于 : docker pull nginx:latest )docker pull nginx:xxx下载指定版本的Nginx镜像 (xxx指具体版本号)</code></pre><img src="/2022/061040991/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVG91Y2gm,size_20,color_FFFFFF,t_70,g_se,x_16-16548994344123.png" class title="img"><p> 检查当前所有Docker下载的镜像</p><pre><code>docker images</code></pre><p> 3、创建Nginx配置文件<br>启动前需要先创建Nginx外部挂载的配置文件（ &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf）<br>之所以要先创建 , 是因为Nginx本身容器只存在&#x2F;etc&#x2F;nginx 目录 , 本身就不创建 nginx.conf 文件<br>当服务器和容器都不存在 nginx.conf 文件时, 执行启动命令的时候 docker会将nginx.conf 作为目录创建 , 这并不是我们想要的结果 。</p><p>首先启动一个Nginx容器</p><pre><code>docker run --name my-nginx -p 80:80 -d nginx</code></pre><p>测试：</p><pre><code>http://192.168.136.129</code></pre><img src="/2022/061040991/image-20220612053039896.png" class title="image-20220612053039896"><p>进入容器</p><pre><code>docker exec -it my-nginx bash</code></pre><pre><code>查看Nginx的html、配置和日志目录/etc/nginx：配置文件的目录/usr/share/nginx/html：html目录/var/log/nginx：日志目录root@33aab93c60f7:/# find / -name nginx/etc/default/nginx/etc/init.d/nginx/etc/logrotate.d/nginx/etc/nginxfind: &#39;/proc/1/map_files&#39;: Operation not permittedfind: &#39;/proc/31/map_files&#39;: Operation not permittedfind: &#39;/proc/32/map_files&#39;: Operation not permittedfind: &#39;/proc/38/map_files&#39;: Operation not permitted/usr/lib/nginx/usr/sbin/nginx/usr/share/doc/nginx/usr/share/nginx/var/cache/nginx/var/log/nginx</code></pre><p>exit退出容器，在&#x2F;opt下创建nginx目录用来存放html、配置和日志目录</p><pre><code>mkdir /opt/nginx</code></pre><p>拷贝容器中nginx的配置目录到&#x2F;opt&#x2F;nginx，并改名为conf</p><pre><code>docker cp my-nginx:/etc/nginx/conf.d /opt/nginx/conf.ddocker cp my-nginx:/usr/share/nginx/html /opt/nginxdocker cp my-nginx:/var/log/nginx /opt/nginx/log</code></pre><p>删除容器</p><pre><code>docker rm -f my-nginx</code></pre><p>启动nginx容器并挂载目录</p><pre><code>docker run -p 80:80 --name nginx \    -v /opt/nginx/conf.d:/etc/nginx.d \    -v /opt/nginx/html:/usr/share/nginx/html \    -v /opt/nginx/log:/var/log/nginx \    -d nginx</code></pre><hr><p> 5、结果检测</p><p> 6、修改内容进行展示</p><img src="/2022/061040991/image-20220612061210504.png" class title="image-20220612061210504"><p>6.删除容器，重新挂载，测试修改后的内容是否还在</p><pre><code>docker rm -f nginxdocker run -p 80:80 --name nginx \    -v /opt/nginx/conf.d:/etc/nginx.d \    -v /opt/nginx/html:/usr/share/nginx/html \    -v /opt/nginx/log:/var/log/nginx \    -d nginx</code></pre><img src="/2022/061040991/image-20220612061252131.png" class title="image-20220612061252131"><h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><p>一、Docker搜索redis镜像<br>命令：docker search &lt;镜像名称&gt;</p><pre><code>docker search redis</code></pre><p>可以看到有很多redis的镜像，此处因没有指定版本，所以下载的就是默认的最新版本 。redis latest.</p><p>二、Docker拉取镜像<br>命令：：docker pull &lt;镜像名称&gt;:&lt;版本号&gt;</p><pre><code>docker pull redis</code></pre><p>三、Docker挂载配置文件<br>接下来就是要将redis 的配置文件进行挂载，以配置文件方式启动redis 容器。（挂载：即将宿主的文件和容器内部目录相关联，相互绑定，在宿主机内修改文件的话也随之修改容器内部文件）</p><p>1）、挂载redis的配置文件</p><p>2）、挂载redis 的持久化文件（为了数据的持久化）。</p><p>本人的配置文件是放在</p><p>liunx 下redis.conf文件位置： &#x2F;home&#x2F;redis&#x2F;myredis&#x2F;redis.conf</p><p>liunx 下redis的data文件位置 ： &#x2F;home&#x2F;redis&#x2F;myredis&#x2F;data</p><p>位置可以自己随便选择哈</p><pre><code>mkdir -p /home/redis/myredis 命令 是不存在就直接创建/home/redis/myredis 文件夹</code></pre><p>myredis.conf 是我手动上传的。 （文件在文末，redis.conf的标准文件在redis官网也可以找到）</p><p>四、启动redis 容器</p><pre><code>docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name myredis -v /home/redis/myredis/myredis.conf:/etc/redis/redis.conf -v /home/redis/myredis/data:/data -d redis redis-server /etc/redis/redis.conf  --appendonly yes  --requirepass 000415</code></pre><p>–restart&#x3D;always 总是开机启动<br>–log是日志方面的<br>-p 6379:6379 将6379端口挂载出去<br>–name 给这个容器取一个名字<br>-v 数据卷挂载<br>&#x2F;home&#x2F;redis&#x2F;myredis&#x2F;myredis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf 这里是将 liunx 路径下的myredis.conf 和redis下的redis.conf 挂载在一起。<br>&#x2F;home&#x2F;redis&#x2F;myredis&#x2F;data:&#x2F;data 这个同上<br>-d redis 表示后台启动redis<br>redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf 以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录 &#x2F;etc&#x2F;redis&#x2F;redis.conf 也就是liunx下的&#x2F;home&#x2F;redis&#x2F;myredis&#x2F;myredis.conf<br>–appendonly yes 开启redis 持久化<br>–requirepass 000415 设置密码 （如果你是通过docker 容器内部连接的话，就随意，可设可不设。但是如果想向外开放的话，一定要设置，我被搞过，可以看这篇文章“阿里云服务器中毒‘Kirito666’经历”）<br>成功界面</p><p>五、测试<br>1、通过docker ps指令查看启动状态</p><pre><code>docker ps -a |grep myredis # 通过docker ps指令查看启动状态，是否成功.</code></pre><p>2、查看容器运行日志<br>命令：docker logs –since 30m &lt;容器名&gt;</p><p>此处 –since 30m 是查看此容器30分钟之内的日志情况。</p><pre><code>docker logs --since 30m myredis</code></pre><p>3、容器内部连接进行测试<br>进入容器</p><p>命令：docker exec -it &lt;容器名&gt; &#x2F;bin&#x2F;bash</p><p>此处跟着的redis-cli是直接将命令输在上面了。</p><pre><code>docker exec -it myredis redis-cli</code></pre><p>进入之后，我直接输入查看命令：</p><p>error是没有权限验证。（因为设置了密码的。）</p><p>验证密码：</p><pre><code>auth 密码</code></pre><img src="/2022/061040991/bb3eff84e9e54af1af36ac779dc429dc.png" class title="在这里插入图片描述"><p>查看当前redis有没有设置密码：（得验证通过了才能输入的）</p><pre><code>config get requirepass</code></pre><img src="/2022/061040991/d0eecb450247469383cb3b60105ba568.png" class title="在这里插入图片描述"><p>六、配置文件<br>myredis.conf</p><pre><code># bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1#bind 127.0.0.1protected-mode noport 6379tcp-backlog 511requirepass 000415timeout 0tcp-keepalive 300daemonize nosupervised nopidfile /var/run/redis_6379.pidloglevel noticelogfile &quot;&quot;databases 30always-show-logo yessave 900 1save 300 10save 60 10000stop-writes-on-bgsave-error yesrdbcompression yesrdbchecksum yesdbfilename dump.rdbdir ./replica-serve-stale-data yesreplica-read-only yesrepl-diskless-sync norepl-disable-tcp-nodelay noreplica-priority 100lazyfree-lazy-eviction nolazyfree-lazy-expire nolazyfree-lazy-server-del noreplica-lazy-flush noappendonly yesappendfilename &quot;appendonly.aof&quot;no-appendfsync-on-rewrite noauto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mbaof-load-truncated yesaof-use-rdb-preamble yeslua-time-limit 5000slowlog-max-len 128notify-keyspace-events &quot;&quot;hash-max-ziplist-entries 512hash-max-ziplist-value 64list-max-ziplist-size -2list-compress-depth 0set-max-intset-entries 512zset-max-ziplist-entries 128zset-max-ziplist-value 64hll-sparse-max-bytes 3000stream-node-max-bytes 4096stream-node-max-entries 100activerehashing yeshz 10dynamic-hz yesaof-rewrite-incremental-fsync yesrdb-save-incremental-fsync yes</code></pre><p>七、Docker删除Redis<br>教了大家怎么装，咱们也得学会怎么卸载哈，不然没法成为熟练工人（手动狗头）</p><p>6.1、删除Redis 容器<br>查看所有在运行的容器：<br>命令：</p><pre><code>docker ps -a</code></pre><p>停止运行的Redis</p><p>停止命令：docker stop &lt;容器名&gt;</p><pre><code>docker stop myredis # myredis 是我启动redis 命名的别</code></pre><p>删除redis 容器：</p><p>删除容器命令： docker rm &lt;容器名&gt;</p><pre><code>docker rm myredis</code></pre><p>6.2、删除Redis镜像<br>删除容器后，我们开始删除redis镜像。</p><p>查看全部镜像 命令：</p><pre><code>docker images</code></pre><p>删除镜像 命令 docker rmi &lt;容器 id&gt;</p><pre><code>docker rmi 739b59b96069 # 这是我镜像redis id</code></pre><p>可以看到Redis 的镜像已经被删除啦。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_45821811/article/details/116211724">https://blog.csdn.net/weixin_45821811/article/details/116211724</a></p><h2 id="docker安装tomcat"><a href="#docker安装tomcat" class="headerlink" title="docker安装tomcat"></a>docker安装tomcat</h2><p>1、安装tomcat镜像<br>访问docker hub仓库找出你想安装的版本：docker hub<br>网址：<a href="https://registry.hub.docker.com/">https://registry.hub.docker.com/</a></p><p>直接在搜索框里搜tomcat就可以，如果想把自己镜像放到上边就自己注册一个账号</p><p>选择tomcat</p><p>这里先看下啥镜像都没有，容器也没有。</p><pre><code>[root@wangazure ~]# docker images   #查看所有镜像REPOSITORY   TAG       IMAGE ID   CREATED   SIZE[root@wangazure ~]# docker ps #查看所有容器CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@wangazure ~]# </code></pre><p>把复制官网上的命令贴在这等着就好了</p><pre><code>docker pull tomcat:8.0 #拉取tomcat镜像</code></pre><p>再看一下docker里的镜像，这里就有了tomcat镜像</p><pre><code>[root@wangazure ~]# docker imagesREPOSITORY   TAG       IMAGE ID       CREATED       SIZEtomcat       8.0       ef6a7c98d192   3 years ago   356MB[root@wangazure ~]# </code></pre><p>2、运行tomcat镜像</p><pre><code> docker run -p 8080:8080 -d --name tomcat01 tomcat:8.0</code></pre><p><strong>注意：最新版tomcat10中，webapps目录中没有内容，需要从webapps.dist中拷贝所有内容到webapps中</strong></p><pre><code>docker exec -it tomcat bashroot@2779cb76c827:/usr/local/tomcat/webapps.dist# cp * ../webapps -r</code></pre><p>这里的 -p 8080:8080 的意思就是把容器的端口号8080映射到linux系统里的8080端口这里的两个端口8080前边的是linux里的端口号，后边的是运行的tomcat里的端口，外边也就是linux里的端口号可以随便换的，而容器里的是不能换的。<br>这里的 -d 的意思是后台运行<br>这里 –name 是给容器起一个别名</p><img src="/2022/061040991/image-20220612081134878.png" class title="image-20220612081134878"><p>再次查看docker里的容器</p><pre><code>docker ps</code></pre><p>这里去访问浏览器8080端口就可以看见tom猫了，版本也是8.0的（如果用的阿里云的服务器注意要开放8080端口再访问）</p><p>3、开多个端口给tomcat<br>这里我又开放了一个8082的作为tomcat，名字为tomcat02，注意：这里的名字（tomcat02）和Linux端口不能和上边的名字（tomcat01）一样！</p><pre><code>docker run -p 8082:8080 -d --name tomcat02 tomcat:8.0</code></pre><p>上浏览器访问8082，又见tomcat猫了</p><p>4、tomcat容器的操作<br>关闭容器</p><pre><code>docker stop 1adf1a9b21a1 </code></pre><p>再次查看容器，就只剩一个8080端口的了</p><p>启动关闭的容器</p><pre><code>docker start tomcat02</code></pre><p>暂停容器</p><pre><code>docker pause tomcat02</code></pre><p>暂停之后这里的STATUS会显示Up About a minute (Paused)表示已暂停，你访问8082也访问不到。</p><p>恢复容器</p><pre><code>docker unpause tomcat02</code></pre><p>恢复之后Up About a minute (Paused)就消失了，8082也能访问了。</p><p>杀死容器</p><pre><code> docker kill tomcat02</code></pre><p>删除容器</p><pre><code>docker rm tomcat02</code></pre><p>rm如果不行就加-f</p><p>删除所有的容器</p><pre><code>docker rm -f $(docker ps -aq)</code></pre><p>查看容器运行的日志</p><pre><code>docker logs tomcat02</code></pre><p>也可以用docker logs -f id&#x2F;name(容器的id或名字)，用这个命令之后就进去了，想出来就按CTRL+C</p><p>进入容器内部<br>之后就可以到容器里了，镜像是不能动的，容器是可以进去的</p><pre><code>docker exec -it tomcat01 bash #-it进入交互模式最后记得加bash</code></pre><p>退出容器</p><pre><code> exit</code></pre><p>容器与宿主机文件相互复制拷贝<br>用vi命令建一个test.html</p><pre><code>[root@wangazure ~]# vi test.html #建一个test.html[root@wangazure ~]# cat test.html #查看test.html&lt;html&gt;&lt;body&gt;hello,docker!!!&lt;/body&gt;&lt;/html&gt;[root@wangazure ~]# </code></pre><p>CP命令</p><pre><code>[root@wangazure ~]# docker cp test.html tomcat01:/usr/local/tomcat/webapps #复制到webapps里[root@wangazure ~]# docker exec -it tomcat01 bash #进入到容器里root@91ff3bca3aee:/usr/local/tomcat# lsLICENSE  NOTICE  RELEASE-NOTESRUNNING.txt  bin  confinclude  lib  logs  native-jni-lib  temp  webapps  workroot@91ff3bca3aee:/usr/local/tomcat# cd webapps/root@91ff3bca3aee:/usr/local/tomcat/webapps# lsROOT  docs  examples  host-manager  manager  test.htmlroot@91ff3bca3aee:/usr/local/tomcat/webapps# mkdir test #创建test文件root@91ff3bca3aee:/usr/local/tomcat/webapps# cp test.html test #把test.html复制到test文件夹里root@91ff3bca3aee:/usr/local/tomcat/webapps# cd testroot@91ff3bca3aee:/usr/local/tomcat/webapps/test# lstest.htmlroot@91ff3bca3aee:/usr/local/tomcat/webapps/test# </code></pre><p>如果想把容器里的东西复制出来，那就把两个地址一换就好了</p><pre><code>[root@wangazure ~]# lsinstall.sh[root@wangazure ~]# docker cp tomcat01:/usr/local/tomcat/webapps/examples /root[root@wangazure ~]# lsexamples  install.sh[root@wangazure ~]# cd examples/[root@wangazure examples]# lsindex.html  jsp  servlets  WEB-INF  websocket[root@wangazure examples]# </code></pre><p>5、查看所有容器</p><pre><code>[root@wangazure ~]# docker  psCONTAINER ID   IMAGE        COMMAND             CREATED          STATUS          PORTS                                       NAMES1adf1a9b21a1   tomcat:8.0   &quot;catalina.sh run&quot;   17 minutes ago   Up 5 minutes    0.0.0.0:8082-&gt;8080/tcp, :::8082-&gt;8080/tcp   tomcat02643b0adcfd17   tomcat:8.0   &quot;catalina.sh run&quot;   23 minutes ago   Up 23 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01[root@wangazure ~]# docker ps -aq1adf1a9b21a1643b0adcfd17[root@wangazure ~]# docker ps -qa1adf1a9b21a1643b0adcfd17[root@wangazure ~]# docker ps -aCONTAINER ID   IMAGE        COMMAND             CREATED          STATUS          PORTS                                       NAMES1adf1a9b21a1   tomcat:8.0   &quot;catalina.sh run&quot;   16 minutes ago   Up 4 minutes    0.0.0.0:8082-&gt;8080/tcp, :::8082-&gt;8080/tcp   tomcat02643b0adcfd17   tomcat:8.0   &quot;catalina.sh run&quot;   22 minutes ago   Up 22 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01[root@wangazure ~]# </code></pre><p>原文链接：<a href="https://blog.csdn.net/weixin_44953395/article/details/122639514">https://blog.csdn.net/weixin_44953395/article/details/122639514</a></p><h2 id="创建Docker镜像"><a href="#创建Docker镜像" class="headerlink" title="创建Docker镜像"></a>创建Docker镜像</h2><ol><li><p>创建文件：dockerfile</p><pre><code>FROM nodeLABEL maintainer pcbhyy@163.comRUN git clone -q https://gitee.com/null_476_2723/todo.gitWORKDIR todoRUN npm install &gt; /dev/nullEXPOSE 8000CMD [&quot;npm&quot;,&quot;start&quot;]</code></pre></li><li><p>构建镜像（在dockerfile文件所在目录下执行）</p><pre><code>docker build .</code></pre></li><li><p>查看镜像</p><pre><code>docker images</code></pre></li><li><p>打包镜像</p><pre><code>docker tag 2654988fe97b todoapp</code></pre></li><li><p>运行容器</p><pre><code>docker run -i -t -p 8000:8000 --name example1 todoapp//后台运行docker run -i -t -d -p 8000:8000 --name example1 todoapp</code></pre></li><li><p>测试</p><ul><li><p>开放端口：8000</p><pre><code>firewall-cmd --zone=public --add-port=5672/tcp --permanent  # 开放5672端口firewall-cmd --zone=public --remove-port=5672/tcp --permanent #关闭5672端口firewall-cmd --reload  # 配置立即生效//关闭防火墙systemctl stop firewalld.service</code></pre></li><li><p>测试</p><pre><code>http://192.168.136.129:8000</code></pre><img src="/2022/061040991/image-20220612065452739.png" class title="image-20220612065452739"></li></ul></li></ol><h2 id="在Docker-Hub上分享镜像"><a href="#在Docker-Hub上分享镜像" class="headerlink" title="在Docker Hub上分享镜像"></a>在Docker Hub上分享镜像</h2><ol><li><p>在 Docker Hub创建账号(如：pcbhyy)</p></li><li><p>在账号中创建仓库(如：mytest),一个仓库可以放置一个镜像的多个tag版本</p></li><li><p>在本地创建 镜像（可从远程拉取，tomcat:9.0）</p></li><li><p>给镜像打标签</p><pre><code>docker tag 仓库名:版本号 dockerhub用户名/仓库名：版本号如：docker tag tomcat:9.0 pcbhyy/mytest:9</code></pre></li><li><p>登录docker hub</p><pre><code>docker login--输入用户名和密码</code></pre></li><li><p>推送镜像到docker hub</p><pre><code>docker push dockerhub用户名/仓库名：版本号如：docker push pcbhyy/mytest:9</code></pre></li><li><p>拉取自己的镜像</p><pre><code>docker pull pcbhyy/mytest:9</code></pre><img src="/2022/061040991/image-20220612071430023.png" class title="image-20220612071430023"></li></ol><p>中文手册：<a href="http://www.dockerinfo.net/document">http://www.dockerinfo.net/document</a></p><img src="/2022/061040991/image-20210320061746159.png" class title="image-20210320061746159"><p>简而言之，容器运行着由镜像定义的系统。这些镜像由一个或多个层（或差异集）加上一些Docker的元数据组成。</p><p>Docker的中心功能是构建、分发及在任何具有Docker的地方运行软件。对终端用户而言，Docker是他们运行的一个命令行程序。就像Git（或任何源代码控制工具）一样，这个程序具有用于执行不同操作的子命令。表1-1中列出了将在宿主机上使用的主要的Docker子命令。</p><p><code>docker build</code> 构建一个Docker镜像</p><p><code>docker run</code> 以容器形式运行一个Docker镜像</p><p><code>docker commit</code> 将一个Docker容器作为一个镜像提交</p><p><code>docker tag</code> 给一个Docker镜像打标签</p><img src="/2022/061040991/image-20210320062815434.png" class title="image-20210320062815434"><p>看待镜像和容器的一种方式是将它们类比成程序与进程。一个进程可以视为一个“被执行的应用程序”，同样，一个Docker容器可以视为一个运行中的Docker镜像。</p><p>如果读者熟悉面向对象原理，看待镜像和容器的另一种方法是将镜像看作类而将容器看作对象。对象是类的具体实例，同样，容器是镜像的实例。用户可以从单个镜像创建多个容器，就像对象一样，它们之间全都是相互隔离的。不论用户在对象内修改了什么，都不会影响类的定义——它们从根本上就是不同的东西。</p><h2 id="创建Docker镜像的方式"><a href="#创建Docker镜像的方式" class="headerlink" title="创建Docker镜像的方式"></a>创建Docker镜像的方式</h2><table><thead><tr><th>方法</th><th>描述</th><th>技巧</th></tr></thead><tbody><tr><td>Docker命令&#x2F;“手工”</td><td>使用docker run 启动一个容器，并在命令行输入命令来创建镜像。使用docker commit来创建一个新镜像</td><td>详见技巧15</td></tr><tr><td>Dockerfile</td><td>从一个已知基础镜像开始构建，并指定一组有限的简单命令来构建</td><td>稍后讨论</td></tr><tr><td>Dockerfile及配置管理（configuration management，CM）工具</td><td>与Dockerfile相同，不过将构建的控制权交给了更为复杂的CM工具</td><td>详见技巧55</td></tr><tr><td>从头创建镜像并导入一组文件</td><td>从一个空白镜像开始，导入一个含有所需文件的TAR文件</td><td>详见技巧11</td></tr></tbody></table><h2 id="编写一个Dockerfile"><a href="#编写一个Dockerfile" class="headerlink" title="编写一个Dockerfile"></a>编写一个Dockerfile</h2><p>Dockerfile是一个包含一系列命令的文本文件。本示例中我们将使用的Dockerfile如代码清单1-1所示。创建一个新目录，移动到这个目录里，然后使用这些内容创建一个名为“Dockerfile”的文件。</p><p>代码清单1-1　todoapp Dockerfile</p><pre><code>FROM node　　⇽---　定义基础镜像LABEL maintainer ian.miell@gmail.com　　⇽---　声明维护人员RUN git clone -q https://gitee.com/null_476_2723/todo.git　　⇽---　克隆todoapp代码WORKDIR todo　　⇽---　移动到新的克隆目录RUN npm install &gt; /dev/null　　⇽---　执行node包管理器的安装命令（npm）EXPOSE 8000　　⇽---　指定从所构建的镜像启动的容器需要监听这个端口CMD [&quot;npm&quot;,&quot;start&quot;]　　⇽---　指定在启动时需要执行的命令</code></pre><pre><code>FROM nodeLABEL maintainer ian.miell@gmail.comRUN git clone -q https://gitee.com/null_476_2723/todo.gitWORKDIR todoRUN npm install &gt; /dev/nullEXPOSE 8000CMD [&quot;npm&quot;,&quot;start&quot;]</code></pre><p>Dockerfile的开始部分是使用FROM命令定义基础镜像。本示例使用了一个Node.js镜像以便访问Node.js程序。官方的Node.js镜像名为node。</p><p>接下来，使用LABEL命令声明维护人员。在这里，我们使用的是其中一个人的电子邮件地址，读者也可以替换成自己的，因为现在它是你的Dockerfile了。这一行不是创建可工作的Docker镜像所必需的，不过将其包含进来是一个很好的做法。到这个时候，构建已经继承了node容器的状态，读者可以在它上面做操作了。<br>接下来，使用RUN命令克隆todoapp代码。这里使用指定的命令获取应用程序的代码：在容器内运行git。在这个示例中，Git是安装在基础node镜像里的，不过读者不能对这类事情做假定。</p><p>现在使用WORKDIR命令移动到新克隆的目录中。这不仅会改变构建环境中的目录，最后一条WORKDIR命令还决定了从所构建镜像启动容器时用户所处的默认目录。<br>接下来，执行node包管理器的安装命令（npm）。这将为应用程序设置依赖。我们对输出的信息不感兴趣，所以将其重定向到&#x2F;dev&#x2F;null上。<br>由于应用程序使用了8000端口，使用EXPOSE命令告诉Docker从所构建镜像启动的容器应该监听这个端口。</p><p>最后，使用CMD命令告诉Docker在容器启动时将执行哪条命令。</p><p>这个简单的示例演示了Docker及Dockerfile的几个核心功能。Dockerfile是一组严格按顺序执行的有限的命令集的简单序列。它影响了最终镜像的文件和元数据。这里的RUN命令通过签出并安装应用程序影响了文件系统，而EXPOSE、CMD和WORKDIR命令影响了镜像的元数据。</p><img src="/2022/061040991/image-20210320065823742.png" class title="image-20210320065823742"><p>输出看起来和下面类似。</p><pre><code>Sending build context to Docker daemon 2.048kB　　⇽---　 Docker会上传docker build指定目录下的文件和目录Step 1/7 : FROM node　　⇽---　每个构建步骤从 1 开始按顺序编号，并与命令一起输出 ---&gt; 2ca756a6578b　　⇽---　每个命令会导致一个新镜像被创建，其镜像ID在此输出Step 2/7 : LABEL maintainer ian.miell@gmail.com ---&gt; Running in bf73f87c88d6 ---&gt; 5383857304fcRemoving intermediate container bf73f87c88d6　　⇽---　为节省空间，在继续前每个中间容器会被移除Step 3/7 : RUN git clone -q https://github.com/docker-in-practice/todo.git ---&gt; Running in 761baf524cc1 ---&gt; 4350cb1c977cRemoving intermediate container 761baf524cc1Step 4/7 : WORKDIR todo ---&gt; a1b24710f458Removing intermediate container 0f8cd22fbe83Step 5/7 : RUN npm install &gt; /dev/null ---&gt; Running in 92a8f9ba530anpm info it worked if it ends with ok　　⇽---　构建的调试信息在此输出（限于篇幅，本代码清单做了删减） [...] npm info ok ---&gt; 6ee4d7bba544Removing intermediate container 92a8f9ba530aStep 6/7 : EXPOSE 8000 ---&gt; Running in 8e33c1ded161 ---&gt; 3ea44544f13cRemoving intermediate container 8e33c1ded161Step 7/7 : CMD npm start ---&gt; Running in ccc076ee38fe ---&gt; 66c76cea05bbRemoving intermediate container ccc076ee38feSuccessfully built 66c76cea05bb　　⇽---　此次构建的最终镜像ID，可用于打标签</code></pre><p>现在，拥有了一个具有镜像ID（前面示例中的“66c76cea05bb”，不过读者的ID会不一样）的Docker镜像。总是引用这个ID会很麻烦，可以为其打标签以方便引用，如图1-8所示。</p><img src="/2022/061040991/image-20210320065947023.png" class title="image-20210320065947023"><p>输入图1-8所示的命令，将66c76cea05bb替换成读者生成的镜像ID。<br>现在就能从一个Dockerfile构建自己的Docker镜像副本，并重现别人定义的环境了！</p><h2 id="运行一个Docker容器"><a href="#运行一个Docker容器" class="headerlink" title="运行一个Docker容器"></a>运行一个Docker容器</h2><p>运行一个Docker容器</p><pre><code>$ docker run -i -t -p 8000:8000 --name example1 todoapp　　⇽---　 docker run子命令启动容器，-p将容器的 8000 端口映射到宿主机的8000端口上，--name给容器赋予一个唯一的名字，最后一个参数是镜像npm installnpm info it worked if it ends with oknpm info using npm@2.14.4npm info using node@v4.1.1npm info prestart todomvc-swarm@0.0.1&gt; todomvc-swarm@0.0.1 prestart /todo　　⇽---　容器的启动进程的输出被发送到终端中&gt; make allnpm installnpm info it worked if it ends with oknpm info using npm@2.14.4npm info using node@v4.1.1npm WARN package.json todomvc-swarm@0.0.1 No repository field.npm WARN package.json todomvc-swarm@0.0.1 license should be a valid SPDX➥ license expressionnpm info preinstall todomvc-swarm@0.0.1npm info package.json statics@0.1.0 license should be a valid SPDX license➥ expressionnpm info package.json react-tools@0.11.2 No license field.npm info package.json react@0.11.2 No license field.npm info package.json node-     jsx@0.11.0 license should be a valid SPDX license expressionnpm info package.json ws@0.4.32 No license field.npm info build /todonpm info linkStuff todomvc-swarm@0.0.1npm info install todomvc-swarm@0.0.1npm info postinstall todomvc-swarm@0.0.1npm info prepublish todomvc-swarm@0.0.1npm info okif [ ! -e dist/ ]; then mkdir dist; ficp node_modules/react/dist/react.min.js dist/react.min.jsLocalTodoApp.js:9:    // TODO: default english versionLocalTodoApp.js:84:            fwdList = this.host.get(&#39;/TodoList#&#39;+listId); // TODO fn+id sigTodoApp.js:117:        // TODO scroll into viewTodoApp.js:176:        if (i&gt;=list.length()) &#123; i=list.length()-1; &#125; // TODO➥ .lengthlocal.html:30:    &lt;!-- TODO 2-split, 3-split --&gt;model/TodoList.js:29:        // TODO one op - repeated spec? long spec?view/Footer.jsx:61:        // TODO: show the entry&#39;s metadataview/Footer.jsx:80:            todoList.addObject(new TodoItem()); // TODO➥ create defaultview/Header.jsx:25:        // TODO list some meaningful header (apart from the➥ id)npm info start todomvc-swarm@0.0.1&gt; todomvc-swarm@0.0.1 start /todo&gt; node TodoAppServer.jsSwarm server started port 8000^Cshutting down http-server... 　　⇽---　在此按组合键Ctrl+C终止进程和容器 closing swarm host...swarm host closednpm info lifecycle todomvc-swarm@0.0.1~poststart: todomvc-swarm@0.0.1npm info ok$ docker ps -a　　⇽---　执行这个命令查看已经启动和移除的容器，以及其ID和状态（就像进程一样） CONTAINER ID  IMAGE    COMMAND      CREATED        STATUS PORTS NAMESb9db5ada0461  todoapp  &quot;npm start&quot;  2 minutes ago  Exited (0) 2 minutes ago➥                example1$ docker start example1　　⇽---　重新启动容器，这次是在后台运行example1$ docker psCONTAINER ID  IMAGE    COMMAND      CREATED       STATUS➥ PORTS                    NAMESb9db5ada0461  todoapp  &quot;npm start&quot;  8 minutes ago  Up 10 seconds➥ 0.0.0.0:8000-&gt;8000/tcp example1　　⇽---　再次执行ps命令查看发生变化的状态$ docker diff example1　　⇽---　 docker diff子命令显示了自镜像被实例化成一个容器以来哪些文件受到了影响C /rootC /root/.npmC /root/.npm/_locksC /root/.npm/anonymous-cli-metrics.jsonC /todo　　⇽---　修改了/todo目录（C）A /todo/.swarm　　⇽---　增加了/todo/.swarm目录（A）A /todo/.swarm/_logA /todo/distA /todo/dist/LocalTodoApp.app.jsA /todo/dist/TodoApp.app.jsA /todo/dist/react.min.jsC /todo/node_modules</code></pre><p>docker run子命令启动容器。-p标志将容器的8000端口映射到宿主机的8000端口上，读者现在应该可以使用浏览器访问<a href="http://localhost:8000来查看这个应用程序了。--name标志赋予了容器一个唯一的名称，以便后面引用。最后的参数是镜像名称。">http://localhost:8000来查看这个应用程序了。--name标志赋予了容器一个唯一的名称，以便后面引用。最后的参数是镜像名称。</a></p><p>一旦容器启动，我们就可以按组合键Ctrl+C终止进程和容器。读者可以执行ps命令查看被启动且未被移除的容器。注意，每个容器都具有自己的容器 ID 和状态，与进程类似。它的状态是Exited（已退出），不过读者可以重新启动它。这么做之后，注意状态已经改变为Up（运行中），且容器到宿主机的端口映射现在也显示出来了。</p><p>docker diff子命令显示了自镜像被实例化成一个容器以来哪些文件受到了影响。在这个示例中，todo目录被修改了（C），而其他列出的文件是新增的（A）。没有文件被删除（D），这是另一种可能性。</p><h2 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h2><img src="/2022/061040991/image-20210320160948248.png" class title="image-20210320160948248"><h3 id="Docker守护进程"><a href="#Docker守护进程" class="headerlink" title="Docker守护进程"></a>Docker守护进程</h3><p>Docker守护进程（见图2-2）是用户与Docker交互的枢纽，因而它是理解所有相关部分的最佳切入点。它控制着用户机器上的Docker访问权限，管理着容器与镜像的状态，同时代理着与外界的交互。</p><p>守护进程是运行在后台的一个进程，不在用户的直接控制之下。服务器是负责接受客户端请求，并执行用于满足该请求所需的操作的一个进程。守护进程通常也是服务器，接收来自客户端的请求，为其执行操作。docker命令是一个客户端，而Docker守护进程则作为服务器对Docker容器和镜像进行操作。</p><h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>Docker客户端（见图2-4）是Docker架构中最简单的部件。在主机上输入docker run或docker pull这类命令时运行的便是它。它的任务是通过HTTP请求与Docker守护进程通信。</p><h2 id="CentOS中安装Docker-引擎"><a href="#CentOS中安装Docker-引擎" class="headerlink" title="CentOS中安装Docker 引擎"></a>CentOS中安装Docker 引擎</h2><p>地址：<a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p><h4 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h4><p>安装<code>yum-utils</code>包（提供<code>yum-config-manager</code> 实用程序）并设置<strong>稳定</strong>存储库。</p><pre><code> sudo yum install -y yum-utils sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>Another app is currently holding the yum lock解决方法</p><pre><code>rm -f /var/run/yum.pid</code></pre><h4 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h4><ol><li><p>安装<em>最新版本</em>的 Docker Engine 和 containerd</p><pre><code>yum install docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>启动 Docker</p><pre><code>systemctl start docker</code></pre></li><li><p>通过运行<code>hello-world</code> 映像验证 Docker Engine 是否已正确安装。</p><pre><code>docker run hello-world</code></pre><p>此命令下载测试映像并在容器中运行它。当容器运行时，它会打印一条消息并退出。</p></li></ol><h2 id="卸载-Docker-引擎"><a href="#卸载-Docker-引擎" class="headerlink" title="卸载 Docker 引擎"></a>卸载 Docker 引擎</h2><ol><li><p>卸载 Docker Engine、CLI 和 Containerd 包：</p><pre><code>$ sudo yum remove docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>主机上的映像、容器、卷或自定义配置文件不会自动删除。删除所有镜像、容器和卷：</p><pre><code>$ sudo rm -rf /var/lib/docker$ sudo rm -rf /var/lib/containerd</code></pre></li></ol><p>您必须手动删除任何已编辑的配置文件。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>docker images</th><th>查看所有镜像</th></tr></thead><tbody><tr><td>docker history 镜像ID</td><td>查看镜像历史</td></tr><tr><td>docker stats</td><td>查看状态</td></tr><tr><td>docker run centos &#x2F;bin&#x2F;bash</td><td>运行镜像</td></tr><tr><td>docker build .</td><td>使用 dockerfile 创建镜像</td></tr><tr><td>docker build <strong>–tag, -t:</strong> 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签</td><td></td></tr><tr><td>docker tag 镜像id 镜像标签名</td><td>给镜像加标签名</td></tr><tr><td>exit</td><td>退出centos容器</td></tr><tr><td>ctrl +p ，ctrl+q</td><td>不退出 容器，回到系统</td></tr><tr><td>docker ps -a</td><td>查看所有容器</td></tr><tr><td>docker stop 容器id</td><td>停止容器</td></tr><tr><td>docker attach &lt;容器ID或者容器名&gt;</td><td>进入已经启动的容器</td></tr><tr><td>docker exec  -it centos &#x2F;bin&#x2F;bash</td><td>在启动的容器中执行命令</td></tr><tr><td>docker rmi 仓库名:标签名</td><td>删除镜像的某个标签</td></tr><tr><td>docker rmi 镜像ID</td><td>删除镜像</td></tr><tr><td>docker rm -f &lt;容器ID或者容器名&gt; &lt;容器ID或者容器名&gt;</td><td>强制删除一个或多个容器</td></tr><tr><td>docker rm -f $(docker ps -a -q)</td><td>强制删除所有运行容器</td></tr><tr><td>docker volume prune -f</td><td>删除未被任何容器使用的本地卷</td></tr><tr><td>docker cp &#x2F;root&#x2F;my.cnf 16ff8a4cd5d9:&#x2F;etc&#x2F;mysql&#x2F;my.cnf</td><td>拷贝文件到容器中</td></tr><tr><td>docker logs nginx</td><td>查看容器日志</td></tr></tbody></table><h2 id="使用socat监控Docker-API流量"><a href="#使用socat监控Docker-API流量" class="headerlink" title="使用socat监控Docker API流量"></a>使用socat监控Docker API流量</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>yum install -y socat</p><h3 id="要创建这个代理，会用到socat"><a href="#要创建这个代理，会用到socat" class="headerlink" title="要创建这个代理，会用到socat"></a>要创建这个代理，会用到socat</h3><pre><code>$ socat -v UNIX-LISTEN:/tmp/dockerapi.sock,fork \　UNIX-CONNECT:/var/run/docker.sock &amp;</code></pre><p>socat是一个强大的命令，能让用户在两个几乎任意类型的数据通道之间中继数据。如果熟悉netcat，可以将其看作是加强版的netcat。你可使用系统的标准包管理器来安装它。</p><p>在这条命令中，-v用于提高输出的可读性，带有数据流的指示。UNIX-LISTEN部分是让socat在一个Unix套接字上进行监听，fork确保socat不会在首次请求后退出，而UNIX-CONNECT是让socat连接到Docker的Unix套接字。&amp;符号指定在后台执行该命令。如果你通常使用sudo来运行Docker客户端，这里也需要这么做。<br>发往守护进程的请求所经过的新路由如图2-6所示。所有双向流量都会被socat看到，并与Docker客户端所提供的任何输出一起记录到终端日志中。</p><img src="/2022/061040991/image-20210321141714179.png" class title="image-20210321141714179"><p>现在一个简单的docker命令的输出看起来将类似下面这样：</p><pre><code>docker -H unix:///tmp/dockerapi.sock ps -a　　⇽---　用于查看请求与响应所发送的命令</code></pre><p>使用socat不仅对Docker来说是一种强大的调试方式，对工作过程中可能碰到的任何其他网络服务也是如此。</p><ul><li>Socat就像一把瑞士军刀，可以处理很多不同的协议。上述示例演示的是在Unix套接字上进行监听，不过你也可以使用TCP-LISTEN:2375,fork取代UNIX-LISTEN:…参数，让它监听外部端口。这相当于技巧1的一个更简单的版本。使用这个方法无须重启Docker守护进程（这会杀掉所有运行中的容器），可根据需要启动或停止socat监听器。</li><li>由于前一条设置起来如此简单，并且是临时的，你可以将其与技巧47结合起来，以便远程加入同事的运行容器中，协助他们调试问题。你也可以使用很少用到的docker attach命令加入他们以docker run启动的同一个终端中，以便直接协作。</li><li>如果你有一台共享的Docker服务器（或许是使用技巧1设置的），你可以使用对外公开的功能将socat设置为外界与Docker套接字之间的代理，将其作为原始的审计日志，记录下所有请求来源及所进行的操作。</li></ul><h2 id="使用端口连接容器"><a href="#使用端口连接容器" class="headerlink" title="使用端口连接容器"></a>使用端口连接容器</h2><p>Docker容器从一开始就被设计用于运行服务。在大多数情况下，都是这样或那样的 HTTP服务。其中很大一部分是可以使用浏览器访问的Web服务。</p><p>这会造成一个问题。如果有多个Docker容器运行在其内部环境中的80端口上，它们将无法全部通过宿主机的80端口进行访问。本技巧将展示如何通过公开和映射容器的端口来管理这一常见场景。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>想要将多个运行在同一个端口的Docker容器服务公开到宿主机上。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用Docker的-p标志将容器的端口映射到宿主机上。</p><p>在这个示例中，我们将使用tutum-wordpress镜像。这里假定我们想在宿主机上运行两个实例来服务不同的博客。<br>由于此前有很多人想这么做，已经有人准备了任何人都可以获取并启动的镜像。要从外部地址获取镜像，可以使用docker pull命令。在默认情况下，镜像将从Docker Hub下载：</p><pre><code>docker pull tutum/wordpress</code></pre><p>如果镜像在你的机器上还不存在，当你试图运行它们时，也会自动获取。</p><p>要运行第一个博客，可使用如下命令：</p><pre><code>docker run -d -p 10001:80 --name blog1 tutum/wordpress</code></pre><p>这里的docker run命令以守护进程方式（-d）及发布标志（-p）运行容器。它指定将宿主机端口（10001）映射到容器端口（80）上，并赋予该容器一个名称用于识别它（–name blog1 tutum&#x2F;wordpress）。</p><p>可以对第二个博客做相同操作：</p><pre><code>docker run -d -p 10002:80 --name blog2 tutum/wordpress</code></pre><p>如果现在执行这个命令：</p><pre><code>docker ps | grep blog</code></pre><p>将看到列出的两个博客容器及其端口映射，看起来像下面这样：</p><pre><code>$ docker ps | grep blog9afb95ad3617　tutum/wordpress:latest &quot;/run.sh&quot; 9 seconds ago➥ Up 9 seconds　 3306/tcp, 0.0.0.0:10001-&gt;80/tcp blog131ddc8a7a2fd　tutum/wordpress:latest　&quot;/run.sh&quot; 17 seconds ago➥ Up 16 seconds　3306/tcp, 0.0.0.0:10002-&gt;80/tcp　blog2</code></pre><p>现在可以通过浏览<a href="http://localhost:10001和http://localhost:10002来访问自己的容器。">http://localhost:10001和http://localhost:10002来访问自己的容器。</a><br>要在完成后删除这些容器（假设不想保留它们——我们将在技巧7中利用它们），可执行下面这个命令：</p><pre><code>docker rm -f blog1 blog2</code></pre><p>如果需要，现在就可以通过管理端口分配在宿主机上运行多个相同的镜像和服务了</p><h2 id="Docker注册中心"><a href="#Docker注册中心" class="headerlink" title="Docker注册中心"></a>Docker注册中心</h2><p>Docker注册中心允许多个用户使用REST风格API将镜像推送到一个中央存储中，也可以从中拉取镜像。<br>与Docker自身一样，注册中心代码也是开源的。很多公司（如我们公司）建立了私有注册中心在内部存储和共享专有的镜像。这是在我们进一步说明Docker公司的注册中心之前，我们将要讨论的东西。</p><img src="/2022/061040991/image-20210322130851350.png" class title="image-20210322130851350"><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>想要一个在本地托管镜像的方法。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>在本地网络上建立一个注册中心服务器。<br>简单地在一台具有大量磁盘空间的机器上发起以下命令：</p><pre><code>docker run -d -p 5000:5000 -v $HOME/registry:/var/lib/registry registry:2</code></pre><p>这条命令让注册中心运行于Docker宿主机的5000端口上（-p 5000:5000）。使用-v标志，它可以使宿主机（&#x2F;var&#x2F;lib&#x2F;registry）上的registry在容器中用作$HOME&#x2F;registry。因此，该registry的文件将存储在&#x2F;var&#x2F;lib&#x2F;registry目录下。<br>在所有想访问这个注册中心的机器上，将下列内容添加到守护进程选项中（HOSTNAME是新的注册中心服务器的主机名或IP地址）：–insecure-registry HOSTNAME（有关如何执行此操作的详细信息，参见附录B）。现在可以发出docker push HOSTNAME:5000&#x2F;image:tag命令。</p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>Docker Hub（见图2-10）是由Docker公司维护的一个注册中心。它拥有成千上万个镜像可供下载和运行。任何Docker用户都可以在上面创建免费账号，并存储公共Docker镜像。除了用户提供的镜像，上面还维护着一些作为参考的官方镜像。</p><p>镜像受用户认证的保护，同时具有一个与GitHub类似的支持率打星系统。这些官方镜像的表现形式可能是Linux发行版（如Ubuntu或Cent OS）、预装软件包（如Node.js）或完整的软件栈（如WordPress）。</p><h2 id="查找并运行一个Docker镜像"><a href="#查找并运行一个Docker镜像" class="headerlink" title="查找并运行一个Docker镜像"></a>查找并运行一个Docker镜像</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>想要查找一个Docker镜像形式的应用程序或工具，并进行尝试。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用docker search命令来查找要拉取的镜像，然后运行它。</p><pre><code>docker search mysql</code></pre><p>docker search的输出是按评星数量排序的</p><p>一旦选择了一个镜像，就可以通过对其名称执行docker pull命令来下载它：</p><pre><code>docker pull mysql</code></pre><p>接着，可以使用-t和-i标志以交互方式运行它。-t标志指明创建一个TTY设备（一个终端），而-i标志指明该Docker会话是交互式的：</p><pre><code>docker run -e MYSQL_ROOT_PASSWORD=root --name mysql -it -d -p 5001:3306  mysql-p 5001:3306  //宿主机使用5001端口，容器使用3306端口-d 守护进程，后台运行--name mysql：给容器命名为：mysql</code></pre><h3 id="使用-tomcat-镜像"><a href="#使用-tomcat-镜像" class="headerlink" title="使用 tomcat 镜像"></a>使用 tomcat 镜像</h3><ol><li><p>拉取</p><pre><code>docker pull tomcat:9.0</code></pre></li><li><p>运行</p><pre><code>docker run -it -d -p 8889:8080 --name tomcat9 tomcat:9.0</code></pre></li><li><p>进入容器</p><pre><code>docker exec -it  tomcat9 bash </code></pre></li><li><p>拷贝文件</p><pre><code>cp webapps.dist/. webapps -r</code></pre></li><li><p>退出容器</p><pre><code>exit</code></pre></li><li><p>重启容器</p><pre><code>docker restart tomcat9</code></pre></li><li><p>测试</p><pre><code>http://ip:8889</code></pre></li></ol><h3 id="使用-redis-镜像"><a href="#使用-redis-镜像" class="headerlink" title="使用 redis 镜像"></a>使用 redis 镜像</h3><ol><li><p>拉取</p><pre><code>docker pull redis</code></pre></li><li><p>运行容器</p><pre><code>docker run -d --name redis -p 6379:6379 redis redis-server --appendonly yes --requirepass &quot;123456&quot;</code></pre><p>–appendonly yes ：使用 aof 模式持久化数据</p><p>requirepass “123456” ：服务器连接密码</p></li><li><p>在windows 中安装了 redis，使用 redis-cli 连接 docker reids</p><pre><code>redis-cli -h 111.229.80.53 -p 6379 -a 123456</code></pre><p>-a 123456：使用密码 123456 连接服务器</p></li><li><p>可以进入到docker容器中的redis测试</p><pre><code>进入容器：docker exec -it redis /bin/bash到redis-cli目录cd /usr/local/bin执行命令：./redis-cli -a 123456测试：set name tomget name</code></pre></li></ol><h2 id="将一个系统拆成微服务容器"><a href="#将一个系统拆成微服务容器" class="headerlink" title="将一个系统拆成微服务容器"></a>将一个系统拆成微服务容器</h2><p>在Docker的世界里，公认的最佳实践是尽可能多地把系统拆分开，直到在每个容器上都只运行一个“服务”，并且所有容器都通过网络互相连通。</p><p>使用一个容器一个服务的主要原因在于可以更容易通过单一职责原则（single responsibility principle）实现关注点分离（separation of concerns）。如果用户的容器执行的是单一任务，那么可以很方便地把该容器应用到从开发、测试到生产的整个软件开发生命周期里，而无须太担心它与其他组件的交互问题。这就使软件项目可以更敏捷地交付并且具备更好的扩展性。但是，它的确带来了一些管理上的负担，因此，最好思量一下在自己的用例场景下这样做是否真的值得。<br>暂且不论哪种方案更适合，最佳实践方法至少拥有一个明显的优势——正如所见，在使用Dockerfile时实验和重新构建都比前一套方案快上不少。</p><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>想要将应用程序拆分为各个单独的且更易于管理的服务。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>为每个单独的服务进程对应创建一个容器。</p><h2 id="在Docker-Hub上分享镜像-1"><a href="#在Docker-Hub上分享镜像-1" class="headerlink" title="在Docker Hub上分享镜像"></a>在Docker Hub上分享镜像</h2><ol><li><p>在 Docker Hub创建账号(如：pcbhyy)</p></li><li><p>在账号中创建仓库(如：mytest),一个仓库可以放置一个镜像的多个tag版本</p></li><li><p>在本地创建 镜像（可从远程拉取，tomcat:9.0）</p></li><li><p>给镜像打标签</p><pre><code>docker tag 仓库名:版本号 dockerhub用户名/仓库名：版本号如：docker tag tomcat:9.0 pcbhyy/mytest:9</code></pre></li><li><p>登录docker hub</p><pre><code>docker login--输入用户名和密码</code></pre></li><li><p>推送镜像到docker hub</p><pre><code>docker push dockerhub用户名/仓库名：版本号如：docker push pcbhyy/mytest:9</code></pre></li></ol><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="使用ADD指令将文件注入镜像里"><a href="#使用ADD指令将文件注入镜像里" class="headerlink" title="使用ADD指令将文件注入镜像里"></a>使用ADD指令将文件注入镜像里</h3><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><p>想要以一种简洁的方式下载并解压一个压缩包到镜像里。</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><p>打包并压缩目标文件，然后在Dockerfile里使用ADD指令。<br>通过mkdir add_example &amp;&amp; cd add_example来为这次Docker构建创造一个全新的环境。随后检索一个压缩包，并给它指定一个名字作为后续引用的标识</p><ol><li><p>下载一个TAR文件</p><pre><code>$ curl \https://www.flamingspork.com/projects/libeatmydata/➥ libeatmydata-105.tar.gz &gt; my.tar.g</code></pre></li><li><p>添加一个TAR文件到镜像里</p><pre><code>FROM debianRUN mkdir -p /opt/libeatmydataADD my.tar.gz /opt/libeatmydata/RUN ls -lRt /opt/libeatmydata</code></pre><p>通过docker build –no-cache .来构建这个Dockerfile</p></li><li><p>带有TAR文件的镜像构建</p><pre><code>$ docker build --no-cache .</code></pre><p>从输出中可以看到，压缩包被Docker守护进程解压到了目标目录（所有文件的扩展输出已被省略）。Docker支持解压绝大多数标准类型的压缩文件（.gz、.bz2、.xz、.tar）。</p><p>值得留意的是，尽管用户可以从指定的URL下载压缩包，但是只有当它们被存储在本地文件系统时才会被自动解压。这一点可能会导致混淆。</p><p>文件名里带有空格如果指定的文件名里带有空格，用户将需要在ADD（或COPY）时带上引号的形式</p><pre><code>ADD &quot;space file.txt&quot; &quot;/tmp/space file.txt&quot;</code></pre><p>人们常问的一个问题是如何添加一个压缩文件，但不对其进行解压。为此，用户应该使用的是COPY命令，该命令看上去和ADD命令完全相同，但是它不会解压任何文件，也不支持通过互联网下载文件。docker –</p></li></ol><h2 id="privileged-x3D-true-参数作用"><a href="#privileged-x3D-true-参数作用" class="headerlink" title="privileged&#x3D;true 参数作用"></a>privileged&#x3D;true 参数作用</h2><p>大约在0.6版，privileged被引入docker。<br>使用该参数，container内的root拥有真正的root权限。<br>否则，container内的root只是外部的一个普通用户权限。<br>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。<br>甚至允许你在docker容器中启动docker容器</p><h2 id="IPv4-forwarding-is-disabled"><a href="#IPv4-forwarding-is-disabled" class="headerlink" title="IPv4 forwarding is disabled"></a>IPv4 forwarding is disabled</h2><p>装完了Docker，然后启动镜像，发现没有网络，而且不能ifconfig，因网桥配置完后，需要开启转发，不然容器启动后，就会没有网络，配置&#x2F;etc&#x2F;sysctl.conf,添加net.ipv4.ip_forward&#x3D;1即可，操作如下：</p><pre><code>配置转发vim /etc/sysctl.conf#配置转发net.ipv4.ip_forward=1#重启服务，让配置生效systemctl restart network#查看是否成功,如果返回为“net.ipv4.ip_forward = 1”则表示成功sysctl net.ipv4.ip_forwardvim /etc/sysctl.conf#配置转发net.ipv4.ip_forward=1#重启服务，让配置生效systemctl restart network#查看是否成功,如果返回为“net.ipv4.ip_forward = 1”则表示成功sysctl net.ipv4.ip_forward检查容器是否正常访问网络#重启docker服务service docker restart #查看运行过的容器docker ps -a#启动gitlab 容器docker start gitblab2 #进入gitlab容器docker attach gitlab2#试试获取百度信息看是否成功curl baidu.com#重启docker服务service docker restart #查看运行过的容器docker ps -a#启动gitlab 容器docker start gitblab2 #进入gitlab容器docker attach gitlab2#获取百度信息curl baidu.com完美 </code></pre><h2 id="Shell教程"><a href="#Shell教程" class="headerlink" title="Shell教程"></a>Shell教程</h2><h3 id="为什么学Shell"><a href="#为什么学Shell" class="headerlink" title="为什么学Shell"></a>为什么学Shell</h3><p>链接：<a href="https://www.zhihu.com/question/309875771/answer/579235911">https://www.zhihu.com/question/309875771/answer/579235911</a></p><p>你看，每一种语言，它都封装了一些东西——除了汇编。</p><p>这些封装，使得它的使用者可以更简洁的完成日常功能的同时，也不可避免的要付出一些底层控制能力&#x2F;灵活性方面的代价——毕竟你只能通过它提供的、“封装”的代理，才能完成任务。</p><p>其中，汇编可以控制一切；但用它时，就连if你都得自己拆开，用cmp&#x2F;jnz&#x2F;jz等指令的组合实现类if控制结构——在程序流程控制可以无限精确、无限复杂的同时……你不觉得每次都得根据实际情况，把if这俩字母拆成三五条甚至十几条语句，太过繁琐了吗？</p><p>而C&#x2F;C++呢，你近似可以控制一切，汇编能做到的，你99.99%都能做到。这就大大提高了开发效率。</p><p>等到了java，你失去了对内存的大部分控制权；但当你要写一个商业&#x2F;工业程序时，却前所未有的简单。</p><p>脚本语言，如python、php等，也都类似——它们比java更简单，但也更慢。</p><p>再往上，就是<a href="https://www.zhihu.com/search?q=shell%E8%84%9A%E6%9C%AC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:579235911%7D">shell脚本</a>了。</p><p>shell脚本是一种比python更“糙”、因此性能等方面更为受限的语言；但它有个极大的优点，那就是可以把其他人写的程序本身，像其他语言的库函数那样使用。</p><p>为了做到这个，它要求每个程序都把命令行参数当作“函数输入”、向stdout&#x2F;stderr的输出当作函数输出，同时以<a href="https://www.zhihu.com/search?q=%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:579235911%7D">程序返回值</a>说明执行成功与否。</p><p>这个约定是强制性的，在操作系统设计时就确定了的——这也是C语言的main函数需要返回一个int的原因。</p><p>但是，这个“<a href="https://www.zhihu.com/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:579235911%7D">命令行参数</a>”的约定也束缚了shell，使得它比起其他语言更在乎空格&#x2F;回车等符号——因为它的每一行，都必须是“命令 参数1 参数2”的格式。</p><p>这个约定就使得它语法怪异，也很难像其他编程语言那样，支持<a href="https://www.zhihu.com/search?q=%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:579235911%7D">语法结构</a>的任意嵌套——不管有多像，它毕竟是“用命令行模拟出来的语法结构”。</p><p>那么，这就是shell脚本的定位：它是一种只能支持较为简单逻辑的、可以直接把任意现有程序当作函数无缝集成的“超高级语言”；但因为“命令行模拟”这个本质，它的语法较为笨拙，很难像正规的脚本语言那样得到很多很多的语法糖或者其它便利。</p><p>但，同样的，其它<a href="https://www.zhihu.com/search?q=%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:579235911%7D">脚本语言</a>语法结构是灵活了；但它们也就不可能很方便的和系统安装的现有程序交互了——注意是不方便，不是不能。你完全可以通过popen&#x2F;shellexec等方法调用外部程序。</p><p>程序员都是一群特别特别“懒”的人。他们会根据目标的不同，选择能够最轻易达到目标的方法——这种选择同样包括编程语言。这反过来也导致了诸多不同定位的语言的出现。</p><h3 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h3 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。</p><h3 id="shell中文乱码"><a href="#shell中文乱码" class="headerlink" title="shell中文乱码"></a>shell中文乱码</h3><p>修改文件类型为：utf-8</p><img src="/2022/061040991/image-20211224103305667.png" class title="image-20211224103305667"><img src="/2022/061040991/image-20211224103350347.png" class title="image-20211224103350347"><h3 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h3><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li>Bourne Again Shell（&#x2F;bin&#x2F;bash）</li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li><li>……</li></ul><p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!&#x2F;bin&#x2F;sh</strong>，它同样也可以改为 <strong>#!&#x2F;bin&#x2F;bash</strong>。</p><p><strong>#!</strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h3 id="第一个shell脚本"><a href="#第一个shell脚本" class="headerlink" title="第一个shell脚本"></a>第一个shell脚本</h3><p>打开文本编辑器(可以使用 vi&#x2F;vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p><p>输入一些代码，第一行一般是这样：</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code>#!/bin/bashecho &quot;Hello World !&quot;</code></pre><p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>echo 命令用于向窗口输出文本。</p><p>注意：#！和 &#x2F;bin&#x2F;bash中间不能有空格</p><h3 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a>运行 Shell 脚本有两种方法：</h3><p><strong>1、作为可执行程序</strong></p><p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p><pre><code>chmod +x ./test.sh  #使脚本具有执行权限./test.sh  #执行脚本</code></pre><p>注意，一定要写成 <strong>.&#x2F;test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 .&#x2F;test.sh 告诉系统说，就在当前目录找。</p><p><strong>2、作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><pre><code>/bin/sh test.sh/bin/php test.php</code></pre><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h3 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h3><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p><pre><code>your_name=&quot;runoob.com&quot;</code></pre><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>有效的 Shell 变量名示例如下：</p><pre><code>RUNOOBLD_LIBRARY_PATH_varvar2</code></pre><p>无效的变量命名：</p><pre><code>?var=123user*name=runoob</code></pre><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><pre><code>for file in `ls /etc`或for file in $(ls /etc)</code></pre><p>以上语句将 &#x2F;etc 下目录的文件名循环出来。</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><pre><code>your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125;</code></pre><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><pre><code>for skill in Ada Coffe Action Java; do    echo &quot;I am good at $&#123;skill&#125;Script&quot;done</code></pre><p>如果不给skill变量加花括号，写成echo “I am good at $skillScript”，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p>推荐给所有变量加上花括号，这是个好的编程习惯。</p><p>已定义的变量，可以被重新定义，如：</p><pre><code>your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name</code></pre><p>这样写是合法的，但注意，第二次赋值的时候不能写$your_name&#x3D;”alibaba”，使用变量的时候才加美元符（$）。</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><pre><code>#!/bin/bashmyUrl=&quot;https://www.google.com&quot;readonly myUrlmyUrl=&quot;https://www.runoob.com&quot;</code></pre><p>运行脚本，结果如下：</p><pre><code>/bin/sh: NAME: This variable is read only.</code></pre><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。语法：</p><pre><code>unset variable_name</code></pre><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><p><strong>实例</strong></p><pre><code>#!/bin/shmyUrl=&quot;https://www.runoob.com&quot;unset myUrlecho $myUrl</code></pre><p>以上实例执行将没有任何输出。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h3 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a>Shell 字符串</h3><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。</p><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><pre><code>str=&#39;this is a string&#39;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><pre><code>your_name=&#39;runoob&#39;str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;echo -e $str</code></pre><p>输出结果为：</p><pre><code>Hello, I know you are &quot;runoob&quot;! </code></pre><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><pre><code>your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting  $greeting_1# 使用单引号拼接greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;greeting_3=&#39;hello, $&#123;your_name&#125; !&#39;echo $greeting_2  $greeting_3</code></pre><p>输出结果为：</p><pre><code>hello, runoob ! hello, runoob !hello, runoob ! hello, $&#123;your_name&#125; !</code></pre><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><pre><code>string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4```#### 提取子字符串以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：```string="runoob is a great site"echo $&#123;string:1:4&#125; # 输出 unoo```**注意**：第一个字符的索引值为 **0**。#### 查找子字符串查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：```string="runoob is a great site"echo `expr index "$string" io`  # 输出 4```**注意：** 以上脚本中 **`** 是反引号，而不是单引号 **'**，不要看错了哦。没有找到返回：0### Shell 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。#### 定义数组在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：```数组名=(值1 值2 ... 值n)```例如：```array_name=(value0 value1 value2 value3)```或者```array_name=(value0value1value2value3)```还可以单独定义数组的各个分量：```array_name[0]=value0array_name[1]=value1array_name[n]=valuen```可以不使用连续的下标，而且下标的范围没有限制。#### 读取数组读取数组元素值的一般格式是：```$&#123;数组名[下标]&#125;```例如：```valuen=$&#123;array_name[n]&#125;```使用 **@** 符号可以获取数组中的所有元素，例如：```echo $&#123;array_name[@]&#125;```#### 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如：```# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125;```### Shell 注释以 **#** 开头的行就是注释，会被解释器忽略。通过每一行加一个 **#** 号设置多行注释，像这样：```#--------------------------------------------# 这是一个注释# author：菜鸟教程# site：www.runoob.com# slogan：学的不仅是技术，更是梦想！#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息# ###### 用户配置区 结束  #####```如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。#### 多行注释多行注释还可以使用以下格式：```:<<EOF 0 1 2 3 4 30 200 注释内容... eof ``` 也可以使用其他符号: :<<' ' :<<! ! ### shell 传递参数 我们可以在执行 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… #### 实例 以下实例我们向脚本传递三个参数，并分别输出，其中 **$0** 为执行的文件名（包含文件路径）： #! bin bash # author:菜鸟教程 url:www.runoob.com echo "shell 传递参数实例！"; "执行的文件名：$0"; "第一个参数为：$1"; "第二个参数为：$2"; "第三个参数为：$3"; 为脚本设置可执行权限，并执行脚本，输出结果如下所示： $ chmod +x test.sh . 传递参数实例！ 执行的文件名：. 第一个参数为：1 第二个参数为：2 第三个参数为：3 另外，还有几个特殊字符用来处理参数： | 参数处理 说明 :------- :----------------------------------------------------------- $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。 如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 $$ 脚本运行的当前进程id号 $! 后台运行的最后一个进程的id号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" "$n" 的形式输出所有参数。 $- 显示shell使用的当前选项，与[set命令](https: www.runoob.com linux linux-comm-set.html)功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 "参数个数为：$#"; "传递的参数作为一个字符串显示：$*"; 执行脚本，输出结果如下所示： 参数个数为：3 传递的参数作为一个字符串显示：1 与 区别： - 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * 等价于 "1 3"（传递了一个参数），而 "@" "1" "2" "3"（传递了三个参数）。 "-- \$* 演示 ---" for i in "$*"; do $i done \$@ "$@"; -- --- 基本运算符 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(**注意使用的是反引号 \**`\** 而不是单引号 \**'\****)： *#! bash* val="`expr" + 2` **echo** "两数之和为 : $val" [运行实例 »](https: try runcode.php?filename="add2data&type=bash)" 两数之和为 两点注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 反引号 包含，注意这个字符不是常用的单引号，在 esc 键下边。 ------ 算术运算符 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 20： 运算符 举例 :----- :-------------------------------------------- :---------------------------- 加法 `expr $a $b` 结果为 30。 减法 -10。 乘法 \* 200。 除法 $b $a` 2。 % 取余 0。 赋值 将把变量 的值赋给 a。 相等。用于比较两个数字，相同则返回 true。 [ ] 返回 false。 不相等。用于比较两个数字，不相同则返回 **注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a="=$b]**" 是错误的，必须写成 **[ ]**。 算术运算符实例如下： *# author:菜鸟教程* url:www.runoob.com* $b**`** "a \***** ** $a**`** "b **%** **if** **[** **]** **then** 等于 b" **fi** **!**="$b" 不等于 -10> **注意：**>> - 乘号(*)前边必须加反斜杠(\)才能实现乘法运算；> - if...then...fi 是条件语句，后续将会讲解。> - 在 MAC 中 shell 的 expr 语法是：**$((表达式))**，此处表达式中的 "*" 不需要转义符号 "\" 。------#### 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：| 运算符 | 说明                                                  | 举例                       || :----- | :---------------------------------------------------- | :------------------------- || -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 || -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  || -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 || -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  || -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 || -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |#### 实例关系运算符实例如下：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com*a=10b=20**if** **[** $a -eq $b **]****then**  **echo** "$a -eq $b : a 等于 b"**else**  **echo** "$a -eq $b: a 不等于 b"**fi****if** **[** $a -ne $b **]****then**  **echo** "$a -ne $b: a 不等于 b"**else**  **echo** "$a -ne $b : a 等于 b"**fi****if** **[** $a -gt $b **]****then**  **echo** "$a -gt $b: a 大于 b"**else**  **echo** "$a -gt $b: a 不大于 b"**fi****if** **[** $a -lt $b **]****then**  **echo** "$a -lt $b: a 小于 b"**else**  **echo** "$a -lt $b: a 不小于 b"**fi****if** **[** $a -ge $b **]****then**  **echo** "$a -ge $b: a 大于或等于 b"**else**  **echo** "$a -ge $b: a 小于 b"**fi****if** **[** $a -le $b **]****then**  **echo** "$a -le $b: a 小于或等于 b"**else**  **echo** "$a -le $b: a 大于 b"**fi**执行脚本，输出结果如下所示：```10 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b```------#### 布尔运算符下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：| 运算符 | 说明                                                | 举例                                     || :----- | :-------------------------------------------------- | :--------------------------------------- || !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  || -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  || -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |#### 实例布尔运算符实例如下：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com*a=10b=20**if** **[** $a **!**= $b **]****then**  **echo** "$a != $b : a 不等于 b"**else**  **echo** "$a == $b: a 等于 b"**fi****if** **[** $a -lt 100 -a $b -gt 15 **]****then**  **echo** "$a 小于 100 且 $b 大于 15 : 返回 true"**else**  **echo** "$a 小于 100 且 $b 大于 15 : 返回 false"**fi****if** **[** $a -lt 100 -o $b -gt 100 **]****then**  **echo** "$a 小于 100 或 $b 大于 100 : 返回 true"**else**  **echo** "$a 小于 100 或 $b 大于 100 : 返回 false"**fi****if** **[** $a -lt 5 -o $b -gt 100 **]****then**  **echo** "$a 小于 5 或 $b 大于 100 : 返回 true"**else**  **echo** "$a 小于 5 或 $b 大于 100 : 返回 false"**fi**执行脚本，输出结果如下所示：```10 != 20 : a 不等于 b10 小于 100 且 20 大于 15 : 返回 true10 小于 100 或 20 大于 100 : 返回 true10 小于 5 或 20 大于 100 : 返回 false```------#### 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:| 运算符 | 说明       | 举例                                       || :----- | :--------- | :----------------------------------------- || &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  || \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |#### 实例逻辑运算符实例如下：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com*a=10b=20**if** **[****[** $a -lt 100 **&&** $b -gt 100 **]****]****then**  **echo** "返回 true"**else**  **echo** "返回 false"**fi****if** **[****[** $a -lt 100 **||** $b -gt 100 **]****]****then**  **echo** "返回 true"**else**  **echo** "返回 false"**fi**执行脚本，输出结果如下所示：```返回 false返回 true```------#### 字符串运算符下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：| 运算符 | 说明                                         | 举例                     || :----- | :------------------------------------------- | :----------------------- || =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 || !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ $a != $b ] 返回 true。 || -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   || -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  || $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |#### 实例字符串运算符实例如下：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com*a="abc"b="efg"**if** **[** $a = $b **]****then**  **echo** "$a = $b : a 等于 b"**else**  **echo** "$a = $b: a 不等于 b"**fi****if** **[** $a **!**= $b **]****then**  **echo** "$a != $b : a 不等于 b"**else**  **echo** "$a != $b: a 等于 b"**fi****if** **[** -z $a **]****then**  **echo** "-z $a : 字符串长度为 0"**else**  **echo** "-z $a : 字符串长度不为 0"**fi****if** **[** -n "$a" **]****then**  **echo** "-n $a : 字符串长度不为 0"**else**  **echo** "-n $a : 字符串长度为 0"**fi****if** **[** $a **]****then**  **echo** "$a : 字符串不为空"**else**  **echo** "$a : 字符串为空"**fi**执行脚本，输出结果如下所示：```abc = efg: a 不等于 babc != efg : a 不等于 b-z abc : 字符串长度不为 0-n abc : 字符串长度不为 0abc : 字符串不为空```------#### 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。属性检测描述如下：| 操作符  | 说明                                                         | 举例                      || :------ | :----------------------------------------------------------- | :------------------------ || -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 || -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 || -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 || -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  || -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 || -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 || -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 || -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 || -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  || -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  || -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  || -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  || -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |其他检查符：- **-S**: 判断某文件是否 socket。- **-L**: 检测文件是否存在并且是一个符号链接。#### 实例变量 file 表示文件 **/var/www/runoob/test.sh**，它的大小为 100 字节，具有 **rwx** 权限。下面的代码，将检测该文件的各种属性：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com*file="/var/www/runoob/test.sh"**if** **[** -r $file **]****then**  **echo** "文件可读"**else**  **echo** "文件不可读"**fi****if** **[** -w $file **]****then**  **echo** "文件可写"**else**  **echo** "文件不可写"**fi****if** **[** -x $file **]****then**  **echo** "文件可执行"**else**  **echo** "文件不可执行"**fi****if** **[** -f $file **]****then**  **echo** "文件为普通文件"**else**  **echo** "文件为特殊文件"**fi****if** **[** -d $file **]****then**  **echo** "文件是个目录"**else**  **echo** "文件不是个目录"**fi****if** **[** -s $file **]****then**  **echo** "文件不为空"**else**  **echo** "文件为空"**fi****if** **[** -e $file **]****then**  **echo** "文件存在"**else**  **echo** "文件不存在"**fi**执行脚本，输出结果如下所示：```文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在```### Shell echo命令Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：```echo string```您可以使用echo实现更复杂的输出格式控制。#### 1.显示普通字符串:```echo "It is a test"```这里的双引号完全可以省略，以下命令与上面实例效果一致：```echo It is a test```#### 2.显示转义字符```echo "\"It is a test\""```结果将是:```"It is a test"```同样，双引号也可以省略#### 3.显示变量read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量```#!/bin/shread name echo "$name It is a test"```以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:```[root@www ~]# sh test.shOK                     #标准输入OK It is a test        #输出```#### 4.显示换行```echo -e "OK! \n" # -e 开启转义echo "It is a test"```输出结果：```OK!It is a test```#### 5.显示不换行```#!/bin/shecho -e "OK! \c" # -e 开启转义 \c 不换行echo "It is a test"```输出结果：```OK! It is a test```#### 6.显示结果定向至文件```echo "It is a test" > myfile```#### 7.原样输出字符串，不进行转义或取变量(用单引号)```echo '$name\"'```输出结果：```$name\"```#### 8.显示命令执行结果```echo `date````**注意：** 这里使用的是反引号 **`**, 而不是单引号 **'**。结果将显示当前日期```Thu Jul 24 10:08:46 CST 2014```### Shell printf 命令上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。printf 命令模仿 C 程序库（library）里的 printf() 程序。printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。printf 命令的语法：```printf  format-string  [arguments...]```**参数说明：**- **format-string:** 为格式控制字符串- **arguments:** 为参数列表。#### 实例$ **echo** "Hello, Shell"Hello, Shell$ **printf** "Hello, Shell**\n**"Hello, Shell$接下来,我来用一个脚本来体现 printf 的强大功能：#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com***printf** "%-10s %-8s %-4s**\n**" 姓名 性别 体重kg  **printf** "%-10s %-8s %-4.2f**\n**" 郭靖 男 66.1234**printf** "%-10s %-8s %-4.2f**\n**" 杨过 男 48.6543**printf** "%-10s %-8s %-4.2f**\n**" 郭芙 女 47.9876执行脚本，输出结果如下所示：```姓名     性别   体重kg郭靖     男      66.12杨过     男      48.65郭芙     女      47.99```**%s %c %d %f** 都是格式替代符，**％s** 输出一个字符串，**％d** 整型输出，**％c** 输出一个字符，**％f** 输出实数，以小数形式输出。**%-10s** 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。**%-4.2f** 指格式化为小数，其中 **.2** 指保留2位小数。#### 实例*#!/bin/bash**# author:菜鸟教程**# url:www.runoob.com**# format-string为双引号***printf** "%d %s**\n**" 1 "abc"*# 单引号与双引号效果一样***printf** '%d %s\n' 1 "abc"*# 没有引号也可以输出***printf** **%**s abcdef*# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用***printf** **%**s abc def**printf** "%s**\n**" abc def**printf** "%s %s %s**\n**" a b c d e f g h i j*# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替***printf** "%s and %d **\n**"执行脚本，输出结果如下所示：```1 abc1 abcabcdefabcdefabcdefa b cd e fg h ij   and 0```------#### printf 的转义序列| 序列  | 说明                                                         || :---- | :----------------------------------------------------------- || \a    | 警告字符，通常为ASCII的BEL字符                               || \b    | 后退                                                         || \c    | 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 || \f    | 换页（formfeed）                                             || \n    | 换行                                                         || \r    | 回车（Carriage return）                                      || \t    | 水平制表符                                                   || \v    | 垂直制表符                                                   || \\    | 一个字面上的反斜杠字符                                       || \ddd  | 表示1到3位数八进制值的字符。仅在格式字符串中有效             || \0ddd | 表示1到3位的八进制值字符                                     |#### 实例$ **printf** "a string, no processing:<%s>**\n**" "A**\n**B"a string, no processing:**<**A\nB**>**$ **printf** "a string, no processing:<%b>**\n**" "A**\n**B"a string, no processing:**<**A b**>**$ **printf** "www.runoob.com \a"www.runoob.com $          *#不换行*### Shell test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。------#### 数值测试| 参数 | 说明           || :--- | :------------- || -eq  | 等于则为真     || -ne  | 不等于则为真   || -gt  | 大于则为真     || -ge  | 大于等于则为真 || -lt  | 小于则为真     || -le  | 小于等于则为真 |#### 实例num1=100num2=100**if** **test** $**[**num1**]** -eq $**[**num2**]****then**  **echo** '两个数相等！'**else**  **echo** '两个数不相等！'**fi**输出结果：```两个数相等！```代码中的 **[]** 执行基本的算数运算，如：#### 实例*#!/bin/bash*a=5b=6result=$**[**a+b**]** *# 注意等号两边不能有空格***echo** "result 为： $result"结果为:```result 为： 11```------#### 字符串测试| 参数      | 说明                     || :-------- | :----------------------- || =         | 等于则为真               || !=        | 不相等则为真             || -z 字符串 | 字符串的长度为零则为真   || -n 字符串 | 字符串的长度不为零则为真 |#### 实例num1="ru1noob"num2="runoob"**if** **test** $num1 = $num2**then**  **echo** '两个字符串相等!'**else**  **echo** '两个字符串不相等!'**fi**输出结果：```两个字符串不相等!```------#### 文件测试| 参数      | 说明                                 || :-------- | :----------------------------------- || -e 文件名 | 如果文件存在则为真                   || -r 文件名 | 如果文件存在且可读则为真             || -w 文件名 | 如果文件存在且可写则为真             || -x 文件名 | 如果文件存在且可执行则为真           || -s 文件名 | 如果文件存在且至少有一个字符则为真   || -d 文件名 | 如果文件存在且为目录则为真           || -f 文件名 | 如果文件存在且为普通文件则为真       || -c 文件名 | 如果文件存在且为字符型特殊文件则为真 || -b 文件名 | 如果文件存在且为块特殊文件则为真     |#### 实例**cd** **/**bin**if** **test** -e .**/****bash****then**  **echo** '文件已存在!'**else**  **echo** '文件不存在!'**fi**输出结果：```文件已存在!```另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： **!** 最高， **-a** 次之， **-o** 最低。例如：#### 实例**cd** **/**bin**if** **test** -e .**/**notFile -o -e .**/****bash****then**  **echo** '至少有一个文件存在!'**else**  **echo** '两个文件都不存在'**fi**输出结果：```至少有一个文件存在!```### Shell 流程控制和 Java、PHP 等语言不一样，sh 的流程控制不可为空，如(以下为 PHP 流程控制写法)：#### 实例<?phpif (isset($_GET["q"])) &#123;  search(q);&#125;else &#123;  *// 不做任何事情*&#125;在 sh/bash 里可不能这么写，如果 else 分支没有语句执行，就不要写这个 else。------#### if else#### fiif 语句语法格式：```if conditionthen    command1     command2    ...    commandN fi```写成一行（适用于终端命令提示符）：```if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi```末尾的 fi 就是 if 倒过来拼写，后面还会遇到类似的。#### if elseif else 语法格式：```if conditionthen    command1     command2    ...    commandNelse    commandfi```#### if else-if elseif else-if else 语法格式：```if condition1then    command1elif condition2 then     command2else    commandNfi```以下实例判断两个变量是否相等：#### 实例a=10b=20**if** **[** $a == $b **]****then**  **echo** "a 等于 b"**elif** **[** $a -gt $b **]****then**  **echo** "a 大于 b"**elif** **[** $a -lt $b **]****then**  **echo** "a 小于 b"**else**  **echo** "没有符合的条件"**fi**输出结果：```a 小于 b```if else 语句经常与 test 命令结合使用，如下所示：#### 实例num1=$**[**2*****3**]**num2=$**[**1+5**]****if** **test** $**[**num1**]** -eq $**[**num2**]****then**  **echo** '两个数字相等!'**else**  **echo** '两个数字不相等!'**fi**输出结果：```两个数字相等!```------#### for 循环与其他编程语言类似，Shell支持for循环。for循环一般格式为：```for var in item1 item2 ... itemNdo    command1    command2    ...    commandNdone```写成一行：```for var in item1 item2 ... itemN; do command1; command2… done;```当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。in列表是可选的，如果不用它，for循环使用命令行的位置参数。例如，顺序输出当前列表中的数字：#### 实例**for** loop **in** 1 2 3 4 5**do**  **echo** "The value is: $loop"**done**输出结果：```The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5```顺序输出字符串中的字符：```#!/bin/bashfor str in This is a stringdo    echo $strdone```输出结果：```Thisisastring```------#### while 语句while 循环用于不断执行一系列命令，也用于从输入文件中读取数据。其语法格式为：```while conditiondo    commanddone```以下是一个基本的 while 循环，测试条件是：如果 int 小于等于 5，那么条件返回真。int 从 1 开始，每次循环处理时，int 加 1。运行上述脚本，返回数字 1 到 5，然后终止。#### 实例*#!/bin/bash*int=1**while****(****(** $int**<**=5 **)****)****do**  **echo** $int  **let** "int++"**done**运行脚本，输出：```12345```以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：[Bash let 命令](https://www.runoob.com/linux/linux-comm-let.html)。while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。#### 实例**echo** '按下 <CTRL-D> 退出'**echo** -n '输入你最喜欢的网站名: '**while** **read** FILM**do**  **echo** "是的！$FILM 是一个好网站"**done**运行脚本，输出类似下面：```按下 <CTRL-D> 退出输入你最喜欢的网站名:菜鸟教程是的！菜鸟教程 是一个好网站```#### 无限循环无限循环语法格式：```while :do    commanddone```或者```while truedo    commanddone```或者```for (( ; ; ))```------#### until 循环until 循环执行一系列命令直至条件为 true 时停止。until 循环与 while 循环在处理方式上刚好相反。一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。until 语法格式:```until conditiondo    commanddone```condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。以下实例我们使用 until 命令来输出 0 ~ 9 的数字：#### 实例*#!/bin/bash*a=0**until** **[** **!** $a -lt 10 **]****do**  **echo** $a  a=**`****expr** $a + 1**`****done**运行结果：输出结果为：```0123456789```------#### case ... esac**case ... esac** 为多选择语句，与其他语言中的 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 **;;** 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。**case ... esac** 语法格式如下：```case 值 in模式1)    command1    command2    ...    commandN    ;;模式2）    command1    command2    ...    commandN    ;;esac```case 工作方式如上所示，取值后面必须为单词 **in**，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 **;;**。取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。下面的脚本提示输入 1 到 4，与每一种模式进行匹配：#### 实例**echo** '输入 1 到 4 之间的数字:'**echo** '你输入的数字为:'**read** aNum**case** $aNum **in**  1**)** **echo** '你选择了 1'  **;;**  2**)** **echo** '你选择了 2'  **;;**  3**)** **echo** '你选择了 3'  **;;**  4**)** **echo** '你选择了 4'  **;;**  *******)** **echo** '你没有输入 1 到 4 之间的数字'  **;;****esac**输入不同的内容，会有不同的结果，例如：```输入 1 到 4 之间的数字:你输入的数字为:3你选择了 3```下面的脚本匹配字符串：#### 实例*#!/bin/sh*site="runoob"**case** "$site" **in**  "runoob"**)** **echo** "菜鸟教程"  **;;**  "google"**)** **echo** "Google 搜索"  **;;**  "taobao"**)** **echo** "淘宝网"  **;;****esac**输出结果为：```菜鸟教程```------#### 跳出循环在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。#### break命令break命令允许跳出所有循环（终止执行后面的所有循环）。下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。##### 实例*#!/bin/bash***while** :**do**  **echo** -n "输入 1 到 5 之间的数字:"  **read** aNum  **case** $aNum **in**    1**|**2**|**3**|**4**|**5**)** **echo** "你输入的数字为 $aNum!"    **;;**    *******)** **echo** "你输入的数字不是 1 到 5 之间的! 游戏结束"      **break**    **;;**  **esac****done**执行以上代码，输出结果为：```输入 1 到 5 之间的数字:3你输入的数字为 3!输入 1 到 5 之间的数字:7你输入的数字不是 1 到 5 之间的! 游戏结束```#### continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。对上面的例子进行修改：#### 实例*#!/bin/bash***while** :**do**  **echo** -n "输入 1 到 5 之间的数字: "  **read** aNum  **case** $aNum **in**    1**|**2**|**3**|**4**|**5**)** **echo** "你输入的数字为 $aNum!"    **;;**    *******)** **echo** "你输入的数字不是 1 到 5 之间的!"      **continue**      **echo** "游戏结束"    **;;**  **esac****done**运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 **echo "游戏结束"** 永远不会被执行。### Shell 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。shell中函数的定义格式如下：```[ function ] funname [()]&#123;    action;    [return int;]&#125;```说明：- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255下面的例子定义了一个函数并进行调用：```#!/bin/bash# author:菜鸟教程# url:www.runoob.comdemoFun()&#123;    echo "这是我的第一个 shell 函数!"&#125;echo "-----函数开始执行-----"demoFunecho "-----函数执行完毕-----"```输出结果：```-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕-----```下面定义一个带有return语句的函数：```#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn()&#123;    echo "这个函数会对输入的两个数字进行相加运算..."    echo "输入第一个数字: "    read aNum    echo "输入第二个数字: "    read anotherNum    echo "两个数字分别为 $aNum 和 $anotherNum !"    return $(($aNum+$anotherNum))&#125;funWithReturnecho "输入的两个数字之和为 $? !"```输出类似下面：```这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 !```函数返回值在调用该函数后通过 $? 来获得。注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。------#### 函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数...带参数的函数示例：```#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam()&#123;    echo "第一个参数为 $1 !"    echo "第二个参数为 $2 !"    echo "第十个参数为 $10 !"    echo "第十个参数为 $&#123;10&#125; !"    echo "第十一个参数为 $&#123;11&#125; !"    echo "参数总数有 $# 个!"    echo "作为一个字符串输出所有参数 $* !"&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73```输出结果：```第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !```注意，$10 不能获取第十个参数，获取第十个参数需要$&#123;10&#125;。当n>=10时，需要使用$&#123;n&#125;来获取参数。另外，还有几个特殊字符用来处理参数：| 参数处理 | 说明                                                         || :------- | :----------------------------------------------------------- || $#       | 传递到脚本或函数的参数个数                                   || $*       | 以一个单字符串显示所有向脚本传递的参数                       || $$       | 脚本运行的当前进程ID号                                       || $!       | 后台运行的最后一个进程的ID号                                 || $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。         || $-       | 显示Shell使用的当前选项，与set命令功能相同。                 || $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |### Shell 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。重定向命令列表如下：| 命令            | 说明                                               || :-------------- | :------------------------------------------------- || command > file  | 将输出重定向到 file。                              || command < file  | 将输入重定向到 file。                              || command >> file | 将输出以追加的方式重定向到 file。                  || n > file        | 将文件描述符为 n 的文件重定向到 file。             || n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file。 || n >& m          | 将输出文件 m 和 n 合并。                           || n <& m | 将输入文件 和 n 合并。 << tag 将开始标记 和结束标记 之间的内容作为输入。> 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。------#### 输出重定向重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:```command1 > file1```上面这个命令执行command1然后将输出的内容存入file1。注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符。#### 实例执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):```$ who > users```执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。你可以使用 cat 命令查看文件内容：```$ cat users_mbsetupuser console  Oct 31 17:35 tianqixin    console  Oct 31 17:35 tianqixin    ttys000  Dec  1 11:33 ```输出重定向会覆盖文件内容，请看下面的例子：```$ echo "菜鸟教程：www.runoob.com" > users$ cat users菜鸟教程：www.runoob.com$```如果不希望文件内容被覆盖，可以使用 >> 追加到文件末尾，例如：```$ echo "菜鸟教程：www.runoob.com" >> users$ cat users菜鸟教程：www.runoob.com菜鸟教程：www.runoob.com$```------#### 输入重定向和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：```command1 < file1```这样，本来需要从键盘获取输入的命令会转移到文件读取内容。注意：输出重定向是大于号(>)，输入重定向是小于号(<)。 2 #### 实例 接着以上实例，我们需要统计 users 文件的行数,执行以下命令： ``` $ wc -l 也可以将输入重定向到 文件： < 注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。 command1 infile> outfile```同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。#### 重定向深入讲解一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。默认情况下，command > file 将 stdout 重定向到 file，command < file 将stdin 重定向到 file。如果希望 stderr 重定向到 file，可以这样写：```$ command 2>file```如果希望 stderr 追加到 file 文件末尾，可以这样写：```$ command 2>>file```**2** 表示标准错误文件(stderr)。如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：```$ command > file 2>&1或者$ command >> file 2>&1```如果希望对 stdin 和 stdout 都重定向，可以这样写：```$ command < file1 >file2```command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。------#### Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。它的基本的形式如下：```command << delimiter    documentdelimiter```它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。> 注意：>> - 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。> - 开始的delimiter前后的空格会被忽略掉。#### 实例在命令行中通过 **wc -l** 命令计算 Here Document 的行数：```$ wc -l << EOF    欢迎来到    菜鸟教程    www.runoob.comEOF3          # 输出结果为 3 行$```我们也可以将 Here Document 用在脚本中，例如：```#!/bin/bash# author:菜鸟教程# url:www.runoob.comcat << EOF欢迎来到菜鸟教程www.runoob.comEOF```执行以上脚本，输出结果：```欢迎来到菜鸟教程www.runoob.com```------#### /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：```$ command > /dev/null```/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"禁止输出"的效果。如果希望屏蔽 stdout 和 stderr，可以这样写：```$ command > /dev/null 2>&1```> **注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。>> 这里的 **2** 和 **>** 之间不可以有空格，**2>** 是一体的时候才表示错误输出。### Shell 文件包含和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。Shell 文件包含的语法格式如下：```. filename   # 注意点号(.)和文件名中间有一空格或source filename```#### 实例创建两个 shell 脚本文件。test1.sh 代码如下：```#!/bin/bash# author:菜鸟教程# url:www.runoob.comurl="http://www.runoob.com"```test2.sh 代码如下：```#!/bin/bash# author:菜鸟教程# url:www.runoob.com#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho "菜鸟教程官网地址：$url"```接下来，我们为 test2.sh 添加可执行权限并执行：```$ chmod +x test2.sh $ ./test2.sh 菜鸟教程官网地址：http://www.runoob.com```> **注：**被包含的文件 test1.sh 不需要可执行权限。### 在Idea中编辑shell脚本&#123;% asset_img image-20211224111619055.png image-20211224111619055 %&#125;&#123;% asset_img image-20211224111715173.png image-20211224111715173 %&#125;&#123;% asset_img image-20211224111744060.png image-20211224111744060 %&#125;&#123;% asset_img image-20211224111916874.png image-20211224111916874 %&#125;&#123;% asset_img image-20211224112414039.png image-20211224112414039 %&#125;&#123;% asset_img image-20211224112123123.png image-20211224112123123 %&#125;&#123;% asset_img image-20211224112159463.png image-20211224112159463 %&#125;&#123;% asset_img image-20211224112526807.png image-20211224112526807 %&#125;&#123;% asset_img image-20211224112648343.png image-20211224112648343 %&#125;在虚拟机上运行该文件### 综合案例1. 求1到10之间偶数和   ```   #!/bin/bash   i=1   s=0   while (($i <= 1 2="=" 3 50 1099 1200 10)) do if (($i % 0)) then s="$((" $s + $i )) fi i="$((" done echo "the sum is:$s" ``` let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$，例如： let result="no1+no2" $result no2］ 在［］中也可以使用$前缀，例如： 5］ 也可以使用(())，但使用(())时，变量名之前需要加上$： no1 expr同样可以用于基本算术操作： 4` $no1 5) 以上这些方法只能用于整数运算，而不支持浮点数。 bc是一个用于数学运算的高级工具，这个精密计算器包含了大量的选项。我们可以借助它执行浮点数运算并应用一些高级函数： "4 * 0.56" | bc 2.24 no="54" "$no 1.5" bc` 81.0 ## docker卷——持久化的问题 容器的大部分力量源自它们能够尽可能多地封装运行时环境里的文件系统状态，这一点的确很有用处。 然而，有时候用户并不想把文件放到容器里。用户可能想要在容器之间共享或者单独管理一些大文件。一个经典的例子便是想要在容器里访问一个大型的集中式数据库，但是又希望其他的（也许是更传统的）客户端也能和新容器一样访问它。 解决方案便是卷，一种docker用来管理容器生命周期之外的文件的机制。尽管这有悖于容器“可以在任意地方部署”的原则（例如，用户将无法在不兼容数据库挂载的地方部署有数据库依赖的容器），但是在实际的docker使用中这仍然是一个很有用的功能。 ### 问题 想要在容器里访问宿主机上的文件。 解决方案 使用docker的volume标志，在容器里访问宿主机上的文件。图5-3演示了使用volume标志和宿主机上的文件系统交互的例子。 下面的命令展示了如何将宿主机上的 var db tables目录挂载到容器里的 data1目录，该命令在图5-3里启动容器时被执行： $ docker run -v tables: data1 -it debian bash &#123;% asset_img image-20210326051559896.png image-20210326051559896 %&#125; 图5-3　容器里的一个数据卷-v标志（--volume的简写）表示容器指定的一个外部卷。随后的参数以冒号分隔两个目录的形式给出了卷的挂载配置，告知docker将外部的 tables目录映射到容器里的 data1目录。外部目录和容器目录两者任一不存在的话均会被创建。 对已经存在的目录建立映射时要小心。即便镜像里已经存在需要映射的目录，该目录依旧会映射到宿主机上的对应目录。这意味着容器里映射目录的原本内容将会消失。如果用户试图映射一个关键目录，将会发生一些有趣的事情！例如，试试挂载一个空目录到 bin。 另外要注意的一点是，dockerfile里的卷被设定为不是持久化的。如果用户添加了一个卷，然后在一个dockerfile里对该目录做了一些更改，那么这些变化将不会被持久化到最终生成的镜像里。 最后还有一点，用户将会看到不少技巧里用到了-v docker.sock: docker.sock，技巧45就是其中的一个。这样做会把特殊的unix套接字文件公开到容器里，并且展示出此项技巧的一个重要功能——用户不必局限于所谓的“常规”文件，还可以应用更多不常见的文件系统层面的用例。但是，如果用户遇到设备节点的权限问题（举个例子），可能需要参考技巧93，了解一下--privileged标志的作用。 部署 springboot项目 1.创建springboot项目 ![img](https: upload-images.jianshu.io upload_images 15536448-022dcb5d56f43d70.png?imagemogr2 auto-orient strip|imageview2 w format webp) 创建springboot项目 ```css package com.eangulee.demo.controller; import org.springframework.stereotype.controller; org.springframework.web.bind.annotation.getmapping; org.springframework.web.bind.annotation.requestmapping; org.springframework.web.bind.annotation.responsebody; @controller public class hellocontroller &#123; @requestmapping(" ") @responsebody string hello() return "hello, springboot with docker"; &#125; 2.打包springboot项目为jar包 15536448-30b7e78666cc0094.png?imagemogr2 打包命令： clean 3. 编写dockerfile文件 ```ruby # image for file version 0.0.1 author: eangulee 基础镜像使用java from java:8 作者 maintainer <eangulee@gmail.com># VOLUME 指定了临时文件目录为/tmp。# 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmpVOLUME /tmp # 将jar包添加到容器中并更名为app.jarADD demo-0.0.1-SNAPSHOT.jar app.jar # 运行jar包RUN bash -c 'touch /app.jar'ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]```**解释下这个配置文件：**VOLUME 指定了临时文件目录为/tmp。其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。该步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 项目的 jar 文件作为 “app.jar” 添加到容器的 ENTRYPOINT 执行项目 app.jar。为了缩短 Tomcat 启动时间，添加一个系统属性指向 “/dev/./urandom” 作为 Entropy Source如果是第一次打包，它会自动下载java 8的镜像作为基础镜像，以后再制作镜像的时候就不会再下载了。### 4. 部署文件在服务器新建一个docker文件夹，将maven打包好的jar包和Dockerfile文件复制到服务器的docker文件夹下![img](https:////upload-images.jianshu.io/upload_images/15536448-9af07900b7686a79.png?imageMogr2/auto-orient/strip|imageView2/2/w/360/format/webp)docker文件夹### 5. 制作镜像执行下面命令， 看好，最后面有个"."点！```undefineddocker build -t springbootdemo4docker .```-t 参数是指定此镜像的tag名![img](https:////upload-images.jianshu.io/upload_images/15536448-d5087e016f87a13a.png?imageMogr2/auto-orient/strip|imageView2/2/w/729/format/webp)制作完成后通过**docker images**命令查看我们制作的镜像![img](https:////upload-images.jianshu.io/upload_images/15536448-4a8a43c82addd15e.png?imageMogr2/auto-orient/strip|imageView2/2/w/882/format/webp)### 6.启动容器```csharp[root@localhost docker]# docker run -d -p 8080:8085 springbootdemo4docker-d参数是让容器后台运行 -p 是做端口映射，此时将服务器中的8080端口映射到容器中的8085(项目中端口配置的是8085)端口```### 7. 访问网站直接浏览器访问： http://你的服务器ip地址:8080/![img](https:////upload-images.jianshu.io/upload_images/15536448-a42bfc6b886d4ae2.png?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp)## Docker部署SpringBoot项目及mysql最近写了一个小项目，正好比较闲，就想趁机会学习一下docker，把服务docker化。本以为会比较简单，结果没想到项目与容器内数据库连接的时候卡住了，具体看操作步骤吧。安装docker```yum -y install docker-io```启动docker```service docker start```启动自带helloworld测试```docker run hello-world  ```配置阿里云镜像加速登录阿里云控制台，网址：https://cr.console.aliyun.com/?accounttraceid=6fb2e741-14b1-477e-a5a3-976f3a963051#/accelerator进入如下界面，按照讲解配置镜像加速5.安装java镜像，因为之后要通过java -jar命令运行项目jar包，所以下载java镜像；```docker pull java:8u111```6.创建mysql容器   搜索mysql镜像```docker search mysql```安装mysql5.7镜像```docker pull mysql:5.7```使用镜像创建容器```docker run -p 3306:3306 --name mysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7docker run -p 3306:3306 --name mysql -v /root/mysql/conf:/etc/mysql/conf.d -v /root/mysql/logs:/logs -v /root/mysql/data:/opt/mysql/data -e MYSQL_ROOT_PASSWORD=root -d 192.168.1.190:5000/centos/mysql-57-centos7```7.部署springboot项目jar包将项目打包成可执行的jar包，数据库配置可以直接写localhost先建docker文件夹把jar包上传到服务器放到docker文件夹去，同时创建文件Dockerfile，内容如下：开始构建镜像，注意一定要使用host网络连接方式，否则项目会连接不上mysql，导致项目起不来。```docker run    --net=host  --name=news  -d -p 8081:8081 news```目前为止，项目就成功跑来了，可以去浏览器访问一下看看是否成功。小编一开始没有采用host的方式去启动项目容器，结果一直连接不上mysql，这是因为docker会自动给每个容器分配ip，但是项目里配置的mysql地址是localhost，在容器内连接localhost是连接容器本身而不是宿主机的localhost，所以一直找不到mysql。所以采用host的网络方式将容器与宿主机共用一个Network Namespace,这样容器内localhost就是宿主机的localhost了。具体请参考以下两篇文章：点击打开链接 点击打开链接## 在Centos上安装docker compose官网安装说明：https://docs.docker.com/compose/install/1. 运行以下命令以下载Docker Compose的当前稳定版本：   ```   sudo curl -L "https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose   ```2. 将可执行权限应用于二进制文件：   ```   sudo chmod +x /usr/local/bin/docker-compose   ```3. 测试安装   ```   docker-compose --version   ```## 阿里云镜像加速器1. 访问阿里云官网：https://www.aliyun.com/2. 使用 支付宝 或 钉钉 登录3. 访问镜像加速器   &#123;% asset_img image-20210410061812531.png image-20210410061812531 %&#125;4. 粘贴加速器地址到 docker desktop 的设置中   &#123;% asset_img image-20210410061910390.png image-20210410061910390 %&#125;5. 保存并重启# 防火墙操作1. 查看状态：systemctl status firewalld2. 关闭防火墙：systemctl stop firewalld# 启动mysql容器 docker run --name mysql-read -p 3316:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7# 安装vim apt-get updateapt-get install vim# 重启mysql服务service mysql restart# 解压gz文件gzip -dv *# dhclient释放获取IPdhclient -r //release ip 释放IPdhclient //获取IP# 开放及查看端口1、开放端口**firewall-cmd --zone=public --add-port=5672/tcp --permanent**  # 开放5672端口**firewall-cmd --zone=public --remove-port=5672/tcp --permanent** #关闭5672端口**firewall-cmd --reload**  # 配置立即生效 2、查看防火墙所有开放的端口**firewall-cmd --zone=public --list-ports** 3.、关闭防火墙如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估**systemctl stop firewalld.service** 4、查看防火墙状态 **firewall-cmd --state** 5、查看监听的端口**netstat -lnpt**&#123;% asset_img 1336432-20190302110949754-1765820036.png img %&#125;*PS:centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools*  6、检查端口被哪个进程占用**netstat -lnpt |grep 5672**&#123;% asset_img 1336432-20190302104128381-1210567174.png img %&#125; 7、查看进程的详细信息**ps 6832**&#123;% asset_img 1336432-20190302104342651-779103690.png img %&#125; 8、中止进程**kill -9 6832**# Docker的启动与停止```textsystemctl命令是系统服务管理器指令启动docker：systemctl start docker停止docker：systemctl stop docker重启docker：systemctl restart docker查看docker状态：systemctl status docker开机启动：systemctl enable docker查看docker概要信息docker info查看docker帮助文档docker ‐‐help```# 修改主机名//永久性的修改主机名称，重启后能保持修改后的。hostnamectl set-hostname xxx//删除hostnamehostnamectl set-hostname ""hostnamectl set-hostname "" --statichostnamectl set-hostname "" --pretty# 重启linuxreboot -f# 在命令行模式和图形模式切换在图形界面时1.按ctrl+alt+f3（任何时候都可以不仅限以下画面）2.在终端输入init 3在命令行模式时1.按ctrl+alt+f12.登录用户后输入init 5## 查看CentOS版本```cat  /etc/redhat-release```## 阿里云CentOS镜像```https://mirrors.aliyun.com/centos/7/isos/x86_64/```# 华信服务器说明```http://192.168.1.190:8080/```## 查看docker服务器内容``` curl 192.168.1.190:5000/v2/_catalog  &#123;"repositories":["centos/mysql-57-centos7","nginx","redis","tomcat"]&#125;```## 查看镜像版本号``` curl 192.168.1.190:5000/v2/redis/tags/list```## 添加/etc/docker/daemon.json文件```&#123;       "registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"],       "insecure-registries":["192.168.1.190:5000"]&#125;```## 重启docker服务```systemctl restart docker```## 下载tomcat的docker镜像测试```docker pull 192.168.1.190:5000/tomcat:8```下载其他的镜像的时候，不需要添加最后的标签名，因为服务器上他们的默认标签名是：latest# centos7 rpm 离线安装 docker```https://www.jianshu.com/p/764ec08196e0```## Docker下载包```https://download.docker.com/linux/centos/```## 更新yum源```1.备份原有yum源cd /etc/yum.repos.d/mkdir backupmv ./*.repo ./backup/ 2.输入如下命令REPO_URL=http://192.168.1.190:5001/repository/dhee-group-yum/cat > /etc/yum.repos.d/nexus.repo << EOF[base]name=Nexusbaseurl=$REPO_URL\$releasever/os/\$basearch/enabled=1gpgcheck=0[extras]name=Nexusbaseurl=$REPO_URL\$releasever/extras/\$basearch/enabled=1gpgcheck=0[centosplus]name=Nexusbaseurl=$REPO_URL\$releasever/centosplus/\$basearch/enabled=1gpgcheck=0EOF3.更新本地yum源yum update```## 安装顺序安装依赖包：按照下列顺序安装```-rw-r--r--. 1 root root  78256 12月 22 14:50 audit-libs-python-2.8.5-4.el7.x86_64.rpm-rw-r--r--. 1 root root 302068 12月 22 14:50 checkpolicy-2.5-8.el7.x86_64.rpm-rw-r--r--. 1 root root  67720 12月 22 14:51 libcgroup-0.41-21.el7.x86_64.rpm-rw-r--r--. 1 root root  57460 12月 22 14:51 libseccomp-2.3.1-4.el7.x86_64.rpm-rw-r--r--. 1 root root 115284 12月 22 14:51 libsemanage-python-2.5-14.el7.x86_64.rpm-rw-r--r--. 1 root root  32880 12月 22 14:52 python-IPy-0.75-6.el7.noarch.rpm-rw-r--r--. 1 root root 635184 12月 22 14:52 setools-libs-3.3.8-4.el7.x86_64.rpm-rw-r--r--. 1 root root   468316 12月 22 14:52 policycoreutils-python-2.5-34.el7.x86_64.rpm```按照顺序安装docker1. container-selinux-2.119.2-1.911c772.el7_8.noarch.rpm2. containerd.io-1.4.9-3.1.el7.x86_64.rpm3. docker-ce-cli-19.03.9-3.el7.x86_64.rpm4. docker-ce-19.03.9-3.el7.x86_64.rpm重启docker服务器`````````192.168.204.26```# 华信Docker离线安装1. 更新Yum源   ```   补充：   手工删除/etc/yum.repos.d/目录中除了 nexus.repo 之外的其他repo文件      yum clean all   yum makecache   ```   2. 安装Docker3. 更改docker源配置# 华信安装redis一、安装gcc依赖由于 redis 是用 C 语言开发，安装之前必先确认是否安装 gcc 环境（gcc -v），如果没有安装，执行以下命令进行安装 **[root@localhost local]# yum install -y gcc**  二、下载并解压安装包**[root@localhost local]# wget http://download.redis.io/releases/redis-5.0.3.tar.gz**（此步骤不做，从网上下载redis最新版）redis最新版下载地址：https://redis.io/download&#123;% asset_img image-20211223110812306.png image-20211223110812306 %&#125;**[root@localhost local]# tar -zxvf redis-5.0.3.tar.gz** 三、cd切换到redis解压目录下，执行编译**[root@localhost local]# cd redis-5.0.3****[root@localhost redis-5.0.3]# make** 四、安装并指定安装目录**[root@localhost redis-5.0.3]# make install PREFIX=/usr/local/redis** 五、启动服务5.1前台启动**[root@localhost redis-5.0.3]# cd /usr/local/redis/bin/****[root@localhost bin]# ./redis-server** 5.2后台启动从 redis 的源码目录中复制 redis.conf 到 redis 的安装目录**[root@localhost bin]# cp /usr/local/redis-5.0.3/redis.conf /usr/local/redis/bin/** 修改 redis.conf 文件，把 daemonize no 改为 daemonize yes**[root@localhost bin]# vi redis.conf**&#123;% asset_img 1336432-20190302212509880-1874470634.png img %&#125;后台启动**[root@localhost bin]# ./redis-server redis.conf**&#123;% asset_img 1336432-20190302212804992-1094141996.png img %&#125; 六、设置开机启动添加开机启动服务**[root@localhost bin]# vi /etc/systemd/system/redis.service**复制粘贴以下内容：[&#123;% asset_img copycode.gif)](javascript:void(0); 复制代码 %&#125;[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target[&#123;% asset_img copycode.gif)](javascript:void(0); 复制代码 %&#125;注意：ExecStart配置成自己的路径  设置开机启动**[root@localhost bin]# systemctl daemon-reload****[root@localhost bin]# systemctl start redis.service****[root@localhost bin]# systemctl enable redis.service** 创建 redis 命令软链接**[root@localhost ~]# ln -s /usr/local/redis/bin/redis-cli /usr/bin/redis**测试 redis&#123;% asset_img 1336432-20190302221347104-518199130.png img %&#125; 服务操作命令systemctl start redis.service  #启动redis服务systemctl stop redis.service  #停止redis服务systemctl restart redis.service  #重新启动服务systemctl status redis.service  #查看服务当前状态systemctl enable redis.service  #设置开机自启动systemctl disable redis.service  #停止开机自启动 代码改变一切！# 华信安装无法独立安装mysqlrpm包缺少依赖# 华信安装nginx1. 下载：https://nginx.org/en/download.html   ```   nginx-1.21.4.tar.gz   ```2. 解压   依然是直接命令：   ```   tar -zxvf nginx-1.21.4.tar.gz   cd nginx-1.21.4   ```3. 安装依赖   ```   yum -y install pcre-devel   yum -y install openssl openssl-devel   ```4. 配置   - 其实在 nginx-1.21.4 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。     使用默认配置   ```   ./configure   ```   - 自定义配置（不推荐）   ```   ./configure \   --prefix=/usr/local/nginx \   --conf-path=/usr/local/nginx/conf/nginx.conf \   --pid-path=/usr/local/nginx/conf/nginx.pid \   --lock-path=/var/lock/nginx.lock \   --error-log-path=/var/log/nginx/error.log \   --http-log-path=/var/log/nginx/access.log \   --with-http_gzip_static_module \   --http-client-body-temp-path=/var/temp/nginx/client \   --http-proxy-temp-path=/var/temp/nginx/proxy \   --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \   --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \   --http-scgi-temp-path=/var/temp/nginx/scgi   ```   > 注：将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录4. 编译安装   ```   make      make install PREFIX=/usr/local/nginx   ```5. 查找安装路径：   ```   whereis nginx   ```6. 启动、停止nginx   ```   cd /usr/local/nginx/sbin/   ./nginx    ./nginx -s stop   ./nginx -s quit   ./nginx -s reload   ``````启动时报80端口被占用:nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)```` 解决办法：1、安装net-tool 包：`yum install net-tools``` ```> `./nginx -s quit`:此方式停止步骤是待nginx进程处理任务完毕进行停止。> `./nginx -s stop`:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。查询nginx进程：```ps aux|grep nginx```重启 nginx1.先停止再启动（推荐）：对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下：```./nginx -s quit./nginx```2.重新加载配置文件：当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用`-s reload`不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效，如下：./nginx -s reload启动成功后，在浏览器可以看到这样的页面：&#123;% asset_img 160905180451093.png nginx-welcome.png %&#125;# 华信安装jdk8JDK安装步骤：1）查看当前Linux系统是否已经安装java输入 rpm -qa | grep java2）卸载两个openJDK输入rpm -e --nodeps 要卸载的软件名3）上传jdk到linux4）安装jdk运行需要的插件yum install glibc.i686（特殊情况下可选做，一般还是要安装的）5）解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local6）配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去#set java environmentJAVA_HOME=/usr/local/jdk1.7.0_71CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 7）重新加载/etc/profile配置文件 source /etc/profile8）使用命令测试，是否安装成功java -version# 华信安装tomcat9```Tomcat安装步骤：1）上传Tomcat到linux上2）解压Tomcat到/usr/local下tar -xvf apache-tomcat-7.0.57.tar.gz -C /usr/local/3）开放Linux的对外访问的端口8080/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT//规则防火墙规则(centos7中不好用)/etc/rc.d/init.d/iptables save4）启动关闭Tomcat进入tomcat的bin下启动：./startup.sh进入tomcat的bin下关闭：./shutdown.sh5)测试：http://linux服务器ip:8080显示tomcat主页，验证成功！```# 华信使用Nginx```5.配置虚拟主机配置虚拟主机就是在一台服务器启动多个网站。如何区分不同的网站：a、域名不同b、端口不同6.通过端口区分不同虚拟机1)修改Nginx的配置文件：（注意修改内容，如下，注意结束大括号的位置）/usr/local/nginx/conf/nginx.conf，在最下面copy一个server，修改其端口号：server &#123;listen       81;server_name  localhost;#charset koi8-r;#access_log  logs/host.access.log  main;location / &#123;root   html-81;index  index.html index.htm;&#125;&#125;保存2）复制html文件夹，命名为html-81[root@CentOs nginx]# cp -r html html-813）修改html-81文件夹下的index.html文件，以区分不同的端口网站，如，改成：<h1>Welcome to nginx-81!</h1>编辑文件：[root@CentOs html-81]# vim index.html输入i：然后可以修改内容，改完后按esc键，再按“:”，再按“wq”（保存后退出）4）刷新nginx服务：[root@CentOs sbin]# ./nginx -s reload5）在浏览器中测试该81端口：http://192.168.146.128:81/7.域名域名就是网站。www.baidu.comwww.taobao.comwww.jd.comTcp/ipDns服务器：把域名解析为ip地址。保存的就是域名和ip的映射关系。一级域名：Baidu.comTaobao.comJd.com二级域名：www.baidu.comImage.baidu.comItem.baidu.com三级域名：1.Image.baidu.comAaa.image.baidu.com一个域名对应一个ip地址，一个ip地址可以被多个域名绑定。本地测试可以修改hosts文件。修改window的hosts文件：（C:\Windows\System32\drivers\etc），默认内容都被注释掉了可以配置域名和ip的映射关系，如果hosts文件中配置了域名和ip的对应关系，不需要走dns服务器。8.使用switchhosts修改主机域名解析（配置后，这里的域名就不走dns了）1）打开switchhosts软件，添加一个新的本地方案（使用窗口底部左面的“+”按钮）2）设置本地方案名称3）编辑本地方案内：如192.168.146.128 www.test.com192.168.146.128 www.test2.com192.168.146.128 www.test3.com4）切换host（使用底部右边“对号”按钮来切换，有时系统会拦截该切换行为，弹出对话框，要允许该操作才可以）5）在浏览器中测试，分别输入上面设置的域名，如：www.test2.com,看能不能访问nginx网站9.nginx域名配置1）修改nginx的配置文件：/usr/local/nginx/conf/nginx.conf，改为：server &#123;listen       80;server_name  www.test.com;#charset koi8-r;#access_log  logs/host.access.log  main;location / &#123;root   html-test;index  index.html index.htm;&#125;&#125;server &#123;listen       80;server_name  www.test2.com;#charset koi8-r;#access_log  logs/host.access.log  main;location / &#123;root   html-test2;index  index.html index.htm;&#125;&#125;目的：一个ip地址，可以为多个域名提供80端口的服务映射2）在linux上复制出html-test和html-test2目录：[root@CentOs nginx]# cp -r html html-test[root@CentOs nginx]# cp -r html html-test23）修改html-test和html-test2目录中index.html的内容为：nginx-test! 和 nginx-test2!2）刷新nginx服务器：[root@CentOs sbin]# ./nginx -s reload3）在浏览器中测试：http://www.test.com =>nginx-test!http://www.test2.com =>nginx-test2!10.nginx反向代理反向代理服务器决定哪台服务器提供服务。反向代理服务器不提供服务，就是请求的转发。正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器这个代理服务器呢,他能访问那个我不能访问的网站于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容代理服务器去取回来,然后返回给我从网站的角度,只在代理服务器来取内容的时候有一次记录有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站结论就是 正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。11.nginx实现反向代理（假设该公司只有一个公网ip，但有两个网站，分别放在了两台服务器上）1）在本机的hosts文件中添加：（不能带端口号）192.168.146.128 www.sina.com.cn192.168.146.128 www.sohu.com2）上传tomcat 安装包到linux的root下3）解压缩tomcat安装包：tar zxf apache-tomcat-7.0.57.tar.gz4）复制一份，命名为：cp apache-tomcat-7.0.57 tomcat-sina -r5）复制一份，命名为：cp apache-tomcat-7.0.57 tomcat-sohu -r6）编辑sohu tomcat端口号：vim tomcat-sohu/conf/server.xml（使用/port查找）i）<Server port="8005" shutdown="SHUTDOWN">改为：<Server port="8006" shutdown="SHUTDOWN">ii）<Connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">改为：<Connector port="8081" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">iii）<Connector port="8009" protocol="AJP/1.3" redirectport="8443">改为：<Connector port="8010" protocol="AJP/1.3" redirectport="8443">以Tomcat7.0为例, 在安装目录下. conf/server.xml 中可以配置三个端口号, 如果使用多个tomcat 是需要配置这三个.该Connector 用于监听请求.protocol: HTTP/1.1 协议 ，用于监听浏览器发送的请求. 设置成80 后可以直接使用http://localhost 访问   AJP/1.3   协议 ， 用于监听其他服务器转发过来的请求.connectionTimeout: 连接超时时间redirectPort: 如果发送的是https 请求. 就将请求转发到8443 端口. <Connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">使用8009 接受其他服务器转发过来的请求.<Connector port="8009" protocol="AJP/1.3" redirectport="8443">tomcat 监听的关闭端口.<Server port="8005" shutdown="SHUTDOWN">7）分别启动两个tomcat：tomcat-sina/bin/startup.shtomcat-sohu/bin/startup.sh8）在浏览器中测试：http://192.168.146.128:8080/http://192.168.146.128:8081/9）修改tomcat中欢迎页内容，表示区别i）vim tomcat-sina/webapps/ROOT/index.jspii）使用命令:/h1，定位到h1标签，修改内容为：<h1>$&#123;pageContext.servletContext.serverInfo&#125;-sina</h1>iii）vim tomcat-sohu/webapps/ROOT/index.jspiv）使用命令:/h1，定位到h1标签，修改内容为：<h1>$&#123;pageContext.servletContext.serverInfo&#125;-sohu</h1>10）在浏览器中重新测试：http://192.168.146.128:8080/http://192.168.146.128:8081/11）修改nginx的配置文件：/usr/local/nginx/conf/nginx.conf，添加如下内容：upstream sina&#123;server 192.168.146.128:8080;&#125;server &#123;listen       80;server_name  www.sina.com.cn;#charset koi8-r;#access_log  logs/host.access.log  main;location / &#123;proxy_pass   http://sina;index  index.html index.htm;&#125;&#125;upstream sohu&#123;server 192.168.146.128:8081;&#125;server &#123;listen       80;server_name  www.sohu.com;#charset koi8-r;#access_log  logs/host.access.log  main;location / &#123;proxy_pass   http://sohu;index  index.html index.htm;&#125;&#125;12）刷新nginx服务器：[root@CentOs sbin]# ./nginx -s reload13）在浏览器中测试：http://www.sina.com.cnhttp://www.sohu.com12)nginx负载均衡如果一个服务由多个服务器提供，需要把负载分配到不同的服务器处理，需要负载均衡。 upstream sina &#123;server 192.168.25.148:8081;server 192.168.25.148:8082;  &#125;1）复制一份tomcat，命名为：cp apache-tomcat-7.0.57 tomcat-sina2 -r2）编辑sohu tomcat端口号：vim tomcat-sina2/conf/server.xml（使用/port查找）i）<Server port="8005" shutdown="SHUTDOWN">改为：<Server port="8007" shutdown="SHUTDOWN">ii）<Connector port="8080" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">改为：<Connector port="8082" protocol="HTTP/1.1" connectiontimeout="20000" redirectport="8443">iii）<Connector port="8009" protocol="AJP/1.3" redirectport="8443">改为：<Connector port="8011" protocol="AJP/1.3" redirectport="8443">3）启动tomcat：tomcat-sina2/bin/startup.sh4）修改tomcat中欢迎页内容，表示区别i）vim tomcat-sina2/webapps/ROOT/index.jspii）使用命令:/h1，定位到h1标签，修改内容为：<h1>$&#123;pageContext.servletContext.serverInfo&#125;-sina2</h1>5）在浏览器中重新测试：http://192.168.146.128:8082/6）修改upstream sina&#123;server 192.168.146.128:8080;&#125;改为：upstream sina&#123;server 192.168.146.128:8080;server 192.168.146.128:8082;&#125;7）刷新nginx服务器：[root@CentOs sbin]# ./nginx -s reload8）在浏览器中测试：（反复刷新，看是否在两台服务器间负载均衡，别再eclipse中的浏览器测试，最好使用谷歌浏览器）http://www.sina.com.cn9）可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1i）修改权重upstream sina&#123;server 192.168.146.128:8080;server 192.168.146.128:8082 weight=2;&#125;ii）刷新nginx服务器：[root@CentOs sbin]# ./nginx -s reloadiii）在浏览器中测试：（反复刷新，看是否在两台服务器间负载均衡，别再eclipse中的浏览器测试，最好使用谷歌浏览器）http://www.sina.com.cn```# Docker的卷## 问题想要在容器里访问宿主机上的文件。## 解决方案使用Docker的volume标志，在容器里访问宿主机上的文件。图5-3演示了使用volume标志和宿主机上的文件系统交互的例子。下面的命令展示了如何将宿主机上的/var/db/tables目录挂载到容器里的/var/data1目录，该命令在图5-3里启动容器时被执行：``` docker run -v /var/db/tables:/var/data1 -it debian bash```&#123;% asset_img image-20211227133001386.png image-20211227133001386 %&#125;-v标志（--volume的简写）表示容器指定的一个外部卷。随后的参数以冒号分隔两个目录的形式给出了卷的挂载配置，告知Docker将外部的/var/db/tables目录映射到容器里的/var/data1目录。外部目录和容器目录两者任一不存在的话均会被创建。# Docker以守护进程运行```//与docker run一起使用的-d标志将以守护进程方式运行容器。//-i标志则赋予容器与Telnet会话交互的能力docker run -d -i debian bashdocker exec -it 容器id```# Dockerfile命令## **FROM** 功能为指定基础镜像，并且必须是第一条指令。如果不以任何镜像为基础，那么写法为：FROM scratch。同时意味着接下来所写的指令将作为镜像的第一层开始 语法：```FROM <image>FROM <image>:<tag>FROM <image>:<digest> ```三种写法，其中<tag>和<digest> 是可选项，如果没有选择，那么默认值为latest  ## RUN 功能为运行指定的命令RUN命令有两种格式```1. RUN <command>2. RUN ["executable", "param1", "param2"]```第一种后边直接跟shell命令- 在linux操作系统上默认 /bin/sh -c- 在windows操作系统上默认 cmd /S /C第二种是类似于函数调用。可将executable理解成为可执行文件，后面就是两个参数。 两种写法比对：- ```  RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME  ```- ```  RUN ["/bin/bash", "-c", "echo hello"]  ```注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层. 多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。RUN书写时的换行符是\  ## CMD 功能为容器启动时要运行的命令语法有三种写法```1. CMD ["executable","param1","param2"]2. CMD ["param1","param2"]3. CMD command param1 param2```第三种比较好理解了，就时shell这种执行方式和写法第一种和第二种其实都是可执行文件加上参数的形式 举例说明两种写法：- ```  CMD [ "sh", "-c", "echo $HOME"   ```- ```  CMD [ "echo", "$HOME" ]  ```补充细节：这里边包括参数的一定要用双引号，就是",不能是单引号。千万不能写成单引号。原因是参数传递后，docker解析的是一个JSON array RUN & CMD不要把RUN和CMD搞混了。RUN是构件容器时就运行的命令以及提交运行结果CMD是容器启动时执行的命令，在构件时并不运行，构件时紧紧指定了这个命令到底是个什么样子  ## LABEL功能是为镜像指定标签 语法：```LABEL <key>=<value> <key>=<value> <key>=<value> ...``` 一个Dockerfile种可以有多个LABEL，如下：```LABEL "com.example.vendor"="ACME Incorporated"LABEL com.example.label-with-value="foo"LABEL version="1.0"LABEL description="This text illustrates \that label-values can span multiple lines."``` 但是并不建议这样写，最好就写成一行，如太长需要换行的话则使用\符号如下：```LABEL multi.label1="value1" \multi.label2="value2" \other="value3"``` 说明：LABEL会继承基础镜像种的LABEL，如遇到key相同，则值覆盖  ## MAINTAINER指定作者语法：```MAINTAINER <name>```  ## EXPOSE功能为暴漏容器运行时的监听端口给外部但是EXPOSE并不会使容器访问主机的端口如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数  ## ENV功能为设置环境变量语法有两种```1. ENV <key> <value>2. ENV <key>=<value> ...```两者的区别就是第一种是一次设置一个，第二种是一次设置多个  ## **ADD** 一个复制命令，把文件复制到景象中。如果把虚拟机与容器想象成两台linux服务器的话，那么这个命令就类似于scp，只是scp需要加用户名和密码的权限验证，而ADD不用。 语法如下：```1. ADD <src>... <dest>2. ADD ["<src>",... "<dest>"]``` <dest>路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径<src>可以是一个本地文件或者是一个本地压缩文件，还可以是一个url 如果把<src>写成一个url，那么ADD就类似于wget命令 如以下写法都是可以的：- ```  ADD test relativeDir/   ```- ```  ADD test /relativeDir  ```- ```  ADD http://example.com/foobar /  ```尽量不要把<scr>写成一个文件夹，如果<src>是一个文件夹了，复制整个目录的内容,包括文件系统元数据 ## COPY看这个名字就知道，又是一个复制命令语法如下：```1. COPY <src>... <dest>2. COPY ["<src>",... "<dest>"]```与ADD的区别COPY的<src>只能是本地文件，其他用法一致  ## ENTRYPOINT功能是启动时的默认命令 语法如下：```1. ENTRYPOINT ["executable", "param1", "param2"]2. ENTRYPOINT command param1 param2``` 如果从上到下看到这里的话，那么你应该对这两种语法很熟悉啦。第二种就是写shell第一种就是可执行文件加参数 与CMD比较说明（这俩命令太像了，而且还可以配合使用）：\1. 相同点：- 只能写一条，如果写了多条，那么只有最后一条生效- 容器启动时才运行，运行时机相同 \2. 不同点：-  ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖-  如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数如下：```FROM ubuntuENTRYPOINT ["top", "-b"]CMD ["-c"]```- 如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效如下：```FROM ubuntuENTRYPOINT ["top", "-b"]CMD ls -al```那么将执行ls -al ,top -b不会执行。 Docker官方使用一张表格来展示了ENTRYPOINT 和CMD不同组合的执行情况（下方表格来自docker官网）&#123;% asset_img 0.jpeg img %&#125;  ## VOLUME 可实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器种 语法为：```VOLUME ["/data"]```  说明：  ["/data"]可以是一个JsonArray ，也可以是多个值。所以如下几种写法都是正确的```VOLUME ["/var/log/"]VOLUME /var/logVOLUME /var/log /var/db```一般的使用场景为需要持久化存储数据时容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。所以当数据需要持久化时用这个命令。  ## USER 设置启动容器的用户，可以是用户名或UID，所以，只有下面的两种写法是正确的- ```  USER daemo  ```- ```  USER UID  ```注意：如果设置了容器以daemon用户去运行，那么RUN, CMD 和 ENTRYPOINT 都会以这个用户去运行  ## WORKDIR 语法：```WORKDIR /path/to/workdir``` 设置工作目录，对RUN,CMD,ENTRYPOINT,COPY,ADD生效。如果不存在则会创建，也可以设置多次。 如：```WORKDIR /aWORKDIR bWORKDIR cRUN pwd```pwd执行的结果是/a/b/c WORKDIR也可以解析环境变量如：```ENV DIRPATH /pathWORKDIR $DIRPATH/$DIRNAMERUN pwd```pwd的执行结果是/path/$DIRNAME ## ARG语法：```ARG <name>[=<default value>]```设置变量命令，ARG命令定义了一个变量，在docker build创建镜像的时候，使用 --build-arg <varname>=<value>来指定参数如果用户在build镜像时指定了一个参数没有定义在Dockerfile种，那么将有一个Warning提示如下：```[Warning] One or more build-args [foo] were not consumed.```  我们可以定义一个或多个参数，如下：```FROM busyboxARG user1ARG buildno...```也可以给参数一个默认值：```FROM busyboxARG user1=someuserARG buildno=1...```如果我们给了ARG定义的参数默认值，那么当build镜像时没有指定参数值，将会使用这个默认值  ## ONBUILD语法：```ONBUILD [INSTRUCTION]```这个命令只对当前镜像的子镜像生效。比如当前镜像为A，在Dockerfile种添加：```ONBUILD RUN ls -al```这个 ls -al 命令不会在A镜像构建或启动的时候执行 此时有一个镜像B是基于A镜像构建的，那么这个ls -al 命令会在B镜像构建的时候被执行。  ## STOPSIGNAL语法：```STOPSIGNAL signal```STOPSIGNAL命令是的作用是当容器推出时给系统发送什么样的指令  HEALTHCHECK 容器健康状况检查命令语法有两种：```1. HEALTHCHECK [OPTIONS] CMD command2. HEALTHCHECK NONE```第一个的功能是在容器内部运行一个命令来检查容器的健康状况第二个的功能是在基础镜像中取消健康检查命令 [OPTIONS]的选项支持以下三中选项：  ***--interval=DURATION 两次检查默认的时间间隔为30秒***  ***--timeout=DURATION 健康检查命令运行超时时长，默认30秒***  ***--retries=N 当连续失败指定次数后，则容器被认为是不健康的，状态为unhealthy，默认次数是3***  注意：HEALTHCHECK命令只能出现一次，如果出现了多次，只有最后一个生效。 CMD后边的命令的返回值决定了本次健康检查是否成功，具体的返回值如下：***0: success - 表示容器是健康的******1: unhealthy - 表示容器已经不能工作了******2: reserved - 保留值*** 例子：```HEALTHCHECK --interval=5m --timeout=3s \CMD curl -f http://localhost/ || exit 1``` 健康检查命令是：curl -f http://localhost/ || exit 1两次检查的间隔时间是5秒命令超时时间为3秒# docker命令详解Dockerfile中包括FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOINT、VOLUME、USER、WORKDIR、ONBUILD等13个指令。下面一一讲解。## FROM所谓定制镜像，那么就一定是以一个镜像为基础，在其上进行修改定制。就像我们之前运行了一个Nginx的容器，在其上面修改一样，基础容器是必需指定的。而`FROM`就是指定基础镜像，因此在DockerFile中，`FROM`是必备指定，并且必需是第一条指令！除了指定现有的基础镜像以外，DockerFile还存在一个特殊的镜像`srcatch`，这个镜像是一个虚拟的概念，并不实际存在，它表示一个空白的镜像：```bashFROM scratch...```如果你以`scratch`作为基础镜像，意味着你将不使用任何镜像为基础，接下来你所写的指令将作为第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见。如`swarm`、`coreos/etcd`。对Linux下静态编译的程序来说，并不需要其他操作提供其运行时支持，所需的一切库都在可执行文件里了，因此使用`scratch`作为基础，可以使镜像的体积更加小巧。格式为FROM image或FROM image:tag，且在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令。## RUN`RUN`指令是用来执行命令行命令的，由于命令行的强大功能，`RUN`指令是定制镜像时最常用的指令之一。其格式有两种：- **shell格式**：就像在命令行中输入的Shell脚本命令一样，比如之前的：```bashecho '<h1>Hello Docker!</h1>' > /usr/share/nginx/html/index.html```- **exec格式**：像是函数调用的格式，例如：```bashapt-get updatemkdir -p /usr/src/redis```DockerFile的每一个指令都会新构建一层，`RUN`命令也不例外。每一个`RUN`行为，都会新建立一层，然后在其上执行命令，执行完毕后，提交这一层的修改，构成新的镜像！UnionFS是有最大层数限制的，比如AUFS，曾经是最大不能超过42层，现在是最大不能超过127层。所以，对于一些编译、软件的安装、更新等操作，无需分成好几层来操作，这样会使得镜像非常臃肿，拥有非常多的层，不仅仅增加了构建部署的时间，也很容易出错！！例如，上面的`exec`格式的命令可以写作一层：```bashRUN buildDeps=apt-get update && mkdir -p /usr/src/redis && apt-get purge -y --auto-remove $buildDeps```这里仅仅使用了一个`RUN`指令，所以只会新建一层！对于一些编译、安装以及软件的更新等操作，没有必要分为很多层来操作，只需要一层就可以了！在此，我们可以使用`&&`符号将多个命令分割开，使其先后执行。此时，一个`RUN`指令有可能会变得非常长，为了使DockerFile的可阅读性和代码更加美观，我们可以使用`\`进行换行操作。另外，我们还可以使用`#`进行行首的注释。观察刚刚编写的`RUN`指令，我们会发现在指令的结尾处添加了清理工作的命令，删除了为了编译构建的软件，清理了所有下载、展开的文件，并且还清理`apt`缓存文件。我们之前说过，镜像是多层存储，每一层存储的东西不会在下一层删除，会一直跟随着镜像。因此在镜像构建时，一定要确保每一层只添加真正需要的东西，任何无关的东西都应该被清理掉。格式为RUN command或 RUN ["EXECUTABLE","PARAM1","PARAM2".....]，前者在shell终端中运行命令，/bin/sh -c command，例如：/bin/sh -c "echo hello"；后者使用exec执行，指定其他运行终端使用RUN["/bin/bash","-c","echo hello"]&#123;% asset_img 270324-20180407222151795-458304224.png img %&#125;&#123;% asset_img 270324-20180407222206219-1004812737.png img %&#125;每条RUN指令将当前的镜像基础上执行指令，并提交为新的镜像，命令较长的时候可以使用\来换行。## COPY`COPY`指令将从上下文目录中的指定路径下的文件或文件夹复制到新的一层的镜像内的指定路径之下，格式为：```bashCOPY <源路径> ... <目标路径>```原路径可以是多个，甚至是通配符，其通配规则只需要满足GO语言的`filepath.Math`规则即可，如下：```bashCOPY ./test1.py ./test2.py /test/COPY ./t*.py /test/COPY ./test?.py /test/```目标路径是容器内的绝对路径，也可以是工作目录下的相对路径，工作目录可以使用`WORKDIR`指令进行指定。目标路径不需要事先创建，Docker会自动创建所需的文件目录。使用`COPY`指令会将源路径的文件的所有元数据，比如读、写、指定全选、时间变更等。如果源路径时一个目录，那么会将整个目录复制到容器中，包括文件系统元数据。## ADD`ADD`指令和`COPY`的格式和性质基本一致，只不过是在`COPY`的基础上增加了一些功能。例如`ADD`指定中，源路径可以是一个远程URL，Docker引擎会自动帮我们将远程URL的文件下载下来到目标路径下，例如：```bashADD http://192.168.0.89:5000/test.py /test/```我们使用`docker build`进行构建镜像，然后使用`docker run`创建并启动容器，会发现在根目录下的test文件夹下有了`test.py`文件。如果源路径是本地的一个tar压缩文件时，`ADD`指定在复制到目录路径下会自动将其进行解压，如下：```bashADD docker2.tar /test/```压缩格式为`gzip`、`bzip2`以及`xz`的情况下，`ADD`指令都会将其解压缩！非常值得注意的是，目标路径为一个URL时，会将其自动下载到目标路径下，但是其权限被自动设置成了`600`，如果这并不是你想要的权限，那么你还需要额外增加一层`RUN`命令进行更改，另外，如果下载的是一个压缩包，同样你还需要额外增加一层`RUN`命令进行解压缩。所以，在这种情况下，你还不如指定只用一层`RUN`，使用`curl`或者`wget`工具进行下载，并更改权限，然后进行解压缩，最后清理无用文件！当你的源路径为压缩文件并且不想让Docker引擎将其自动解压缩，这个时候就不可以使用`ADD`命令，你可以使用`COPY`命令进行完成！其实`ADD`命令并不实用，并不推荐使用！！！## CMD支持三种格式：CMD ["executable","param1","param2"]，使用exec执行，这是推荐的方式。CMD command param1 param2 在/bin/sh中执行。CMD ["param1","param2"] 提供给ENTERYPOINT的默认参数。CMD用于指定容器启动时执行的命令，每个Dockerfile只能有一个CMD命令，多个CMD命令只执行最后一个。若容器启动时指定了运行的命令，则会覆盖掉CMD中指定的命令。`CMD`指令与`RUN`指令相似，也具有两种格式：- **shell格式**：**CMD <命令>**- **exec格式**：**CMD [“可执行文件”, “参数1”, “参数2”, …]**之前介绍容器的时候就说过，Docker不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，就需要指定运行的程序及参数。`CMD`就是指定默认的容器主进程的启动命令的。在运行时可以设置`CMD`指令来代替镜像设置中的命令，例如Ubuntu默认的`CMD`是`/bin/bash`，当我们使用命令`docker run -it ubuntu`创建并启动一个容器会直接进入`bash`。我们也可以在运行时指定运行别的命令，比如`docker run -it ubuntu cat /etc/os-release`，这就用`cat /etc/os-release`命令代替了默认的`/bin/bash`命令，输出了系统版本信息。比如，我想在启动容器的时候，在控制台中输出`Hello Docker!`，我们可以在Dockerfile中这样写，如下：```bashFROM ubuntuCMD echo "Hello Docker!"```接下来，我们构建一个镜像`ubuntu:v1.0`，接下来，我们以此镜像为基础创建并启动一个容器，如下：```bashdocker run -it ubuntu:v1.0```这样，就会在控制台中输出`Hello Docker!`的信息。值得注意的是，如果使用shell格式，那么实际的命令会被包装成为`sh -c`的参数的形式进行执行。上面的`CMD`指令，在实际执行中会变成：```bashCMD ["sh", "-c", "echo", "Hello Docker!"]```因为这种特性，一些命令在加上`sh -c`之后，有可能会发生意想不到的错误，因此在Dockerfile中使用`RUN`指令时，更加推荐使用`exec`格式！最后需要牢记，使用`docker run`命令指定要执行的命令可以覆盖`RUN`指令，如果我们的`docker run`中指定了我们将要执行的命令，并且在Dockerfile中也指定了CMD命令，那么最终只会执行`docker run`命令中指定的命令。比如有这样一个Dockerfile：```bashFROM ubuntuCMD ["echo", "Hello Docker!"]```我们将其构建成成镜像`ubuntu:v1.1`，下面，我们以此镜像为基础创建并启动一个容器，如下：```bashdocker run -it ubuntu:v1.1 cat /etc/os-release```那么容器只会执行`cat /etc/os-release`命令，也就是说在控制台只会输出系统版本信息，并不会输出Hello Docker!信息## ENTRYPOINT格式有两种：ENTRYPOINT ["executable","param1","param2"]ENTRYPOINT command param1,param2 会在shell中执行。用于配置容器启动后执行的命令，这些命令不能被docker run提供的参数覆盖。和CMD一样，每个Dockerfile中只能有一个ENTRYPOINT，当有多个时最后一个生效。`ENTRYPOINT`指令和`CMD`指令目的一样，都是指定容器运行程序及参数，并且与`CMD`一样拥有两种格式的写法：- **shell格式**：**ENTRYPOINT <命令>**- **exec格式**：**ENTRYPOINT [“可执行文件”, “参数1”, “参数2”, …]**与`CMD`指令一样，`ENTRYPOINT`也更加推荐使用`exec`格式，`ENTRYPOINT`在`docker run`命令中同样也可以进行指定，只不过比`CMD`指令来的繁琐一些，需要指定`--entrypoint`参数。同样，在`docker run`命令中指定了`--entrypoint`参数的话，会覆盖Dockerfile中`ENTRYPOINT`上的指令。当指定了`ENTRYPOINT`指令时，`CMD`指令里的命令性质将会发生改变！`CMD`指令中的内容将会以参数形式传递给`ENTRYPOINT`指令中的命令，如下：```bashFROM ubuntuENTRYPOINT ["rm", "docker2"]CMD ["-rf"]```其实，它真正执行的命令将会是：```bashrm docker2 -rf```从例子中可以看出，`ENTRYPOINT`指令和`CMD`指令非常的相似，也很容易将其搞混，就比如上面的例子，就可以完全使用一条`CMD`指令`CMD ["rm", "docker2", "-rf"]`来完成。这两个指令到底有什么区别，为什么要同时保留这两条指令呢？我们可以使用`ENTRYPOINT`指令和`CMD`指令相结合，使得在创建并启动时要执行的命令更加灵活！有如下Dockerfile：```bashFROM ubuntuRUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*ENTRYPOINT ["curl", "-s", "http://ip.cn"]```此时，我们将其构建成镜像`ubuntu:v1.2`，下面我们创建并启动容器：```bashdocker run -it ubuntu:v1.2```将会在控制台输出我们相应的公网IP信息！此时，如果我们还需要获取HTTP头信息时，我们可以这样：```bashdocker run -it ubuntu:v1.2 -i```此时，将会在控制台中将公网IP信息以及HTTP头信息全部输出！我们知道，`docker run`命令中紧跟在镜像后面的是`CMD`指令命令，运行时会替换默认的`CMD`指令。因为我们在Dockerfile中指定了`ENTRYPOINT`指令，根据`ENTRYPOINT`指令的特性知道，当指定了`ENTRYPOINT`指令，`CMD`指令的内容将会以参数的形式传递给`ENTRYPOINT`，所以在容器中最终执行的命令是`curl -s -i http://ip.cn`，`-i`参数被传递到`ENTRYPOINT`中，所以最终在控制台中会输出HTTP头信息！！！## ENV`ENV`指令用于设置环境变量，格式有两种：- **ENV**- **ENV = = …**这个指令非常简单，就是用于设置环境变量而已，无论是接下来的指令，还是在容器中运行的程序，都可以使用这里定义的环境变量。例如：```bashFROM ubuntu:16.04ENV MODE=testRUN apt-get update && apt-get install -y curl && curl http://192.168.0.89:5000/$MODE && rm -rf /var/lib/apt/lists/*```如果你要设置多个环境变量，为了美观，你可以使用`\`来进行换行。多个环境变量的隔开，使用空格进行隔开的，如果某个环境变量的值是由一组英文单词构成，那么你可以将其使用`""`进行圈起来。如下：```bashFROM ubuntu:16.04RUN MODE=test DESCRITPION="ios 12" \    TITLE="iphone"```接下来，将这个Dockerfile构建成镜像，然后以此镜像为基础创建并启动一个容器，在容器中，我们调用这个环境变量，仍然是有用的！！！值得注意的是，如果你想通过`CMD`或者`ENTRYPOINT`指令的exec格式来打印环境，就像下面这样：```bashCMD ["echo", $MODE]CMD ["echo", "$MODE"]```这样都是不能正确输出环境变量的值的，你可以改成exec格式来执行shell命令，如下：```bashCMD ["sh", "-c", "echo $MODE"]```如此，就能正确输出环境变量的值了！## ARG构建参数`ARG`和`ENV`指令一样，都是设置环境变量。与之不同的是，`ARG`设置的环境变量只是在镜像构建时所设置的，在将来容器运行时是不会存在这些环境变量的。但是不要因此就用`ARG`来保存密码之类的信息，因为通过`docker history`还是能够看得到的。`ARG`指令与`ENV`指令的使用类似，如下：```bashFROM ubuntu:16.04ARG app="python-pip"RUN apt-get update && apt-get install -y $app && rm -rf /var/lib/apt/lists/*````ARG`构建参数可以通过`docker run`命令中的`--build-arg`参数来进行覆盖## VOLUME`VOLUME`指令用于构建镜像时定义匿名卷，其格式有两种：- **VOLUME <路径>**- **VOLUME [“<路径1>”, “<路径2>”, …]**之前我们说过，容器存储层应该保持无状态化，容器运行时应尽量保持容器内不发生任何写入操作，对于需要保存动态数据的应用，其数据文件应该将其保存在数据卷中(VOLUME)定义一个匿名卷：```bashFROM ubuntu:16.04VOLUME /data```定义多个匿名卷：```bashFROM ubuntu:16.04VOLUME ["/data", "/command"]```这里的`/data`和`/command`目录在容器运行时会自动挂载为匿名卷，任何向`/data`和`/command`目录中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化！容器匿名卷目录指定可以通过`docker run`命令中指定`-v`参数来进行覆盖## EXPOSE格式为 EXPOSE port [port2,port3,...]，例如EXPOSE 80这条指令告诉Docker服务器暴露80端口，供容器外部连接使用。在启动容器的使用使用-P，Docker会自动分配一个端口和转发指定的端口，使用-p可以具体指定使用哪个本地的端口来映射对外开放的端口。`EXPOSE`指令是声明运行时容器服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在Dockerfile中这样声明有两个好处：一个是帮助镜像使用者更好的理解这个镜像服务的守护端口，另一个作用则是在运行时使用随机端口映射时，也就是`docker run -p`命令时，会自动随机映射`EXPOSE`端口。要将`EXPOSE`和在运行时使用`-p <宿主>:<容器端口>`区分开来，`-p`是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而`EXPOSE`仅仅是声明端口使用什么端口而已，并不会自动在宿主进行端口映射。## WORKDIR格式： WORKDIR /path为后续的RUN CMD ENTRYPOINT指定配置工作目录，可以使用多个WORKDIR指令，若后续指令用得是相对路径，则会基于之前的命令指定路径。使用`WORKDIR`指令来制定工作目录(或者称为当前目录)，以后各层操作的当前目录就是为指定的目录，如果该目录不存在，`WORKDIR`会自动帮你创建目录，如下：```bashFROM ubuntu:16.04WORKDIR /data/testRUN mkdir docker && echo "test" > demo.txt```当我们使用`docker build`构建此镜像，并使用`docker run`命令进行创建和启动容器之后，会发现目录被自动切换到了`/data/test`，并且在当前目录下有一个文件夹`docker`，在`docker`下有一个文件`domo.txt`并且有相应的内容。我们还可以为特定的指令指定不同的工作目录，如下：```bashFROM ubuntu:16.04WORKDIR /data/testRUN mkdir dockerWORKDIR /data/test/dockerRUN echo "test" > demo.txt```这样，Dockerfile中两次`RUN`指令的操作都在不同的目录下进行，最终容器会切换到最后一次`WORKDIR`指令下的目录。`WORKDIR`指令可以通过`docker run`命令中的`-w`参数来进行覆盖## USER```格式为：USER username指定容器运行时的用户名或UID，后续的RUN也会使用指定的用户。要临时使用管理员权限可以使用sudo。在USER命令之前可以使用RUN命令创建需要的用户。例如：RUN groupadd -r docker && useradd -r -g docker docker````USER`指令用于将会用以什么样的用户去运行，例如：```bashFROM ubuntu:16.04USER docker```基于该镜像启动的容器会以`docker`用户的身份来运行，我们可以指定用户名或者UID，组名或者GID，或者两者的结合，如下：```bashFROM ubuntu:16.04USER userUSER user:groupUSER uidUSER uid:gidUSER user:gidUSER uid:group````USER`指令可以在`docker run`命令中的`-u`参数进行覆盖## HEALTHCHECK`HEALTHECHECK`指令是告诉Docker该如何判断容器的状态是否正常，这是1.12引入的新指令，其格式有两种：- **HEALTHCHECK [options] CMD <命令>**：检查容器健康状态的命令- **HEALTHCHECK NONE**：如果基础镜像有健康检查指令，这一行将会屏蔽掉其健康检查指令HEALTHECHECK支持下列选项：- **–interval=<间隔>**：两次检查的时间间隔，默认为30s- **–timeout=<时长>**：健康检查命令运行超时时间，如果超过这个时间，本次健康检查将会判定为失败，默认为30s- **–retries=<次数>**：当连续失败指定次数之后，则将容器状态视为`unhealthy`，默认为3次在没有`HEALTHCHECK`指令之前，Docker引擎只可以通过容器内主进程是否退出来判断容器状态是否异常。很多情况下这没有问题，但是如果程序进入了死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法继续提供服务了。在1.12之前，Docker引擎不会检测到容器的这种状态，从而不会重新调度，导致可能容器已经无法提供服务了却仍然还在接收用户的请求。假设我们有个镜像是最简单的Web服务，我们希望增加健康检查来判断Web服务是否在正常工作，我们可以用`curl`来帮助判断，其`Dockerfile`的`HEALTHCHECK`可以这么写：```bashFROM nginxRUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s CMD curl -fs http://localhost/ || exit 1```接下来，我们将该Dockerfile编译构建成一个镜像，并以此镜像为基础创建并启动一个容器。此时，我们使用`docker container ls`命令来查看容器的状态，如下：```bashroot@ubuntu:~/docker# docker container lsCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS                NAMES036b91eea00d        nginx:v1.2          "nginx -g 'daemon of…"   7 seconds ago       Up 6 seconds (healthy)   0.0.0.0:80->80/tcp   web```我们再`STATUS`这一列中可以看到，状态未`healthy`。如果我们快速的多次执行`docker container ls`的话，会发现`STATUS`状态是由`health: starting`最后变为`healthy`，当然如果容器未在正常工作，最后的状态将会变为`unhealthy`这里，我们设置了每5s检查一次，如果检查时间超过3s没有响应就视为失败。`||`符号左边的命令执行结果为假，右边的命令才会执行！为了帮助排除故障，健康检查命令的输出会被存储于健康状态里，我们可以使用`docker inspect`命令来进行查看：```bashroot@ubuntu:~/docker# docker inspect --format '&#123;&#123;json .State.Health&#125;&#125;&#39; web | python3 -m json.tool&#123;    &quot;Status&quot;: &quot;healthy&quot;,    &quot;FailingStreak&quot;: 0,    &quot;Log&quot;: [        &#123;            &quot;Start&quot;: &quot;2018-07-17T21:15:05.900643297+08:00&quot;,            &quot;End&quot;: &quot;2018-07-17T21:15:05.968989028+08:00&quot;,            &quot;ExitCode&quot;: 0,            &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\&quot;http://nginx.org/\&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\&quot;http://nginx.com/\&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;        &#125;    ]&#125;</次数></时长></间隔></命令></容器端口></宿主></路径2></路径1></路径></命令></命令></目标路径></源路径></value></varname></default></name></src></dest></src></dest></src></src></scr></src></src></dest></dest></src></dest></src></value></key></value></key></name></value></key></value></key></value></key></digest></tag></digest></image></tag></image></image></Connector></Connector></Connector></Connector></Server></Server></Server></Connector></Connector></Connector></Connector></Connector></Connector></Server></Server></=></)。></&></CTRL-D></CTRL-D></**A></%b></**A\nB**></%s></EOF></code></pre><p>和<code>CMD</code>、<code>NETRYPOINT</code>一样，<code>HEALTHCHECK</code>指令只可以出现一次，如果有多个<code>HEALTHCHECK</code>指令，那么只有最后一个才会生效！！！</p><h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><pre><code>格式ONBUILD [INSTRUCTION]该配置指定当所创建的镜像作为其他新建镜像的基础镜像时所执行的指令。例如下面的Dockerfile创建了镜像A：ONBUILD ADD . /appONBUILD RUN python app.py</code></pre><p>&#96;&#96;</p><pre><code>ONBUILD`是一个特殊的指令，它后面跟着的是其他指令，比如`COPY`、`RUN`等，而这些命令在当前镜像被构建时，并不会被执行。只有以当前镜像为基础镜像去构建下一级镜像时，才会被执行。格式为：`ONBUILD &lt;其他指令&gt;</code></pre><p><code>Dockerfile</code>中的其他指令都是为了构建当前镜像准备的，只有<code>ONBUILD</code>指令是为了帮助别人定制而准备的。例如：</p><pre class=" language-bash"><code class="language-bash">from ubuntu:16.04WORKDIR /dataONBUILD RUN <span class="token function">mkdir</span> <span class="token function">test</span></code></pre><p>此时，我们以此<code>Dockerfile</code>进行构建镜像<code>ubuntu:test</code>，并以此镜像为基础创建并启动一个容器，进入容器后，容器会自动切换到<code>WORKDIR</code>指令下的目录，此时我们使用<code>ls</code>命令会发现在工作目录下，并未创建<code>test</code>文件夹，如下：</p><pre class=" language-bash"><code class="language-bash">root@ubuntu:~/docker<span class="token comment" spellcheck="true"># docker run -it ubuntu:test</span>root@3a8f912fd23b:/data<span class="token comment" spellcheck="true"># ls</span>root@3a8f912fd23b:/data<span class="token comment" spellcheck="true">#</span></code></pre><p>此时，我们再创建一个<code>Dockerfile</code>，只需一个<code>FROM</code>指令即可，使其继承刚刚我们构建的<code>ubuntu:test</code>镜像，如下：</p><pre class=" language-bash"><code class="language-bash">FROM ubuntu:test</code></pre><p>我们再以此<code>Dockerfile</code>构建镜像<code>ubuntu:test_onbuild</code>，并以此镜像为基础创建并启动一个容器，进入容器后，容器会自动切换到<code>WORKDIR</code>指令下的目录，此时我们使用<code>ls</code>命令会发现在工作目录下，已经创建好了一个名为<code>test</code>的文件夹，如下：</p><pre class=" language-bash"><code class="language-bash">root@ubuntu:~/docker<span class="token comment" spellcheck="true"># docker run -it ubuntu:test_onbuild</span>root@5394e605b6ea:/data<span class="token comment" spellcheck="true"># ls</span><span class="token function">test</span></code></pre><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><pre><code>LABEL`指令可以为镜像指定标签，其格式为：`LABEL &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ...</code></pre><p><code>LABEL</code>后面是键值对，多个键值对以空格进行隔开，如果value中包含空格，请使用<code>&quot;&quot;</code>将value进行圈起来，如下：</p><pre class=" language-bash"><code class="language-bash">FROM ubuntu:16.04LABEL name<span class="token operator">=</span>testLABEL description<span class="token operator">=</span><span class="token string">"a container is used to test"</span></code></pre><p>我们知道，DockerFile的每一个指令都会新构建一层，所以，上面的<code>LABEL</code>我们可以写成一条指令，用空格进行隔开，如下：</p><pre class=" language-bash"><code class="language-bash">FROM ubuntu:16.04LABEL name<span class="token operator">=</span>test description<span class="token operator">=</span><span class="token string">"a container is used to test"</span></code></pre><p>为了美观，我们还可以使用<code>\</code>符号进行换行操作。</p><p>要查看镜像的标签，我们可以使用<code>docker inspect</code>命令，如下：</p><pre class=" language-bash"><code class="language-bash">root@ubuntu:~<span class="token comment" spellcheck="true"># docker inspect --format '&amp;#123;&amp;#123;json .Config.Labels&amp;#125;&amp;#125;' test | python3 -m json.tool </span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    <span class="token string">"description"</span><span class="token keyword">:</span> <span class="token string">"a container is used to test"</span>,    <span class="token string">"name"</span><span class="token keyword">:</span> <span class="token string">"test"</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre><p>其中“test”为容器名称！</p><p>值得注意的是，这里的标签并非是我们一开始将镜像名称中的<code>&lt;仓库&gt;:&lt;标签&gt;</code>，这两者是不一样的！这里标签，类似于签条，注解之类的意思</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><pre><code>MAINTAINER`指令用于指定生成镜像的作者名称，其格式为：`MAINTAINER &lt;name&gt;</code></pre><p><code>MAINTAINER</code>指令已经被弃用，可以使用<code>LABEL</code>指令进行替代，如下：</p><pre class=" language-bash"><code class="language-bash">LABEL maintainer<span class="token operator">=</span><span class="token string">'Stephen Chow'</span></code></pre><p><code>MAINTAINER</code>指令在一些老的Dockerfile中仍然可以看到，所以还是需要了解一下的！</p><p><strong>docker build</strong><br>创建好Dockerfile之后，通过docker build命令来创建镜像，该命令首先会上传Dockerfile文件给Docker服务器端，服务器端将逐行执行Dockerfile中定义的指令。<br>通常建议放置Dockerfile的目录为空目录。另外可以在目录下创建.dockerignore文件，让Docker忽略路径下的文件和目录，这一点与Git中的配置很相似。</p><p>通过 -t 指定镜像的标签信息，例如：docker build -t regenzm&#x2F;first_image . ##”.”指定的是Dockerfile所在的路径</p><h2 id="Docker-history-查看docker镜像构建过程-还原dockerfile"><a href="#Docker-history-查看docker镜像构建过程-还原dockerfile" class="headerlink" title="Docker history 查看docker镜像构建过程 还原dockerfile"></a>Docker history 查看docker镜像构建过程 还原dockerfile</h2><p>介绍：</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">history</span> --helpUsage:  docker <span class="token function">history</span> <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGEShow the <span class="token function">history</span> of an imageOptions:      --format string   Pretty-print images using a Go template      --help            Print usage  -H, --human           Print sizes and dates <span class="token keyword">in</span> human readable <span class="token function">format</span> <span class="token punctuation">(</span>default true<span class="token punctuation">)</span>      --no-trunc        Don't truncate output  -q, --quiet           Only show numeric IDs</code></pre><p>示例：</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">history</span> kubeguide/tomcat-app:v1IMAGE               CREATED             CREATED BY                                      SIZE                COMMENTa29e200a18e9        2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ADD dir:c5c3bddef49cbc9f...   992kB               </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) MAINTAINER bestme &lt;bestm...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) CMD ["catalina.sh" "run"]     0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) EXPOSE 8080/tcp               0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token keyword">set</span> -e  <span class="token operator">&amp;&amp;</span> nativeLines<span class="token operator">=</span><span class="token string">"$(catal...   0B                  &lt;missing>           2 years ago         /bin/sh -c set -x   &amp;&amp; curl -fSL "</span><span class="token variable">$TOMCAT_</span><span class="token punctuation">..</span>.   16.6MB              <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV TOMCAT_TGZ_URL=https...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV TOMCAT_VERSION=8.0.35     0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV TOMCAT_MAJOR=8            0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token keyword">set</span> -ex  <span class="token operator">&amp;&amp;</span> <span class="token keyword">for</span> key <span class="token keyword">in</span>   05AB33<span class="token punctuation">..</span>.   114kB               <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> insta<span class="token punctuation">..</span>.   7.18MB              <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;   echo 'deb http://httpredir....   172B                </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV OPENSSL_VERSION=1.0....   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) WORKDIR /usr/local/tomcat     0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token function">mkdir</span> -p <span class="token string">"<span class="token variable">$CATALINA_HOME</span>"</span>            0B                  <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV PATH=/usr/local/tomc...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV CATALINA_HOME=/usr/l...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token keyword">set</span> -x  <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> update  <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">..</span>.   163MB               <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV JAVA_DEBIAN_VERSION=...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV JAVA_VERSION=7u101        0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV JAVA_HOME=/usr/lib/j...   0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;   echo '#!/bin/sh';   echo 's...   87B                 </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ENV LANG=C.UTF-8              0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> insta<span class="token punctuation">..</span>.   1.17MB              <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> insta<span class="token punctuation">..</span>.   44.3MB              <span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) CMD ["/bin/bash"]             0B                  </span><span class="token operator">&lt;</span>missing<span class="token operator">></span>           2 years ago         /bin/sh -c <span class="token comment" spellcheck="true">#(nop) ADD file:5d8521419ad6cfb...   125MB</span></code></pre><p>如果要让CREATED BY 列完整显示，可以加上 –no-trunc 参数。直接在shell中看会比较乱，可以输出到文件查看，就比较直观了</p><pre class=" language-bash"><code class="language-bash">docker <span class="token function">history</span> --no-trunc 镜像:tag</code></pre><h1 id="docker学习路线指引"><a href="#docker学习路线指引" class="headerlink" title="docker学习路线指引"></a>docker学习路线指引</h1><p>在上一节课 <a href="http://baijiahao.baidu.com/s?id=1701153261049761046">docker学习00-容器技术产生的背景</a> 中，我们讨论了容器技术产生的背景，和容器所解决的痛点问题，可见，容器技术的产生，可以显著地提高生产力，方便开发和运维工作，甚至推动了整个IT架构的演进。也让DEVOPS成为了可能！</p><p>那么在容器技术领域，有着许多的技术实现，比如LXC容器、OpenVZ，CoreOS rkt（备注: coreos已经被redhat收购），Containerd 、docker等等，这些都可以作为容器运行。</p><p>因为容器被越来越重视，使用越来越广泛，因此，在行业内，已经形成了容器技术的一些标准，比如OCI （开放容器计划），CRI（容器运行时接口），现在我们只需要知道，只要符合这些标准的容器技术，就可以相互替代，就如同满足USB3.0 的数据线，或者是type-c的数据线可以共用一样。</p><p>为什么选择docker？在众多的容器实现中，docker无疑是出类拔萃的，它甚至是行业标准的推进者，尽管容器编排老大k8s说在新版本中默认编排工具放弃使用docker，但终端用户完全无需担心，因为，docker是符合OCI标准的，用户使用docker进行的镜像构建，打包的应用，完全可以在k8s中的容器中运行，并且，docker对终端用户来说，使用起来，真的很方便！</p><p>好了，上面是一些背景知识，现在，接下来就可以开始docker的学习了。学习docker之前，我们要先了解要学习哪些内容，这样，才不至于，只见树木不见森林！</p><p>docker学习中，将学习哪些内容呢？下面是学习路线：</p><img src="/2022/061040991/241f95cad1c8a7864903d91c99435f3570cf504e.jpeg" class title="img"><h3 id="docker初探"><a href="#docker初探" class="headerlink" title="docker初探"></a>docker初探</h3><p>带你初步认识docker，体验docker的魅力 </p><ul><li>docker安装：这一章节，将会介绍，docker的安装方式</li><li>docker开胃菜：这一节，会通过几个例子，来体验下docker的具体使用方法，以及其带来的便捷；</li></ul><h3 id="docker基础"><a href="#docker基础" class="headerlink" title="docker基础"></a>docker基础</h3><p>带你一步步走进docker的世界，和docker交朋友</p><ul><li>docker架构及底层技术：通过docker初探，我们对docker有了初步的感性认识，这一节将详细介绍docker的软件设计架构及依赖的底层技术，帮助大家更好的深入了解docker；</li><li>docker镜像：从这节开始，将介绍几个重要的docker对象，包括 docker镜像image，docker 容器container，docker镜像仓库 registry，docker存储，docker网络等； 这节课重点介绍 docker镜像；</li><li>docker 镜像仓库：介绍docker镜像仓库registry的内容；</li><li>docker容器：详细介绍docker容器的使用；</li><li>docker镜像多阶段构建：介绍docker镜像的新特性，多阶段构建相关内容；</li><li>网络基础回顾：这节会带你回顾下网络相关的基础知识，方便后续能够更好的掌握docker网络相关知识；</li></ul><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><p>带你了解docker通讯的原理</p><ul><li>docker单机网络：这节介绍docker在单台主机上运行时的网络模式；</li><li>docker跨主机网络：介绍docker在不同主机间的通讯原理，采用的网络模式等；</li></ul><h3 id="docker存储"><a href="#docker存储" class="headerlink" title="docker存储"></a>docker存储</h3><p>带你掌握docker存储驱动和数据持久化机制</p><ul><li>docker容器存储：这节课介绍docker容器的存储驱动类型，注意，这节课介绍的是docker运行时，数据在docker内的存储实现，而非在docker外部的持久化存储；</li><li>持久化存储和数据共享：这节课将介绍如何实现docker容器数据的持久化和不同docker容器间的数据共享等；</li></ul><h3 id="docker容器编排"><a href="#docker容器编排" class="headerlink" title="docker容器编排"></a>docker容器编排</h3><p>带你大规模玩转docker容器，让docker成为提高生产力的“利剑” </p><ul><li>单机编排工具之docker compose：从这节课开始讲介绍容器的编排工具，就是说，如何大规模地使用这些docker容器； 这节课将重点介绍单机编排工具之 docker compose的语法，用法等；</li><li>大规模编排之k8s：这节课介绍docker大规模编排工具k8s，会带你初步认识k8s，并介绍k8s是如何实现大规模，集群化容器编排的，了解k8s是如何提高生产力的；</li></ul><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p>主要是针对比较重要的内容，并且需要前面的基础知识做铺垫，所以，在这里给予补充，后面比较重要的东西，都会在这里进行补充。</p><ul><li>docker镜像仓库开源工具之 Harbor：主要介绍 docker开源镜像仓库工具 harbor的部署，搭建、配置和使用等</li></ul><h1 id="Docker练习"><a href="#Docker练习" class="headerlink" title="Docker练习"></a>Docker练习</h1><h2 id="部署SSM项目到docker容器中"><a href="#部署SSM项目到docker容器中" class="headerlink" title="部署SSM项目到docker容器中"></a>部署SSM项目到docker容器中</h2><ol><li><p>基于 tomcat9镜像，使用Dockerfile创建项目镜像</p><ul><li><p>搭建静态网站</p><pre><code>//DockerfileFROM tomcat:9.0-jdk8-correttoRUN mkdir $CATALINA_HOME/webapps/ROOTADD index.html $CATALINA_HOME/webapps/ROOT/index.htmlCMD [&quot;catalina.sh&quot;,&quot;run&quot;]//运行镜像docker run --name tomcat -d -p 80:8080 镜像id//测试http://主机id</code></pre></li><li><p>搭建动态网站</p><pre><code>//压缩文件tar -zcvf app.tar.gz *//DockerfileFROM tomcat:9.0-jdk8-correttoRUN mkdir $CATALINA_HOME/webapps/ROOTADD app.tar.gz $CATALINA_HOME/webapps/ROOT/CMD [&quot;catalina.sh&quot;,&quot;run&quot;]//运行镜像docker run --name tomcat -d -p 80:8080 镜像id//测试http://主机id</code></pre></li></ul></li><li><p>基于mysql5.7镜像，使用Dockerfile创建项目的数据库镜像</p><ul><li><p>启动mysql服务器</p><pre><code>//DockerfileFROM mysql:5.7WORKDIR /docker-entrypoint-initdb.dENV LANG=C.UTF-8ADD init.sql .//运行mysql镜像//-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；//-d: 后台运行容器，并返回容器ID；//-i: 以交互模式运行容器，通常与 -t 同时使用；//-e username=&quot;ritchie&quot;: 设置环境变量；//--name=&quot;nginx-lb&quot;: 为容器指定一个名称；//-p: 指定端口映射，格式为：主机(宿主)端口:容器端口docker run -e MYSQL_ROOT_PASSWORD=root --name mysql -it -d -p 5001:3306  镜像Id</code></pre></li><li><p>init.sql文件(注意文件类型编码为：utf8，回车换行符为：linux)</p><pre><code>CREATE DATABASE `mydb` /*!40100 DEFAULT CHARACTER SET utf8 */;use mydb;CREATE TABLE `dept` (  `deptno` int(11) NOT NULL,  `dname` varchar(14) DEFAULT NULL,  `loc` varchar(13) DEFAULT NULL,  PRIMARY KEY (`deptno`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `dept` VALUES (10, &#39;ACCOUNTING&#39;, &#39;NEW YORK&#39;);INSERT INTO `dept` VALUES (20, &#39;RESEARCH&#39;, &#39;DALLAS&#39;);INSERT INTO `dept` VALUES (30, &#39;SALES&#39;, &#39;CHICAGO&#39;);INSERT INTO `dept` VALUES (40, &#39;OPERATIONS&#39;, &#39;BOSTON&#39;);INSERT INTO `dept` VALUES (50, &#39;hr2&#39;, &#39;sy3&#39;);</code></pre></li></ul><ol start="3"><li><p>把mysql容器连接到tomcat容器</p><pre><code># 先删除mysql容器docker rm -f mysql容器id#重新创建mysql容器，并连接到tomcat# --net=container:tomcat 把新容器连接到tomcat容器的同一网络（共享网络空间） docker run -e MYSQL_ROOT_PASSWORD=root --name mysql -it -d --net=container:tomcat mysql镜像Id  #测试 http://主机id/dept/getAll.action</code></pre></li></ol></li></ol><h1 id="查看镜像详细信息"><a href="#查看镜像详细信息" class="headerlink" title="查看镜像详细信息"></a>查看镜像详细信息</h1><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等</p><pre><code>docker inspect 镜像Id</code></pre><h1 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h1><p>通过 <code>docker history</code> 命令，可以列出各个层（layer）的创建信息</p><pre><code>docker history</code></pre><h1 id="容器运行后休眠"><a href="#容器运行后休眠" class="headerlink" title="容器运行后休眠"></a>容器运行后休眠</h1><pre><code># 容器运行后一直休眠 infinity（永远）docker run -d 镜像Id sleep infinity#在容器中直接执行命令docker exec 容器id cat /etc/hosts</code></pre><h1 id="图形化管理Docker"><a href="#图形化管理Docker" class="headerlink" title="图形化管理Docker"></a>图形化管理Docker</h1><p>Portainer，这是一款由Docker核心贡献者之一开发的工具。Portainer的前身是DockerUI</p><pre><code>docker run -d -p 9000:9000 \ -v /var/run/docker.sock:/var/run/docker.sock \ portainer/portainer -H unix:///var/run/docker.sock  或   docker run -d --restart=always -p 9000:9000 \ -v /var/run/docker.sock:/var/run/docker.sock \ -v portainer_data:/data \ -v /public:/public \ --name=portainer portainer/portainer  运行参数信息：-d：容器在后台运行；-p 80:9000 ：宿主机80端口映射容器中的9000端口，前一个80是宿主机端口，后一个9000是docker内部应用端口-v /var/run/docker.sock:/var/run/docker.sock  ：把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中；-v portainer_data:/data ：把宿主机portainer_data数据卷挂载到容器/data目录下，以”:”分隔–name=portainer:指定运行portainer容器的名称为portainer，以后再次运行时只需通过docker run portainer来运行了--restart=always: 实现容器在宿主机开机时自启动--privileged：映射文件最高权限，可以进行读写操作</code></pre><p>执行上述命令将会在后台启动一个portainer容器。如果现在访问 <a href="http://localhost:9000/">http://localhost:9000</a> ，可以在看板上看到机器上运行的Docker的简要信息。</p><p>解决错误：<strong>WARNING: IPv4 forwarding is disabled. Networking will not work.</strong></p><p>解决方法:</p><p>第一步：找到文件 ：vim &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;00-system.conf</p><p> 添加代码：net.ipv4.ip_forward&#x3D;1</p><p>第二步：重启network服务和docker服务：</p><p> systemctl restart network &amp;&amp; systemctl restart docker</p><p>第三步：重启建容器</p><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>可以下载汉化包之后解压，并将解压后的public文件夹上传到centos系统的根目录下</p><img src="/2022/061040991/image-20220101110247704.png" class title="image-20220101110247704"><p>然后执行以下命令：（如果已部署，需要将之前的容器删除）</p><pre><code>docker run -d --restart=always -p 9000:9000 \&gt;  -v /var/run/docker.sock:/var/run/docker.sock \&gt;  -v portainer_data:/data \&gt;  -v /public:/public \&gt;  --name=portainer portainer/portainer</code></pre><p>汉化后效果图：</p><img src="/2022/061040991/image-20220101110436310.png" class title="image-20220101110436310"><h1 id="镜像导出与导入"><a href="#镜像导出与导入" class="headerlink" title="镜像导出与导入"></a>镜像导出与导入</h1><pre><code>#导出docker save -o debian.tar 镜像Id#导入docker load &lt; debian.tar#导入后没有tag，打标签docker tag 镜像id  debian:latest</code></pre><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装 pip</p><pre><code> yum install python-pip</code></pre></li><li><p>4343</p><pre><code>yum install python3-pip</code></pre></li><li><p>44</p><pre><code>pip3 install docker-compose</code></pre></li><li><p>测试</p><pre><code>docker-compose -v结果docker-compose version 1.29.2, build unknown</code></pre></li><li><p>配置 wordpress</p><pre><code>version: &quot;3.9&quot;    services:  db:    image: mysql:5.7    volumes:      - db_data:/var/lib/mysql    restart: always    environment:      MYSQL_ROOT_PASSWORD: somewordpress      MYSQL_DATABASE: wordpress      MYSQL_USER: wordpress      MYSQL_PASSWORD: wordpress      wordpress:    depends_on:      - db    image: wordpress:latest    volumes:      - wordpress_data:/var/www/html    ports:      - &quot;8000:80&quot;    restart: always    environment:      WORDPRESS_DB_HOST: db      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: wordpress      WORDPRESS_DB_NAME: wordpressvolumes:  db_data: &#123;&#125;  wordpress_data: &#123;&#125;</code></pre></li><li><p>安装 wordpress</p><pre><code>docker-compose up -d</code></pre></li><li><p>测试：</p><pre><code>http://ip:8000</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理总线</title>
      <link href="/2022/060954841.html"/>
      <url>/2022/060954841.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理总线"><a href="#计算机组成原理总线" class="headerlink" title="计算机组成原理总线"></a>计算机组成原理总线</h1><h2 id="总线的概念及分类"><a href="#总线的概念及分类" class="headerlink" title="总线的概念及分类"></a>总线的概念及分类</h2><img src="/2022/060954841/10.jpg" class>   <ul><li>总线：<br>①定义：  <img src="/2022/060954841/1.jpg" class>   ②特性（机械，电器，功能，时间）：  <img src="/2022/060954841/2.jpg" class>   ③分类：  <img src="/2022/060954841/3.jpg" class>  其中：<br>按照数据格式传输：  <img src="/2022/060954841/4.jpg" class>    按照功能分类：  <img src="/2022/060954841/5.jpg" class>   <img src="/2022/060954841/6.jpg" class>   按照时序控制方式：  </li><li>系统总线经典结构：<br>①单总线：  <img src="/2022/060954841/7.jpg" class>   ②双总线：  <img src="/2022/060954841/8.jpg" class>   ③三总线：  <h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2></li><li><img src="/2022/060954841/11.jpg" class>   ①总线的传输周期（总线周期）：<br>一次总线操作时间（申请，寻址，传输，结束四个阶段），通常包括若干个总线时钟周期。  <img src="/2022/060954841/12.jpg" class>   ②总线时钟周期：<br>即及其的时钟周期，计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要收此时钟的控制。<br>③总线的工作频率：<br>总线上各种操作的频率，为总线周期的倒数。<br>④总线的时钟频率：<br>即机器的时钟频率，为周期的倒数，也就是一秒内有多少个时钟周期。<br>⑤总线宽度：<br>总线位宽，总线上同时传输的数据位数，也就是数据总线根数。<br>⑥总线宽度：<br>总线的数据传输率，即单位时间内可传输的数据的位数，单位是B&#x2F;s。指的是总线本身达到的最高传输速率。<br>⑦总线复用：<br>一种信号线在不同时间传输不同的信息。可以用较少的线传输更多的信息，从而节省了空间和成本。<br>⑧信号线数：<br>地址总线，数据总线，控制总线。三种线的总和。<br>⑨总结：  <img src="/2022/060954841/14.jpg" class>   </li><li>串行总线和并行总线：  <img src="/2022/060954841/13.jpg" class>   <h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><img src="/2022/060954841/15.jpg" class>   </li><li>集中仲裁：  <img src="/2022/060954841/16.jpg" class>   <img src="/2022/060954841/17.jpg" class>   <img src="/2022/060954841/18.jpg" class>   总结：  <img src="/2022/060954841/19.jpg" class>   </li><li>分布仲裁:  <img src="/2022/060954841/20.jpg" class>   <h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2></li><li>总线传输的四个阶段：  <img src="/2022/060954841/21.jpg" class>   </li><li>总线定时：<br>①同步定时方式：  <img src="/2022/060954841/22.jpg" class>   ②异步定时方式：  <img src="/2022/060954841/23.jpg" class>   <img src="/2022/060954841/24.jpg" class>   ③半同步通信：略<br>④分离式通信：略</li><li>波特率：<br>单位时间内传送的二进制数据的位数，单位用bps，记作波特。  </li><li>比特率：<br>单位时间内传送的二进制有效数据的位数，单位用bps，即bit&#x2F;s。<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2></li><li>概念：  <img src="/2022/060954841/25.jpg" class>   </li><li>常见标准：  <img src="/2022/060954841/26.jpg" class>   ISA，EISA，PCI，AGP，PCI-E，USB，RS-232C，SATA，SCSI，PCMCI</li><li>桥接器：用于连接不同总线，具有数据缓冲， 转换和控制功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理中央处理器</title>
      <link href="/2022/060947947.html"/>
      <url>/2022/060947947.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理中央处理器"><a href="#计算机组成原理中央处理器" class="headerlink" title="计算机组成原理中央处理器"></a>计算机组成原理中央处理器</h1><img src="/2022/060947947/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8.jpg" class> <h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><img src="/2022/060947947/5.jpg" class>   <ul><li><img src="/2022/060947947/1.jpg" class>   分为运算器和控制器：  <img src="/2022/060947947/2.jpg" class>   </li><li>运算器基本结构：  <img src="/2022/060947947/3.jpg" class>   </li><li>控制器的基本结构：<img src="/2022/060947947/4.jpg" class>   </li><li>总体划分为ALU，寄存器，CU，中断系统四部分电路。  <h2 id="CPU中指令执行过程"><a href="#CPU中指令执行过程" class="headerlink" title="CPU中指令执行过程"></a>CPU中指令执行过程</h2><img src="/2022/060947947/13.jpg" class>   </li><li>指令周期：CPU从主存中取出并执行一条指令所需的全部时间。常常用若干机器周期（又叫CPU周期）来表示。而机器周期又包含若干时钟周期（CPU操作最基本单位）。  <img src="/2022/060947947/6.jpg" class>   不同指令内机器周期可以不同：  <img src="/2022/060947947/8.jpg" class>   指令周期流程：  <img src="/2022/060947947/7.jpg" class>   ①取指周期：  <img src="/2022/060947947/9.jpg" class>   ②间址周期：  <img src="/2022/060947947/12.jpg" class>   ③执行周期：<br>任务就是根据IR中的指令字的操作码和操作数通过ALU操作产生结果，不同指令的执行周期操作不同，因此没有统一的数据流向。<br>④中断周期：  <img src="/2022/060947947/11.jpg" class>   </li><li>指令执行方案：  <img src="/2022/060947947/10.jpg" class>   <h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2></li><li>数据通路：数据在功能部件之间的传送路径。  </li><li>CPU内部单总线方式：   <img src="/2022/060947947/14.jpg" class>   内部总线指的是同一部件如CPU内部连接各寄存器及运算部件之间的总线。而系统总线是一台计算机各部件，如CPU，内存，通道和各类IO接口间的相互连接的总线。  <img src="/2022/060947947/15.jpg" class>   </li><li>专用数据通路方式：<br>类似于总线，但直接利用通路进行传送而不是输入到总线再输出。  <h2 id="控制器：硬布线和微程序（略）"><a href="#控制器：硬布线和微程序（略）" class="headerlink" title="控制器：硬布线和微程序（略）"></a>控制器：硬布线和微程序（略）</h2><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2></li><li>指令阶段：  <img src="/2022/060947947/16.jpg" class>   </li><li>指令执行方式：  <img src="/2022/060947947/17.jpg" class>   </li><li>流水线的性能指标：<br>①吞吐率TP：  <img src="/2022/060947947/18.jpg" class>   ②加速比S：  <img src="/2022/060947947/19.jpg" class>   ③效率E：  <img src="/2022/060947947/20.jpg" class>   <h2 id="影响流水线因素和分类"><a href="#影响流水线因素和分类" class="headerlink" title="影响流水线因素和分类"></a>影响流水线因素和分类</h2>方便流水线设计，把每个阶段耗时取成一样，以最长耗时为标准。  </li><li>影响因素：<br>①结构相关（资源冲突）：  <img src="/2022/060947947/21.jpg" class>   ②数据相关（数据冲突）：<img src="/2022/060947947/22.jpg" class>   ③控制相关（控制冲突）：  <img src="/2022/060947947/23.jpg" class>   </li><li>分类：  <img src="/2022/060947947/24.jpg" class>   <img src="/2022/060947947/25.jpg" class>   </li><li>流水线的多发技术：<br>①超标量技术：  <img src="/2022/060947947/26.jpg" class>   ②超流水技术：  <img src="/2022/060947947/27.jpg" class>   ③超长指令字：  <img src="/2022/060947947/28.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理指令系统</title>
      <link href="/2022/060920601.html"/>
      <url>/2022/060920601.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理指令系统"><a href="#计算机组成原理指令系统" class="headerlink" title="计算机组成原理指令系统"></a>计算机组成原理指令系统</h1><img src="/2022/060920601/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.jpg" class>   <h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><img src="/2022/060920601/8.jpg" class>   <ul><li>定义：指示计算机执行某种操作的命令，是计算机运行的最小功能单位，一台计算机所有指令集合构成该机的指令系统（指令集）。  </li><li>格式：  <img src="/2022/060920601/2.jpg" class>   从四地址指令把指令和数据分开放，引入PC，使得减去下条指令的地址，变为三地址指令：  <img src="/2022/060920601/3.jpg" class>   定长指令字结构：  <img src="/2022/060920601/4.jpg" class>   扩展操作码：   <img src="/2022/060920601/5.jpg" class>   不允许短操作码是长操作码前缀，且使用频率高的指令分配较短的操作码（哈夫曼编码的思想）  <img src="/2022/060920601/6.jpg" class>   </li><li>操作类型：  <img src="/2022/060920601/7.jpg" class>   <h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><img src="/2022/060920601/11.jpg" class>   </li><li>数据存取：（存储器定位到某个存储单元）  <img src="/2022/060920601/9.jpg" class>   尽量把边界对齐减少存取次数：起始地址是字长的整数倍。    <img src="/2022/060920601/10.jpg" class>   </li><li>指令寻址：<br>分别定位指令（下一个指令的地址）和数据（本指令的操作数地址）<br>指令寻址：<br>顺序寻址（PC自增），跳跃寻址（由转移指令指出）  <h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><img src="/2022/060920601/25.jpg" class>   </li><li>操作数类型：  <img src="/2022/060920601/12.jpg" class>   </li><li>数据寻址：<br>根据寻址特征，把形式地址转换为操作数的真实地址，称为有效地址。  <img src="/2022/060920601/13.jpg" class>   ①立即寻址:  <img src="/2022/060920601/14.jpg" class>   ②直接寻址：  <img src="/2022/060920601/15.jpg" class>   ③间接寻址：  <img src="/2022/060920601/16.jpg" class>   ④寄存器寻址：  <img src="/2022/060920601/17.jpg" class>   ⑤寄存器间接寻址：  <img src="/2022/060920601/18.jpg" class>   ⑥隐含寻址：  <img src="/2022/060920601/19.jpg" class>   ⑦基址寻址（偏移寻址）：   <img src="/2022/060920601/20.jpg" class>   EA&#x3D;BR+D（相对地址，直接寻址需要改变）  <img src="/2022/060920601/21.jpg" class>   ⑧变址寻址：  <img src="/2022/060920601/22.jpg" class>   ⑨相对寻址：  <img src="/2022/060920601/23.jpg" class>   </li><li>总结：  <img src="/2022/060920601/24.jpg" class>   </li><li>堆栈寻址和隐含寻址：<br>隐含是隐含了一个操作数，而堆栈则是隐藏了所有操作数。使用寄存器实现就是硬堆栈，存储器实现就是软堆栈。   <img src="/2022/060920601/26.jpg" class>   <h2 id="CISE和RISE"><a href="#CISE和RISE" class="headerlink" title="CISE和RISE"></a>CISE和RISE</h2><img src="/2022/060920601/27.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理存储系统</title>
      <link href="/2022/06079185.html"/>
      <url>/2022/06079185.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理存储系统"><a href="#计算机组成原理存储系统" class="headerlink" title="计算机组成原理存储系统"></a>计算机组成原理存储系统</h1><img src="/2022/06079185/6.jpg" class>   <h2 id="主存模型和寻址"><a href="#主存模型和寻址" class="headerlink" title="主存模型和寻址"></a>主存模型和寻址</h2><img src="/2022/06079185/5.jpg" class>   <ul><li>一个能够完成二进制位读写的单元为存储元，存储体由多个存储元构成。  <img src="/2022/06079185/1.jpg" class>    其中时序控制逻辑如图：  <img src="/2022/06079185/2.jpg" class>    封装称为存储器芯片。其中有若干接口线：地址线，数据线，片选线，读写控制线。总容量&#x3D;存储单元个数X存储字长。  <img src="/2022/06079185/3.jpg" class>   </li><li>寻址：如何定位到一个存储单元（一行）<br>按照字节寻址，每单元1B。按照字寻址，每个单元4B。还有半字2B和双字8B。根据单元个数求出地址线根数，分出若干组，求出每组的组号作为字地址。<br>而此时如何存放一个字？字长为4B，可以根据大端和小端方式来存放字。    <img src="/2022/06079185/4.jpg" class>   <h2 id="半导体存储器RAM"><a href="#半导体存储器RAM" class="headerlink" title="半导体存储器RAM"></a>半导体存储器RAM</h2><img src="/2022/06079185/8.jpg" class>   </li><li>半导体存储器芯片的基本结构：  <img src="/2022/06079185/9.jpg" class>   </li><li>SRAM和DRAM比较：  <img src="/2022/06079185/7.jpg" class>   </li><li>DRAM的刷新：<br>①刷新周期2ms。<br>②每次刷新一行存储单元，并且根据行列等长地址定位（减少选通线的数量）。<br>③根据硬件，读出一行之后重新写入，占用一个读&#x2F;写周期。<br>④整个刷新周期每行刷新一次即可。  <h2 id="半导体存储器ROM"><a href="#半导体存储器ROM" class="headerlink" title="半导体存储器ROM"></a>半导体存储器ROM</h2><img src="/2022/06079185/11.jpg" class>   RAM是易失性存储器，断电丢失数据，所以不能作为主存，所以出现了ROM（存储开机之后需要初始的固定信息）。  <img src="/2022/06079185/10.jpg" class>   <h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><img src="/2022/06079185/16.jpg" class>   </li><li>分类：<br>使用不同材料：①磁表面存储器：磁盘（直接存取）磁带（顺序存储）。②磁芯存储器。③半导体存储器（随机存储ROM，RAM）。④光存储器。  <img src="/2022/06079185/13.jpg" class>   </li><li>性能指标：  <img src="/2022/06079185/14.jpg" class>   </li><li>存储器层次化结构：  <img src="/2022/06079185/15.jpg" class>   <h2 id="主存和CPU的连接"><a href="#主存和CPU的连接" class="headerlink" title="主存和CPU的连接"></a>主存和CPU的连接</h2><img src="/2022/06079185/21.jpg" class>     </li><li>CPU和存储器之间地址线和数据线分别连接，可以通过位扩展和字扩展。<br>位扩展：  <img src="/2022/06079185/17.jpg" class>   字扩展：<br>①线选法：n条线控制n个选片信号  <img src="/2022/06079185/18.jpg" class>   ②译码器片选法：n条线控制2的n次方个选片信号  <img src="/2022/06079185/19.jpg" class>   字位同时扩展：  <img src="/2022/06079185/20.jpg" class>   <h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2>两者都是为了提高存储器的工作速度。<br>存取周期：存取时间+恢复时间（利用恢复时间存取其他数据）  <img src="/2022/06079185/36.jpg" class>   </li><li>双端口RAM：  <img src="/2022/06079185/37.jpg" class>   </li><li>多模块存储器：  <img src="/2022/06079185/38.jpg" class></li></ul><h2 id="高速缓冲存储器局部性原理"><a href="#高速缓冲存储器局部性原理" class="headerlink" title="高速缓冲存储器局部性原理"></a>高速缓冲存储器局部性原理</h2><img src="/2022/06079185/24.jpg" class>   <p>把主存数据调入Cache之后，使CPU和Cache交互处理数据。  </p><img src="/2022/06079185/22.jpg" class>   <img src="/2022/06079185/23.jpg" class>   <h2 id="Cache和主存之间的地址映射"><a href="#Cache和主存之间的地址映射" class="headerlink" title="Cache和主存之间的地址映射"></a>Cache和主存之间的地址映射</h2><img src="/2022/06079185/25.jpg" class>  <img src="/2022/06079185/27.jpg" class>    <img src="/2022/06079185/26.jpg" class>   <h2 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h2><img src="/2022/06079185/30.jpg" class>   <img src="/2022/06079185/28.jpg" class>   <img src="/2022/06079185/29.jpg" class>  <h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><img src="/2022/06079185/31.jpg" class>    <p>根据划分单位不同，分为三种不同虚拟存储器：  </p><ul><li>页式虚拟存储器：  <img src="/2022/06079185/32.jpg" class>   </li><li>段式虚拟存储器：  <img src="/2022/06079185/33.jpg" class>   </li><li>段页式虚拟存储器：  <img src="/2022/06079185/34.jpg" class>   快表TLB：<br>页表，段表放在主存中，收到虚拟地址之后要先访问主存，查询页表和段表进行转换，放在内存中的表称为慢表。为了提高变换速度，用高速缓冲存储器存放常用的页表项，形成了快表TLB。  <img src="/2022/06079185/35.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理数据的表示和运算</title>
      <link href="/2022/060652765.html"/>
      <url>/2022/060652765.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理数据的表示和运算"><a href="#计算机组成原理数据的表示和运算" class="headerlink" title="计算机组成原理数据的表示和运算"></a>计算机组成原理数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><img src="/2022/060652765/2.jpg" class>   <ul><li>符号反映权重：罗马数字Ⅴ&#x3D;5。  </li><li>十进制：数字符号反映权重，且符号位置也反映权重（位权）。  </li><li>进位计数制（逢N进1）：基数（每个数码位所用到的不同符号的个数，r进制的基数为r）。   </li><li>进制之间相互转化：<br>各进制转化为十进制。<br>十进制转化为各进制。（整数部分用短除法：不停除r求余数，先得到的余数是低位。小数部分用乘积取整法：不停乘r取整数，先得到的整数是高位）<br>二进制变为八进制和十六进制。（分别是3或4位变为1位）<br>十六，八进制转化为二进制。（1位变为4或3位）</li><li>真值：符合人类习惯的数字。<br>机器数：数字实际存到机器里的形式（正负号需要添加符号位0&#x2F;1）  <h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><img src="/2022/060652765/1.jpg" class>   </li><li>8421码：四个位表示一个十进制数字。进行加法运算时若结果位于10-15内，后四位就继续加6（0110），进一位.若结果大于15时，后四位也加6（0110）。————有权码</li><li>余3码：8421码+（0011）————无权码  </li><li>2421码：改变权值的定义，5以后的数字首位必为1。  <h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><img src="/2022/060652765/3.jpg" class>   </li><li>ASCII码：8位，128个字符（7位即可高位补0），32-126是可打印字符，其余字符是控制和通信字符。  </li><li>汉字的表示和编码：GB2312-80汉字+各种符号共7445个，定义了区位码（94X94个位置）映射到汉字。为了防止信息交互和ASCII码冲突，+20H得到国标码，进一步得到汉字内码。汉字输入输出通过国标码和汉字内码实现二进制和汉字之间转换。  </li><li>字符串：按字节编址，连续存储，最后一位&#x2F;0。带汉字的时候两个地址存一个汉字。  <h2 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h2><img src="/2022/060652765/5.jpg" class>  位错误导致01反转。<img src="/2022/060652765/4.jpg" class>  </li><li>添加一个奇偶校验位。<br>奇校验码：码中1的个数为奇数。<br>偶校验码：码中1的个数为偶数。但多个位错误有可能检测不出来。    </li><li>求偶校验位：所有位数异或得到。<br>而进行偶校验时候，则把所有位异或看是否为0，为0则正确否则为错误。  <h2 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h2><img src="/2022/060652765/8.jpg" class>  奇偶校验码没法查看哪些错误，只能反馈对&#x2F;错。而海明码则把信息位分组进行偶校验，设置多个校验位，找出出错位置。   </li><li>信息n位，校验k位，则2的k次方大于等于n+k+1。<br>其中校验位的值根据信息位的位置求得，各个分组异或得到。  <img src="/2022/060652765/9.jpg" class>   <img src="/2022/060652765/6.jpg" class>   <img src="/2022/060652765/7.jpg" class>   <h2 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h2><img src="/2022/060652765/12.jpg" class>   </li><li>数据发送和接收方约定一个“除数”，K信息位+R校验位作为”被除数“,添加校验位之后保证余数为0，接收方检查余数是否为0。非0则重传&#x2F;单比特纠错。当2的R次方大于等于K+R+1的时候，CRC码可以纠正一位错误（否则位置大于信息位能表示的位个数）  <img src="/2022/060652765/10.jpg" class>   <img src="/2022/060652765/11.jpg" class>   <h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><img src="/2022/060652765/18.jpg" class>   定点数：小数点固定，比如99.99。<br>浮点数：小数点不固定，比如9.999*10（科学计数法）  </li><li>无符号数：整个机器字长全部二进制位均为数值位，没有符号位，通常是整数。表示范围0-2的n次方-1。  </li><li>有符号数：分别保存整数和小数<br>原码：  <img src="/2022/060652765/13.jpg" class>   <img src="/2022/060652765/14.jpg" class>   反码：<br>若符号为0，则反码和原码相同，否则数值位全部取反。  <img src="/2022/060652765/15.jpg" class>   补码：  <img src="/2022/060652765/16.jpg" class>  移码： <img src="/2022/060652765/17.jpg" class>   方便计算机比较，从前到后位数哪个不是1哪个就小。<h2 id="各种码的作用"><a href="#各种码的作用" class="headerlink" title="各种码的作用"></a>各种码的作用</h2>补码让减法变为加法，节约硬件成本，ALU无须集成减法器。<br>移码实现两个整数的比较大小，用硬件非常方便。<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2>通过移位运算实现乘法和除法。  </li><li>原码的算数移位：<br>符号位不变，数值位移动。<br>右移：高位补0，低位舍弃。舍弃的位&#x3D;0则相当于除2，若舍弃的位不等0，则丢失精度。<br>左移：低位补0，高位舍弃。舍弃的位&#x3D;0则相当于乘2，若舍弃的位不等0，则出现严重误差。 </li><li>反码的算数移位：<br>正数的反码和原码一样，所以左右移位也一样。<br>负数的反码数值位和原码数值位相反，则：<br>右移：高位补1，低位舍弃。<br>左移：低位补1，高位舍弃。  </li><li>补码的算数移位：  <img src="/2022/060652765/19.jpg" class>   <h2 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h2>单纯补充0  <h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2>左右端被移出的数字放到相反的一端。<br>但加法溢出的一位则有一个保留进位。（进位位）  <h2 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h2><img src="/2022/060652765/21.jpg" class>    </li><li>原码的加减：<br>四种加法运算：++，+-，-+，–。<br>四种减法运算：转化为加法。  </li><li>补码的加减：  <img src="/2022/060652765/20.jpg" class>   <h2 id="乘法和除法"><a href="#乘法和除法" class="headerlink" title="乘法和除法"></a>乘法和除法</h2>原码和补码的乘法除法（暂不复习）<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><img src="/2022/060652765/22.jpg" class>   <h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2>定点数表示数字范围有限，但我们不能无限制增加长度。<br>十进制科学计数法：  <img src="/2022/060652765/23.jpg" class>   阶码E反映浮点数的表示范围及小数点的实际位置。<br>尾数的数值部分的位数n反映浮点数的精度。  <img src="/2022/060652765/24.jpg" class>  <h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><img src="/2022/060652765/25.jpg" class>   浮点数标准 <h2 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h2><img src="/2022/060652765/30.jpg" class>   </li><li>ALU功能：算术运算（加减乘除），逻辑运算（与或非异或），辅助功能（移位，求补）。<br>基本结构：输入，输出，控制。  <img src="/2022/060652765/26.jpg" class>   </li><li>最基本的逻辑运算：与或非。优先级：与&gt;或。有分配律，结合律等定义简化电路。<br>复合逻辑：与非，或非，异或，同或（异或的取反）  </li><li>一位全加器FA：  <img src="/2022/060652765/27.jpg" class>   </li><li>串行加法器：  <img src="/2022/060652765/28.jpg" class>  </li><li>串行进位的并行加法器：  <img src="/2022/060652765/29.jpg" class>    一般来说是四个FA组成一个4位的计算装置，依赖于低位的进位才可以进行计算，如何更快的产生进位？<br>利用多个四位的计算装置再次串联  <img src="/2022/060652765/31.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理计算机系统概述</title>
      <link href="/2022/06059000.html"/>
      <url>/2022/06059000.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机发展历程"><a href="#计算机发展历程" class="headerlink" title="计算机发展历程"></a>计算机发展历程</h2><ul><li><img src="/2022/06059000/2.jpg" class>  </li><li>计算机系统&#x3D;软件+硬件。<br>软件分为系统软件（OS，DBMS等）和应用软件。   </li><li>计算机发展历史：<br>硬件发展：  <img src="/2022/06059000/1.jpg" class>   机器字长：计算机一次整数运算能够处理的二进制位数。<br>摩尔定律：集成电路可容纳的晶体管数目，每隔18个月便会增加一倍，整体性能也将提升一倍。<br>软件发展：<br>机器语言和汇编语言，高级编程语言（FORTRAN，PASCAL），操作系统从DOS到Windows。  <h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2></li><li><img src="/2022/06059000/7.jpg" class>   </li><li><img src="/2022/06059000/3.jpg" class>  </li><li><img src="/2022/06059000/4.jpg" class>   特点：①计算机由五大部件组成（IO，存储器，运算器，控制器）。②指令和数据以同等地位位于存储器。③指令和数据二进制表示。④指令由操作码和地址码组成。⑤存储程序（提前存储）。⑥以运算器为中心（数据传送也通过运算器）。  </li><li><img src="/2022/06059000/5.jpg" class>   </li><li><img src="/2022/06059000/6.jpg" class>   <h2 id="认识硬件部件"><a href="#认识硬件部件" class="headerlink" title="认识硬件部件"></a>认识硬件部件</h2><img src="/2022/06059000/12.jpg" class>   </li><li>主存储器基本组成：  <img src="/2022/06059000/8.jpg" class>   </li><li>运算器的基本组成：  <img src="/2022/06059000/9.jpg" class>   </li><li>控制器的基本组成：  <img src="/2022/06059000/10.jpg" class>   </li><li>计算机总体运行步骤：  <img src="/2022/06059000/11.jpg" class>    <h2 id="多级层次结构"><a href="#多级层次结构" class="headerlink" title="多级层次结构"></a>多级层次结构</h2><img src="/2022/06059000/15.jpg" class>   </li><li>下层是上层的基础，上层是下层的扩展：  <img src="/2022/06059000/13.jpg" class>   </li><li>编译程序和解释程序：  <img src="/2022/06059000/14.jpg" class>    <h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><img src="/2022/06059000/19.jpg" class>  </li><li>存储器的性能指标：  <img src="/2022/06059000/16.jpg" class>  </li><li>CPU的性能指标：  <img src="/2022/06059000/17.jpg" class>   </li><li>系统整体性能指标：  <img src="/2022/06059000/18.jpg" class>  使用基准程序来测量计算机处理速度（跑分软件）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js</title>
      <link href="/2022/060432144.html"/>
      <url>/2022/060432144.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>Vue是一个专注于构建web用户界面的 JavaScript 库</li><li>作者：尤雨溪，中国人，早前就职于 Google</li><li>思想：MVVM（Model-View-ViewModel）</li><li>一个渐进式的框架</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-基础案例"><a href="#1-基础案例" class="headerlink" title="1.基础案例"></a>1.基础案例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &#123;msg&#125;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el: &quot;#app&quot;,                data:&#123;                    msg:&#39;hello&#39;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>el：是一个必不可少的属性，用来指定一个页面中已存在的Dom元素来挂载vue实例，其值可以是一个dom元素，也可以是css选择器</p><p>data:存放数据的对象</p><p>{}*2：文本插值，类似于：innerText，会把数据原封不动的显示出来，其中的值可以是JavaScript的表达式</p><p><strong>Vue3</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;VueDemo&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &#123;msg&#125;    &lt;/div&gt;    &lt;script&gt;        const config = &#123;            data()&#123;                return &#123;                    msg:&quot;hello&quot;                &#125;            &#125;        &#125;        //Vue.createApp(config):基于config配置对象，创建一个Vue应用实例        //mount(&quot;#app&quot;):把Vue实例挂载到id为app的div上        const root = Vue.createApp(config).mount(&quot;#app&quot;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-v-html"><a href="#2-v-html" class="headerlink" title="2.v-html"></a>2.v-html</h3><p>v-html：会对数据中的html内容进行解析，显示解析后的结果，类似于Dom的 innerHTML</p><p>v-text: 不会对数据中的html内容进行解析，类似于dom中的 innerText</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &#123;msg&#125;&lt;br&gt;            &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;            &lt;p v-html=&quot;msg&quot;&gt;&lt;/p&gt;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el: &quot;#app&quot;,                data:&#123;                    msg:&#39;&lt;span style=&quot;color:red;&quot;&gt;hello&lt;/span&gt;&#39;                &#125;            &#125;);        &lt;/script&gt;</code></pre><h3 id="3-v-bind"><a href="#3-v-bind" class="headerlink" title="3.v-bind"></a>3.v-bind</h3><p>动态绑定一个或多个属性（简写形式： 冒号）</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;p :align=&quot;align&quot; v-html=&quot;msg&quot;&gt;&lt;/p&gt;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el: &quot;#app&quot;,                data:&#123;                    msg:&#39;&lt;span style=&quot;color:red;&quot;&gt;hello&lt;/span&gt;&#39;,                    align:&#39;right&#39;                &#125;            &#125;);        &lt;/script&gt;</code></pre><h3 id="4-v-model"><a href="#4-v-model" class="headerlink" title="4.v-model"></a>4.v-model</h3><p>绑定表单数据，双向绑定</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el: &quot;#app&quot;,                data:&#123;                    msg:&#39;&lt;span style=&quot;color:red;&quot;&gt;hello&lt;/span&gt;&#39;,                &#125;            &#125;);        &lt;/script&gt;</code></pre><h3 id="5-v-on"><a href="#5-v-on" class="headerlink" title="5.v-on"></a>5.v-on</h3><p>绑定事件处理程序（简写：@）</p><pre><code>        &lt;div id=&quot;app&quot;&gt;                        &lt;input type=&quot;text&quot; :value=&quot;msg&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;del&quot;&gt;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el: &quot;#app&quot;,                data:&#123;                    msg:&#39;&lt;span style=&quot;color:red;&quot;&gt;hello&lt;/span&gt;&#39;,                &#125;,                methods:&#123;                    del()&#123;                        console.log(100);                    &#125;                &#125;            &#125;);        &lt;/script&gt;</code></pre><h3 id="6-v-show"><a href="#6-v-show" class="headerlink" title="6.v-show"></a>6.v-show</h3><p>是否显示元素</p><p>当 v-show的值为：0、空字符串、undefined、null、false、NaN时候隐藏，其他显示</p><pre><code>&lt;p v-show=&quot;isShow&quot;&gt;可能隐藏的内容&lt;/p&gt;data:&#123;    isShow:null&#125;</code></pre><h3 id="7-v-if、v-else-if、v-else"><a href="#7-v-if、v-else-if、v-else" class="headerlink" title="7.v-if、v-else-if、v-else"></a>7.v-if、v-else-if、v-else</h3><pre><code>&lt;p v-if=&quot;isShow&quot;&gt;可能隐藏的内容&lt;/p&gt;&lt;p v-else-if=&quot;elseIf&quot;&gt;else if 部分&lt;/p&gt;&lt;p v-else&gt;else 部分&lt;/p&gt;data:&#123;    isShow:0,    elseIf:0&#125;</code></pre><p>v-if和v-show区别</p><p>v-if：如果为false，删除dom元素，为true：创建dom元素</p><p>v-show：用来显示和隐藏元素</p><h3 id="8-v-for"><a href="#8-v-for" class="headerlink" title="8.v-for"></a>8.v-for</h3><p>循环指令</p><pre><code>&lt;p v-for=&quot;(name,index) in arr&quot; &gt;&#123;index&#125;-&#123;name&#125;&lt;/p&gt;data:&#123;  arr:[&quot;tom&quot;,&quot;marry&quot;,&quot;scott&quot;]&#125;</code></pre><p>html模板</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;                    &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="省市级联案例"><a href="#省市级联案例" class="headerlink" title="省市级联案例"></a>省市级联案例</h2><img src="/2022/060432144/image-20210615152247042.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            省份：            &lt;select @change=&quot;getCity&quot; v-model=&quot;province&quot;&gt;                &lt;option&gt;请选择&lt;/option&gt;                &lt;option v-for=&quot;(item,index) in map.keys()&quot;&gt;&#123;item&#125;&lt;/option&gt;            &lt;/select&gt;            城市：            &lt;select&gt;                &lt;option&gt;请选择&lt;/option&gt;                &lt;option v-for=&quot;(item,index) in cities&quot;&gt;&#123;item&#125;&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    map: new Map([                        [&quot;辽宁&quot;,[&quot;沈阳&quot;,&quot;大连&quot;]],                        [&quot;吉林&quot;,[&quot;长春&quot;,&quot;四平&quot;]],                        [&quot;黑龙江&quot;,[&quot;哈尔滨&quot;,&quot;齐齐哈尔&quot;]]                    ]),                    province:&#39;请选择&#39;,                    cities:[]                &#125;,                methods:&#123;                    getCity()&#123;                        this.cities = this.map.get(this.province);                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="移动列表选中项案例"><a href="#移动列表选中项案例" class="headerlink" title="移动列表选中项案例"></a>移动列表选中项案例</h2><img src="/2022/060432144/image-20210615152334471.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;select size=&quot;10&quot; multiple=&quot;multiple&quot; v-model=&quot;leftSelected&quot;&gt;                &lt;option v-for=&quot;n in leftList&quot; &gt;&#123;n&#125;&lt;/option&gt;            &lt;/select&gt;            &lt;input type=&quot;button&quot; value=&quot;=&gt;&quot; @click=&quot;toRight&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;&lt;=&quot; @click=&quot;toLeft&quot;&gt;            &lt;select size=&quot;10&quot; multiple=&quot;multiple&quot;&gt;                &lt;option v-for=&quot;n in rightList&quot; :value=&quot;n&quot;&gt;&#123;n&#125;&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;                &lt;script&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    leftList:[1,2,3,4,5,6,7,8],                    rightList:[10,20],                    leftSelected:[2,3]                                    &#125;,                methods:&#123;                    toRight()&#123;                        for(n of this.leftSelected)&#123;                            this.rightList.push(n);                        &#125;                        var temp = this.leftList.filter(n=&gt;!this.leftSelected.includes(n));                        this.leftList = temp;                    &#125;,                    toLeft()&#123;                                            &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3实现"><a href="#vue3实现" class="headerlink" title="vue3实现"></a>vue3实现</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;vuedemo&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;style&gt;        select&#123;            width:40px;            height: 200px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;select multiple size=&quot;15&quot; v-model=&quot;leftSel&quot;&gt;            &lt;option v-for=&quot;n in left&quot;&gt;&#123;n&#125;&lt;/option&gt;        &lt;/select&gt;        &lt;input type=&quot;button&quot; value=&quot;=&gt;&quot; @click=&quot;toRight&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;&lt;=&quot; @click=&quot;toLeft&quot;&gt;        &lt;select multiple size=&quot;15&quot; v-model=&quot;rightSel&quot;&gt;            &lt;option v-for=&quot;n in right&quot;&gt;&#123;n&#125;&lt;/option&gt;        &lt;/select&gt;    &lt;/div&gt;    &lt;script&gt;    //vue的配置对象    let config = &#123;        data()&#123;            return &#123;                left:[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;],                right:[],                leftSel:[],                rightSel:[]            &#125;        &#125;,        methods:&#123;            toRight()&#123;                for(let i = 0;i &lt; this.leftSel.length;i++)&#123;                    this.right.push(this.leftSel[i])                    let index = this.left.indexOf(this.leftSel[i]);                    this.left.splice(index,1)                &#125;                this.leftSel.length = 0            &#125;,            toLeft()&#123;                for(let i = 0;i &lt; this.rightSel.length;i++)&#123;                    this.left.push(this.rightSel[i])                    let index = this.right.indexOf(this.rightSel[i]);                    this.right.splice(index,1)                &#125;                this.rightSel.length = 0            &#125;        &#125;    &#125;    //createApp方法返回一个应用程序对象    const app = Vue.createApp(config);    const p = app.mount(&quot;#app&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;</code></pre><h2 id="vue绑定复选框"><a href="#vue绑定复选框" class="headerlink" title="vue绑定复选框"></a>vue绑定复选框</h2><pre><code>&lt;input type=&quot;checkbox&quot; v-model=&quot;all&quot; value=&quot;1&quot;&gt;如果all为数组，选中复选框，value值在数组中，没有选中，value值不在数组中data:&#123;    all:[]&#125;如果all不是数组，选中复选框，all的值为true，不选中，为falsedata:&#123;    all:true&#125;</code></pre><h2 id="vue绑定下拉列表框"><a href="#vue绑定下拉列表框" class="headerlink" title="vue绑定下拉列表框"></a>vue绑定下拉列表框</h2><pre><code>&lt;select v-model=&quot;s&quot; multiple&gt;    &lt;option&gt;1&lt;/option&gt;    &lt;option&gt;2&lt;/option&gt;    &lt;option&gt;3&lt;/option&gt;&lt;/select&gt;如果有multiple属性，需要绑定一个数组,数组中的元素被选中data:&#123;    s:[]&#125;如果没有multiple属性，需要绑定单个值，value等于该值的被选中，没有value属性的，value属性等于innerTextdata:&#123;    s:&#39;2&#39;&#125;</code></pre><h2 id="vue绑定单选按钮"><a href="#vue绑定单选按钮" class="headerlink" title="vue绑定单选按钮"></a>vue绑定单选按钮</h2><pre><code>&lt;input type=&quot;radio&quot; value=&quot;1&quot; v-model=&quot;r&quot;&gt;&lt;input type=&quot;radio&quot; value=&quot;2&quot; v-model=&quot;r&quot;&gt;单选按钮需要绑定到单个值，不能绑定到数组，当v-model的值与value值相等的时候，单选按钮被选中data:&#123;    r:&#39;1&#39;&#125;</code></pre><h2 id="Vue动态添加属性"><a href="#Vue动态添加属性" class="headerlink" title="Vue动态添加属性"></a>Vue动态添加属性</h2><p>默认情况下，vue不跟踪动态添加的属性</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &#123;stu.name&#125;            &lt;input type=&quot;button&quot; value=&quot;动态添加属性&quot; @click=&quot;addAttr&quot;&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    stu:&#123;&#125;                &#125;,                methods:&#123;                    addAttr()&#123;                        // this.stu.name =&quot;tom&quot;;//不行                        // this.$set(this.stu,&quot;name&quot;,&quot;tom&quot;)//可以                        Vue.set(this.stu,&quot;name&quot;,&quot;tom&quot;);                    &#125;                &#125;            &#125;);        &lt;/script&gt;</code></pre><h2 id="综合案例：员工管理"><a href="#综合案例：员工管理" class="headerlink" title="综合案例：员工管理"></a>综合案例：员工管理</h2><img src="/2022/060432144/image-20210616100122588.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            编号:&lt;input type=&quot;text&quot; v-model=&quot;dept.deptno&quot;&gt;&lt;br&gt;            名称:&lt;input type=&quot;text&quot; v-model=&quot;dept.dname&quot;&gt;&lt;br&gt;            地址:&lt;input type=&quot;text&quot; v-model=&quot;dept.loc&quot;&gt;&lt;br&gt;            &lt;input type=&quot;button&quot; value=&quot;添加&quot; @click=&quot;add&quot;&gt;&lt;br&gt;            &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt;                &lt;tbody &gt;                    &lt;tr v-for=&quot;dept,index in depts&quot;&gt;                        &lt;td&gt;&#123;dept.deptno&#125;&lt;/td&gt;                                                &lt;td v-if=&quot;dept.edit&quot;&gt;                            &lt;input type=&quot;text&quot;  v-model=&quot;tempDept.dname&quot; size=&quot;4&quot;&gt;                        &lt;/td&gt;                        &lt;td v-else&gt;&#123;dept.dname&#125;&lt;/td&gt;                                                &lt;td v-if=&quot;dept.edit&quot;&gt;                            &lt;input type=&quot;text&quot;  v-model=&quot;tempDept.loc&quot; size=&quot;4&quot;&gt;                        &lt;/td&gt;                        &lt;td v-else&gt;&#123;dept.loc&#125;&lt;/td&gt;                        &lt;td&gt;                            &lt;input type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;del(index)&quot;&gt;                            &lt;input type=&quot;button&quot; :value=&quot;dept.editBtnValue&quot; @click=&quot;handleClick(dept,index)&quot;&gt;                            &lt;input type=&quot;button&quot; value=&quot;取消&quot; @click=&quot;cancel(dept,index)&quot;&gt;                        &lt;/td&gt;                    &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    depts:[],                    dept:&#123;&#125;,                    tempDept:&#123;&#125;,                    editBtnValue:&quot;编辑&quot;                &#125;,                created()&#123;                    //模仿ajax操作，得到部门集合                    this.depts = [                        &#123;&quot;deptno&quot;:10,&quot;dname&quot;:&quot;市场部&quot;,&quot;loc&quot;:&quot;沈阳&quot;,&quot;editBtnValue&quot;:&quot;编辑&quot;&#125;,                        &#123;&quot;deptno&quot;:20,&quot;dname&quot;:&quot;生产部&quot;,&quot;loc&quot;:&quot;大连&quot;,&quot;editBtnValue&quot;:&quot;编辑&quot;&#125;,                        &#123;&quot;deptno&quot;:30,&quot;dname&quot;:&quot;供应部&quot;,&quot;loc&quot;:&quot;北京&quot;,&quot;editBtnValue&quot;:&quot;编辑&quot;&#125;                    ]                                    &#125;,                methods:&#123;                    del(index)&#123;                        if(confirm(&quot;是否删除?&quot;))&#123;                            this.depts.splice(index,1);                        &#125;                    &#125;,                    add()&#123;                        this.depts.push(this.dept);                        this.dept = &#123;&#125;;                    &#125;,                    handleClick(dept,index)&#123;                        if(dept.editBtnValue == &quot;编辑&quot;)&#123;                            this.$set(dept,&quot;edit&quot;,true)                            dept.editBtnValue = &quot;保存&quot;;                            this.tempDept.dname = dept.dname;                            this.tempDept.loc = dept.loc;                                                    &#125;else&#123;                            dept.edit = false;                            dept.editBtnValue = &quot;编辑&quot;;                                                        dept.dname = this.tempDept.dname;                            dept.loc = this.tempDept.loc;                        &#125;                                            &#125;,                    cancel(dept,index)&#123;                        dept.edit = false;                        dept.editBtnValue = &quot;编辑&quot;;                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3实现-1"><a href="#vue3实现-1" class="headerlink" title="vue3实现"></a>vue3实现</h3><pre><code>&lt;template&gt;员工管理  &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt;    &lt;tr v-for=&quot;emp,index in emps&quot; :key=&quot;emp.empno&quot;&gt;      &lt;template v-if=&quot;emp.edit&quot;&gt;        &lt;td&gt;&#123;emp.empno&#125;&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&quot;copyEmps[index].ename&quot;&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type=&quot;text&quot; v-model=&quot;copyEmps[index].sal&quot;&gt;&lt;/td&gt;        &lt;td&gt;          &lt;input type=&quot;button&quot; value=&quot;保存&quot; @click=&quot;update(index)&quot;&gt;          &lt;input type=&quot;button&quot; value=&quot;取消&quot; @click=&quot;cancel(index)&quot;&gt;        &lt;/td&gt;      &lt;/template&gt;      &lt;template v-else&gt;        &lt;td&gt;&#123;emp.empno&#125;&lt;/td&gt;        &lt;td&gt;&#123;emp.ename&#125;&lt;/td&gt;        &lt;td&gt;&#123;emp.sal&#125;&lt;/td&gt;        &lt;td&gt;          &lt;input type=&quot;button&quot; value=&quot;编辑&quot; @click=&quot;edit(index)&quot;&gt;          &lt;input type=&quot;button&quot; value=&quot;删除&quot; @click=&quot;del(index)&quot;&gt;        &lt;/td&gt;      &lt;/template&gt;    &lt;/tr&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Emp&quot;,  data()&#123;    return &#123;      emps:[        &#123;empno:1,ename:&quot;tom&quot;,sal:3000&#125;,        &#123;empno:2,ename:&quot;scott&quot;,sal:2000&#125;,        &#123;empno:3,ename:&quot;marry&quot;,sal:3300&#125;      ],      copyEmps:[]    &#125;  &#125;,  created() &#123;      //初始化的时候，复制员工数组    let s = JSON.stringify(this.emps);    this.copyEmps = JSON.parse(s);  &#125;,  methods:&#123;    edit(index)&#123;      this.emps[index].edit = true    &#125;,    update(index)&#123;      this.emps[index].edit = false      this.emps[index] = &#123;...this.copyEmps[index]&#125;//克隆元素    &#125;,    cancel(index)&#123;      this.emps[index].edit = false      this.copyEmps[index] = &#123;...this.emps[index]&#125;    &#125;,    del(index)&#123;      if(confirm(&quot;是否删除&quot;))&#123;        this.emps.splice(index,1)        this.copyEmps.splice(index,1)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>作用：处理一些复杂逻辑</p><p><strong>计算属性将基于它们的响应依赖关系缓存</strong>。</p><p>计算属性只会在相关响应式依赖发生改变时重新求值。</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            商品单价：&lt;input type=&quot;text&quot; v-model=&quot;price&quot;&gt;&lt;br&gt;            商品数量：&lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;&lt;br&gt;            总额：&#123;total&#125;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    username:&quot;marry&quot;,                    price:&#39;&#39;,                    num:&#39;&#39;                &#125;,                computed:&#123;                    un()&#123;                        return this.username.toUpperCase();                    &#125;,                    total()&#123;                        return this.price * this.num;                    &#125;                &#125;            &#125;);        &lt;/script&gt;</code></pre><p>vue3</p><pre><code>&lt;div id=&quot;app&quot;&gt;  商品单价：&lt;input type=&quot;text&quot; v-model=&quot;price&quot;&gt;&lt;br&gt;  商品数量：&lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;&lt;br&gt;  总额：&#123;total&#125;&lt;/div&gt;computed:&#123;      total()&#123;          return this.total = this.price * this.num;      &#125;    &#125;</code></pre><p>上面的方式会产生一个警告：</p><img src="/2022/060432144/image-20220604094238412.png" class><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  商品单价：&lt;input type=&quot;text&quot; v-model=&quot;price&quot;&gt;&lt;br&gt;  商品数量：&lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;&lt;br&gt;  总额：&#123;total&#125;&lt;/div&gt;&lt;script&gt;  const config = &#123;    name:&quot;root&quot;,    data()&#123;      return &#123;        price:&#39;&#39;,        num:&#39;&#39;      &#125;    &#125;,    computed:&#123;      total:&#123;        get()&#123;          return this.total = this.price * this.num;        &#125;,        set(newValue)&#123;                        &#125;      &#125;    &#125;  &#125;  //Vue.createApp(config):基于config配置对象，创建一个Vue应用实例  //mount(&quot;#app&quot;):把Vue实例挂载到id为app的div上  const app = Vue.createApp(config)  const vm = app.mount(&quot;#app&quot;);&lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h2><p>可以通过watch来响应数据的变化</p><p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;input type=&quot;text&quot; v-model=&quot;km&quot;&gt;千米&lt;br&gt;            &lt;input type=&quot;text&quot; v-model=&quot;m&quot;&gt;米&lt;br&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    km:&#39;&#39;,                    m:&#39;&#39;                &#125;,                watch:&#123;                    km(newValue,oldValue)&#123;                        this.m = newValue * 1000;                    &#125;,                    m(newValue,oldValue)&#123;                        this.km = newValue/1000;                    &#125;                &#125;            &#125;);        &lt;/script&gt;</code></pre><p>监听对象</p><pre><code>&lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            商品单价：&lt;input type=&quot;text&quot; v-model=&quot;good.price&quot;&gt;&lt;br&gt;            商品数量：&lt;input type=&quot;text&quot; v-model=&quot;good.num&quot;&gt;&lt;br&gt;            总额：&lt;span v-if=&quot;!isNaN(good.total)&quot;&gt;&#123;good.total&#125;&lt;/span&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    good:&#123;                                            &#125;                &#125;                watch:&#123;                    good:&#123;                        //handle方法名固定                        handler(newValue,oldValue)&#123;                            newValue.total = newValue.price * newValue.num;                        &#125;,                        deep:true                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;</code></pre><p>vue3</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  商品单价：&lt;input type=&quot;text&quot; v-model=&quot;good.price&quot;&gt;&lt;br&gt;  商品数量：&lt;input type=&quot;text&quot; v-model=&quot;good.num&quot;&gt;&lt;br&gt;  总额：&lt;span v-if=&quot;!isNaN(good.total)&quot;&gt;&#123;good.total&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;  const config = &#123;    name:&quot;root&quot;,    data()&#123;      return &#123;        good:&#123;&#125;      &#125;    &#125;,    watch:&#123;      good:&#123;        handler(newValue,oldValue)&#123;          this.good.total = this.good.price * this.good.num;        &#125;,        deep:true      &#125;    &#125;  &#125;  const app = Vue.createApp(config)  const vm = app.mount(&quot;#app&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="v-model参数特性"><a href="#v-model参数特性" class="headerlink" title="v-model参数特性"></a>v-model参数特性</h2><ol><li><p>lazy：在默认情况下，v-mode在每次 input 事件触发后，将输入框的值与数据同步，可以使用 lazy 修饰符，从而转变为使用 change 事件进行同步</p><pre><code>    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;input type=&quot;text&quot; v-model.lazy=&quot;km&quot;&gt;千米&lt;br&gt;            &lt;input type=&quot;text&quot; v-model=&quot;m&quot;&gt;米&lt;br&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    km:&#39;&#39;,                    m:&#39;&#39;                &#125;,                watch:&#123;                    km(newValue,oldValue)&#123;                        this.m = newValue * 1000;                    &#125;,                    m(newValue,oldValue)&#123;                        this.km = newValue/1000;                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;</code></pre></li><li><p>number：如果想自动将用户输入值类型转换为数值类型，可以使用number修饰符</p><p>可通过vue开发者工具查看对象数据类型</p><pre><code>&lt;input type=&quot;text&quot; v-model.number=&quot;km&quot;&gt;千米&lt;br&gt;</code></pre></li><li><p>trim:自动过滤用户输入的首尾空白符，使用trim去掉首尾空白符</p><p>可通过vue开发者工具查看对象数据类型</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    msg:&#39;tom&#39;                &#125;            &#125;);        &lt;/script&gt;</code></pre></li></ol><h2 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h2><ol><li><p>绑定 class 类样式（值是一个对象）</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;style&gt;            .class1&#123;                color:red;            &#125;            .class2&#123;                font-size: 40px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;div :class=&quot;&#123;class1:class1Style,class2:class2Style&#125;&quot;&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    class1Style:true,                    class2Style:true                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>可以把一个数组传递给class属性</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;style&gt;            .class1&#123;                color:red;            &#125;            .class2&#123;                font-size: 40px;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;div :class=&quot;[class1Style,class2Style]&quot;&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    class1Style:&#39;class1&#39;,                    class2Style:&quot;class2&quot;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>style对象语法</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;div :style=&quot;&#123;&#39;color&#39;:color,&#39;font-size&#39;:size&#125;&quot;&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    color:&#39;blue&#39;,                    size:&#39;50px&#39;                &#125;            &#125;);        &lt;/script&gt;</code></pre></li><li><p>style数组语法</p><pre><code>        &lt;div id=&quot;app&quot;&gt;            &lt;div :style=&quot;[style1,style2]&quot;&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    style1:&#123;&#39;color&#39;:&#39;red&#39;&#125;,                    style2:&#123;&#39;font-size&#39;:&#39;20px&#39;&#125;                &#125;            &#125;);        &lt;/script&gt;</code></pre></li></ol><h2 id="定时器使用案例"><a href="#定时器使用案例" class="headerlink" title="定时器使用案例"></a>定时器使用案例</h2><img src="/2022/060432144/image-20210616113432389.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;div&gt;&#123;name&#125;&lt;/div&gt;            &lt;input type=&quot;button&quot; value=&quot;开始&quot; @click=&quot;startGame&quot;&gt;            &lt;input type=&quot;button&quot; value=&quot;停止&quot; @click=&quot;stopGame&quot;&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    name:&#39;请选择&#39;,                    arr:[&quot;唐僧&quot;,&quot;悟空&quot;,&quot;八戒&quot;,&quot;沙僧&quot;,&quot;小白龙&quot;],                    t:&#39;&#39;,                    index:0                &#125;,                methods:&#123;                    startGame()&#123;                        this.index = parseInt(Math.random()*this.arr.length);                        this.name = this.arr[this.index];                                                this.t = setTimeout(this.startGame,100);                    &#125;,                    stopGame()&#123;                        clearTimeout(this.t);                        this.arr.splice(this.index,1);                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>vue3</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;摇奖&lt;/title&gt;  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #style1&#123;      color:blue;      font-size: 180px;      text-align: center;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div id=&quot;style1&quot;&gt;&#123;name&#125;&lt;/div&gt;  &lt;input type=&quot;button&quot;  value=&quot;开始&quot; @click=&quot;startGame&quot; ref=&quot;startGame&quot;&gt;  &lt;input type=&quot;button&quot;  value=&quot;结束&quot; @click=&quot;endGame&quot; ref=&quot;endGame&quot;&gt;&lt;/div&gt;&lt;script&gt;  const config = &#123;    data()&#123;      return &#123;        stus:[&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;,&quot;赵六&quot;,&quot;马七&quot;],        name:&#39;请选择&#39;,        t:null,        index:&#39;&#39;,        b:false      &#125;    &#125;,    methods:&#123;      startGame()&#123;        this.$refs.endGame.focus();        if(this.stus.length &gt; 0)&#123;          this.index = parseInt(Math.random()*this.stus.length)          this.name = this.stus[this.index];          this.t = setTimeout(this.startGame,100)        &#125;else&#123;          alert(&quot;摇奖结束&quot;)        &#125;      &#125;,      endGame()&#123;        clearTimeout(this.t)        this.stus.splice(this.index,1)        this.$refs.startGame.focus();      &#125;    &#125;,    mounted() &#123;      this.$refs.startGame.focus();    &#125;  &#125;  Vue.createApp(config).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="定时器练习"><a href="#定时器练习" class="headerlink" title="定时器练习"></a>定时器练习</h3><p>点击开始按钮，随机生成4个各不相同的数，并滚动显示</p><p>点击停止按钮的时候，求和</p><img src="/2022/060432144/image-20210616115025322.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;vuedemo&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;div&gt;            &lt;input type=&quot;button&quot; v-for=&quot;num in arr&quot; :value=&quot;num&quot;&gt;            和：&#123;sum&#125;        &lt;/div&gt;        &lt;input type=&quot;button&quot; value=&quot;开始&quot; @click=&quot;startGame&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;结束&quot; @click=&quot;stopGame&quot;&gt;    &lt;/div&gt;    &lt;script&gt;    //vue的配置对象    let config = &#123;        data()&#123;            return &#123;                arr:[0,0,0,0],                t:-1,//定时器                sum:0            &#125;        &#125;,        methods:&#123;            startGame()&#123;                this.arr.length = 0;                this.sum = &#39;&#39;                /*for(let i = 0;i &lt; 4;i++)&#123;                    let n = parseInt(Math.random()*10);                    this.arr.push(n);                &#125;*/                //生成各不相同的4个数                while(true)&#123;                    let n = parseInt(Math.random()*10);                    if(this.arr.indexOf(n) == -1)&#123;                        this.arr.push(n);                    &#125;                    if(this.arr.length == 4) break;                &#125;                this.t = setTimeout(this.startGame,100)            &#125;,            stopGame()&#123;                clearTimeout(this.t)                this.sum = 0;                for(let i = 0;i &lt; 4;i++)&#123;                    this.sum += this.arr[i]                &#125;            &#125;        &#125;    &#125;    //createApp方法返回一个应用程序对象    const app = Vue.createApp(config);    const p = app.mount(&quot;#app&quot;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="vue3键盘事件"><a href="#vue3键盘事件" class="headerlink" title="vue3键盘事件"></a>vue3键盘事件</h2><p>Vue 提供了绝大多数常用的按键码的别名:</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>使用</p><pre class=" language-javascript"><code class="language-javascript">@keyup<span class="token punctuation">.</span>enter<span class="token operator">=</span>showInfo@keydown<span class="token punctuation">.</span>tab<span class="token operator">=</span>showInfo</code></pre><h3 id="登录案例"><a href="#登录案例" class="headerlink" title="登录案例"></a>登录案例</h3><p>回车触发登录</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;登录&lt;/title&gt;  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #style1&#123;      color:blue;      font-size: 180px;      text-align: center;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div @keyup.enter=&quot;login&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;手机号码&quot;&gt;    &lt;input type=&quot;text&quot; placeholder=&quot;密码&quot;&gt;    &lt;button  @click=&quot;login&quot; &gt;登录&lt;/button&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;  const config = &#123;    data()&#123;      return &#123;      &#125;    &#125;,    methods:&#123;      login()&#123;        console.log(&quot;login&quot;)      &#125;    &#125;  &#125;  Vue.createApp(config).mount(&quot;#app&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="游戏案例"><a href="#游戏案例" class="headerlink" title="游戏案例"></a>游戏案例</h3><p>在document对象上触发onkeydown事件</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;游戏&lt;/title&gt;  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;  &lt;style&gt;    #style1&#123;      color:blue;      font-size: 180px;      text-align: center;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div id=&quot;style1&quot;&gt;    请选择  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;  const config = &#123;    data()&#123;      return &#123;      &#125;    &#125;,    methods:&#123;      keyDown(e)&#123;        if(e.code == &quot;Enter&quot;)&#123;          this.startGame()        &#125;else if(e.code == &quot;Space&quot;)&#123;          this.endGame()        &#125;      &#125;,      startGame()&#123;        alert(&quot;开始游戏&quot;)      &#125;,      endGame()&#123;        alert(&quot;结束游戏&quot;)      &#125;    &#125;,    created()&#123;      document.addEventListener(&quot;keydown&quot;,this.keyDown);    &#125;  &#125;  Vue.createApp(config).mount(&quot;#app&quot;)&lt;/script&gt;</code></pre><h2 id="VueCli"><a href="#VueCli" class="headerlink" title="VueCli"></a>VueCli</h2><ol><li><p>vue.js开发的标准工具</p></li><li><p>Node.js:是一个基于 Chrome V8引擎的 JavaScript运行时环境（需要安装）</p></li><li><p>npm：是随着node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写好的第三方包到本地</p><p>测试：npm –version</p></li><li><p>配置npm源：</p><pre><code>npm config set registry http://192.168.1.190:5001/repository/dhee-group-npm/外网npm config set registry http://registry.npm.taobao.org/</code></pre></li><li><p>安装vuecli</p><pre><code>npm i -g @vue/cli@4.5.13//安装最新版npm i -g @vue/cli</code></pre></li></ol><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><pre><code>vue create 项目名</code></pre><p>单页面应用</p><h3 id="在Idea中打开项目"><a href="#在Idea中打开项目" class="headerlink" title="在Idea中打开项目"></a>在Idea中打开项目</h3><img src="/2022/060432144/image-20220522162047005.png" class><p>选择上面创建好的Vue项目</p><img src="/2022/060432144/image-20220522162142496.png" class><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><pre><code>npm run serve</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ol><li><p>定义：可以复用的Vue实例，且带有一个名字</p></li><li><p>使用</p><ul><li><p>定义组件</p><pre><code>            const mybtn = &#123;                template:                `                &lt;button type=&quot;button&quot; @click=&quot;add&quot;&gt;点击 &#123;num&#125;&lt;/button&gt;                `,                //data必须是一个方法                data()&#123;                    return&#123;                        num:0                    &#125;                &#125;,                methods:&#123;                    add()&#123;                        this.num++;                    &#125;                &#125;            &#125;;                        const mybtn = Vue.extend(&#123;                        &#125;);</code></pre></li><li><p>注册</p><ul><li><p>全局注册</p><pre><code>Vue.component(&quot;mybtn&quot;,mybtn);</code></pre></li><li><p>局部注册</p><pre><code>            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;,                components:&#123;                    &quot;mybtn&quot;:mybtn//简写：mybtn                &#125;            &#125;);</code></pre></li></ul></li><li><p>使用</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;mybtn&gt;&lt;/mybtn&gt;&lt;/div&gt;</code></pre></li></ul><p>vue3，在Vue-cli中全局注册</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import Demo1 from &quot;./components/Demo1&quot;;const app = createApp(App)//全局注册组件app.component(&quot;Demo1&quot;,Demo1)app.mount(&#39;#app&#39;)</code></pre><p>任意组件中使用</p><pre><code>&lt;template&gt;  &lt;Demo1&gt;&lt;/Demo1&gt;&lt;/template&gt;</code></pre><p>vue3局部注册同vue2相同</p></li><li><p>vue组件命名（非单文件组件中）</p><p>在模板中（挂载点）的标签名（组件名），使用短横线命名法（单词之间用短横线分隔），所有字符小写</p></li><li><p>template编写方法</p><ul><li><p>直接写到vue实例对象中</p></li><li><p>使用<template>标签</template></p><pre><code>        &lt;template id=&quot;btn&quot;&gt;            &lt;button type=&quot;button&quot; @click=&quot;add&quot;&gt;点击 &#123;num&#125;&lt;/button&gt;        &lt;/template&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            const mybtn = &#123;                template:&quot;#btn&quot;,                data()&#123;                    return&#123;                        num:0                    &#125;                &#125;,                methods:&#123;                    add()&#123;                        this.num++;                    &#125;                &#125;            &#125;;            //全局注册            // Vue.component(&quot;myBtn&quot;,mybtn);            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;,                components:&#123;                    &quot;myBtn&quot;:mybtn                &#125;            &#125;);        &lt;/script&gt;</code></pre></li></ul></li></ol><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li><p>使用 prop 属性向组件传值，在组件中定义属性接收值</p><pre><code>//父组件&lt;my-btn num=&quot;10&quot;&gt;&lt;/my-btn&gt;//子组件        &lt;template id=&quot;btn&quot;&gt;            &lt;button type=&quot;button&quot; @click=&quot;add&quot;&gt;点击 &#123;num&#125;&lt;/button&gt;        &lt;/template&gt;            const mybtn = &#123;                template:&quot;#btn&quot;,                data()&#123;                    return&#123;                        n:&#39;&#39;                    &#125;                &#125;,                created()&#123;                    this.n = this.num;//初始同步                &#125;,                methods:&#123;                    add()&#123;                        this.n++;                    &#125;                &#125;,                props:[                    &quot;num&quot;                ]            &#125;;</code></pre></li><li><p>在子组件中，可以向使用data的属性一样，来使用props中的属性</p></li><li><p>注意：在子组件中不要去改变属性的值</p></li></ol><h2 id="通过-自定义事件-子组件向父组件传值"><a href="#通过-自定义事件-子组件向父组件传值" class="headerlink" title="通过 自定义事件 子组件向父组件传值"></a>通过 自定义事件 子组件向父组件传值</h2><ol><li><p>在 子组件中 触发自定义事件（什么时候想向父组件传值，什么时候触发）</p><pre><code>this.$emit(&quot;retval&quot;,this.n);</code></pre></li><li><p>父组件中，订阅子组件触发的自定义事件</p><pre><code>&lt;my-btn :num=&quot;num&quot; @retval=&quot;getValue($event)&quot;&gt;&lt;/my-btn&gt;</code></pre></li><li><p>注意：自定义的事件名与组件命名规则相同</p></li></ol><p>vue3</p><p>子组件</p><pre><code>&lt;template&gt;  Demo1  &lt;button @click=&quot;send&quot;&gt;传递值&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Demo1&quot;,  props:[      &quot;num&quot;  ],  //声明可以触发的事件列表  emits:[    &#39;retval&#39;  ],  data()&#123;    return &#123;      age:22    &#125;  &#125;,  methods:&#123;    send()&#123;      this.$emit(&quot;retval&quot;,this.age);    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>父组件</p><pre><code>&lt;template&gt;  &lt;Demo1 num=&quot;10&quot; @retval=&quot;getAge($event)&quot;&gt;&lt;/Demo1&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,  components: &#123;  &#125;,  methods:&#123;    getAge(age)&#123;      console.log(age)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="组件传值综合练习"><a href="#组件传值综合练习" class="headerlink" title="组件传值综合练习"></a>组件传值综合练习</h2><img src="/2022/060432144/image-20210616152932331.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;div&gt;        &lt;child v-for=&quot;q in n&quot; :endval=&quot;endval&quot; :isstart=&quot;isstart&quot; @myevent=&quot;getVal($event)&quot; style=&quot;width:30px&quot;&gt;&lt;/child&gt;        &lt;div&gt;            &lt;input type=&quot;button&quot; value=&quot;开始&quot; @click=&quot;isstart=true&quot; &gt;            &lt;input type=&quot;button&quot; value=&quot;停止&quot; @click=&quot;isstart=false&quot; &gt;            和:&#123;sum&#125;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;input type=&quot;button&quot; v-model=&quot;num&quot;&gt;&lt;/template&gt;&lt;script&gt;    let child = &#123;        template: &quot;#child&quot;,        props: [            &quot;endval&quot;,            &quot;isstart&quot;        ],        created() &#123;            this.start();        &#125;,        data() &#123;            return &#123;                num: &#39;0&#39;,//按钮上默认数字                b:false//是否已返回数            &#125;        &#125;,        methods: &#123;            start() &#123;                setTimeout(this.start, 100);//循环执行，始终监听是否重新开始运行                if (this.isstart) &#123;                    this.num = parseInt(Math.random() * this.endval) + 1;//产生随机数                    this.b = false;//重新开始                &#125;else&#123;                    if(!this.b)&#123;                        this.$emit(&quot;myevent&quot;,this.num);//触发自定义事件，并返回数                        this.b = true//已返回数                    &#125;                &#125;            &#125;        &#125;    &#125;    let app = new Vue(&#123;        el: &quot;#app&quot;,        components: &#123;            child        &#125;,        data: &#123;            isstart: true,//是否开始            endval: 35,//数字范围            nums:[],//存储组件返回的数            sum:0,//和            n:10,//按钮个数            i:0//已返回数字的按钮数        &#125;,        methods:&#123;            getVal(num)&#123;                this.nums.push(num);//把新产生的数添加到数组中                this.i++;                //全部组件都返回数后计算                if(this.i == this.n)&#123;                    this.sum = 0;//重新开始计算                    for(let p of this.nums)&#123;                        this.sum += p;                    &#125;                    this.nums = [];//重新开始计算                    this.i = 0;//重新开始计算                &#125;            &#125;        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>vue3的cli实现</p><p>ChildCom</p><ul><li><p>接收父组件是否开始的消息和随机数范围</p></li><li><p>负责把随机生成的数显示在按钮上</p></li><li><p>接收父组件停止命令，返回此刻产生的随机数给父组件</p></li></ul><pre><code>&lt;template&gt;  &lt;input type=&quot;button&quot; v-model=&quot;num&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;ChildCom&quot;,  props: [    &quot;endval&quot;,    &quot;isstart&quot;  ],  created() &#123;    this.start();  &#125;,  data() &#123;    return &#123;      num: &#39;0&#39;,//按钮上默认数字      b:false//是否已返回数    &#125;  &#125;,  emits:[      &quot;myevent&quot;  ]  ,  methods: &#123;    start() &#123;      setTimeout(this.start, 100);//循环执行，始终监听是否重新开始运行      if (this.isstart) &#123;        this.num = parseInt(Math.random() * this.endval) + 1;//产生随机数        this.b = false;//重新开始      &#125;else&#123;        if(!this.b)&#123;          this.$emit(&quot;myevent&quot;,this.num);//触发自定义事件，并返回数          this.b = true//已返回数        &#125;      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>父组件：ParentCom</p><ul><li>控制子组件的开始和结束</li><li>接收子组件返回的数</li><li>控制子组件数量</li><li>求子组件返回数的和</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;ChildCom v-for=&quot;q in n&quot; :key=&quot;q&quot; :endval=&quot;endval&quot; :isstart=&quot;isstart&quot; @myevent=&quot;getVal($event)&quot; style=&quot;width:30px&quot;&gt;&lt;/ChildCom&gt;    &lt;div&gt;      &lt;input type=&quot;button&quot; value=&quot;开始&quot; @click=&quot;isstart=true&quot; &gt;      &lt;input type=&quot;button&quot; value=&quot;停止&quot; @click=&quot;isstart=false&quot; &gt;      和:&#123;sum&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildCom from &#39;./ChildCom&#39;export default &#123;  name: &quot;ParentCom&quot;,  data()&#123;    return &#123;      isstart: true,//是否开始      endval: 35,//数字范围      nums:[],//存储组件返回的数      sum:0,//和      n:20,//按钮个数      i:0//已返回数字的按钮数    &#125;  &#125;,  components:&#123;    ChildCom  &#125;,  methods:&#123;    getVal(num)&#123;      this.nums.push(num);//把新产生的数添加到数组中      this.i++;      //全部组件都返回数后计算      if(this.i == this.n)&#123;        this.sum = 0;//重新开始计算        for(let p of this.nums)&#123;          this.sum += p;        &#125;        this.nums = [];//重新开始计算        this.i = 0;//重新开始计算      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><p>App.vue</p><pre><code>&lt;template&gt;  &lt;ParentCom&gt;&lt;/ParentCom&gt;&lt;/template&gt;&lt;script&gt;import ParentCom from &quot;./components/ParentCom&quot;;export default &#123;  name: &#39;App&#39;,  components: &#123;    ParentCom  &#125;,  methods:&#123;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h2 id="单向数据流讲解"><a href="#单向数据流讲解" class="headerlink" title="单向数据流讲解"></a>单向数据流讲解</h2><p>单向数据流（堆可以修改，栈不可修改）</p><p>我们都知道, 父传子的数据, 是单向数据流,即子组件不能直接修改, 父组件传递过来的值</p><p>但实际上, 对于修改值, 真正是:基本数据类型不可修改，复杂数据类型不要修改引用地址（栈），它的值可以随便修改</p><h3 id="向子组件传值，修改后再返回"><a href="#向子组件传值，修改后再返回" class="headerlink" title="向子组件传值，修改后再返回"></a>向子组件传值，修改后再返回</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;child :com-num=&quot;num&quot; @myevent=&quot;num=$event&quot; &gt;&lt;/child&gt;      &lt;!--&lt;child :com-num.sync=&quot;num&quot;&gt;&lt;/child&gt;--&gt;      &lt;div&gt;          &#123;num&#125;      &lt;/div&gt;  &lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;div&gt;        &lt;input type=&quot;text&quot; :value=&quot;comNum&quot;&gt;        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;传出&quot; @click=&quot;toVal&quot;&gt;    &lt;/div&gt;&lt;/template&gt;  &lt;script&gt;      let child = &#123;          template:&quot;#child&quot;,          props:[              &quot;comNum&quot;          ],          data()&#123;              return &#123;                  num:&#39;&#39;              &#125;          &#125;,          methods: &#123;              toVal()&#123;                  // this.$emit(&quot;update:comNum&quot;,this.num)                  this.$emit(&quot;myevent&quot;,this.num)              &#125;          &#125;      &#125;    var app = new Vue(&#123;      el:&quot;#app&quot;,      data:&#123;        num:10      &#125;,        components:&#123;          child        &#125;    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>简化写法：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;!--&lt;child :com-num=&quot;num&quot; @myevent=&quot;num=$event&quot; &gt;&lt;/child&gt;--&gt;    &lt;!--.sync表示异步修改，需要组件内支持，即自定义事件名为：update:组件属性名--&gt;    &lt;child :com-num.sync=&quot;num&quot;&gt;&lt;/child&gt;    &lt;div&gt;        &#123;num&#125;    &lt;/div&gt;&lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;div&gt;        &lt;input type=&quot;text&quot; :value=&quot;comNum&quot;&gt;        &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;传出&quot; @click=&quot;toVal&quot;&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = &#123;        template: &quot;#child&quot;,        props: [            &quot;comNum&quot;        ],        data() &#123;            return &#123;                num: &#39;&#39;            &#125;        &#125;,        methods: &#123;            toVal() &#123;                //update:comNum中的comNum与属性名相同，前缀固定为update                this.$emit(&quot;update:comNum&quot;, this.num)                // this.$emit(&quot;myevent&quot;,this.num)            &#125;        &#125;    &#125;    var app = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            num: 10        &#125;,        components: &#123;            child        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3中cli实现"><a href="#vue3中cli实现" class="headerlink" title="vue3中cli实现"></a>vue3中cli实现</h3><p>如果直接修改父组件传递过来的属性，vue3中会报错：Unexpected mutation of “sonProp” prop  vue&#x2F;no-mutating-props（不能修改的属性）</p><pre><code>change()&#123;      this.sonProp = this.sonProp + 1;//报错&#125;</code></pre><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h4><p>子组件：Child1</p><pre><code>&lt;template&gt;  &lt;div&gt;&#123;sonProp&#125;&lt;/div&gt;  &lt;button @click=&quot;change&quot;&gt;返回&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child1&quot;,  props:[      &quot;sonProp&quot;  ],  emits:[      &quot;retVal&quot;  ],  methods:&#123;    change()&#123;      this.$emit(&quot;retVal&quot;,this.sonProp+1);    &#125;  &#125;,  data()&#123;    return&#123;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件：Parent1</p><pre><code>&lt;template&gt;  &lt;Child1 :sonProp=&quot;num&quot; @retVal=&quot;num=$event&quot;&gt;&lt;/Child1&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &#39;./Child1&#39;export default &#123;  name: &quot;Parent1&quot;,  components:&#123;    Child1  &#125;,  data()&#123;    return&#123;      num:0    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h4 id="简化写法"><a href="#简化写法" class="headerlink" title="简化写法"></a>简化写法</h4><p>子组件：Child1</p><pre><code>&lt;template&gt;  &lt;div&gt;&#123;sonProp&#125;&lt;/div&gt;  &lt;button @click=&quot;change&quot;&gt;返回&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child1&quot;,  props:[      &quot;sonProp&quot;  ],  emits:[      &quot;update:sonProp&quot;  ],  methods:&#123;    change()&#123;      this.$emit(&quot;update:sonProp&quot;,this.sonProp+1);    &#125;  &#125;,  data()&#123;    return&#123;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件：Parent1</p><pre><code>&lt;template&gt;  &lt;Child1 v-model:sonProp=&quot;num&quot;&gt;&lt;/Child1&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &#39;./Child1&#39;export default &#123;  name: &quot;Parent1&quot;,  components:&#123;    Child1  &#125;,  data()&#123;    return&#123;      num:0    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>App.vue</p><pre><code>&lt;template&gt;  &lt;Parent1&gt;&lt;/Parent1&gt;&lt;/template&gt;&lt;script&gt;import Parent1 from &quot;./components/Parent1&quot;;export default &#123;  name: &#39;App&#39;,  components: &#123;    Parent1  &#125;&#125;&lt;/script&gt;</code></pre><h4 id="多属性"><a href="#多属性" class="headerlink" title="多属性"></a>多属性</h4><p>子组件：Child1</p><pre><code>&lt;template&gt;  &lt;div&gt;&#123;sonProp&#125;&lt;/div&gt;  &lt;div&gt;&#123;prop2&#125;&lt;/div&gt;  &lt;button @click=&quot;change&quot;&gt;返回&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child1&quot;,  props:[      &quot;sonProp&quot;,      &quot;prop2&quot;  ],  emits:[      &quot;update:sonProp&quot;,      &quot;update:prop2&quot;  ],  methods:&#123;    change()&#123;      this.$emit(&quot;update:sonProp&quot;,this.sonProp+1);      this.$emit(&quot;update:prop2&quot;,this.prop2+2);    &#125;  &#125;,  data()&#123;    return&#123;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>父组件：Parent1</p><pre><code>&lt;template&gt;  &lt;Child1 v-model:sonProp=&quot;num&quot; v-model:prop2=&quot;num2&quot;&gt;&lt;/Child1&gt;&lt;/template&gt;&lt;script&gt;import Child1 from &#39;./Child1&#39;export default &#123;  name: &quot;Parent1&quot;,  components:&#123;    Child1  &#125;,  data()&#123;    return&#123;      num:0,      num2:100    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>需求：组件间传递值比较麻烦，有的时候，仅仅需要把父组件的值显示到子组件的可视范围内</p><p>匿名插槽：<code>&lt;slot&gt;&lt;/slot&gt;</code>，只能有一个</p><pre><code>&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;child&gt;&#123;msg&#125;&lt;/child&gt;&lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;div&gt;        &lt;hr&gt;        &lt;!-- 引用父组件的值 --&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;hr&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = &#123;        template: &quot;#child&quot;    &#125;    let app = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            msg: &#39;hello&#39;        &#125;,        components: &#123;            child        &#125;    &#125;);&lt;/script&gt;</code></pre><p>具名插槽：<code>&lt;slot name=&quot;插槽名&quot;&gt;&lt;/slot&gt;</code></p><img src="/2022/060432144/image-20210617101053490.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;child &gt;                &lt;!--为插槽s1赋值--&gt;                &lt;template slot=&quot;s1&quot;&gt;marry&lt;/template&gt;                &lt;template slot=&quot;s2&quot;&gt;scott&lt;/template&gt;                &lt;!--为匿名插槽赋值--&gt;                &lt;template&gt;&#123;msg&#125;&lt;/template&gt;                &lt;!--或 &#123;msg&#125;--&gt;            &lt;/child&gt;        &lt;/div&gt;        &lt;template id=&quot;child&quot;&gt;            &lt;div&gt;                子组件                &lt;hr&gt;                &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;                &lt;hr&gt;                &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;                &lt;hr&gt;                &lt;slot&gt;&lt;/slot&gt;                &lt;hr&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var child = &#123;                template:&quot;#child&quot;            &#125;;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    msg:&quot;tom&quot;                &#125;,                components:&#123;                    child                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>注意：插槽属于父组件，在子组件中，只能决定放置在哪个地方，不能修改</p><h3 id="vue3中cli"><a href="#vue3中cli" class="headerlink" title="vue3中cli"></a>vue3中cli</h3><h4 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h4><p>子组件：</p><pre><code>&lt;template&gt;  &lt;hr&gt;  &lt;slot&gt;&lt;/slot&gt;  &lt;hr&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child2&quot;&#125;&lt;/script&gt;</code></pre><p>父组件：</p><pre><code>&lt;template&gt;  &lt;Child2&gt;    &lt;template #default&gt;100&lt;/template&gt;  &lt;/Child2&gt;  或  &lt;Child2&gt;100&lt;/Child2&gt;&lt;/template&gt;&lt;script&gt;import Child2 from &#39;./Child2&#39;export default &#123;  name: &quot;Parent2&quot;,  components:&#123;    Child2  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p><slot name="插槽名"></slot></p><p>子组件</p><pre><code>&lt;template&gt;  &lt;hr&gt;  &lt;slot&gt;&lt;/slot&gt;  &lt;hr&gt;  &lt;slot name=&quot;name1&quot;&gt;&lt;/slot&gt;  &lt;hr&gt;  &lt;slot name=&quot;name2&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child2&quot;&#125;&lt;/script&gt;</code></pre><p>父组件</p><pre><code>&lt;template&gt;  &lt;Child2&gt;    &lt;template #default&gt;100&lt;/template&gt;    &lt;template #name1&gt;200&lt;/template&gt;    &lt;template #name2&gt;300&lt;/template&gt;  &lt;/Child2&gt;&lt;/template&gt;或&lt;template&gt;  &lt;MyDemo3&gt;    &lt;template v-slot:default&gt;1002&lt;/template&gt;    &lt;template v-slot:name1&gt;200&lt;/template&gt;    &lt;template v-slot:name2&gt;300&lt;/template&gt;  &lt;/MyDemo3&gt;&lt;/template&gt;&lt;script&gt;import Child2 from &#39;./Child2&#39;export default &#123;  name: &quot;Parent2&quot;,  components:&#123;    Child2  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>作用：把子组件的值通过插槽属性传递出来，由父组件决定如何显示，并且只在当前插槽中有效</p><p>slot-scope：就像一个临时变量，包含了从组件传回的所有属性。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;child&gt;        &lt;template slot-scope=&quot;scope&quot; slot=&quot;s1&quot;&gt;            &lt;span&gt;姓名：&#123;scope.name1&#125;&lt;/span&gt;            &lt;span&gt;年龄：&#123;scope.age&#125;&lt;/span&gt;        &lt;/template&gt;    &lt;/child&gt;&lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;div&gt;        &lt;!-- 注意插槽的属性不能为name，否则不显示 --&gt;        &lt;slot name=&quot;s1&quot; :name1=&quot;name&quot; :age=&quot;age&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = &#123;        template: &quot;#child&quot;,        data()&#123;            return&#123;                name:&#39;tom&#39;,                age:20            &#125;        &#125;    &#125;    let app = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            msg: &#39;hello&#39;        &#125;,        components: &#123;            child        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>也可以传递对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;child&gt;        &lt;template slot-scope=&quot;scope&quot; slot=&quot;s1&quot;&gt;            &lt;span&gt;姓名：&#123;scope.stu.name&#125;&lt;/span&gt;            &lt;span&gt;年龄：&#123;scope.stu.age&#125;&lt;/span&gt;        &lt;/template&gt;    &lt;/child&gt;&lt;/div&gt;&lt;template id=&quot;child&quot;&gt;    &lt;div&gt;        &lt;slot name=&quot;s1&quot; :stu=&quot;stu&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = &#123;        template: &quot;#child&quot;,        data()&#123;            return&#123;                stu:&#123;name:&quot;tom&quot;,age:20&#125;//传递对象            &#125;        &#125;    &#125;    let app = new Vue(&#123;        el: &quot;#app&quot;,        data: &#123;            msg: &#39;hello&#39;        &#125;,        components: &#123;            child        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/060432144/image-20210617101022861.png" class><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;child :data=&quot;arr&quot;&gt;                &lt;template slot-scope=&quot;scope&quot;&gt;                    &lt;li&gt;&lt;h3&gt;&#123;scope.n&#125;&lt;/h3&gt;&lt;h4&gt;&#123;scope.i&#125;&lt;/h4&gt;&lt;/li&gt;                &lt;/template&gt;            &lt;/child&gt;        &lt;/div&gt;        &lt;template id=&quot;t1&quot;&gt;            &lt;div&gt;                &lt;ul&gt;                    &lt;slot v-for=&quot;(name,index) in data&quot; :n=&quot;name&quot; :i=&quot;index&quot;&gt;&lt;/slot&gt;                &lt;/ul&gt;            &lt;/div&gt;        &lt;/template&gt;                &lt;script type=&quot;text/javascript&quot;&gt;            var child = &#123;                template:&quot;#t1&quot;,                props:[                    &quot;data&quot;                ]            &#125;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    arr:[&quot;tom&quot;,&quot;marry&quot;,&quot;scott&quot;]                &#125;,                components:&#123;                    child                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3中cli实现-1"><a href="#vue3中cli实现-1" class="headerlink" title="vue3中cli实现"></a>vue3中cli实现</h3><h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><p>Child3.vue</p><pre><code>&lt;template&gt;  &lt;slot age=&quot;20&quot; name2=&quot;tom&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child3&quot;&#125;&lt;/script&gt;</code></pre><h4 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h4><p>Parent3.vue</p><pre><code>&lt;template&gt;  &lt;Child3 v-slot=&quot;scope&quot;&gt;    &#123;scope.age&#125;-&#123;scope.name2&#125;  &lt;/Child3&gt;&lt;/template&gt;&lt;script&gt;import Child3 from &quot;./Child3&quot;;export default &#123;  name: &quot;Parent3&quot;,  components:&#123;    Child3  &#125;&#125;&lt;/script&gt;</code></pre><h4 id="具名作用域插槽"><a href="#具名作用域插槽" class="headerlink" title="具名作用域插槽"></a>具名作用域插槽</h4><p>子组件</p><p>Child3.vue</p><pre><code>&lt;template&gt;  &lt;slot age=&quot;30&quot;&gt;&lt;/slot&gt;  &lt;slot name2=&quot;tom&quot; name=&quot;name1&quot; age=&quot;20&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Child3&quot;&#125;&lt;/script&gt;</code></pre><p>父组件</p><p>Parent3.vue</p><pre><code>&lt;template&gt;  &lt;Child3  &gt;    &lt;!--  可简写为：#default=&quot;scope&quot;   --&gt;    &lt;template v-slot:default=&quot;scope&quot;&gt;      &#123;scope.age&#125;    &lt;/template&gt;    &lt;!--  可简写为：#name1=&quot;scope&quot;   --&gt;    &lt;template v-slot:name1=&quot;scope&quot;&gt;      &#123;scope.name2&#125;-&#123;scope.age&#125;    &lt;/template&gt;  &lt;/Child3&gt;&lt;/template&gt;&lt;script&gt;import Child3 from &quot;./Child3&quot;;export default &#123;  name: &quot;Parent3&quot;,  components:&#123;    Child3  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p><code>&lt;component :is=&quot;com&quot;&gt;&lt;/component&gt;</code>:com属性的值是一个组件对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;            &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;component :is=&quot;com&quot;&gt;&lt;/component&gt;            &lt;button type=&quot;button&quot; @click=&quot;getCom&quot;&gt;切换组件&lt;/button&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var com1 = &#123;                template:`&lt;div&gt;组件1&lt;/div&gt;`            &#125;            var com2 = &#123;                template:`&lt;div&gt;组件2&lt;/div&gt;`            &#125;            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                    com:com2                &#125;,                components:&#123;                    com1,com2                &#125;,                methods:&#123;                    getCom()&#123;                        this.com = com1;                    &#125;                &#125;            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>vue3中cli实现</p><p>子组件</p><p>Child4，child5</p><pre><code>&lt;template&gt;  &lt;div&gt;子组件4&lt;/div&gt;&lt;/template&gt;&lt;template&gt;  &lt;div&gt;子组件５&lt;/div&gt;&lt;/template&gt;</code></pre><p>父组件</p><p>Parent4</p><pre><code>&lt;template&gt;  &lt;component :is=&quot;com&quot;&gt;&lt;/component&gt;  &lt;button @click=&quot;change&quot;&gt;更换组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Child4 from &#39;./Child4&#39;import Child5 from &#39;./Child5&#39;import &#123;markRaw&#125; from &#39;vue&#39;export default &#123;  name: &quot;Parent4&quot;,  components:&#123;    Child4,Child5  &#125;,  data()&#123;    return &#123;     //markRaw:把该组件变为非响应式的，否则会有警告      com:markRaw(Child4)    &#125;  &#125;,  methods:&#123;    change()&#123;      if(this.com.name ==&quot;Child4&quot;)&#123;        this.com = markRaw(Child5)      &#125;else&#123;        this.com = markRaw(Child4)      &#125;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>作用：在应用中切换组件</p></li><li><p>使用</p><ul><li><p>创建组件</p></li><li><p>导入路由文件</p><pre><code>&lt;script src=&quot;js/vue-router.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>创建路由器实例，配置路由器</p><pre><code>            var router = new VueRouter(&#123;                //路由表                routes:[                    //路由                    &#123;                        path:&#39;/login&#39;,                        component:login                    &#125;,                    &#123;                        path:&#39;/main&#39;,                        component:main                    &#125;                ]            &#125;);</code></pre></li><li><p>注册路由器</p><pre><code>            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;,                router            &#125;);</code></pre></li><li><p><code>&lt;router-link to=&quot;/login&quot;&gt;登录页&lt;/router-link&gt;</code>:功能类似于超链接，用来链接组件</p></li><li><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>：用来显示组件</p></li><li><p>使用代码切换组件</p><pre><code>this.$router.push(&quot;/main&quot;);</code></pre></li><li><p>显示第一个组件</p><pre><code>//配置路由 &#123;     path:&#39;/&#39;,     component:login &#125;  //通过代码             var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;,                router,                created()&#123;                    this.$router.push(&quot;/login&quot;);                &#125;                            &#125;);</code></pre></li><li><p>命名路由</p><pre><code>                    &#123;                        path:&#39;/login&#39;,                        name:&quot;login&quot;,                        component:login                    &#125;,                    &#123;                        path:&#39;/main&#39;,                        name:&quot;main&quot;,                        component:main                    &#125;</code></pre><p>使用路由名子切换组件</p><pre><code>this.$router.push(&#123;name:&#39;login&#39;&#125;).catch(()=&gt;&#123;&#125;);</code></pre></li><li><p>嵌套路由</p><pre><code>            var router = new VueRouter(&#123;                //路由表                routes:[                    //路由                    /* &#123;                        path:&#39;/&#39;,                        component:login                    &#125;, */                    &#123;                        path:&#39;/login&#39;,                        name:&quot;login&quot;,                        component:login                    &#125;,                    &#123;                        path:&#39;/main&#39;,                        name:&quot;main&quot;,                        component:main,                        children:[                            &#123;                                path:&#39;/dept&#39;,                                name:&#39;dept&#39;,                                component:dept                            &#125;,                            &#123;                                path:&#39;/emp&#39;,                                name:&#39;emp&#39;,                                component:emp                            &#125;                        ]                    &#125;                ]            &#125;);</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src=&quot;js/vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;script src=&quot;js/vue-router.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;        &lt;style&gt;            #parent&#123;                width: 800px;                height:500px;                display: flex;            &#125;            #nav&#123;                width:100px;                height:500px;                background-color: bisque;            &#125;            #main&#123;                width:600px;                height:500px;                background-color: aliceblue;            &#125;        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;!-- &lt;router-link to=&quot;/login&quot;&gt;登录页&lt;/router-link&gt;            &lt;router-link to=&quot;/main&quot;&gt;主页&lt;/router-link&gt; --&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/div&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var login = &#123;                template:`                    &lt;div&gt;                        &lt;h1&gt;登录页&lt;/h1&gt;                        &lt;input type=&quot;button&quot; value=&quot;登录&quot; @click=&quot;login&quot;&gt;                    &lt;/div&gt;                `,                methods:&#123;                    login()&#123;                        this.$router.push(&quot;/main&quot;);                    &#125;                &#125;            &#125;            var main = &#123;                template:`                    &lt;div&gt;                        &lt;h1&gt;主页&lt;/h1&gt;                        &lt;div id=&quot;parent&quot;&gt;                            &lt;div id=&quot;nav&quot;&gt;                                &lt;h4&gt;导航&lt;/h4&gt;                                &lt;router-link to=&quot;/dept&quot;&gt;部门管理&lt;/router-link&gt;&lt;br&gt;                                &lt;router-link to=&quot;/emp&quot;&gt;员工管理&lt;/router-link&gt;                            &lt;/div&gt;                            &lt;div id=&quot;main&quot;&gt;                                &lt;h4&gt;主区域&lt;/h4&gt;                                &lt;router-view&gt;&lt;/router-view&gt;                            &lt;/div&gt;                        &lt;/div&gt;                    &lt;/div&gt;                `            &#125;            var dept = &#123;                template:`&lt;div&gt;&lt;h2&gt;部门管理&lt;/h2&gt;&lt;/div&gt;`            &#125;            var emp = &#123;                template:`&lt;div&gt;&lt;h2&gt;员工管理&lt;/h2&gt;&lt;/div&gt;`            &#125;            var router = new VueRouter(&#123;                //路由表                routes:[                    //路由                    /* &#123;                        path:&#39;/&#39;,                        component:login                    &#125;, */                    &#123;                        path:&#39;/login&#39;,                        name:&quot;login&quot;,                        component:login                    &#125;,                    &#123;                        path:&#39;/main&#39;,                        name:&quot;main&quot;,                        component:main,                        children:[                            &#123;                                path:&#39;/dept&#39;,                                name:&#39;dept&#39;,                                component:dept                            &#125;,                            &#123;                                path:&#39;/emp&#39;,                                name:&#39;emp&#39;,                                component:emp                            &#125;                        ]                    &#125;                ]            &#125;);            var app = new Vue(&#123;                el:&quot;#app&quot;,                data:&#123;                                    &#125;,                router,                created()&#123;                    // this.$router.push(&quot;/login&quot;);                    this.$router.push(&#123;name:&#39;login&#39;&#125;).catch(()=&gt;&#123;&#125;);                &#125;                            &#125;);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ul></li></ol><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><ol><li><p>向切换后的组件传递参数</p></li><li><p>动态路由</p><pre><code>//路由表&#123;    path:&#39;/dept/:deptno&#39;,    name:&#39;dept&#39;,    component:dept&#125;//router-link&lt;router-link to=&quot;/dept/10&quot;&gt;部门管理&lt;/router-link&gt;//代码this.$router.push(&#123;path:&#39;/editdept/20/hr5&#39;&#125;);//在组件中得到路由参数&#123;$route.params.deptno&#125;this.deptno = this.$route.params.deptno;</code></pre><pre><code>//路由表&#123;    path:&#39;/dept&#39;,    component:dept&#125;//router-link&lt;router-link :to=&quot;&#123;path:&#39;/update_dept&#39;,query:&#123;&#39;deptno&#39;:dept.deptno&#125;&quot;&gt;更新&lt;/router-link&gt;//在组件中得到路由参数&#123;$route.query.deptno&#125;this.deptno = this.$route.query.deptno;</code></pre></li><li><p>查询参数（查询参数会显示在地址栏中）</p><pre><code>//路由表&#123;    path:&#39;/dept&#39;,    name:&#39;dept&#39;,    component:dept&#125;发送数据：this.$router.push(&#123;name:&#39;main&#39;,query:&#123;username:&#39;admin&#39;,age:20&#125;);接收数据：&#123;$route.query.username&#125;this.username = this.$route.query.username;</code></pre><p>通过 name 和 params 结合传递参数（地址栏中不显示参数数据）</p><pre><code>//路由表&#123;    path:&#39;/dept&#39;,    name:&#39;dept&#39;,    component:dept&#125;发送数据：this.$router.push(&#123;name:&#39;main&#39;,params:&#123;username:&#39;admin&#39;,age:20&#125;);接收数据：&#123;$route.params.username&#125;this.username = this.$route.params.username;</code></pre></li><li><p>注意：path不能与params同时使用，params会被忽略掉</p></li></ol><h2 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue-Cli"></a>Vue-Cli</h2><ol><li><p>vue.js开发的标准工具</p></li><li><p>Node.js:是一个基于 Chrome V8引擎的 JavaScript运行时环境</p></li><li><p>npm：是随着node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写好的第三方包到本地</p><p>测试：npm –version</p></li><li><p>安装 cnpm</p><pre><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre></li><li><p>安装 Vue-Cli</p><pre><code>cnpm install -g @vue/cli</code></pre></li><li><p>启动项目</p><pre><code>npm run serve</code></pre></li><li><p>安装路由(脚手架插件)</p><pre><code>vue add router</code></pre><p>或</p><pre><code>npm（cnpm） install vue-router</code></pre></li></ol><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><ol><li><p>安装：</p><pre><code>vue add axios</code></pre></li><li><p>定义：易用、简洁且高效的http库</p></li><li><p>作用：用户向后台服务器发送异步请求，并处理响应的结果</p></li><li><p>配置：</p><pre><code>//基础路径配置axios.defaults.baseURL=&quot;http://localhost:8089/&quot;//允许传递证书axios.defaults.withCredentials=true</code></pre></li><li><p>get请求</p><pre><code>var url = `emp/getPaged?pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageSize&#125;`;axios.get(url).then((resp)=&gt;&#123;    console.log(resp);&#125;);</code></pre><pre><code>var url = `emp/getPaged`;var params = &#123;    pageNum:pageNum,    pageSize:pageSize&#125;axios.get(url,&#123;params:params&#125;).then((resp)=&gt;&#123;    console.log(resp);&#125;);</code></pre></li><li><p>post请求</p><pre><code>var url = `emp/getPaged`;                axios.post(url,`pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageSize&#125;`).then((resp)=&gt;&#123;     console.log(resp);&#125;);</code></pre><pre><code>@RequestMapping(&quot;update&quot;)public int update(@RequestBody Emp emp) &#123;    return empService.update(emp);&#125;update()&#123;    var url = &quot;emp/update&quot;;        //this.empVO.emp：为JSON对象        axios.post(url,this.empVO.emp).then((resp)=&gt;&#123;        if(resp.data == 1)&#123;            alert(&quot;更新成功！&quot;);            this.$router.push(&quot;/emp&quot;)        &#125;    &#125;);&#125;</code></pre></li></ol><h2 id="Axios-vue3"><a href="#Axios-vue3" class="headerlink" title="Axios-vue3"></a>Axios-vue3</h2><ol><li><p>定义：易用、简洁且高效的http库</p></li><li><p>安装</p><pre><code>npm install axios</code></pre></li><li><p>配置</p><pre><code>/src/main.jsimport axios from &#39;axios&#39;axios.defaults.baseURL = &quot;http://localhost:8090/&quot;//允许传递证书axios.defaults.withCredentials = trueconst app = createApp(App);app.config.globalProperties.$http = axios</code></pre></li><li><p>springboot添加允许跨域请求</p><pre><code>package com.dhee.springbootdemo1;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;//表示当前类是一个spring配置类@Configurationpublic class SpringMVCConfig implements WebMvcConfigurer &#123;    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowCredentials(true)                .allowedHeaders(&quot;*&quot;)                .allowedMethods(&quot;*&quot;)                .allowedOriginPatterns(&quot;*&quot;);    &#125;&#125;</code></pre></li><li><p>get请求</p><pre><code>let url = `user/login?username=$&#123;this.user.username&#125;&amp;password=$&#123;this.user.password&#125;`;        this.$http.get(url).then((resp)=&gt;&#123;          if(resp.data != null &amp;&amp; resp.data != &quot;&quot;)&#123;            sessionStorage.setItem(&quot;username&quot;,&quot;admin&quot;)            // alert(&quot;登录成功&quot;);            //向路由器中路径的历史记录中添加一条记录            this.$router.push(&quot;/main&quot;);          &#125;else&#123;            alert(&quot;登录失败！&quot;)          &#125;        &#125;)</code></pre><pre><code>let url = `user/login`;        this.$http.get(url,&#123;params:this.user&#125;).then((resp)=&gt;&#123;          if(resp.data != null &amp;&amp; resp.data != &quot;&quot;)&#123;            sessionStorage.setItem(&quot;username&quot;,&quot;admin&quot;)            // alert(&quot;登录成功&quot;);            //向路由器中路径的历史记录中添加一条记录            this.$router.push(&quot;/main&quot;);          &#125;else&#123;            alert(&quot;登录失败！&quot;)          &#125;        &#125;)</code></pre></li><li><p>post请求</p><pre><code>this.$http.post(&quot;dept/update2&quot;,`deptno=$&#123;this.dept.deptno&#125;&amp;dname=$&#123;this.dept.dname&#125;&amp;loc=$&#123;this.dept.loc&#125;`)        .then((resp)=&gt;&#123;          if(resp.data == 1)&#123;            this.$router.push(&quot;/main/dept&quot;)          &#125;else&#123;            alert(&quot;修改失败&quot;)          &#125;        &#125;)</code></pre><pre><code>this.$http.post(&quot;dept/update2&quot;,this.dept)        .then((resp)=&gt;&#123;          if(resp.data == 1)&#123;            this.$router.push(&quot;/main/dept&quot;)          &#125;else&#123;            alert(&quot;修改失败&quot;)          &#125;        &#125;)        //服务器端@RequestMapping(&quot;update2&quot;)    @ResponseBody    public int update2(@RequestBody Dept dept)&#123;        return deptService.update(dept);    &#125;</code></pre></li><li><p>封装axios</p><p>request&#x2F;index.js</p><pre><code>import axios from &#39;axios&#39;// 创建一个 axios 实例const service = axios.create(&#123;    baseURL: &#39;http://localhost:8089/&#39;, // 所有的请求地址前缀部分    timeout: 60000, // 请求超时时间毫秒    withCredentials: true, // 异步请求携带cookie    headers: &#123;        // 设置后端需要的传参类型        &#39;Content-Type&#39;: &#39;application/json&#39;,        // &#39;token&#39;: &#39;your token&#39;,        &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,    &#125;,&#125;)// 添加请求拦截器service.interceptors.request.use(    function (config) &#123;        // 在发送请求之前做些什么        return config    &#125;,    function (error) &#123;        // 对请求错误做些什么        console.log(error)        return Promise.reject(error)    &#125;)// 添加响应拦截器service.interceptors.response.use(    function (response) &#123;        // console.log(response)        // 2xx 范围内的状态码都会触发该函数。        // 对响应数据做点什么        // dataAxios 是 axios 返回数据中的 data        const dataAxios = response.data        // 这个状态码是和后端约定的        // const code = dataAxios.reset        return dataAxios    &#125;,    function (error) &#123;        // 超出 2xx 范围的状态码都会触发该函数。        // 对响应错误做点什么        console.log(error)        return Promise.reject(error)    &#125;)export default service</code></pre><p>main.js</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import  Router from &quot;./router/index&quot;;import store from &#39;./store/index&#39;import axios from &#39;./request/index&#39;const app = createApp(App)app.config.globalProperties.$http = axiosapp.use(Router)app.use(store)app.mount(&#39;#app&#39;)</code></pre><p>Dept.vue</p><pre><code>created() &#123;    let url = &#39;dept/getAll&#39;;    this.$http(url).then(data=&gt;&#123;      console.log(data)      this.depts = data;    &#125;);  &#125;</code></pre></li></ol><h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><h4 id="拦截器介绍"><a href="#拦截器介绍" class="headerlink" title="拦截器介绍"></a>拦截器介绍</h4><p>一般在使用axios时，会用到拦截器的功能，一般分为两种：请求拦截器、响应拦截器。</p><p>请求拦截器 在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；</p><p>响应拦截器 同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。</p><p>比如一些网站过了一定的时间不进行操作，就会退出登录让你重新登陆页面，当然这不用拦截器你或许也可以完成这功能，但是会很麻烦而且代码会产生大量重复，所以我们需要用到拦截器</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>1：每个请求都带上的参数，比如token，时间戳等。<br>2：对返回的状态进行判断，比如token是否过期</p><p>axios的拦截器作用非常大。axios的拦截器分为请求拦截器跟响应拦截器，都是可以设置多个请求或者响应拦截。每个拦截器都可以设置两个拦截函数，一个为成功拦截，一个为失败拦截。在调用axios.request()之后，请求的配置会先进入请求拦截器中，正常可以一直执行成功拦截函数，如果有异常会进入失败拦截函数，并不会发起请求；调起请求响应返回后，会根据响应信息进入响应成功拦截函数或者响应失败拦截函数。</p><p>因此，我们可以在拦截器中处理一些请求的统一处理。比如在请求拦截器中设置请求头，处理统一的请求数据，在响应拦截去中根据响应状态码做统一的提示信息，整理响应数据等。</p><p>在请求或响应被 then 或 catch 处理前拦截它们。</p><pre><code>// 官方用例// 1.添加请求拦截器axios.interceptors.request.use(function (config) &#123;    // 在发送请求之前做些什么    return config;  &#125;, function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error);  &#125;);</code></pre><p>&#x2F;&#x2F; 2.添加响应拦截器</p><pre><code>axios.interceptors.response.use(function (response) &#123;    // 对响应数据做点什么    return response;  &#125;, function (error) &#123;    // 对响应错误做点什么    return Promise.reject(error);  &#125;);</code></pre><h4 id="1-axios-请求拦截器"><a href="#1-axios-请求拦截器" class="headerlink" title="1.axios-请求拦截器"></a>1.axios-请求拦截器</h4><p>目标</p><p>什么是请求</p><p>什么是axios的请求拦截器</p><p>场景</p><p>在发起请求之前, 最后对要发送的请求配置对象进行修改</p><p>例如: 如果本地有token, 携带在请求头给后台</p><pre><code>// 添加请求拦截器--代码实现案例：仅供参考axios.interceptors.request.use(function (config) &#123;  // 在发送请求之前做些什么, 如果vuex里有token携带在请求头中  if (store.state.token.length &gt; 0 &amp;&amp; config.headers.Authorization === undefined) &#123;    // 发起请求之前, 把token携带在请求头上(表明自己身份)    config.headers.Authorization = &#39;Bearer &#39; + store.state.token  &#125;  return config&#125;, function (error) &#123;  // 对请求错误做些什么  return Promise.reject(error)&#125;)</code></pre><p>所有api接口里以后暂时不用自己携带Headers+Token了,简略代码，统一管理</p><p>小结</p><p>请求拦截器时候时候执行?</p><p>在发起请求最后一刻执行</p><h4 id="2-axios-响应拦截器"><a href="#2-axios-响应拦截器" class="headerlink" title="2.axios-响应拦截器"></a>2.axios-响应拦截器</h4><p>目标</p><p>什么是响应</p><p>什么是axios的响应拦截器</p><p>场景</p><p>在响应回来后, 马上执行响应拦截器函数</p><p>例如: 判断是否错误401, 统一进行权限判断</p><pre><code>// 添加响应拦截器--代码实现案例：仅供参考axios.interceptors.response.use(function (response) &#123; // 当状态码为2xx/3xx开头的进这里    // 对响应数据做点什么    return response&#125;, async function (error) &#123; // 响应状态码4xx/5xx进这里    // 对响应错误做点什么   if (error.response.status === 401) &#123; // 身份过期/token无效    //  1.清空vuex的token     store.commit(&#39;setToken&#39;, &#39;&#39;)    store.commit(&#39;setRefreshToken&#39;, &#39;&#39;)    // 2. 清空本地token     localStorage.removeItem(&#39;token&#39;)    localStorage.removeItem(&#39;refresh_token&#39;)    //  跳转到登录页面登录    router.push(&#123;      path: &#39;/login&#39;    &#125;)  &#125;         return Promise.reject(error)&#125;)</code></pre><p>小结</p><p>响应拦截器什么时候执行?</p><p>在响应回来以后</p><p>什么时候进响应拦截器成功, 什么时候进失败?</p><p>2xx&#x2F;3xx开头的响应状态码进入成功</p><p>4xx&#x2F;5xx开头的响应状态码进入失败</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ol><li><p>安装</p><pre><code>npm install --save vuex</code></pre></li><li><p>Vuex是Vue的状态管理库，用来管理状态（应用程序中的信息或数据）。它将状态存储在一个中心位置，使得任何组件都很容易与之交互</p></li><li><p>使用</p><ul><li><p>在src目录下，添加一个文件：store.js,创建Vuex的Store对象</p><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;//安装Vuex插件Vue.use(Vuex)export default new Vuex.Store(&#123;    state:&#123;        count:0    &#125;&#125;)</code></pre></li><li><ul><li><p>在main.js,导入 store.js</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import  Router from &quot;./router/index&quot;;import vuex from &#39;./store/index&#39;const app = createApp(App)app.use(Router)app.use(vuex)app.mount(&#39;#app&#39;)</code></pre></li><li><p>在组件中访问</p><pre><code>&#123;$store.state.user.username&#125;</code></pre></li><li><p>在组件内，来自store的数据是只读的，不能手工修改，改变 store中数据的唯一途径就是显示的提交mutations</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            //payload可以是一个对象            //state.count += payload.num;            state.count += payload;        &#125;    &#125;&#125;)//this.$store.commit(&quot;add&quot;,&#123;num:6&#125;);this.$store.commit(&quot;add&quot;,5);</code></pre></li><li><p>使用store中的getters，来处理state数据，以便以统一的形式来显示数据</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            state.count += payload.num;        &#125;    &#125;,    getters:&#123;        formatCount(state)&#123;            return `个数:$&#123;state.count&#125;`;        &#125;    &#125;&#125;)&#123;$store.getters.formatCount&#125;</code></pre></li><li><p>使用 store的 actions，来执行异步状态管理</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            state.count += payload.num;        &#125;    &#125;,    getters:&#123;        formatCount(state)&#123;            return `个数:$&#123;state.count&#125;`;        &#125;    &#125;,    actions:&#123;        add2(context,payload)&#123;            setTimeout(function()&#123;                context.commit(&quot;add&quot;,payload);            &#125;,1000)        &#125;    &#125;&#125;)this.$store.dispatch(&quot;add2&quot;,&#123;num:7&#125;);//异步操作</code></pre></li></ul></li></ul></li></ol><h2 id="Vuex4"><a href="#Vuex4" class="headerlink" title="Vuex4"></a>Vuex4</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><ol><li><p>安装</p><pre><code>npm install vuex@next --save</code></pre></li><li><p>使用</p><ul><li><p>在src目录下，添加一个文件夹：store，在其下创建文件：index.js</p><pre><code>import &#123;createStore&#125; from &#39;vuex&#39;export default createStore(&#123;    state()&#123;        return &#123;            user:&#123;username:&#39;tom&#39;&#125;        &#125;    &#125;&#125;)</code></pre></li><li><p>在main.js,导入 store.js</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import  Router from &quot;./router/index&quot;;import vuex from &#39;./store/index&#39;const app = createApp(App)app.use(Router)app.use(vuex)app.mount(&#39;#app&#39;)</code></pre></li><li><p>在组件中访问</p><pre><code>&#123;$store.state.user.username&#125;</code></pre></li><li><p>在组件内，来自store的数据是只读的，不能手工修改，改变 store中数据的唯一途径就是显示的提交mutations</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            //payload可以是一个对象            //state.count += payload.num;            state.count += payload;        &#125;    &#125;&#125;)//this.$store.commit(&quot;add&quot;,&#123;num:6&#125;);this.$store.commit(&quot;add&quot;,5);</code></pre></li><li><p>使用store中的getters，来处理state数据，以便以统一的形式来显示数据</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            state.count += payload.num;        &#125;    &#125;,    getters:&#123;        formatCount(state)&#123;            return `个数:$&#123;state.count&#125;`;        &#125;    &#125;&#125;)&#123;$store.getters.formatCount&#125;</code></pre></li><li><p>使用 store的 actions，来执行异步状态管理</p><pre><code>export default new Vuex.Store(&#123;    state:&#123;        count:10    &#125;,    mutations:&#123;        add(state,payload)&#123;            state.count += payload.num;        &#125;    &#125;,    getters:&#123;        formatCount(state)&#123;            return `个数:$&#123;state.count&#125;`;        &#125;    &#125;,    actions:&#123;        add2(context,payload)&#123;            setTimeout(function()&#123;                context.commit(&quot;add&quot;,payload);            &#125;,1000)        &#125;    &#125;&#125;)this.$store.dispatch(&quot;add2&quot;,&#123;num:7&#125;);//异步操作</code></pre></li></ul></li></ol><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p>在路由切换前，对路由进行检查</p></li><li><p>通过路由守卫实现修改网页title的功能</p><ul><li><p>在每个路由中添加meta属性，记录title信息</p><pre><code>import &#123;createRouter,createWebHashHistory&#125; from &quot;vue-router&quot;;export default createRouter(&#123;    history:createWebHashHistory(),    routes:[        &#123;            path:&#39;/&#39;,            component:()=&gt;import(&#39;../components/Login&#39;),            name:&#39;login&#39;,            meta:&#123;                title:&#39;登录&#39;            &#125;        &#125;,        &#123;            path:&#39;/main&#39;,            component:()=&gt;import(&#39;../components/Main&#39;),            children:[                &#123;                    path:&#39;email&#39;,                    component:()=&gt;import(&#39;../components/EmailConfig&#39;),                    meta:&#123;                        title:&#39;邮箱设置&#39;                    &#125;                &#125;,                &#123;                    path:&#39;user&#39;,                    components:&#123;                        default:()=&gt;import(&#39;../components/UserConfig&#39;),                        helper:()=&gt;import(&#39;../components/UserHelper&#39;)                    &#125;,                    meta:&#123;                        title:&#39;用户设置&#39;                    &#125;                &#125;            ]        &#125;    ]&#125;)</code></pre></li><li><p>路由守卫</p><pre><code>import &#123; createApp &#125; from &#39;vue&#39;import App from &#39;./App.vue&#39;import  Router from &quot;./router/index&quot;;import vuex from &#39;./store/index&#39;const app = createApp(App)Router.beforeEach((to,from,next)=&gt;&#123;    window.document.title = to.meta.title;    next();&#125;)app.use(Router)app.use(vuex)app.mount(&#39;#app&#39;)</code></pre><p>to：路由对象，即将要进入的目标</p><p>from:路由对象，当前导航要离开的路由</p><p>next：方法，一定要调用，决定后续如何导航处理</p><ul><li>next():继续后续的操作</li><li>next(false):中断当前导航</li><li>next(“&#x2F;url”):跳转到参数指定的地址</li></ul></li></ul></li><li><p>使用路由守卫进行登录检查 </p><pre><code>login()&#123;                this.$store.commit(&#39;setUser&#39;,&#123;username:&#39;admin&#39;&#125;)                this.$router.push(&quot;/main&quot;);            &#125;</code></pre><pre><code>router.beforeEach((to,from,next)=&gt;&#123;    window.document.title = to.meta.title;        if(to.name != &quot;login&quot; &amp;&amp; !store.state.user.username)&#123;        next(&quot;/&quot;)    &#125;    next();&#125;)</code></pre></li></ol><h2 id="路由监听"><a href="#路由监听" class="headerlink" title="路由监听"></a>路由监听</h2><ol><li><pre><code>&lt;div id=&quot;nav&quot;&gt;    &lt;h4&gt;导航&lt;/h4&gt;    &lt;router-link to=&quot;/dept/10&quot;&gt;10部门管理&lt;/router-link&gt;&lt;br&gt;    &lt;router-link to=&quot;/dept/20&quot;&gt;20部门管理&lt;/router-link&gt;&lt;br&gt;    &lt;router-link to=&quot;/emp&quot;&gt;员工管理&lt;/router-link&gt;&lt;/div&gt;&#123;    path:&quot;/dept/:deptno&quot;,    name:&#39;dept&#39;,    component: ()=&gt; import(&#39;./views/Dept.vue&#39;),    meta:&#123;        title:&quot;部门管理&quot;    &#125;&#125;watch:&#123;    $route(to,from)&#123;        this.deptno = this.$route.params.deptno;    &#125;&#125;</code></pre></li></ol><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><ol><li>sessionStorage：会话存储，关闭浏览器，信息丢失</li><li>localStorage：本地存储，关闭浏览器，信息还在，存储到硬盘上</li><li>setItem(key,value):value只能是字符串</li><li>getItem(key)</li><li>removeItem(key)</li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol><li>JSON.stringify(对象)：把对象转换为字符串</li><li>JSON.parse(字符串)：把字符串转换为JSON对象</li></ol><h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><ol><li><p>安装</p><pre><code>npm i element-ui -S</code></pre></li><li><p>修改main.js</p><pre><code>import ElementUI from &#39;element-ui&#39;import &#39;element-ui/lib/theme-chalk/index.css&#39;//在vue中安装 element-ui插件Vue.use(ElementUI)</code></pre></li><li><p>登录页前端</p><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;el-form class=&quot;login-container&quot; :model=&quot;user&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;            &lt;h3 class=&quot;login-title&quot;&gt;系统登录&lt;/h3&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;密码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;checkCode&quot;&gt;                &lt;img :src=&quot;imgUrl&quot;&gt;&lt;a href=&quot;#&quot; @click=&quot;getcode&quot;&gt;看不清&lt;/a&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item&gt;                &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;            &lt;/el-form-item&gt;        &lt;/el-form&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data()&#123;            var checkCodeValidate = (rule,value,callback)=&gt;&#123;                var url = &quot;user/checkCode&quot;;                axios.post(url,`checkCode=$&#123;this.user.checkCode&#125;`).then(resp=&gt;&#123;                    if(!resp.data)&#123;                        callback(new Error(&quot;验证输入错误！&quot;));                    &#125;else&#123;                        callback();                    &#125;                &#125;);            &#125;;                        return&#123;                imgUrl:&quot;http://localhost:8089/user/getCode&quot;,                user:&#123;&#125;,                rules:&#123;                    username:[                        &#123;required:true,message:&#39;请输入用户名&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;用户名长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    password:[                        &#123;required:true,message:&#39;请输入密码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;密码长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    checkCode:[                        &#123;required:true,message:&#39;请输入验证码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;pattern:/^\w&#123;4&#125;$/,message:&quot;验证码长度必须为4位&quot;&#125;,                        &#123;validator:checkCodeValidate,trigger:&#39;blur&#39;&#125;                    ]                &#125;            &#125;        &#125;,        methods:&#123;            login()&#123;                this.$refs[&quot;loginForm&quot;].validate(valid=&gt;&#123;                    if(valid)&#123;                        var url = &quot;user/login&quot;;                        axios.get(url,&#123;params:this.user&#125;).then((resp)=&gt;&#123;                            if(resp.data)&#123;                                this.$store.commit(&quot;setUsername&quot;,this.user.username);                                this.$router.push(&quot;/main&quot;);                            &#125;else&#123;                                this.$alert(&quot;用户名或密码错误！&quot;);                            &#125;                        &#125;);                    &#125;                &#125;);            &#125;,            getcode()&#123;                this.imgUrl = this.imgUrl + &quot;?&quot;+Math.random();            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped=&quot;scoped&quot;&gt;    .login-container&#123;        width:350px;        margin:100px auto 10px;        border:1px solid #eaeaea;        padding:35px 35px 15px 35px;        border-radius: 15px;        box-shadow:0 0 25px #cac6c6;    &#125;    .login-title&#123;        text-align: center;        color:#505458;        margin:0px auto 40px;    &#125;&lt;/style&gt;</code></pre></li><li><p>登录页后端</p><pre><code>package com.neu.controller;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import javax.imageio.ImageIO;import javax.servlet.http.HttpSession;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123;        /*     * @RequestMapping(&quot;/&quot;) public String getLogin() &#123; return &quot;user/login&quot;; &#125;     */        @RequestMapping(&quot;user/login&quot;)    public boolean login(String username,String password,HttpSession session) &#123;        if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;111&quot;.equals(password)) &#123;            session.setAttribute(&quot;username&quot;, username);            return true;        &#125;else &#123;            return false;        &#125;    &#125;        @RequestMapping(&quot;user/getCode&quot;)    public ResponseEntity&lt;byte[]&gt; getCode(HttpSession session) throws IOException&#123;        char[] arr = &#123;&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;&#125;;        StringBuilder stb = new StringBuilder();        int n;        for(int i = 0;i &lt; 4;i++) &#123;            n = (int)(Math.random()*arr.length);            stb.append(arr[n]);        &#125;                session.setAttribute(&quot;code&quot;, stb.toString());                //把字符串放入到图片中，写入到输出流中        BufferedImage buffImg = new BufferedImage(90, 20, BufferedImage.TYPE_INT_RGB);        //得到画布        Graphics g = buffImg.getGraphics();        //向画布中写入字符串        g.drawString(stb.toString(), 20, 15);                ByteArrayOutputStream bos = new ByteArrayOutputStream();        ImageIO.write(buffImg, &quot;jpeg&quot;, bos);                return new ResponseEntity&lt;byte[]&gt;(bos.toByteArray(),HttpStatus.CREATED);    &#125;        @RequestMapping(&quot;user/checkCode&quot;)    public boolean checkCode(String checkCode,HttpSession session) &#123;        String code = (String)session.getAttribute(&quot;code&quot;);                if(code != null &amp;&amp; code.equals(checkCode)) &#123;            return true;        &#125;else &#123;            return false;        &#125;            &#125;&#125;</code></pre></li></ol><h2 id="Vue-Router-4"><a href="#Vue-Router-4" class="headerlink" title="Vue-Router 4"></a>Vue-Router 4</h2><ol><li><p>安装：</p><pre><code>npm install vue-routernpm install vue-router@4</code></pre></li><li><p>配置</p><ul><li><p><code>history:createWebHistory()</code>:HTML5 history模式,是利用html5的history API实现的,需要服务器配合，服务器需要添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。不过这个工作一般交给运维去做</p><p>地址格式：<code>http://localhost:8080/list</code></p></li><li><p><code>history: createWebHashHistory()</code>:hash模式完全前端就能实现</p><p>地址格式：<code>http://localhost:8080/#/list</code></p></li></ul><pre><code>// /router/index.jsimport &#123;createRouter,createWebHistory&#125; from &#39;vue-router&#39;export default createRouter(&#123;    history:createWebHistory(),    routes:[        &#123;            path:&#39;/&#39;,            redirect:&#39;/login&#39;        &#125;,        &#123;            path:&#39;/login&#39;,            component:()=&gt;import(&#39;../components/login&#39;)        &#125;,        &#123;            path:&#39;/main&#39;,            component:()=&gt;import(&#39;../components/Main&#39;),            children:[                &#123;                    path:&#39;dept&#39;,                    component:()=&gt;import(&#39;../components/Dept&#39;)                &#125;,                &#123;                    path:&#39;emp&#39;,                    component:()=&gt;import(&#39;../components/Emp&#39;)                &#125;,                &#123;                    path:&#39;user&#39;,                    component:()=&gt;import(&#39;../components/User&#39;)                &#125;            ]        &#125;    ]&#125;)</code></pre></li><li><p>main.js</p><pre><code>import VueRouter from &#39;./router/index&#39;const app = createApp(App);//路由守卫VueRouter.beforeEach((to,from,next)=&gt;&#123;    console.log(to,from,next)    let user = sessionStorage.getItem(&quot;user&quot;);    if(to.path != &quot;/login&quot; &amp;&amp; user == null)&#123;        next(&quot;/login&quot;)    &#125;    next()&#125;)</code></pre></li><li><p>主要内容</p><ul><li><code>router-view</code> 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。</li><li><code>router-link</code> 没有使用常规的 <code>a</code> 标签，而是使用一个自定义组件 <code>router-link</code> 来创建链接。这使得 Vue Router 可以在不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码。</li></ul></li><li><p>login.vue</p><img src="/2022/060432144/image-20220219160448161.png" class><pre><code>&lt;template&gt;  &lt;input type=&quot;button&quot; value=&quot;登录&quot; @click=&quot;login&quot;&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;login&quot;,  methods:&#123;    login()&#123;      sessionStorage.setItem(&quot;user&quot;,&#123;&#125;)      this.$router.push(&quot;/main&quot;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre></li><li><p>main.vue</p><img src="/2022/060432144/image-20220219160512190.png" class><pre><code>&lt;template&gt;  &lt;div id=&quot;top&quot;&gt;&lt;!--    &lt;router-link to=&quot;/login&quot;&gt;注销&lt;/router-link&gt;--&gt;    &lt;input type=&quot;button&quot; value=&quot;注销&quot; @click=&quot;destroy&quot;&gt;  &lt;/div&gt;  &lt;div id=&quot;parent&quot;&gt;    &lt;div id=&quot;nav&quot;&gt;      &lt;ul&gt;        &lt;li&gt;&lt;router-link to=&quot;/main/dept&quot;&gt;部门管理&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link to=&quot;/main/emp&quot;&gt;员工管理&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link to=&quot;/main/user&quot;&gt;用户管理&lt;/router-link&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;div id=&quot;main&quot;&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Main&quot;,  created()&#123;    this.$router.replace(&quot;/main/dept&quot;);  &#125;,  methods:&#123;    destroy()&#123;      sessionStorage.removeItem(&quot;user&quot;)      this.$router.replace(&quot;/login&quot;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;#parent&#123;  display: flex;&#125;#nav&#123;  width:200px;  height: 500px;  background-color: antiquewhite;&#125;#main&#123;  width:100%;  height: 500px;  background-color: cornsilk;&#125;li&#123;  list-style: none;&#125;&lt;/style&gt;</code></pre></li></ol><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>除了 <code>path</code> 之外，你还可以为任何路由提供 <code>name</code>。这有以下优点：</p><ul><li>没有硬编码的 URL</li><li><code>params</code> 的自动编码&#x2F;解码。</li><li>防止你在 url 中出现打字错误。</li><li>绕过路径排序（如显示一个）</li></ul><pre><code>const routes = [  &#123;    path: &#39;/user/:username&#39;,    name: &#39;user&#39;,    component: User  &#125;]</code></pre><p>要链接到一个命名的路由，可以向 <code>router-link</code> 组件的 <code>to</code> 属性传递一个对象：</p><pre><code>&lt;router-link :to=&quot;&#123; name: &#39;user&#39;, params: &#123; username: &#39;erina&#39; &#125;&quot;&gt;  User&lt;/router-link&gt;</code></pre><p>这跟代码调用 <code>router.push()</code> 是一回事：</p><pre><code>router.push(&#123; name: &#39;user&#39;, params: &#123; username: &#39;erina&#39; &#125; &#125;)</code></pre><p>在这两种情况下，路由将导航到路径 <code>/user/erina</code></p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>App.vue</p><p>如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p><pre><code>&lt;template&gt;  &lt;div style=&quot;display: flex&quot;&gt;    &lt;div style=&quot;width:200px;background-color: peachpuff;height: 500px;&quot;&gt;      aside      &lt;router-view name=&quot;aside&quot;&gt;&lt;/router-view&gt;    &lt;/div&gt;    &lt;div style=&quot;background-color:cornsilk;width: 100%;&quot;&gt;      main      &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;App&#39;,  components: &#123;  &#125;,  methods:&#123;  &#125;&#125;&lt;/script&gt;</code></pre><p>路由</p><p>router&#x2F;index.js</p><pre><code>import &#123;createRouter,createWebHashHistory&#125; from &quot;vue-router&quot;;export default createRouter(&#123;    history:createWebHashHistory(),    routes:[        &#123;            path:&#39;/&#39;,            // component:()=&gt;import(&#39;../components/Main&#39;),           components:&#123;                   //default:()=&gt;import(&#39;../components/Child3&#39;),                aside:()=&gt;import(&#39;../components/Child5&#39;),                main:()=&gt;import(&#39;../components/Child4&#39;)           &#125;        &#125;    ]&#125;)</code></pre><h3 id="嵌套命名视图"><a href="#嵌套命名视图" class="headerlink" title="嵌套命名视图"></a>嵌套命名视图</h3><p>路由配置</p><p>index.js</p><pre><code>import &#123;createRouter,createWebHashHistory&#125; from &quot;vue-router&quot;;export default createRouter(&#123;    history:createWebHashHistory(),    routes:[        &#123;            path:&#39;/&#39;,            component:()=&gt;import(&#39;../components/Login&#39;),        &#125;,        &#123;            path:&#39;/main&#39;,            component:()=&gt;import(&#39;../components/Main&#39;),            children:[                &#123;                    path:&#39;email&#39;,                    component:()=&gt;import(&#39;../components/EmailConfig&#39;)                &#125;,                &#123;                    path:&#39;user&#39;,                    components:&#123;                        default:()=&gt;import(&#39;../components/UserConfig&#39;),                        helper:()=&gt;import(&#39;../components/UserHelper&#39;)                    &#125;                &#125;            ]        &#125;    ]&#125;)</code></pre><p>App.vue</p><pre><code>&lt;template&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;</code></pre><p>Login.vue</p><img src="/2022/060432144/image-20220605115929618.png" class><pre><code>&lt;template&gt;  登录页  &lt;button @click=&quot;login&quot;&gt;登录&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Login&quot;,  methods:&#123;    login()&#123;      this.$router.push(&#123;path:&#39;/main/email&#39;&#125;);    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p>Main.vue</p><img src="/2022/060432144/image-20220605115953647.png" class><pre><code>&lt;template&gt;  &lt;div style=&quot;display: flex&quot;&gt;    &lt;div style=&quot;width:200px;background-color: peachpuff;height: 500px;&quot;&gt;      &lt;NavMenu&gt;&lt;/NavMenu&gt;    &lt;/div&gt;    &lt;div style=&quot;background-color:cornsilk;width: 100%;&quot;&gt;      &lt;div&gt;        &lt;router-view&gt;&lt;/router-view&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;router-view name=&quot;helper&quot;&gt;&lt;/router-view&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import NavMenu from &#39;./NavMenu&#39;export default &#123;  name: &quot;Main&quot;,  components:&#123;    NavMenu  &#125;&#125;&lt;/script&gt;</code></pre><p>NavMenu.vue</p><pre><code>&lt;template&gt;  &lt;router-link to=&quot;/main/email&quot;&gt;邮箱设置&lt;/router-link&gt;  &lt;br&gt;  &lt;router-link to=&quot;/main/user&quot;&gt;用户设置&lt;/router-link&gt;&lt;/template&gt;</code></pre><p>EmailConfig.vue</p><pre><code>&lt;template&gt;  邮箱配置&lt;/template&gt;</code></pre><p>UserConfig.vue</p><pre><code>&lt;template&gt;  用户配置&lt;/template&gt;</code></pre><p>UserHelper.vue</p><pre><code>&lt;template&gt;  用户帮助&lt;/template&gt;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>pom.xml</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>service</p><pre><code>@Overridepublic PageInfo&lt;Dept&gt; paged(int pageNum, int pageSize) &#123;    PageHelper.startPage(pageNum,pageSize);    List&lt;Dept&gt; list = deptMapper.getAll();    PageInfo pageInfo = new PageInfo(list);    return pageInfo;&#125;</code></pre><p>controller</p><pre><code>@RequestMapping(&quot;paged&quot;)@ResponseBodypublic PageInfo&lt;Dept&gt; paged(@RequestParam(defaultValue = &quot;1&quot;) int pageNum,@RequestParam(defaultValue = &quot;3&quot;) int pageSize)&#123;    return deptService.paged(pageNum,pageSize);&#125;</code></pre><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><pre><code>&lt;template&gt;  部门管理  &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt;    &lt;tr v-for=&quot;dept in pageInfo.list&quot; :key=&quot;dept.deptno&quot;&gt;      &lt;td&gt;&#123;dept.deptno&#125;&lt;/td&gt;      &lt;td&gt;&#123;dept.dname&#125;&lt;/td&gt;      &lt;td&gt;&#123;dept.loc&#125;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td colspan=&quot;3&quot;&gt;        &lt;a href=&quot;#&quot; v-for=&quot;num in pageInfo.navigatepageNums&quot; :key=&quot;num&quot; @click=&quot;paged(num,pageInfo.pageSize)&quot;&gt;[&#123;num&#125;]&lt;/a&gt;       &lt;a href=&quot;#&quot; @click=&quot;paged(pageInfo.navigateFirstPage,pageInfo.pageSize)&quot; v-show=&quot;pageInfo.hasPreviousPage&quot;&gt;第一页&lt;/a&gt;        &lt;a href=&quot;#&quot; @click=&quot;paged(pageInfo.prePage,pageInfo.pageSize)&quot; v-show=&quot;pageInfo.hasPreviousPage&quot;&gt;上一页&lt;/a&gt;        &lt;a href=&quot;#&quot; @click=&quot;paged(pageInfo.nextPage,pageInfo.pageSize)&quot; v-show=&quot;pageInfo.hasNextPage&quot;&gt;下一页&lt;/a&gt;        &lt;a href=&quot;#&quot; @click=&quot;paged(pageInfo.navigateLastPage,pageInfo.pageSize)&quot; v-show=&quot;pageInfo.hasNextPage&quot;&gt;最后一页&lt;/a&gt;        &lt;select v-model=&quot;pageInfo.pageSize&quot; @change=&quot;changePageSize&quot;&gt;          &lt;option&gt;3&lt;/option&gt;          &lt;option&gt;5&lt;/option&gt;          &lt;option&gt;10&lt;/option&gt;        &lt;/select&gt;      &lt;/td&gt;    &lt;/tr&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Dept&quot;,  data()&#123;    return &#123;      pageInfo:&#123;        pageNum:1,pageSize:3      &#125;    &#125;  &#125;,  methods:&#123;    paged(pageNum,pageSize)&#123;      this.$http.post(&#39;dept/paged&#39;,`pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageSize&#125;`)        .then((resp)=&gt;&#123;          this.pageInfo = resp.data;        &#125;)    &#125;,    changePageSize()&#123;      this.paged(1,this.pageInfo.pageSize)    &#125;  &#125;,  created() &#123;    this.paged(1,3)  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="ElementUI-plus"><a href="#ElementUI-plus" class="headerlink" title="ElementUI-plus"></a>ElementUI-plus</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install element-plus --save</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><pre><code>// main.jsimport &#123; createApp &#125; from &#39;vue&#39;import ElementPlus from &#39;element-plus&#39;import &#39;element-plus/dist/index.css&#39;import App from &#39;./App.vue&#39;const app = createApp(App)app.use(ElementPlus)app.mount(&#39;#app&#39;)</code></pre><h3 id="Container-布局容器"><a href="#Container-布局容器" class="headerlink" title="Container 布局容器"></a>Container 布局容器</h3><p>用于布局的容器组件，方便快速搭建页面的基本结构：</p><p><code>&lt;el-container&gt;</code>：外层容器。 当子元素中包含 <code>&lt;el-header&gt;</code> 或 <code>&lt;el-footer&gt;</code> 时，全部子元素会垂直上下排列， 否则会水平左右排列。</p><p><code>&lt;el-header&gt;</code>：顶栏容器。</p><p><code>&lt;el-aside&gt;</code>：侧边栏容器。</p><p><code>&lt;el-main&gt;</code>：主要区域容器。</p><p><code>&lt;el-footer&gt;</code>：底栏容器。</p><img src="/2022/060432144/image-20220529084048004.png" class><pre><code>&lt;template&gt;  &lt;div class=&quot;common-layout&quot;&gt;    &lt;el-container&gt;      &lt;el-header&gt;Header&lt;/el-header&gt;      &lt;el-main&gt;Main&lt;/el-main&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header, .common-layout .el-footer, .common-layout .el-main, .common-layout .el-aside &#123;  display: flex;  justify-content: center;  align-items: center;&#125;.common-layout .el-header, .common-layout .el-footer &#123;  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;&#125;.common-layout .el-main &#123;  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;&#125;&lt;/style&gt;</code></pre><img src="/2022/060432144/image-20220529085225246.png" class><pre><code>&lt;template&gt;  &lt;div class=&quot;common-layout&quot;&gt;    &lt;el-container&gt;      &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt;      &lt;el-container&gt;        &lt;el-header&gt;Header&lt;/el-header&gt;        &lt;el-main&gt;Main&lt;/el-main&gt;        &lt;el-footer&gt;Footer&lt;/el-footer&gt;      &lt;/el-container&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header,.common-layout .el-footer,.common-layout .el-main,.common-layout .el-aside &#123;  display: flex;  justify-content: center;  align-items: center;&#125;.common-layout .el-header,.common-layout .el-footer &#123;  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;&#125;.common-layout .el-main &#123;  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;&#125;.common-layout .el-aside &#123;  background-color: var(--el-color-primary-light-8);  color: var(--el-text-color-primary);  text-align: center;&#125;&lt;/style&gt;</code></pre><img src="/2022/060432144/image-20220529085739138.png" class><pre><code>&lt;template&gt;  &lt;div class=&quot;common-layout&quot;&gt;    &lt;el-container&gt;      &lt;el-header&gt;Header&lt;/el-header&gt;      &lt;el-container&gt;        &lt;el-aside width=&quot;200px&quot;&gt;Aside&lt;/el-aside&gt;        &lt;el-main&gt;Main&lt;/el-main&gt;      &lt;/el-container&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header,.common-layout .el-footer,.common-layout .el-main,.common-layout .el-aside &#123;  display: flex;  justify-content: center;  align-items: center;&#125;.common-layout .el-header,.common-layout .el-footer &#123;  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;&#125;.common-layout .el-main &#123;  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;&#125;.common-layout .el-aside &#123;  /*var()函数中的值可以在浏览器调试中查看*/  background-color: var(--el-color-primary-light-8);  color: var(--el-text-color-primary);  text-align: center;&#125;&lt;/style&gt;</code></pre><h4 id="Container-属性"><a href="#Container-属性" class="headerlink" title="Container 属性"></a>Container 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">direction</td><td align="left">子元素的排列方向</td><td align="left">string</td><td align="left">horizontal &#x2F; vertical</td><td align="left">子元素中有 <code>el-header</code> 或 <code>el-footer</code> 时为 vertical，否则为 horizontal</td></tr></tbody></table><h4 id="Container-插槽"><a href="#Container-插槽" class="headerlink" title="Container 插槽"></a>Container 插槽</h4><table><thead><tr><th align="left">插槽名</th><th align="left">说明</th><th align="left">子标签</th></tr></thead><tbody><tr><td align="left">—</td><td align="left">自定义默认内容</td><td align="left">Container &#x2F; Header &#x2F; Aside &#x2F; Main &#x2F; Footer</td></tr></tbody></table><h4 id="Header-属性"><a href="#Header-属性" class="headerlink" title="Header 属性"></a>Header 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">height</td><td align="left">顶栏高度</td><td align="left">string</td><td align="left">—</td><td align="left">60px</td></tr></tbody></table><h4 id="Header-插槽"><a href="#Header-插槽" class="headerlink" title="Header 插槽"></a>Header 插槽</h4><table><thead><tr><th align="left">插槽名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">—</td><td align="left">自定义默认内容</td></tr></tbody></table><h4 id="Aside-属性"><a href="#Aside-属性" class="headerlink" title="Aside 属性"></a>Aside 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">width</td><td align="left">侧边栏宽度</td><td align="left">string</td><td align="left">—</td><td align="left">300px</td></tr></tbody></table><h4 id="Aside-插槽"><a href="#Aside-插槽" class="headerlink" title="Aside 插槽"></a>Aside 插槽</h4><table><thead><tr><th align="left">插槽名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">—</td><td align="left">自定义默认内容</td></tr></tbody></table><h4 id="Main-插槽"><a href="#Main-插槽" class="headerlink" title="Main 插槽"></a>Main 插槽</h4><table><thead><tr><th align="left">插槽名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">—</td><td align="left">自定义默认内容</td></tr></tbody></table><h4 id="Footer-属性"><a href="#Footer-属性" class="headerlink" title="Footer 属性"></a>Footer 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">height</td><td align="left">底栏高度</td><td align="left">string</td><td align="left">—</td><td align="left">60px</td></tr></tbody></table><h4 id="Footer-插槽"><a href="#Footer-插槽" class="headerlink" title="Footer 插槽"></a>Footer 插槽</h4><table><thead><tr><th align="left">插槽名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">—</td><td align="left">自定义默认内容</td></tr></tbody></table><h4 id="CSS-var-函数"><a href="#CSS-var-函数" class="headerlink" title="CSS var() 函数"></a>CSS var() 函数</h4><p>实例</p><p>定义一个名为 “–main-bg-color” 的属性，然后使用 var() 函数调用该属性：</p><pre><code>:root &#123;  --main-bg-color: coral;&#125; #div1 &#123;  background-color: var(--main-bg-color);&#125; #div2 &#123;  background-color: var(--main-bg-color);&#125;</code></pre><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>通过基础的 24 分栏，迅速简便地创建布局。</p><h4 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h4><p>​       使用列创建基础网格布局。</p><p>​       通过 <code>row</code> 和 <code>col</code> 组件，并通过 col 组件的 <code>span</code> 属性我们就可以自由地组合布局。</p><p>​<img src="/2022/060432144/image-20220529065557853.png" class></p><pre><code>&lt;template&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;24&quot;&gt;&lt;div class=&quot;grid-content bg-purple-dark&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;12&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.el-row &#123;  margin-bottom: 20px;&#125;.el-row:last-child &#123;  margin-bottom: 0;&#125;.el-col &#123;  border-radius: 4px;&#125;.grid-content &#123;  border-radius: 4px;  min-height: 36px;&#125;.bg-purple-dark &#123;    background: #99a9bf;&#125;.bg-purple &#123;    background: rgba(192,132,252);&#125;.bg-purple-light &#123;    background: #e5e9f2;&#125;&lt;/style&gt;</code></pre><h4 id="分栏间隔"><a href="#分栏间隔" class="headerlink" title="分栏间隔"></a>分栏间隔</h4><p>支持列间距。</p><img src="/2022/060432144/image-20220529070245284.png" class><p>行提供 <code>gutter</code> 属性来指定列之间的间距，其默认值为0。</p><pre><code>&lt;template&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row &#123;  margin-bottom: 20px;&#125;.el-row:last-child &#123;  margin-bottom: 0;&#125;.el-col &#123;  border-radius: 4px;&#125;.grid-content &#123;  border-radius: 4px;  min-height: 36px;&#125;.bg-purple-dark &#123;  background: #99a9bf;&#125;.bg-purple &#123;  background: rgba(192,132,252);&#125;.bg-purple-light &#123;  background: #e5e9f2;&#125;&lt;/style&gt;</code></pre><h4 id="混合布局"><a href="#混合布局" class="headerlink" title="混合布局"></a>混合布局</h4><p>通过基础的 1&#x2F;24 分栏任意扩展组合形成较为复杂的混合布局。</p><img src="/2022/060432144/image-20220529071751884.png" class><pre><code>&lt;template&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;16&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;8&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;16&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;4&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row &#123;  margin-bottom: 20px;&#125;.el-row:last-child &#123;  margin-bottom: 0;&#125;.el-col &#123;  border-radius: 4px;&#125;.grid-content &#123;  border-radius: 4px;  min-height: 36px;&#125;.bg-purple &#123;  background: rgba(192,132,252);&#125;&lt;/style&gt;</code></pre><h4 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h4><p>您可以指定列偏移量。</p><img src="/2022/060432144/image-20220529072048322.png" class><p>通过制定 col 组件的 <code>offset</code> 属性可以指定分栏偏移的栏数。</p><pre><code>&lt;template&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;      &gt;&lt;div class=&quot;grid-content bg-purple&quot;    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;      &gt;&lt;div class=&quot;grid-content bg-purple&quot;    /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot; :offset=&quot;6&quot;      &gt;&lt;div class=&quot;grid-content bg-purple&quot;    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter=&quot;20&quot;&gt;    &lt;el-col :span=&quot;12&quot; :offset=&quot;6&quot;      &gt;&lt;div class=&quot;grid-content bg-purple&quot;    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row &#123;  margin-bottom: 20px;&#125;.el-row:last-child &#123;  margin-bottom: 0;&#125;.el-col &#123;  border-radius: 4px;&#125;.grid-content &#123;  border-radius: 4px;  min-height: 36px;&#125;.bg-purple &#123;  background: rgba(192,132,252);&#125;&lt;/style&gt;</code></pre><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>默认使用 flex 布局来对分栏进行灵活的对齐。</p><img src="/2022/060432144/image-20220529072616096.png" class><p>您可以通过<code>justify</code> 属性来定义子元素的排版方式，其取值为start、center、end、space-between、space-around或space-evenly。</p><pre><code>&lt;template&gt;  &lt;el-row class=&quot;row-bg&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class=&quot;row-bg&quot; justify=&quot;center&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class=&quot;row-bg&quot; justify=&quot;end&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class=&quot;row-bg&quot; justify=&quot;space-between&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class=&quot;row-bg&quot; justify=&quot;space-around&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class=&quot;row-bg&quot; justify=&quot;space-evenly&quot;&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple-light&quot; /&gt;&lt;/el-col&gt;    &lt;el-col :span=&quot;6&quot;&gt;&lt;div class=&quot;grid-content bg-purple&quot; /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row &#123;  margin-bottom: 20px;&#125;.el-row:last-child &#123;  margin-bottom: 0;&#125;.el-col &#123;  border-radius: 4px;&#125;.grid-content &#123;  border-radius: 4px;  min-height: 36px;&#125;.bg-purple &#123;  background: rgba(192,132,252);&#125;.bg-purple-light &#123;  background: #e5e9f2;&#125;&lt;/style&gt;</code></pre><h4 id="Row-属性"><a href="#Row-属性" class="headerlink" title="Row 属性"></a>Row 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">gutter</td><td align="left">栅格间隔</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">justify</td><td align="left">flex 布局下的水平排列方式</td><td align="left">string</td><td align="left">start&#x2F;end&#x2F;center&#x2F;space-around&#x2F;space-between&#x2F;space-evenly</td><td align="left">start</td></tr><tr><td align="left">align</td><td align="left">flex 布局下的垂直排列方式</td><td align="left">string</td><td align="left">top&#x2F;middle&#x2F;bottom</td><td align="left">top</td></tr><tr><td align="left">tag</td><td align="left">自定义元素标签</td><td align="left">string</td><td align="left">*</td><td align="left">div</td></tr></tbody></table><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h4 id="Col-属性"><a href="#Col-属性" class="headerlink" title="Col 属性"></a>Col 属性</h4><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">类型</th><th align="left">可选值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">span</td><td align="left">栅格占据的列数</td><td align="left">number</td><td align="left">—</td><td align="left">24</td></tr><tr><td align="left">offset</td><td align="left">栅格左侧的间隔格数</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">push</td><td align="left">栅格向右移动格数</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">pull</td><td align="left">栅格向左移动格数</td><td align="left">number</td><td align="left">—</td><td align="left">0</td></tr><tr><td align="left">xs</td><td align="left"><code>&lt;768px</code> 响应式栅格数或者栅格属性对象</td><td align="left">number&#x2F;object (例如 {span: 4, offset: 4})</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">sm</td><td align="left"><code>≥768px</code> 响应式栅格数或者栅格属性对象</td><td align="left">number&#x2F;object (例如 {span: 4, offset: 4})</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">md</td><td align="left"><code>≥992px</code> 响应式栅格数或者栅格属性对象</td><td align="left">number&#x2F;object (例如 {span: 4, offset: 4})</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">lg</td><td align="left"><code>≥1200px</code> 响应式栅格数或者栅格属性对象</td><td align="left">number&#x2F;object (例如 {span: 4, offset: 4})</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">xl</td><td align="left"><code>≥1920px</code> 响应式栅格数或者栅格属性对象</td><td align="left">number&#x2F;object (例如 {span: 4, offset: 4})</td><td align="left">—</td><td align="left">—</td></tr><tr><td align="left">tag</td><td align="left">自定义元素标签</td><td align="left">string</td><td align="left">*</td><td align="left">div</td></tr></tbody></table><h2 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h2><img src="/2022/060432144/image-20220529163235852.png" class><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;el-form class=&quot;login-container&quot;&gt;      &lt;h3 class=&quot;login-title&quot;&gt;系统登录&lt;/h3&gt;      &lt;el-form-item prop=&quot;username&quot;&gt;        &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop=&quot;password&quot;&gt;        &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;密码&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop=&quot;checkCode&quot;&gt;        &lt;img&gt;&lt;a href=&quot;#&quot; &gt;看不清&lt;/a&gt;        &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; &gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;Login&quot;,  data()&#123;    return&#123;      user:&#123;&#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped=&quot;scoped&quot;&gt;.login-container&#123;  width:350px;  margin:100px auto 10px;  border:1px solid #eaeaea;  padding:35px 35px 15px 35px;  border-radius: 15px;  box-shadow:0 0 25px #cac6c6;&#125;.login-title&#123;  text-align: center;  color:#505458;  margin:0px auto 40px;&#125;&lt;/style&gt;</code></pre><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install @element-plus/icons-vue</code></pre><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><pre><code>import * as ElementPlusIconsVue from &#39;@element-plus/icons-vue&#39;const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123;  app.component(key, component)&#125;</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><pre><code>&lt;template&gt;  &lt;p&gt;    with extra class &lt;b&gt;is-loading&lt;/b&gt;, your icon is able to rotate 360 deg in 2    seconds, you can also override this  &lt;/p&gt;  &lt;el-icon :size=&quot;20&quot;&gt;    &lt;Edit /&gt;  &lt;/el-icon&gt;  &lt;el-icon color=&quot;#409EFC&quot; class=&quot;no-inherit&quot;&gt;    &lt;Share /&gt;  &lt;/el-icon&gt;  &lt;el-icon&gt;    &lt;Delete /&gt;  &lt;/el-icon&gt;  &lt;el-icon class=&quot;is-loading&quot;&gt;    &lt;Loading /&gt;  &lt;/el-icon&gt;  &lt;el-button type=&quot;primary&quot;&gt;    &lt;el-icon style=&quot;vertical-align: middle&quot;&gt;      &lt;Search /&gt;    &lt;/el-icon&gt;    &lt;span style=&quot;vertical-align: middle&quot;&gt; Search &lt;/span&gt;  &lt;/el-button&gt;&lt;/template&gt;</code></pre><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><h3 id="登录页-1"><a href="#登录页-1" class="headerlink" title="登录页"></a>登录页</h3><img src="/2022/060432144/image-20220605151521598.png" class><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><h5 id="elementui的表单和表单元素"><a href="#elementui的表单和表单元素" class="headerlink" title="elementui的表单和表单元素"></a>elementui的表单和表单元素</h5><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;el-form class=&quot;login-container&quot;&gt;            &lt;h3 class=&quot;login-title&quot;&gt;系统登录&lt;/h3&gt;            &lt;el-form-item &gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item &gt;                &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;密码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item &gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item&gt;                &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; &gt;登录&lt;/el-button&gt;            &lt;/el-form-item&gt;        &lt;/el-form&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style scoped=&quot;scoped&quot;&gt;    .login-container&#123;        width:350px;        margin:100px auto 10px;        border:1px solid #eaeaea;        padding:35px 35px 15px 35px;        border-radius: 15px;        box-shadow:0 0 25px #cac6c6;    &#125;    .login-title&#123;        text-align: center;        color:#505458;        margin:0px auto 40px;    &#125;&lt;/style&gt;</code></pre><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>前端</p><pre><code>&lt;el-form-item &gt;    &lt;img :src=&quot;imgUrl&quot;&gt;&lt;a href=&quot;#&quot; @click=&quot;getCode&quot;&gt;看不清&lt;/a&gt;    &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt;</code></pre><pre><code>return&#123; imgUrl:&quot;http://localhost:8089/user/getCode&quot;&#125;</code></pre><pre><code>getCode()&#123;    this.imgUrl = this.imgUrl + &quot;?&quot;+Math.random();&#125;</code></pre><p>后端</p><pre><code>@RequestMapping(&quot;user/getCode&quot;)    public ResponseEntity&lt;byte[]&gt; getCode(HttpSession session) throws IOException&#123;        char[] arr = &#123;&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;&#125;;        StringBuilder stb = new StringBuilder();        int n;        for(int i = 0;i &lt; 4;i++) &#123;            n = (int)(Math.random()*arr.length);            stb.append(arr[n]);        &#125;                session.setAttribute(&quot;code&quot;, stb.toString());                //把字符串放入到图片中，写入到输出流中        BufferedImage buffImg = new BufferedImage(90, 20, BufferedImage.TYPE_INT_RGB);        //得到画布        Graphics g = buffImg.getGraphics();        //向画布中写入字符串        g.drawString(stb.toString(), 20, 15);                ByteArrayOutputStream bos = new ByteArrayOutputStream();        ImageIO.write(buffImg, &quot;jpeg&quot;, bos);                return new ResponseEntity&lt;byte[]&gt;(bos.toByteArray(),HttpStatus.CREATED);    &#125;</code></pre><h5 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h5><p>在表单和表单元素上添加属性</p><pre><code>&lt;template&gt;    &lt;div &gt;        &lt;el-form class=&quot;login-container&quot; :model=&quot;user&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;            &lt;h3 class=&quot;login-title&quot;&gt;系统登录&lt;/h3&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;密码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;checkCode&quot;&gt;                &lt;img :src=&quot;imgUrl&quot;&gt;&lt;a href=&quot;#&quot; @click=&quot;getCode&quot;&gt;看不清&lt;/a&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item&gt;                &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;            &lt;/el-form-item&gt;        &lt;/el-form&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><p>添加验证规则</p><pre><code>&lt;script&gt;    export default &#123;        data()&#123;            let checkCodeValidate = (rule,value,callback)=&gt;&#123;                let url = &quot;user/checkCode&quot;;                this.$http.post(url,`checkCode=$&#123;this.user.checkCode&#125;`).then(resp=&gt;&#123;                    if(!resp.data)&#123;                        callback(new Error(&quot;验证码输入错误！&quot;));                    &#125;else&#123;                        callback();                    &#125;                &#125;);            &#125;;            return&#123;                user:&#123;&#125;,                rules:&#123;                    username:[                        &#123;required:true,message:&#39;请输入用户名&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;用户名长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    password:[                        &#123;required:true,message:&#39;请输入密码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;密码长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    checkCode:[                        &#123;required:true,message:&#39;请输入验证码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;pattern:/^\w&#123;4&#125;$/,message:&quot;验证码长度必须为4位&quot;&#125;,                        &#123;validator:checkCodeValidate,trigger:&#39;blur&#39;&#125;                    ]                &#125;            &#125;        &#125;,        methods:&#123;            login()&#123;                this.$refs[&quot;loginForm&quot;].validate(valid=&gt;&#123;                    if(valid)&#123;                        //登录                    &#125;                &#125;);            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p>后端验证</p><pre><code>@RequestMapping(&quot;user/checkCode&quot;)    public boolean checkCode(String checkCode,HttpSession session) &#123;        String code = (String)session.getAttribute(&quot;code&quot;);                if(code != null &amp;&amp; code.equals(checkCode)) &#123;            return true;        &#125;else &#123;            return false;        &#125;            &#125;</code></pre><h5 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h5><p>登录</p><pre><code>login()&#123;                this.$refs[&quot;loginForm&quot;].validate(valid=&gt;&#123;                    if(valid)&#123;                        let url = &quot;user/login&quot;;                        this.$http.get(url,&#123;params:this.user&#125;).then((resp)=&gt;&#123;                            if(resp.data)&#123;                this.$store.commit(&quot;setUsername&quot;,this.user.username);                                this.$router.push(&quot;/main&quot;);                            &#125;else&#123;                                this.$alert(&quot;用户名或密码错误！&quot;);                            &#125;                        &#125;);                    &#125;                &#125;);            &#125;</code></pre><p>验证验证码</p><pre><code>let checkCodeValidate = (rule,value,callback)=&gt;&#123;                let url = &quot;user/checkCode&quot;;                this.$http.post(url,`checkCode=$&#123;this.user.checkCode&#125;`).then(resp=&gt;&#123;                    if(!resp.data)&#123;                        callback(new Error(&quot;验证码输入错误！&quot;));                    &#125;else&#123;                        callback();                    &#125;                &#125;);            &#125;;</code></pre><h5 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h5><p>登录成功后，修改state</p><pre><code>this.$store.commit(&quot;setUsername&quot;,this.user.username);</code></pre><pre><code>import &#123;createStore&#125; from &#39;vuex&#39;export default createStore(&#123;    state: &#123;        username: &#39;&#39;    &#125;,    mutations: &#123;        setUsername(state, payload) &#123;            state.username = payload;        &#125;    &#125;,    getters: &#123;        formatUsername(state) &#123;            return `用户名：$&#123;state.username&#125;`;        &#125;    &#125;&#125;)</code></pre><h5 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h5><p>登录成功后，跳转到主页</p><pre><code>this.$router.push(&quot;/main&quot;);</code></pre><pre><code>import Login from &#39;./views/Login&#39;import &#123;createRouter, createWebHistory&#125; from &#39;vue-router&#39;export default createRouter(&#123;    history: createWebHistory(),    routes: [        &#123;            path: &#39;/&#39;,            name: &#39;login&#39;,            component: Login        &#125;,        &#123;            path: &#39;/main&#39;,            name: &#39;main&#39;,            // route level code-splitting            // this generates a separate chunk (about.[hash].js) for this route            // which is lazy-loaded when the route is visited.            component: () =&gt; import(&#39;./views/Main.vue&#39;),         &#125;    ]&#125;)</code></pre><h5 id="键盘事件处理"><a href="#键盘事件处理" class="headerlink" title="键盘事件处理"></a>键盘事件处理</h5><p>回车提交表单</p><pre><code>&lt;template&gt;    &lt;div @keydown.enter=&quot;login&quot;&gt;        //...    &lt;/div&gt;&lt;/template&gt;</code></pre><h5 id="elementui的警告对话框alert"><a href="#elementui的警告对话框alert" class="headerlink" title="elementui的警告对话框alert"></a>elementui的警告对话框alert</h5><pre><code>this.$alert(&quot;用户名或密码错误！&quot;);</code></pre><h5 id="完整登录页"><a href="#完整登录页" class="headerlink" title="完整登录页"></a>完整登录页</h5><pre><code>&lt;template&gt;    &lt;div @keydown.enter=&quot;login&quot;&gt;        &lt;el-form class=&quot;login-container&quot; :model=&quot;user&quot; :rules=&quot;rules&quot; ref=&quot;loginForm&quot;&gt;            &lt;h3 class=&quot;login-title&quot;&gt;系统登录&lt;/h3&gt;            &lt;el-form-item prop=&quot;username&quot;&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.username&quot; placeholder=&quot;账号&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;password&quot;&gt;                &lt;el-input type=&quot;password&quot; v-model=&quot;user.password&quot; placeholder=&quot;密码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop=&quot;checkCode&quot;&gt;                &lt;img :src=&quot;imgUrl&quot;&gt;&lt;a href=&quot;#&quot; @click=&quot;getCode&quot;&gt;看不清&lt;/a&gt;                &lt;el-input type=&quot;text&quot; v-model=&quot;user.checkCode&quot; placeholder=&quot;验证码&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item&gt;                &lt;el-button type=&quot;primary&quot; style=&quot;width:100%;&quot; @click=&quot;login&quot;&gt;登录&lt;/el-button&gt;            &lt;/el-form-item&gt;        &lt;/el-form&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default &#123;        data()&#123;            let checkCodeValidate = (rule,value,callback)=&gt;&#123;                let url = &quot;user/checkCode&quot;;                this.$http.post(url,`checkCode=$&#123;this.user.checkCode&#125;`).then(resp=&gt;&#123;                    if(!resp.data)&#123;                        callback(new Error(&quot;验证码输入错误！&quot;));                    &#125;else&#123;                        callback();                    &#125;                &#125;);            &#125;;            return&#123;                imgUrl:&quot;http://localhost:8089/user/getCode&quot;,                user:&#123;&#125;,                rules:&#123;                    username:[                        &#123;required:true,message:&#39;请输入用户名&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;用户名长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    password:[                        &#123;required:true,message:&#39;请输入密码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;min:2,max:10,message:&#39;密码长度必须在2-10个字符之间&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;                    ],                    checkCode:[                        &#123;required:true,message:&#39;请输入验证码&#39;,trigger:[&#39;blur&#39;,&#39;change&#39;]&#125;,                        &#123;pattern:/^\w&#123;4&#125;$/,message:&quot;验证码长度必须为4位&quot;&#125;,                        &#123;validator:checkCodeValidate,trigger:&#39;blur&#39;&#125;                    ]                &#125;            &#125;        &#125;,        methods:&#123;            login()&#123;                this.$refs[&quot;loginForm&quot;].validate(valid=&gt;&#123;                    if(valid)&#123;                        let url = &quot;user/login&quot;;                        this.$http.get(url,&#123;params:this.user&#125;).then((resp)=&gt;&#123;                            if(resp.data)&#123;                this.$store.commit(&quot;setUsername&quot;,this.user.username);                                this.$router.push(&quot;/main&quot;);                            &#125;else&#123;                                this.$alert(&quot;用户名或密码错误！&quot;);                            &#125;                        &#125;);                    &#125;                &#125;);            &#125;,            getCode()&#123;                this.imgUrl = this.imgUrl + &quot;?&quot;+Math.random();            &#125;        &#125;    &#125;&lt;/script&gt;&lt;style scoped=&quot;scoped&quot;&gt;    .login-container&#123;        width:350px;        margin:100px auto 10px;        border:1px solid #eaeaea;        padding:35px 35px 15px 35px;        border-radius: 15px;        box-shadow:0 0 25px #cac6c6;    &#125;    .login-title&#123;        text-align: center;        color:#505458;        margin:0px auto 40px;    &#125;&lt;/style&gt;</code></pre><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><h5 id="布局-1"><a href="#布局-1" class="headerlink" title="布局"></a>布局</h5><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;el-container&gt;      &lt;el-header&gt;        &lt;el-row&gt;          &lt;el-col :span=&quot;6&quot;&gt;            &lt;span class=&quot;main_title&quot;&gt;东软人力资源管理系统&lt;/span&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;2&quot; :offset=&quot;16&quot; class=&quot;user_title&quot;&gt;            ADMIN          &lt;/el-col&gt;        &lt;/el-row&gt;      &lt;/el-header&gt;      &lt;el-container class=&quot;main&quot;&gt;        &lt;el-aside width=&quot;200px&quot;&gt;                  &lt;/el-aside&gt;        &lt;el-main&gt;          &lt;router-view&gt;&lt;/router-view&gt;        &lt;/el-main&gt;      &lt;/el-container&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.el-header,.el-footer &#123;  height: 60px;  background-color: #409EFF;&#125;a &#123;  text-decoration: none;&#125;.main_title &#123;  font-size: 22px;  color: #fff;  height: 60px;  line-height: 60px;&#125;.main&#123;  min-height: 480px;&#125;.user_title &#123;  height: 60px;  display: flex;  align-items: center;  justify-content: center;&#125;&lt;/style&gt;</code></pre><h5 id="Vuex-1"><a href="#Vuex-1" class="headerlink" title="Vuex"></a>Vuex</h5><p>显示用户名</p><pre><code>&lt;span&gt;    &#123; $store.state.username.toUpperCase() &#125;(两个大括号)&lt;/span&gt;</code></pre><h5 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h5><pre><code>&lt;el-aside width=&quot;200px&quot; v-show=&quot;isShowMenu&quot; &gt;          &lt;el-menu&gt;            &lt;el-sub-menu index=&quot;1&quot;&gt;              &lt;template #title&gt;                                &lt;span&gt;部门管理&lt;/span&gt;              &lt;/template&gt;              &lt;el-menu-item index=&quot;1-1&quot;&gt;                &lt;router-link to=&quot;/dept&quot;&gt;部门管理&lt;/router-link&gt;              &lt;/el-menu-item&gt;              &lt;el-menu-item index=&quot;1-2&quot;&gt;                &lt;span&gt;&lt;router-link to=&quot;/report&quot;&gt;报表&lt;/router-link&gt;&lt;/span&gt;              &lt;/el-menu-item&gt;            &lt;/el-sub-menu&gt;            &lt;el-menu-item index=&quot;2&quot;&gt;              &lt;span&gt;&lt;router-link to=&quot;/emp&quot;&gt;员工管理&lt;/router-link&gt;&lt;/span&gt;            &lt;/el-menu-item&gt;          &lt;/el-menu&gt;&lt;/el-aside&gt;</code></pre><h5 id="图标-1"><a href="#图标-1" class="headerlink" title="图标"></a>图标</h5><pre><code>&lt;el-icon&gt;&lt;location /&gt;&lt;/el-icon&gt;&lt;span&gt;部门管理&lt;/span&gt;&lt;el-icon&gt;&lt;document /&gt;&lt;/el-icon&gt;&lt;span&gt;&lt;router-link to=&quot;/emp&quot;&gt;员工管理&lt;/router-link&gt;&lt;/span&gt;</code></pre><h5 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h5><pre><code>&lt;el-col :span=&quot;2&quot; :offset=&quot;16&quot; class=&quot;user_title&quot;&gt;            &lt;el-dropdown class=&quot;el-dropdown-link&quot; @command=&quot;handleCommand&quot;&gt;                        &lt;span&gt;              &#123; $store.state.username.toUpperCase() &#125;                            &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;                        &lt;/span&gt;              &lt;template #dropdown&gt;                &lt;el-dropdown-menu&gt;                  &lt;el-dropdown-item command=&quot;hideMenu&quot;&gt;&#123; hideMenuText &#125;&lt;/el-dropdown-item&gt;                  &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出登录&lt;/el-dropdown-item&gt;                &lt;/el-dropdown-menu&gt;              &lt;/template&gt;            &lt;/el-dropdown&gt;&lt;/el-col&gt;</code></pre><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      hideMenuText: &#39;隐藏菜单&#39;,      isShowMenu: true    &#125;  &#125;,  methods: &#123;    handleCommand(command) &#123;      if (command == &quot;hideMenu&quot;) &#123;        if (this.hideMenuText == &quot;隐藏菜单&quot;) &#123;          this.hideMenuText = &quot;显示菜单&quot;;          this.isShowMenu = false;        &#125; else &#123;          this.hideMenuText = &quot;隐藏菜单&quot;;          this.isShowMenu = true;        &#125;      &#125; else if (command == &quot;exit&quot;) &#123;        this.$confirm(&quot;真的要退出系统吗?&quot;, &quot;提示&quot;).then(() =&gt; &#123;          this.$router.push(&#123;name: &#39;login&#39;&#125;);          this.$store.commit(&quot;setUsername&quot;, &quot;&quot;);        &#125;).catch(() =&gt; &#123;        &#125;);      &#125;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h5 id="完整主页"><a href="#完整主页" class="headerlink" title="完整主页"></a>完整主页</h5><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;el-container&gt;      &lt;el-header&gt;        &lt;el-row&gt;          &lt;el-col :span=&quot;6&quot;&gt;            &lt;span class=&quot;main_title&quot;&gt;东软人力资源管理系统&lt;/span&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;2&quot; :offset=&quot;16&quot; class=&quot;user_title&quot;&gt;                        &lt;el-dropdown class=&quot;el-dropdown-link&quot; @command=&quot;handleCommand&quot;&gt;                        &lt;span&gt;              &#123; $store.state.username.toUpperCase() &#125;                            &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;                        &lt;/span&gt;              &lt;template #dropdown&gt;                &lt;el-dropdown-menu&gt;                  &lt;el-dropdown-item command=&quot;hideMenu&quot;&gt;&#123; hideMenuText &#125;&lt;/el-dropdown-item&gt;                  &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出登录&lt;/el-dropdown-item&gt;                &lt;/el-dropdown-menu&gt;              &lt;/template&gt;            &lt;/el-dropdown&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;      &lt;/el-header&gt;      &lt;el-container class=&quot;main&quot;&gt;        &lt;el-aside width=&quot;200px&quot; v-show=&quot;isShowMenu&quot; &gt;          &lt;el-menu&gt;            &lt;el-sub-menu index=&quot;1&quot;&gt;              &lt;template #title&gt;                &lt;el-icon&gt;&lt;location /&gt;&lt;/el-icon&gt;                &lt;span&gt;部门管理&lt;/span&gt;              &lt;/template&gt;              &lt;el-menu-item index=&quot;1-1&quot;&gt;                &lt;router-link to=&quot;/dept&quot;&gt;部门管理&lt;/router-link&gt;              &lt;/el-menu-item&gt;              &lt;el-menu-item index=&quot;1-2&quot;&gt;                &lt;span&gt;&lt;router-link to=&quot;/report&quot;&gt;报表&lt;/router-link&gt;&lt;/span&gt;              &lt;/el-menu-item&gt;            &lt;/el-sub-menu&gt;            &lt;el-menu-item index=&quot;2&quot;&gt;              &lt;el-icon&gt;&lt;document /&gt;&lt;/el-icon&gt;              &lt;span&gt;&lt;router-link to=&quot;/emp&quot;&gt;员工管理&lt;/router-link&gt;&lt;/span&gt;            &lt;/el-menu-item&gt;          &lt;/el-menu&gt;        &lt;/el-aside&gt;        &lt;el-main&gt;          &lt;router-view&gt;&lt;/router-view&gt;        &lt;/el-main&gt;      &lt;/el-container&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      hideMenuText: &#39;隐藏菜单&#39;,      isShowMenu: true    &#125;  &#125;,  methods: &#123;    handleCommand(command) &#123;      if (command == &quot;hideMenu&quot;) &#123;        if (this.hideMenuText == &quot;隐藏菜单&quot;) &#123;          this.hideMenuText = &quot;显示菜单&quot;;          this.isShowMenu = false;        &#125; else &#123;          this.hideMenuText = &quot;隐藏菜单&quot;;          this.isShowMenu = true;        &#125;      &#125; else if (command == &quot;exit&quot;) &#123;        this.$confirm(&quot;真的要退出系统吗?&quot;, &quot;提示&quot;).then(() =&gt; &#123;          this.$router.push(&#123;name: &#39;login&#39;&#125;);          this.$store.commit(&quot;setUsername&quot;, &quot;&quot;);        &#125;).catch(() =&gt; &#123;        &#125;);      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.el-header,.el-footer &#123;  height: 60px;  background-color: #409EFF;&#125;a &#123;  text-decoration: none;&#125;.main_title &#123;  font-size: 22px;  color: #fff;  height: 60px;  line-height: 60px;&#125;.main&#123;  min-height: 480px;&#125;.user_title &#123;  height: 60px;  display: flex;  align-items: center;  justify-content: center;&#125;.el-dropdown-link &#123;  cursor: pointer;  color: #FFF;&#125;.el-icon-arrow-down &#123;  font-size: 12px;&#125;&lt;/style&gt;</code></pre><h3 id="部门管理"><a href="#部门管理" class="headerlink" title="部门管理"></a>部门管理</h3><p>Dept.vue</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;部门管理&lt;/h1&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;add&quot;&gt;添加部门&lt;/el-button&gt;    &lt;el-button @click=&quot;handleExport&quot;&gt;导出数据&lt;/el-button&gt;    &lt;el-table :data=&quot;depts&quot;&gt;      &lt;!-- &lt;el-table-column label=&quot;部门编号&quot; prop=&quot;deptno&quot;&gt;&lt;/el-table-column&gt; --&gt;      &lt;!-- &lt;el-table-column label=&quot;部门名称&quot; prop=&quot;dname&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;部门地址&quot; prop=&quot;loc&quot;&gt;&lt;/el-table-column&gt; --&gt;      &lt;el-table-column label=&quot;部门名称&quot;&gt;        &lt;template #default=&quot;&#123;row,$index&#125;&quot;&gt;          &lt;template v-if=&quot;row.insert&quot;&gt;            &lt;el-input type=&quot;text&quot; v-model=&quot;tempDepts[$index].deptno&quot;&gt;&lt;/el-input&gt;          &lt;/template&gt;          &lt;template v-else&gt;            &lt;span&gt;&#123; row.deptno &#125;&lt;/span&gt;          &lt;/template&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;部门名称&quot;&gt;        &lt;template #default=&quot;&#123;row,$index&#125;&quot;&gt;          &lt;template v-if=&quot;row.edit&quot;&gt;            &lt;el-input type=&quot;text&quot; v-model=&quot;tempDepts[$index].dname&quot;&gt;&lt;/el-input&gt;          &lt;/template&gt;          &lt;template v-else-if=&quot;row.insert&quot;&gt;            &lt;el-input type=&quot;text&quot; v-model=&quot;tempDepts[$index].dname&quot;&gt;&lt;/el-input&gt;          &lt;/template&gt;          &lt;template v-else&gt;            &lt;span&gt;&#123; row.dname &#125;&lt;/span&gt;          &lt;/template&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column label=&quot;部门地址&quot;&gt;        &lt;template #default=&quot;&#123;row,$index&#125;&quot;&gt;          &lt;template v-if=&quot;row.edit&quot;&gt;            &lt;el-input type=&quot;text&quot; v-model=&quot;tempDepts[$index].loc&quot;&gt;&lt;/el-input&gt;          &lt;/template&gt;          &lt;template v-else-if=&quot;row.insert&quot;&gt;            &lt;el-input type=&quot;text&quot; v-model=&quot;tempDepts[$index].loc&quot;&gt;&lt;/el-input&gt;          &lt;/template&gt;          &lt;template v-else&gt;            &lt;span&gt;&#123; row.loc &#125;&lt;/span&gt;          &lt;/template&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;      &lt;el-table-column&gt;        &lt;template #default=&quot;&#123;row,$index&#125;&quot;&gt;          &lt;template v-if=&quot;row.insert&quot;&gt;            &lt;el-button type=&quot;primary&quot; @click=&quot;insert()&quot;&gt;保存&lt;/el-button&gt;            &lt;el-button type=&quot;warning&quot; @click=&quot;cancelAdd($index)&quot;&gt;取消&lt;/el-button&gt;          &lt;/template&gt;          &lt;template v-else-if=&quot;row.edit&quot;&gt;            &lt;el-button type=&quot;primary&quot; @click=&quot;update(row,$index)&quot;&gt;保存&lt;/el-button&gt;            &lt;el-button type=&quot;warning&quot; @click=&quot;cancel(row,$index)&quot;&gt;取消&lt;/el-button&gt;          &lt;/template&gt;          &lt;template v-else&gt;            &lt;el-button type=&quot;primary&quot; @click=&quot;edit(row)&quot;&gt;编辑&lt;/el-button&gt;            &lt;el-button type=&quot;warning&quot; @click=&quot;del(row,$index)&quot;&gt;删除&lt;/el-button&gt;          &lt;/template&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      depts: [],      tempDepts: [],      isAdd: false    &#125;  &#125;,  created() &#123;    this.showData();  &#125;,  methods: &#123;    showData() &#123;      let url = &quot;dept/getAll&quot;;      this.$http.post(url).then(resp =&gt; &#123;        this.depts = resp.data;        let s = JSON.stringify(this.depts);        this.tempDepts = JSON.parse(s);      &#125;);      return true;    &#125;,    del(row, index) &#123;      this.$confirm(&#39;是否删除?&#39;, &#39;提示&#39;).then(() =&gt; &#123;        let url = `dept/delete?deptno=$&#123;row.deptno&#125;`;        this.$http.get(url).then(resp =&gt; &#123;          if (resp.data == 1) &#123;            this.$message(&#123;              type: &quot;success&quot;,              message: &quot;删除成功！&quot;            &#125;);            this.tempDepts.splice(index, 1)            this.depts.splice(index, 1)          &#125; else &#123;            this.$message(&#123;              type: &quot;error&quot;,              message: &quot;删除失败！&quot;            &#125;);          &#125;        &#125;);      &#125;).catch(() =&gt; &#123;      &#125;);    &#125;,    edit(row) &#123;      row.edit = true;    &#125;,    cancel(row, index) &#123;      row.edit = false;      this.tempDepts[index] = &#123;...this.depts[index]&#125;;    &#125;,    update(row, index) &#123;      let url = &quot;dept/update&quot;;      this.$http.post(url, this.tempDepts[index]).then(resp =&gt; &#123;        if (resp.data == 1) &#123;          this.$message(&#123;            type: &quot;success&quot;,            message: &quot;更新成功！&quot;          &#125;)          row.edit = false;          this.depts[index] = &#123;...this.tempDepts[index]&#125;;        &#125;      &#125;);    &#125;,    add() &#123;      if (this.isAdd) &#123;        this.$alert(&quot;不能同时添加多个部门！&quot;);        return;      &#125;      this.isAdd = true;      this.depts.splice(0, 0, &#123;deptno: &#39;&#39;, dname: &#39;&#39;, loc: &#39;&#39;, insert: true&#125;);      this.tempDepts.splice(0, 0, &#123;deptno: &#39;&#39;, dname: &#39;&#39;, loc: &#39;&#39;, insert: true&#125;);    &#125;,    cancelAdd(index) &#123;      this.$confirm(&quot;是否取消?&quot;, &quot;提示&quot;).then(() =&gt; &#123;        this.depts.splice(index, 1);        this.tempDepts.splice(index, 1);        this.isAdd = false;      &#125;).catch(() =&gt; &#123;      &#125;);    &#125;,    insert() &#123;      let url = &quot;dept/insert&quot;;      this.$http.post(url, this.tempDepts[0]).then(resp =&gt; &#123;        if (resp.data == 1) &#123;          this.$message(&#123;            type: &quot;success&quot;,            message: &quot;添加成功！&quot;          &#125;);          this.tempDepts[0].insert = false;          this.depts[0] = &#123;...this.tempDepts[0]&#125;;        &#125; else &#123;          this.$message(&#123;            type: &quot;error&quot;,            message: &quot;添加失败！&quot;          &#125;);        &#125;        this.isAdd = false;      &#125;);    &#125;,    handleExport() &#123;      let url = &quot;dept/exportExcel&quot;;      this.$http.get(url, &#123;        //服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;，默认是&#39;json&#39;        responseType: &quot;blob&quot;      &#125;)          .then(res =&gt; &#123;            if (!res) return            const blob = new Blob([res.data], &#123;type: &#39;application/vnd.ms-excel&#39;&#125;) // 构造一个blob对象来处理数据，并设置文件类型            if (window.navigator.msSaveOrOpenBlob) &#123; //兼容IE10              navigator.msSaveBlob(blob, this.filename)            &#125; else &#123;              const href = URL.createObjectURL(blob) //创建新的URL表示指定的blob对象              const a = document.createElement(&#39;a&#39;) //创建a标签              a.style.display = &#39;none&#39;              a.href = href // 指定下载链接              a.download = &quot;dept.xls&quot; //指定下载文件名              a.click() //触发下载              URL.revokeObjectURL(a.href) //释放URL对象            &#125;            // 这里也可以不创建a链接，直接window.open(href)也能下载          &#125;)          .catch(err =&gt; &#123;            console.log(err)          &#125;)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>服务器端</p><p>控制器</p><pre><code>package com.neu.controller;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.List;import com.github.pagehelper.PageInfo;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.*;import org.apache.poi.ss.util.CellRangeAddress;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.neu.po.Dept;import com.neu.service.DeptService;@RestController@RequestMapping(&quot;dept&quot;)public class DeptController &#123;    @Autowired    private DeptService deptService;    @RequestMapping(&quot;getById&quot;)    public Dept getById(int deptno) &#123;        Dept dept = deptService.getById(deptno);        return dept;    &#125;    @RequestMapping(&quot;getAll&quot;)    public List&lt;Dept&gt; getAll() &#123;        List&lt;Dept&gt; list = deptService.getAll();        return list;    &#125;    @RequestMapping(&quot;delete&quot;)    public int delete(int deptno) &#123;        return deptService.delete(deptno);    &#125;    @RequestMapping(&quot;update&quot;)    public int update(@RequestBody Dept dept) &#123;        return deptService.update(dept);    &#125;    @RequestMapping(&quot;insert&quot;)    public int insert(@RequestBody Dept dept) &#123;        return deptService.insert(dept);    &#125;    @RequestMapping(&quot;exportExcel&quot;)    public ResponseEntity&lt;byte[]&gt; exportExcel() throws IOException &#123;        List&lt;Dept&gt; list = deptService.getAll();        Workbook wb = new HSSFWorkbook();        Sheet sheet = wb.createSheet(&quot;部门&quot;);        // 起始行号        int rowNum = 1;        // 起始列号        int defaultColumnNum = 0;        int columnNum = defaultColumnNum;        Row titleRow = sheet.createRow(rowNum++);        Cell cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;编号&quot;);        cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;名称&quot;);        cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;地址&quot;);        Row row = null;        for (Dept dept : list) &#123;            row = sheet.createRow(rowNum++);            // 每一行的列号从头开始            columnNum = defaultColumnNum;            row.createCell(columnNum++).setCellValue(dept.getDeptno());            row.createCell(columnNum++).setCellValue(dept.getDname());            row.createCell(columnNum++).setCellValue(dept.getLoc());        &#125;        sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 2));        Cell cellTitle = sheet.createRow(0).createCell(0);        cellTitle.setCellValue(&quot;部门列表&quot;);        CellStyle titleStyle = wb.createCellStyle();        titleStyle.setAlignment(HorizontalAlignment.CENTER);        titleStyle.setVerticalAlignment(VerticalAlignment.CENTER);        Font font = wb.createFont();        font.setFontHeightInPoints((short)24);        //设置粗体        font.setBold(true);        font.setFontName(&quot;宋体&quot;);        font.setColor(IndexedColors.BLUE.index);        titleStyle.setFont(font);        cellTitle.setCellStyle(titleStyle);        // 创建一个字节数组输出流        ByteArrayOutputStream bos = new ByteArrayOutputStream();        // 把工作簿内容写入到输出流中        wb.write(bos);        // 创建http协议的头        HttpHeaders headers = new HttpHeaders();//headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);        // 设置附件的名字        headers.setContentDispositionFormData(&quot;attachment&quot;, &quot;dept.xls&quot;);        wb.close();        return new ResponseEntity&lt;byte[]&gt;(bos.toByteArray(), headers, HttpStatus.CREATED);    &#125;&#125;</code></pre><h4 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h4><p>jar</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>后端</p><pre><code>@RequestMapping(&quot;exportExcel&quot;)    public ResponseEntity&lt;byte[]&gt; exportExcel() throws IOException &#123;        List&lt;Dept&gt; list = deptService.getAll();        Workbook wb = new HSSFWorkbook();        Sheet sheet = wb.createSheet(&quot;部门&quot;);        // 起始行号        int rowNum = 1;        // 起始列号        int defaultColumnNum = 0;        int columnNum = defaultColumnNum;        Row titleRow = sheet.createRow(rowNum++);        Cell cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;编号&quot;);        cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;名称&quot;);        cell = titleRow.createCell(columnNum++);        cell.setCellValue(&quot;地址&quot;);        Row row = null;        for (Dept dept : list) &#123;            row = sheet.createRow(rowNum++);            // 每一行的列号从头开始            columnNum = defaultColumnNum;            row.createCell(columnNum++).setCellValue(dept.getDeptno());            row.createCell(columnNum++).setCellValue(dept.getDname());            row.createCell(columnNum++).setCellValue(dept.getLoc());        &#125;        sheet.addMergedRegion(new CellRangeAddress(0, 0, 0, 2));        Cell cellTitle = sheet.createRow(0).createCell(0);        cellTitle.setCellValue(&quot;部门列表&quot;);        CellStyle titleStyle = wb.createCellStyle();        titleStyle.setAlignment(HorizontalAlignment.CENTER);        titleStyle.setVerticalAlignment(VerticalAlignment.CENTER);        Font font = wb.createFont();        font.setFontHeightInPoints((short)24);        //设置粗体        font.setBold(true);        font.setFontName(&quot;宋体&quot;);        font.setColor(IndexedColors.BLUE.index);        titleStyle.setFont(font);        cellTitle.setCellStyle(titleStyle);        // 创建一个字节数组输出流        ByteArrayOutputStream bos = new ByteArrayOutputStream();        // 把工作簿内容写入到输出流中        wb.write(bos);        // 创建http协议的头        HttpHeaders headers = new HttpHeaders();//headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);        // 设置附件的名字        headers.setContentDispositionFormData(&quot;attachment&quot;, &quot;dept.xls&quot;);        wb.close();        return new ResponseEntity&lt;byte[]&gt;(bos.toByteArray(), headers, HttpStatus.CREATED);    &#125;</code></pre><p>前端</p><pre><code>&lt;el-button @click=&quot;handleExport&quot;&gt;导出数据&lt;/el-button&gt;</code></pre><pre><code>handleExport() &#123;      let url = &quot;dept/exportExcel&quot;;      this.$http.get(url, &#123;        //服务器响应的数据类型，可以是 &#39;arraybuffer&#39;, &#39;blob&#39;, &#39;document&#39;, &#39;json&#39;, &#39;text&#39;, &#39;stream&#39;，默认是&#39;json&#39;        responseType: &quot;blob&quot;      &#125;)          .then(res =&gt; &#123;            if (!res) return            const blob = new Blob([res.data], &#123;type: &#39;application/vnd.ms-excel&#39;&#125;) // 构造一个blob对象来处理数据，并设置文件类型            if (window.navigator.msSaveOrOpenBlob) &#123; //兼容IE10              navigator.msSaveBlob(blob, this.filename)            &#125; else &#123;              const href = URL.createObjectURL(blob) //创建新的URL表示指定的blob对象              const a = document.createElement(&#39;a&#39;) //创建a标签              a.style.display = &#39;none&#39;              a.href = href // 指定下载链接              a.download = &quot;dept.xls&quot; //指定下载文件名              a.click() //触发下载              URL.revokeObjectURL(a.href) //释放URL对象            &#125;            // 这里也可以不创建a链接，直接window.open(href)也能下载          &#125;)          .catch(err =&gt; &#123;            console.log(err)          &#125;)    &#125;</code></pre><h4 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h4><p>jar</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;    &lt;artifactId&gt;poi&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>后端Service</p><pre><code>@Transactional//事务处理    public int importData(InputStream in) throws IOException &#123;        Workbook wb = new HSSFWorkbook(in);        //得到工作簿的第一个sheet        Sheet sheet = wb.getSheetAt(0);        //得到数据最后一行的行号        int rows = sheet.getLastRowNum();        Row row;        Dept dept = null;        int id;        Integer deptno;        String dname;        String loc;        for(int i = 2;i &lt;= rows;i++) &#123;            //得到行对象            row = sheet.getRow(i);            deptno = (int)row.getCell(1).getNumericCellValue();//从第二列开始读取            dname = row.getCell(2).getStringCellValue();            loc = row.getCell(3).getStringCellValue();            dept = new Dept(deptno,dname,loc);            insert(dept);//调用当前类中的插入方法        &#125;        try &#123;            Thread.sleep(5000);//测试延迟加载效果        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        return rows - 1;    &#125;</code></pre><p>后端控制器</p><pre><code>@PostMapping(&quot;import&quot;)public int importData(MultipartFile file) throws IOException &#123;    return deptService.importData(file.getInputStream());&#125;</code></pre><p>前端</p><pre><code>&lt;el-upload        style=&quot;display: inline;margin-left:10px;&quot;        :show-file-list=&quot;false&quot;        :before-upload=&quot;beforeUpload&quot;        :on-success=&quot;onSuccess&quot;        :on-error=&quot;onError&quot;        action=&quot;http://localhost:8089/dept/import&quot;        :disabled=&quot;importDataDisabled&quot;    &gt;      &lt;el-button type=&quot;success&quot; :disabled=&quot;importDataDisabled&quot; :icon=&quot;importDataIcon&quot;&gt;&#123;btnText&#125;&lt;/el-button&gt;&lt;/el-upload&gt;//导入图标import &#123;UploadFilled,Loading&#125; from &#39;@element-plus/icons-vue&#39;data()&#123;    return&#123;        importDataDisabled:false,        importDataIcon:UploadFilled,        btnText:&#39;导入数据&#39;    &#125;&#125;//方法beforeUpload()&#123;    this.btnText = &quot;正在导入&quot;;    this.importDataIcon = Loading;    this.importDataDisabled=true;&#125;,onSuccess()&#123;    this.btnText = &quot;导入数据&quot;;    this.importDataIcon = UploadFilled;    this.importDataDisabled=false;    this.$alert(&quot;导入成功！&quot;);    //刷新页面    this.getPaged(1,this.pageInfo.pageSize,this.keyword);&#125;,onError()&#123;    this.btnText = &quot;导入数据&quot;;    this.importDataIcon = UploadFilled;    this.importDataDisabled=false;    this.$alert(&quot;导入失败！&quot;);&#125;</code></pre><p>excel文件</p><img src="/2022/060432144/image-20220612104308797.png" class><h3 id="员工管理"><a href="#员工管理" class="headerlink" title="员工管理"></a>员工管理</h3><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;员工管理&lt;/h1&gt;    &lt;el-button @click=&quot;add&quot;&gt;添加员工&lt;/el-button&gt;    &lt;el-table :data=&quot;pageInfo.list&quot;&gt;      &lt;el-table-column width=&quot;80&quot; label=&quot;编号&quot; prop=&quot;empno&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;80&quot; label=&quot;姓名&quot; prop=&quot;ename&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;100&quot; label=&quot;岗位&quot; prop=&quot;job&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;80&quot; label=&quot;经理&quot; prop=&quot;mgr&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;120&quot; label=&quot;入职日期&quot; prop=&quot;hiredate&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;80&quot; label=&quot;薪水&quot; prop=&quot;sal&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;80&quot; label=&quot;奖金&quot; prop=&quot;comm&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column width=&quot;120&quot; label=&quot;部门&quot; prop=&quot;dept.dname&quot;&gt;&lt;/el-table-column&gt;      &lt;el-table-column label=&quot;操作&quot;&gt;        &lt;template #default=&quot;&#123;row&#125;&quot;&gt;          &lt;el-button @click=&quot;edit(row)&quot;&gt;编辑&lt;/el-button&gt;          &lt;el-button @click=&quot;del(row)&quot;&gt;删除&lt;/el-button&gt;        &lt;/template&gt;      &lt;/el-table-column&gt;    &lt;/el-table&gt;    &lt;el-pagination        layout=&quot;prev,pager,next,total,jumper,sizes&quot;        :total=&quot;pageInfo.total&quot;        v-model:currentPage=&quot;pageInfo.pageNum&quot;        v-model:page-size=&quot;pageInfo.pageSize&quot;        :page-sizes=&quot;[5,10,15,20]&quot;        background        @current-change=&quot;handleCurrentChange&quot;        @size-change=&quot;handleSizeChange&quot;    &gt;    &lt;/el-pagination&gt;    &lt;el-dialog v-model=&quot;disableDialog&quot; :title=&quot;dialogTitle&quot; center width=&quot;500px&quot;&gt;      &lt;el-form&gt;        &lt;el-row :gutter=&quot;20&quot;&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工编号&quot;&gt;              &lt;el-input v-model=&quot;emp.empno&quot; placeholder=&quot;员工编号&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工姓名&quot;&gt;              &lt;el-input v-model=&quot;emp.ename&quot; placeholder=&quot;员工姓名&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;        &lt;el-row :gutter=&quot;20&quot;&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工岗位&quot;&gt;              &lt;el-input v-model=&quot;emp.job&quot; placeholder=&quot;员工岗位&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工经理&quot;&gt;              &lt;el-input v-model=&quot;emp.mgr&quot; placeholder=&quot;员工经理&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;        &lt;el-row :gutter=&quot;20&quot;&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;入职日期&quot;&gt;              &lt;el-date-picker v-model=&quot;emp.hiredate&quot; placeholder=&quot;入职日期&quot;&gt;&lt;/el-date-picker&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工薪水&quot;&gt;              &lt;el-input v-model=&quot;emp.sal&quot; placeholder=&quot;员工薪水&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;        &lt;el-row :gutter=&quot;20&quot;&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工奖金&quot;&gt;              &lt;el-input v-model=&quot;emp.comm&quot; placeholder=&quot;员工奖金&quot;&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;12&quot;&gt;            &lt;el-form-item label=&quot;员工部门&quot;&gt;              &lt;el-select v-model=&quot;emp.dept.deptno&quot; style=&quot;width:215px&quot;&gt;                &lt;el-option                    v-for=&quot;dept in depts&quot;                    :key=&quot;dept.deptno&quot;                    :value=&quot;dept.deptno&quot;                    :label=&quot;dept.dname&quot;                &gt;&lt;/el-option&gt;              &lt;/el-select&gt;            &lt;/el-form-item&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;      &lt;/el-form&gt;      &lt;template #footer&gt;        &lt;el-button type=&quot;warning&quot; @click=&quot;disableDialog=false&quot;&gt;取消&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;saveData&quot;&gt;保存&lt;/el-button&gt;      &lt;/template&gt;    &lt;/el-dialog&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// import &#123; ref &#125; from &#39;vue&#39;export default &#123;  data() &#123;    return &#123;      pageInfo: &#123;&#125;,      disableDialog: false,      emp: &#123;dept: &#123;&#125;,      depts: [],      dialogTitle: &quot;&quot;    &#125;  &#125;,  created() &#123;    this.showData(1, 5);    this.getDepts();  &#125;,  methods: &#123;    showData(pageNum, pageSize) &#123;      let url = `emp/getPaged`;      this.$http.post(url, `pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageSize&#125;`).then((resp) =&gt; &#123;        console.log(resp);        this.pageInfo = resp.data;      &#125;);    &#125;,    edit(row) &#123;      this.disableDialog = true;      this.dialogTitle = &quot;编辑员工&quot;;      this.emp = &#123;...row&#125;;    &#125;,    add() &#123;      this.disableDialog = true;      this.dialogTitle = &quot;添加员工&quot;;      this.emp = &#123;dept: &#123;&#125;;    &#125;,    del(row) &#123;      this.$confirm(&quot;是否删除员工?&quot;, &quot;提示&quot;, &#123;        confirmButtonText: &#39;确定&#39;,        cancelButtonText: &#39;取消&#39;,        type: &#39;warning&#39;      &#125;).then(() =&gt; &#123;            let url = `emp/delete?empno=$&#123;row.empno&#125;`;            // var url = `emp/delete?empno=1230`;            this.$http.get(url).then(resp =&gt; &#123;              if (resp.data == 1) &#123;                this.$message(&#123;                  type: &quot;success&quot;,                  message: &quot;删除成功！&quot;                &#125;)                this.showData(1, this.pageInfo.pageSize);              &#125; else &#123;                this.$message(&#123;                  type: &#39;error&#39;,                  message: &#39;删除失败！&#39;                &#125;);              &#125;            &#125;);          &#125;      ).catch(() =&gt; &#123;      &#125;);    &#125;,    handleCurrentChange(pageNum) &#123;      this.showData(pageNum, this.pageInfo.pageSize);    &#125;,    handleSizeChange(pageSize) &#123;      this.showData(1, pageSize);    &#125;,    getDepts() &#123;      var url = &quot;dept/getAll&quot;;      this.$http.get(url).then(resp =&gt; &#123;        this.depts = resp.data;      &#125;);    &#125;,    update() &#123;      var url = &quot;emp/update&quot;;      this.$http.post(url, this.emp).then(resp =&gt; &#123;        if (resp.data == 1) &#123;          this.$message(&#123;            type: &quot;success&quot;,            message: &quot;更新成功！&quot;          &#125;);          this.disableDialog = false;          this.showData(1, this.pageInfo.pageSize);        &#125;      &#125;);    &#125;,    saveData() &#123;      if (this.dialogTitle == &quot;编辑员工&quot;) &#123;        this.update();      &#125; else &#123;        this.insert();      &#125;    &#125;,    insert() &#123;      var url = &quot;emp/insert&quot;;      this.$http.post(url, this.emp).then(resp =&gt; &#123;        if (resp.data == 1) &#123;          this.$message(&#123;            type: &quot;success&quot;,            message: &quot;添加成功！&quot;          &#125;);          this.disableDialog = false;          this.showData(1, this.pageInfo.pageSize);        &#125;      &#125;);    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><h3 id="下拉菜单-1"><a href="#下拉菜单-1" class="headerlink" title="下拉菜单"></a>下拉菜单</h3><pre><code>&lt;el-header&gt;        &lt;!-- &lt;h1&gt;东软人力资源管理系统-&#123;$store.state.username&#125;&lt;/h1&gt;         --&gt;        &lt;el-row&gt;          &lt;el-col :span=&quot;6&quot;&gt;            &lt;span class=&quot;main_title&quot;&gt;东软人力资源管理系统&lt;/span&gt;          &lt;/el-col&gt;          &lt;el-col :span=&quot;2&quot; :offset=&quot;16&quot; class=&quot;user_title&quot;&gt;            &lt;!--  --&gt;            &lt;el-dropdown class=&quot;el-dropdown-link&quot; @command=&quot;handleCommand&quot;&gt;                        &lt;span&gt;              &#123; $store.state.username.toUpperCase() &#125;              &lt;el-icon class=&quot;el-icon--right&quot;&gt;                &lt;arrow-down /&gt;              &lt;/el-icon&gt;                        &lt;/span&gt;              &lt;template #dropdown&gt;                &lt;el-dropdown-menu&gt;                  &lt;el-dropdown-item command=&quot;hideMenu&quot;&gt;&#123; hideMenuText &#125;&lt;/el-dropdown-item&gt;                  &lt;el-dropdown-item command=&quot;exit&quot;&gt;退出登录&lt;/el-dropdown-item&gt;                &lt;/el-dropdown-menu&gt;              &lt;/template&gt;            &lt;/el-dropdown&gt;          &lt;/el-col&gt;        &lt;/el-row&gt;      &lt;/el-header&gt;data()&#123;    return&#123;        menuText:&#39;隐藏菜单&#39;    &#125;&#125;handleCommand(command)&#123;    if(command == &quot;hideMenu&quot;)&#123;        if(this.menuText == &quot;隐藏菜单&quot;)&#123;            this.menuText = &quot;显示菜单&quot;;        &#125;else&#123;            this.menuText = &quot;隐藏菜单&quot;;        &#125;    &#125;else if(command == &quot;exit&quot;)&#123;        this.$confirm(&quot;真的要退出系统吗？&quot;,&quot;提示&quot;).then(()=&gt;&#123;            this.$router.push(&quot;/login&quot;);            sessionStorage.clear();        &#125;).catch(()=&gt;&#123;&#125;);    &#125;&#125;&lt;el-aside v-show=&quot;menuText==&#39;隐藏菜单&#39;&quot;&gt;&lt;/el-aside&gt;</code></pre><h3 id="记住用户名"><a href="#记住用户名" class="headerlink" title="记住用户名"></a>记住用户名</h3><ol><li><p>复选框绑定变量</p><pre><code>&lt;el-checkbox  v-model=&quot;remember&quot;&gt;记住用户名&lt;/el-checkbox&gt;data()&#123;    return&#123;        remember:false    &#125;&#125;</code></pre></li><li><p>登录成功后，判断是否选中了记住用户名</p><pre><code>this.$http.get(url,&#123;params:this.user&#125;).then((resp)=&gt;&#123;    if(resp.data)&#123;        this.$store.commit(&quot;setUsername&quot;,this.user.username);        if(this.remember)&#123;            localStorage.setItem(&quot;username&quot;,this.user.username);        &#125;else&#123;            localStorage.removeItem(&quot;username&quot;);        &#125;        this.$router.push(&quot;/main&quot;);    &#125;else&#123;        this.$alert(&quot;用户名或密码错误！&quot;);    &#125;&#125;)</code></pre></li><li><p>在打开登录页的时候，判断localStorage中是否包含用户名</p><pre><code>created()&#123;    let username = localStorage.getItem(&quot;username&quot;);      if(username)&#123;        this.user.username = username;        this.remember = true;      &#125;&#125;</code></pre></li></ol><h3 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2022/060432144/image-20220612120142519.png" class></h3><h3 id="tabs"><a href="#tabs" class="headerlink" title="tabs"></a>tabs</h3><p><a href="https://www.w3cschool.cn/vue_elementplus/vue_elementplus-d3ph3kqx.html">https://www.w3cschool.cn/vue_elementplus/vue_elementplus-d3ph3kqx.html</a></p><h4 id="基础案例"><a href="#基础案例" class="headerlink" title="基础案例"></a>基础案例</h4><pre><code>&lt;template&gt;  &lt;el-tabs v-model=&quot;activeName&quot; @tab-click=&quot;handleClick&quot;&gt;    &lt;el-tab-pane label=&quot;用户管理&quot; name=&quot;first&quot;&gt;用户管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;配置管理&quot; name=&quot;second&quot;&gt;配置管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;角色管理&quot; name=&quot;third&quot;&gt;角色管理&lt;/el-tab-pane&gt;    &lt;el-tab-pane label=&quot;定时任务补偿&quot; name=&quot;fourth&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;  &lt;/el-tabs&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        activeName: &#39;second&#39;      &#125;;    &#125;,    methods: &#123;      handleClick(tab, event) &#123;        console.log(tab, event);      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre><h4 id="选项卡样式"><a href="#选项卡样式" class="headerlink" title="选项卡样式"></a>选项卡样式</h4><p>只需要设置 type 属性为 card 或 border-card 就可以使选项卡改变为标签风格。</p><pre><code>&lt;el-tabs type=&quot;border-card&quot;&gt; 或 &lt;el-tabs type=&quot;card&quot;&gt;</code></pre><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>标签一共有四个方向的设置 tabPosition&#x3D;”left|right|top|bottom”</p><pre><code>&lt;el-tabs tab-position=&quot;left&quot; style=&quot;height: 200px;&quot;&gt;    &lt;el-tab-pane label=&quot;用户管理&quot;&gt;用户管理&lt;/el-tab-pane&gt;&lt;/el-tabs&gt;</code></pre><h4 id="自定义标签页图标"><a href="#自定义标签页图标" class="headerlink" title="自定义标签页图标"></a>自定义标签页图标</h4><pre><code>&lt;el-tabs type=&quot;border-card&quot;&gt;  &lt;el-tab-pane&gt;      &lt;template #label&gt;          &lt;el-icon&gt;&lt;House /&gt;&lt;/el-icon&gt;        我的行程      &lt;/template&gt;      我的行程    &lt;/el-tab-pane&gt;  &lt;el-tab-pane label=&quot;消息中心&quot;&gt;消息中心&lt;/el-tab-pane&gt;  &lt;el-tab-pane label=&quot;角色管理&quot;&gt;角色管理&lt;/el-tab-pane&gt;  &lt;el-tab-pane label=&quot;定时任务补偿&quot;&gt;定时任务补偿&lt;/el-tab-pane&gt;&lt;/el-tabs&gt;</code></pre><h4 id="动态增减标签页"><a href="#动态增减标签页" class="headerlink" title="动态增减标签页"></a>动态增减标签页</h4><p>增减标签页按钮只能在选项卡样式的标签页下使用</p><img src="/2022/060432144/1632647528828216.png" class><pre><code>&lt;template&gt;  &lt;el-tabs  v-model=&quot;editableTabsValue&quot;  type=&quot;card&quot;  editable  @edit=&quot;handleTabsEdit&quot;&gt;  &lt;el-tab-pane    :key=&quot;item.name&quot;    v-for=&quot;(item, index) in editableTabs&quot;    :label=&quot;item.title&quot;    :name=&quot;item.name&quot;  &gt;    &#123;item.content&#125;  &lt;/el-tab-pane&gt;&lt;/el-tabs&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        editableTabsValue: &#39;2&#39;,        editableTabs: [          &#123;            title: &#39;Tab 1&#39;,            name: &#39;1&#39;,            content: &#39;Tab 1 content&#39;,          &#125;,          &#123;            title: &#39;Tab 2&#39;,            name: &#39;2&#39;,            content: &#39;Tab 2 content&#39;,          &#125;,        ],        tabIndex: 2,      &#125;    &#125;,    methods: &#123;      handleTabsEdit(targetName, action) &#123;        if (action === &#39;add&#39;) &#123;          let newTabName = ++this.tabIndex + &#39;&#39;          this.editableTabs.push(&#123;            title: &#39;New Tab&#39;,            name: newTabName,            content: &#39;New Tab content&#39;,          &#125;)          this.editableTabsValue = newTabName        &#125;        //实现目标：如果关闭的tab不是当前激活的，关闭tab后，保留原来激活的tab        //如果关闭的是当前激活的tab，先激活下一个，如果没有，激活上一个        //如果关闭的是最后一个，不用设置激活的tab        if (action === &#39;remove&#39;) &#123;          let tabs = this.editableTabs          let activeName = this.editableTabsValue          if (activeName === targetName) &#123;            tabs.forEach((tab, index) =&gt; &#123;              if (tab.name === targetName) &#123;                let nextTab = tabs[index + 1] || tabs[index - 1]                //如果存在可激活tab，设置激活tab的name到临时变量activeName中                if (nextTab) &#123;                  activeName = nextTab.name                &#125;              &#125;            &#125;)          &#125;          this.editableTabsValue = activeName          this.editableTabs = tabs.filter((tab) =&gt; tab.name !== targetName)        &#125;      &#125;,    &#125;,  &#125;&lt;/script&gt;</code></pre><h4 id="自定义增加标签页触发器"><a href="#自定义增加标签页触发器" class="headerlink" title="自定义增加标签页触发器"></a>自定义增加标签页触发器</h4><img src="/2022/060432144/1632647535848776.png" class><pre><code>&lt;template&gt;  &lt;div style=&quot;margin-bottom: 20px;&quot;&gt;  &lt;el-button size=&quot;small&quot; @click=&quot;addTab(editableTabsValue)&quot;&gt;    add tab  &lt;/el-button&gt;&lt;/div&gt;&lt;el-tabs  v-model=&quot;editableTabsValue&quot;  type=&quot;card&quot;  closable  @tab-remove=&quot;removeTab&quot;&gt;  &lt;el-tab-pane    v-for=&quot;(item, index) in editableTabs&quot;    :key=&quot;item.name&quot;    :label=&quot;item.title&quot;    :name=&quot;item.name&quot;  &gt;    &#123;item.content&#125;  &lt;/el-tab-pane&gt;&lt;/el-tabs&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        editableTabsValue: &#39;2&#39;,        editableTabs: [          &#123;            title: &#39;Tab 1&#39;,            name: &#39;1&#39;,            content: &#39;Tab 1 content&#39;,          &#125;,          &#123;            title: &#39;Tab 2&#39;,            name: &#39;2&#39;,            content: &#39;Tab 2 content&#39;,          &#125;,        ],        tabIndex: 2,      &#125;    &#125;,    methods: &#123;      addTab(targetName) &#123;        let newTabName = ++this.tabIndex + &#39;&#39;        this.editableTabs.push(&#123;          title: &#39;New Tab&#39;,          name: newTabName,          content: &#39;New Tab content&#39;,        &#125;)        this.editableTabsValue = newTabName      &#125;,      removeTab(targetName) &#123;        let tabs = this.editableTabs        let activeName = this.editableTabsValue        if (activeName === targetName) &#123;          tabs.forEach((tab, index) =&gt; &#123;            if (tab.name === targetName) &#123;              let nextTab = tabs[index + 1] || tabs[index - 1]              if (nextTab) &#123;                activeName = nextTab.name              &#125;            &#125;          &#125;)        &#125;        this.editableTabsValue = activeName        this.editableTabs = tabs.filter((tab) =&gt; tab.name !== targetName)      &#125;,    &#125;,  &#125;&lt;/script&gt;</code></pre><h4 id="关闭Tab"><a href="#关闭Tab" class="headerlink" title="关闭Tab"></a>关闭Tab</h4><pre><code>&lt;el-tabs type=&quot;card&quot; closable v-model=&quot;activeName&quot; @tab-remove=&quot;handleRemove&quot;&gt;&lt;/el-tabs&gt;handleRemove(targetName)&#123;                let temp = this.activeName;                if(this.activeName === targetName)&#123;                    this.editableTabs.forEach((tab,index)=&gt;&#123;                        if(tab.name === this.activeName)&#123;                            let nextTab = this.editableTabs[index+1]||this.editableTabs[index-1];                            if(nextTab)&#123;                                temp = nextTab.name;                            &#125;                        &#125;                    &#125;)                &#125;                                this.activeName = temp;                //排除要删除的tab                this.editableTabs = this.editableTabs.filter(tab=&gt;tab.name !== targetName);&#125;</code></pre><h3 id="-3"><a href="#-3" class="headerlink" title></a></h3><h2 id="springboot中JSON时区设置"><a href="#springboot中JSON时区设置" class="headerlink" title="springboot中JSON时区设置"></a>springboot中JSON时区设置</h2><pre><code>#使用24小时的时间格式#spring.jackson.default-property-inclusion=NON_NULL#设置日期格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ss#设置时区，GMT：格林威治时间spring.jackson.time-zone=GMT+8</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2022/053113229.html"/>
      <url>/2022/053113229.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>ECMAScript6.0（简称：ES6）是JavaScript语言的下一代标准，在2015年6月正式发布</li><li>目标：使得JavaScript语言可以用来编写复杂大型的应用程序，成为企业级的开发语言</li></ol><h2 id="ES6编程基础"><a href="#ES6编程基础" class="headerlink" title="ES6编程基础"></a>ES6编程基础</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ol><li>使用let声明的变量，只在代码块中有效（代码块作用域）</li><li>let命令没有变量提升</li><li>暂时性死区：只要块级作用域存在let命令，它所声明的变量就“绑定”在这个区域，不再受外界影响</li></ol><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ol><li>const命令声明一个常量，一旦声明，值不能被改变</li><li>必须在声明的同时赋予初始值</li></ol><h3 id="函数的扩展–rest参数（剩余参数）"><a href="#函数的扩展–rest参数（剩余参数）" class="headerlink" title="函数的扩展–rest参数（剩余参数）"></a>函数的扩展–rest参数（剩余参数）</h3><ol><li><p>语法格式：</p><pre><code>function 函数名(命名参数,...剩余参数名)&#123;&#125;</code></pre></li><li><p>剩余参数：不与任何命名参数相比配的其他参数</p></li><li><p>案例：</p><pre><code>function add(sum,...args)&#123;    for(n of args)&#123;       sum += n;    &#125;    console.log(sum);&#125;let sum = 10;add(sum,1,2,3,4);</code></pre></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用解构赋值可以轻松地使用模板从对象或数组中提取数据</p><p>好处：一次可以定义多个变量，并赋值初始值</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ol><li><p>可以一次性的将每个属性赋予给<strong>同名</strong>变量</p><pre><code>//同名let stu = &#123;name:&quot;tom&quot;,age:20&#125;;let &#123;name,age&#125; = stu;console.log(name,age);//不同名let stu = &#123;name:&quot;tom&quot;,age:20&#125;;let &#123;name:stuName,age:stuAge&#125; = stu;console.log(stuName,stuAge);</code></pre></li></ol><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><pre><code>var arr = [&quot;tom&quot;,&quot;marry&quot;,&quot;scott&quot;];var [a,b,c] = arr;console.log(a,b,c);</code></pre><h2 id="增强版的对象字面量"><a href="#增强版的对象字面量" class="headerlink" title="增强版的对象字面量"></a>增强版的对象字面量</h2><pre><code>var name =&quot;marry&quot;;var stu = &#123;    name,//属性的简写形式，将同名变量的值赋予给属性    age:20,    //方法的简写形式    hi()&#123;        alert(&quot;hi&quot;)    &#125;&#125;console.log(stu.name);stu.hi();</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li><p>箭头函数：是ES6中函数表达式定义的一种简化写法</p></li><li><p>ES6中允许使用“箭头” (&#x3D;&gt;)定义函数</p><pre><code>/* var fun1 = function(a)&#123;    return a + 1;&#125; *///var fun1 = (a)=&gt;&#123;return a+1;&#125;var fun1 = a =&gt; a + 1var result = fun1(1);console.log(result);</code></pre><p>注意：</p><ul><li><p>当方法的形参个数为1的时候，形参外的括号可以省略</p></li><li><p>当方法体中只有一条 return语句的时候，方法体外的大括号可以省略，return关键字也可以省略</p></li><li><p>箭头函数在被调用的时候，不会向其传递隐式的 arguments 和 this 对象</p></li><li><p>箭头函数的函数体内的this对象，就是定义箭头函数时所在的对象，而不是调用时的对象</p><pre><code>function test()&#123;                console.log(this);//&#123;&quot;name&quot;:&quot;tom&quot;&#125;                let t;                                /* t = function ()&#123;                    console.log(this);//window                &#125; */                                t = ()=&gt;&#123;                    console.log(this);//&#123;&quot;name&quot;:&quot;tom&quot;&#125;                &#125;                t();            &#125;                        var stu = &#123;&quot;name&quot;:&quot;tom&quot;&#125;;                        stu.test = test;                        stu.test();</code></pre></li></ul></li></ol><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>对象扩展运算符（…）：用于取出参数对象中的所有可遍历的属性，拷贝到当前对象中</p><pre><code>var stu = &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:20&#125;;            var stu2 = &#123;...stu&#125;;stu2.name = &quot;marry&quot;;console.log(stu.name);console.log(stu2.name);</code></pre><p>数组扩展运算符:</p><pre><code>var arr = [1,2,3,4,5];var arr2 = [...arr];arr[0] = 10;console.log(arr2);</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol><li><p>ES6模块的主要思想是必须显示地使用标识符导出模块数据，才能从外部访问模块</p></li><li><p>导入导出方式一：要求导入时使用导出时候的名称</p><pre><code>//1.jsexport var name = &quot;tom&quot;;&lt;script type=&quot;module&quot;&gt;import &#123;name&#125; from &#39;./js/1.js&#39;console.log(name)&lt;/script&gt;//1.jsfunction test1()&#123;    alert(&#39;test1&#39;)&#125;//导出方法export &#123;test1&#125;&lt;script type=&quot;module&quot;&gt;    import &#123;test1&#125; from &quot;./js/1.js&quot;;    test1()&lt;/script&gt;</code></pre></li><li><p>默认导出导入</p><pre><code>//1.jsexport default &#123;    name:&quot;tom&quot;&#125;&lt;script type=&quot;module&quot;&gt;import Stu from &#39;./js/1.js&#39;console.log(Stu.name)&lt;/script&gt;</code></pre></li><li><p>全部导入</p><pre><code>//1.jsexport var name = &quot;tom&quot;;export default &#123;    name:&quot;tom&quot;&#125;function test1()&#123;    alert(&#39;test1&#39;)&#125;//导出方法export &#123;test1&#125;&lt;script type=&quot;module&quot;&gt;import Stu from &#39;./js/1.js&#39;import * as app from &#39;./js/1.js&#39;console.log(Stu.name)console.log(app.name)console.log(app.default.name)app.test1()&lt;/script&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/053018006.html"/>
      <url>/2022/053018006.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>用途：为html页面添加交互行为</li><li>执行：解释器，也称为JavaScript引擎，是浏览器的一部分</li><li>位置：通常直接嵌入到html页面</li><li>开发工具：任意网页开发工具都可以</li><li>特点：<ul><li>脚本语言：没有预先编译的过程，边解释边执行</li><li>弱类型：非强类型，定义变量的时候，不用指定变量的类型，变量的类型根据值得类型来决定</li><li>跨平台：不依赖操作系统，仅仅依赖于浏览器</li></ul></li><li>注意：<ul><li>不同浏览器中使用JavaScript编程，可能有差异</li><li>要遵循 W3C DOM标准，兼容性好</li></ul></li><li>历史<ul><li>1995网景（Netscape）</li><li>是ECMAScript标准的一种实现，是ECMA组织维护</li><li>最新版：ES6</li></ul></li></ol><h2 id="五种原始数据类型"><a href="#五种原始数据类型" class="headerlink" title="五种原始数据类型"></a>五种原始数据类型</h2><ol><li>undefined：未初始化变量的值，值只有一个：undefined</li><li>boolean：值true和false</li><li>number：表示整数和浮点数</li><li>string：字符串类型，值使用单引号或双引号括起来</li><li>null：唯一值 null</li></ol><p>可以使用 typeof 变量名，输出变量的类型：typeof null ，输出：object</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li>parseInt(value):把一个变量的值转换为整数<ul><li>parseInt(“3.14”) &#x2F;&#x2F;3</li><li>parseInt(“3.14aaaaa”) &#x2F;&#x2F;3</li><li>parseInt(3.14) &#x2F;&#x2F;3</li><li>parseInt(“a3.14”)  &#x2F;&#x2F;NaN</li></ul></li><li>parseFloat(value):把一个变量转换为浮点数</li><li>Number(value):把给定的值转换为数字，它转换整个值，而不是部分值<ul><li>Number(“123a”) &#x2F;&#x2F;NaN</li></ul></li></ol><h2 id="运输符"><a href="#运输符" class="headerlink" title="运输符"></a>运输符</h2><p>与java相同</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>语法：</p><pre><code>function 函数名(参数列表)&#123;    return 值;&#125;</code></pre><p>调用方式：</p><ol><li><p>在 <script>中直接调用</p></li><li><p>在其他函数中调用</p></li><li><p>通过事件调用</p><pre><code>&lt;button onclick=&quot;hello()&quot;&gt;调用方法&lt;/button&gt;&lt;a href=&quot;#&quot; onclick=&quot;hello()&quot;&gt;调用方法&lt;/a&gt;</code></pre></li><li><p>用超链接调用</p><pre><code>&lt;a href=&quot;javascript:hello()&quot;&gt;调用方法&lt;/a&gt;</code></pre></li></ol><h3 id="得到文本框的值"><a href="#得到文本框的值" class="headerlink" title="得到文本框的值"></a>得到文本框的值</h3><pre><code>document.getElementById(&quot;result&quot;).value</code></pre><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval(字符串表达式)：能够对表达式进行解析，并求值返回</p><h3 id="函数是对象，函数名是对象的引用"><a href="#函数是对象，函数名是对象的引用" class="headerlink" title="函数是对象，函数名是对象的引用"></a>函数是对象，函数名是对象的引用</h3><pre><code>&lt;script&gt;    function test()&#123;        console.log(&quot;hi&quot;);    &#125;    var a = test;    a();&lt;/script&gt;</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><pre><code>//等号的右边为匿名函数（定义了一个函数对象，但是没有指定该函数名）var test = function()&#123;    console.log(&quot;hi!!!&quot;);&#125;test();</code></pre><h3 id="为元素动态添加事件处理程序"><a href="#为元素动态添加事件处理程序" class="headerlink" title="为元素动态添加事件处理程序"></a>为元素动态添加事件处理程序</h3><pre><code>&lt;form&gt;    &lt;input type=&quot;button&quot; name=&quot;btn&quot; value=&quot;按钮&quot;&gt;&lt;/form&gt;&lt;script&gt;    function test()&#123;        console.log(&quot;hi!!!&quot;);        //alert(&#39;hi&#39;);    &#125;    document.forms[0].btn.onclick=test;&lt;/script&gt;</code></pre><h3 id="javascript中没有函数重载的概念"><a href="#javascript中没有函数重载的概念" class="headerlink" title="javascript中没有函数重载的概念"></a>javascript中没有函数重载的概念</h3><p>如果定义了两个同名的方法，下面的方法会把上面的同名方法覆盖</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><ol><li>js的函数可以接收任意多个参数，通过arguments对象来访问</li><li>该对象类似于数组，可以使用下标来访问，如：arguments[0]</li><li>arguments.length:实参个数</li><li>方法名.length:得到形参的个数</li></ol><h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><ol><li><p>定义：在单个对象中存储多个值</p></li><li><p>构造函数：</p><ul><li>Array():返回一个长度为0的数组对象</li><li>Array(size):返回具有size个元素的数组，元素的初始值：undefined</li><li>Array(元素列表):用元素列表初始化数组，元素可以是任意类型</li></ul></li><li><p>数组的长度不固定，赋值即可改变数组的长度</p><p>arr.length属性不是只读的，可以改变（变大或变小（相当于删除元素））</p></li><li><p>直接创建并初始化数组</p><pre><code>var arr2 = [0,true,null];</code></pre></li><li><p>遍历</p><pre><code>var arr = [1,2,3,4,5];/* for(i = 0;i &lt; arr.length;i++)&#123;    console.log(arr[i]);&#125; *//* for(i in arr)&#123;    console.log(arr[i],i);&#125; *//* for(n of arr)&#123;    console.log(n);&#125; */arr.forEach(function(item,index)&#123;    console.log(item,index);&#125;)</code></pre></li><li><p>常用方法</p><ul><li><p>sort</p><pre><code>var arr = [10,100,3,1,5];//arr.sort();//默认按照字符串排序arr.sort(function(x,y)&#123;    return x - y;&#125;);console.log(arr);</code></pre></li><li><p>splice（index，howmany，element...）:用于向数组添加、删除、替换数组元素</p><ul><li>index：必需，从何处添加、删除元素</li><li>howmany：必需，规定应该删除多少个元素，添加元素的时候，该值为0</li><li>element...:元素列表，可选，向数组添加元素的列表</li></ul><pre><code>var arr = [10,100,3,1,5];                //arr.splice(1,0,&quot;tom&quot;,&quot;marry&quot;)//arr.splice(1,2);arr.splice(1,3,&quot;tom&quot;,&quot;marry&quot;);console.log(arr);</code></pre></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><pre><code>//生成一个日期字符串var d = new Date();var year = d.getFullYear();var month = d.getMonth()+1;var date = d.getDate()var hour = d.getHours();var minute = d.getMinutes();var second = d.getSeconds();var t = year +&quot;-&quot;+month+&quot;-&quot;+date +&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;console.log(t);//把它显示在p中document.getElementById(&quot;time&quot;).innerText = t;</code></pre></li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li>setTimeout("函数()",时间间隔)：在指定的时间间隔后，调用参数1指定的函数，该方法返回一个值，表示定时器</li><li>clearTimeout(定时器引用)：关闭定时器</li></ol><h2 id="案例：选择人名"><a href="#案例：选择人名" class="headerlink" title="案例：选择人名"></a>案例：选择人名</h2><h3 id="使用二个按钮控制"><a href="#使用二个按钮控制" class="headerlink" title="使用二个按钮控制"></a>使用二个按钮控制</h3><img src="/2022/053018006/1.jpg" class=""><pre><code>    &lt;input type=&quot;button&quot; value=&quot;开始&quot; onclick=&quot;startGame()&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stopGame()&quot;&gt;    &lt;script&gt;        var names = [&quot;唐僧&quot;,&quot;悟空&quot;,&quot;八戒&quot;,&quot;沙僧&quot;,&quot;小白龙&quot;];        var tt;        var index;        function startGame()&#123;            index = parseInt(Math.random()*names.length);            var name = names[index];            document.getElementById(&quot;div1&quot;).innerText = name;                        tt = setTimeout(&quot;startGame()&quot;,10);        &#125;                function stopGame()&#123;            clearTimeout(tt);                        names.splice(index,1);        &#125;    &lt;/script&gt;</code></pre><h3 id="使用一个按钮控制"><a href="#使用一个按钮控制" class="headerlink" title="使用一个按钮控制"></a>使用一个按钮控制</h3><img src="/2022/053018006/2.jpg" class=""><pre><code>        &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;        &lt;input type=&quot;button&quot; value=&quot;开始&quot; onclick=&quot;game(this)&quot;&gt;        &lt;!-- &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stopGame()&quot;&gt; --&gt;        &lt;script&gt;            var names = [&quot;唐僧&quot;,&quot;悟空&quot;,&quot;八戒&quot;,&quot;沙僧&quot;,&quot;小白龙&quot;];            var tt;            var index;            var isRun = false;                        function game(o)&#123;                if(isRun)&#123;                    o.value = &quot;开始&quot;;                    stopGame();                    isRun = false;                &#125;else&#123;                    o.value = &quot;停止&quot;;                    startGame();                    isRun = true;                &#125;            &#125;            function startGame()&#123;                index = parseInt(Math.random()*names.length);                var name = names[index];                document.getElementById(&quot;div1&quot;).innerText = name;                                tt = setTimeout(&quot;startGame()&quot;,10);            &#125;                        function stopGame()&#123;                clearTimeout(tt);                                names.splice(index,1);            &#125;                        document.onkeydown = function()&#123;                //得到按键的键盘码                var keyCode = event.keyCode;                //console.log(keyCode);                                if(keyCode == 13)&#123;                    startGame();                &#125;else if(keyCode == 32)&#123;                    stopGame();                &#125;            &#125;        &lt;/script&gt;</code></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ol><li><p>event：事件对象，在事件发生的时候，由系统创建</p><p>属性：</p><p>keyCode：键盘码，每一个按键都不同，13：回车，32：空格，9：tab</p></li><li><p>响应按键事件</p><pre><code>document.onkeydown = function()&#123;    //得到按键的键盘码    var keyCode = event.keyCode;    //console.log(keyCode);    if(keyCode == 13)&#123;        startGame();    &#125;else if(keyCode == 32)&#123;        stopGame();    &#125;&#125;</code></pre></li></ol><h2 id="案例：购物车全选和全不选"><a href="#案例：购物车全选和全不选" class="headerlink" title="案例：购物车全选和全不选"></a>案例：购物车全选和全不选</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkAll(o)&#123;                var cks = document.getElementsByName(&quot;good&quot;);                                for(c of cks)&#123;                    c.checked = o.checked;                &#125;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; width=&quot;400&quot;&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=&quot;checkbox&quot; onchange=&quot;checkAll(this)&quot;&gt;&lt;/td&gt;                    &lt;td&gt;商品名称&lt;/td&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;华为手机&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;笔记本电脑&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;电脑桌&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="案例：省市级联"><a href="#案例：省市级联" class="headerlink" title="案例：省市级联"></a>案例：省市级联</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        省份：        &lt;select onchange=&quot;getCities(this)&quot;&gt;            &lt;option&gt;请选择&lt;/option&gt;            &lt;option&gt;辽宁&lt;/option&gt;            &lt;option&gt;吉林&lt;/option&gt;            &lt;option&gt;黑龙江&lt;/option&gt;        &lt;/select&gt;        城市：        &lt;select id=&quot;city&quot;&gt;            &lt;option&gt;请选择&lt;/option&gt;        &lt;/select&gt;                &lt;script&gt;            var cities = [];            cities[&quot;辽宁&quot;] = [&quot;沈阳&quot;,&quot;大连&quot;,&quot;锦州&quot;];            cities[&quot;吉林&quot;] = [&quot;长春&quot;,&quot;吉林&quot;,&quot;四平&quot;];            cities[&quot;黑龙江&quot;] = [&quot;哈尔滨&quot;,&quot;齐齐哈尔&quot;,&quot;大庆&quot;];            function getCities(province)&#123;                var provinceName = province.value;                var city = document.getElementById(&quot;city&quot;);                                city.options.length = 1;                                // var index = province.selectedIndex;                var arr = cities[provinceName];                                arr.forEach(function(item,i)&#123;                    var option = new Option(item,i);                    city.options.add(option);                &#125;)            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><ol><li><p>定义：在表单提交到服务器之前，对html表单输入的数据进行校验，如果没有错误，就提交，否则，不提交</p></li><li><p>作用：</p><ul><li>在客户端验证，速度快</li><li>减轻服务器压力</li></ul></li><li><p>验证过程</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkForm()&#123;                return checkUsername() &amp;&amp; checkPassword();            &#125;            function checkUsername()&#123;                var username = document.forms[0].username.value;                if(username.length == 0)&#123;                    alert(&quot;用户名不能为空&quot;);                    return false;                &#125;                                return true;            &#125;                        function checkPassword()&#123;                var password = document.forms[0].password.value;                if(password.length == 0)&#123;                    alert(&quot;密码不能为空&quot;);                    return false;                &#125;                                return true;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;login&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>失去焦点验证：onblur</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkForm()&#123;                return checkUsername() &amp;&amp; checkPassword();            &#125;            function checkUsername()&#123;                var username = document.forms[0].username.value;                document.getElementById(&quot;usernameError&quot;).innerHTML=&quot;&quot;;                if(username.length == 0)&#123;                    // alert(&quot;用户名不能为空&quot;);                    document.getElementById(&quot;usernameError&quot;).innerHTML=&quot;用户名不能为空&quot;;                    return false;                &#125;                                return true;            &#125;                        function checkPassword()&#123;                var password = document.forms[0].password.value;                document.getElementById(&quot;passwordError&quot;).innerHTML=&quot;&quot;;                if(password.length == 0)&#123;                    // alert(&quot;密码不能为空&quot;);                    document.getElementById(&quot;passwordError&quot;).innerHTML=&quot;密码不能为空&quot;;                    return false;                &#125;                                return true;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;login&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt;                    &lt;span id=&quot;usernameError&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPassword()&quot;&gt;                    &lt;span id=&quot;passwordError&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h2 id="使用JS操作CSS"><a href="#使用JS操作CSS" class="headerlink" title="使用JS操作CSS"></a>使用JS操作CSS</h2><ol><li>使用元素的 style 属性<ul><li>元素.style.color = "red";</li><li>元素.style.fontSize = "30px";</li></ul></li><li>使用元素的className属性<ul><li>元素.className = "class1 class2";</li></ul></li><li>元素.offsetTop:得到元素相对于其父级中已经定位的元素的上偏移量（只读属性，数值）</li><li>元素.style.top:得到元素相对于其父级中已经定位的元素的上偏移量,（字符串类型，可以修改）</li></ol><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><ol><li><p>DOM：文档对象模型</p></li><li><p>当浏览器加载Html网页的时候，会把该网页解析为一颗DOM树，最顶层对象：document</p></li><li><p>解析过程中，会把网页中的所有内容解析为节点（Node）</p><ul><li>文档本身就是一个文档对象（document）</li><li>所有html元素都是元素节点</li><li>所有html属性都是属性节点</li><li>所有html元素中的文本都是文本节点</li></ul></li><li><p>元素对象：代表一个html元素（标签）</p><p>元素对象的子节点可以是：元素节点、文本、注释节点</p></li><li><p>节点类型：12种类型</p><ul><li>元素节点：html元素，nodeType：1</li><li>属性节点：html元素的属性，nodeType：2</li><li>文本节点：html元素中的文本，nodeType:3</li><li>注释节点：nodeType：8</li><li>文档对象节点：document对象，nodeType：9</li><li>文档类型说明节点：<code>&lt;!DOCTYPE html&gt;</code>，nodeType：10</li></ul></li></ol><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><ol><li>父节点和子节点</li><li>兄弟节点</li><li>当我们获取其中一个元素节点的时候，就可以使用层次关系来获取其相关层次的节点</li></ol><h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><ol><li>parentNode：获取当前节点的父节点</li><li>childNodes：获取当前节点的所有子节点</li><li>children：获取所有子元素</li><li>firstChild：第一个子节点</li><li>previousElementSibling:前一个同级元素</li><li>innerText:得到或设置当前节点中的文本内容</li></ol><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ol><li>创建一个元素：document.createElement("标签名")</li><li>创建一个文本节点：document.createTextNode(文本节点的内容);</li><li>追加子节点：父节点.appendChild(子节点)</li><li>删除当前元素：当前元素.remove()</li><li>克隆当前元素：当前元素.clone(true)</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol><li><p>定义：一组有序的键值对，其中键和值可以是任意类型</p></li><li><p>创建、存取操作</p><ul><li>创建：var map = new Map();</li><li>存储：map.set("键",值)</li><li>取：map.get(键)，如果没有键，返回 undefined</li></ul></li><li><p>其他方法</p><ul><li>has(key):判断给定的key是否存在</li><li>delete(key):删除元素</li><li>clear():清除所有</li></ul></li><li><p>初始化：参数是一个二维数组</p><pre><code>var map = new Map([    [&quot;name&quot;,&quot;tom&quot;],    [&quot;age&quot;,20]]);console.log(map.get(&quot;name&quot;),map.get(&quot;age&quot;));</code></pre></li></ol></script></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/052951905.html"/>
      <url>/2022/052951905.html</url>
      
        <content type="html"><![CDATA[<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>模板引擎，类似于JSP</p></li><li><p>动静结合，不破坏文档结构</p><pre><code>//jsp&lt;span&gt;$&#123;username&#125;&lt;/span&gt;//thymeleaf&lt;span th:text=&quot;$&#123;username&#125;&quot;&gt;tom&lt;/span&gt;</code></pre></li><li><p>Thymeleaf可以运行在服务器里面，也可以本地运行，它既可以让美工在浏览器查看页面的静态效果，也可以让开发人员在服务器端看动态数据渲染之后的效果。</p></li><li><p>Thymeleaf是一个java的模板引擎，是用来显示数据的，Thymeleaf有一个要求，不能直接通过请求访问到Thymeleaf，Thymeleaf在用的时候，要访问Thymeleaf，必须得经过controller，由controller跳转到Thymeleaf，它才能得到一个正确的显示。</p></li><li><p>thymeLea支持Spring Expression Language语言作为方言，也就是SpEL，在学习JSP时我们对EL表达式都有一定的认识了，SpEL是可以用于Spring中的一种EL表达式。</p></li><li><p>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</p></li><li><p>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>导入起步依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>取消缓存</p><pre><code>spring.thymeleaf.cache=false</code></pre></li><li><p>创建页面</p><ul><li><p>在src/main/resources/templates下添加html页面，如：index.html，在idea中，可以直接添加thymeleaf</p></li></ul></li><li><p>从上下文中取值</p><pre><code>&lt;p th:text=&quot;$&#123;name&#125;&quot;&gt;&lt;/p&gt;</code></pre><pre><code>@RequestMapping(&quot;test1&quot;)    public String test1(Model model) &#123;        model.addAttribute(&quot;title&quot;, &quot;&lt;h1&gt;标题&lt;/h1&gt;&quot;);                return &quot;index&quot;;    &#125;    //index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p th:utext=&quot;$&#123;title&#125;&quot;&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;</code></pre><ul><li>th:text:进行文本替换，不会解析html（页面与后台设置值一致）</li><li>th:utext:进行文本替换，会解析html（html页面源码与后台设置值一致）</li></ul></li><li><p>拼接字符串（文本替换）</p><pre><code>&lt;p th:text=&quot;|欢迎，$&#123;name&#125;!!!|&quot;&gt;marry&lt;/p&gt;</code></pre></li><li><p>选择表达式</p><pre><code>&lt;div th:object=&quot;$&#123;dept&#125;&quot;&gt;           &lt;p th:text=&quot;*&#123;deptno&#125;&quot;&gt;&lt;/p&gt;           &lt;p th:text=&quot;*&#123;dname&#125;&quot;&gt;&lt;/p&gt;           &lt;p th:text=&quot;*&#123;loc&#125;&quot;&gt;&lt;/p&gt;&lt;/div&gt;</code></pre></li><li><p>if</p><pre><code>&lt;p th:if=&quot;$&#123;user.isVip&#125;&quot; th:text=&quot;会员&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>each</p><pre><code>&lt;table border=&quot;1&quot; width=&quot;400&quot;&gt;       &lt;tbody &gt;           &lt;tr th:each=&quot;dept,status : $&#123;depts&#125;&quot; th:object=&quot;$&#123;dept&#125;&quot;&gt;               &lt;td th:text=&quot;*&#123;deptno&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;*&#123;dname&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;*&#123;loc&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.index&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.count&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.first&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.last&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.even&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.odd&#125;&quot;&gt;&lt;/td&gt;               &lt;td th:text=&quot;$&#123;status.size&#125;&quot;&gt;&lt;/td&gt;           &lt;/tr&gt;       &lt;/tbody&gt;   &lt;/table&gt;</code></pre></li><li><p>switch</p><pre><code>&lt;p th:switch=&quot;$&#123;sex&#125;&quot;&gt;       &lt;span th:case=&quot;1&quot;&gt;男&lt;/span&gt;       &lt;span th:case=&quot;2&quot;&gt;女&lt;/span&gt;       &lt;span th:case=&quot;*&quot;&gt;默认&lt;/span&gt;   &lt;/p&gt;</code></pre></li><li><p>引入样式表</p><p>/resources/static/css/style1.css</p><pre><code>&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style1.css&#125;&quot;&gt;</code></pre></li><li><p>javascript</p><pre><code>&lt;script th:inline=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;       alert([[$&#123;sex&#125;]]);&lt;/script&gt;</code></pre></li><li><p>动态添加样式</p><pre><code>&lt;style&gt;    .active&#123;        color:blue;    &#125;&lt;/style&gt;&lt;p th:text=&quot;$&#123;sex&#125;&quot; th:classappend=&quot;$&#123;sex==&#39;3&#39;&#125;?&#39;active&#39;&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>日期格式化</p><pre><code>&lt;p th:text=&quot;$&#123;#dates.format(hiredate,&#39;yyyy-MM-dd HH:mm:ss&#39;)&#125;&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>生成数值序列</p><pre><code>&lt;a href=&quot;#&quot; th:each=&quot;num : $&#123;#numbers.sequence(1,10)&#125;&quot; th:text=&quot;| $&#123;num&#125; |&quot;&gt;&lt;/a&gt;</code></pre></li><li><p>得到请求参数</p><pre><code>//请求参数为数组&lt;p th:text=&quot;$&#123;param.username[1]&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;param.size()&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;param.isEmpty()&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;param.containsKey(&#39;username&#39;)&#125;&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>从 HttpServletRequest 和 HttpSession中取值</p><pre><code>&lt;p th:text=&quot;$&#123;#request.getAttribute(&#39;msg&#39;)&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;#session.getAttribute(&#39;msg&#39;)&#125;&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>使用外部js</p><pre><code>&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/script1.js&#125;&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>得到应用程序上下文：contextPath</p><pre><code>&lt;p th:text=&quot;$&#123;#request.contextPath&#125;&quot;&gt;&lt;/p&gt;&lt;p th:text=&quot;$&#123;#request.getContextPath()&#125;&quot;&gt;&lt;/p&gt;</code></pre></li><li><p>组件</p><p><code>/resources/templates/component/coms.html</code></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;div th:fragment=&quot;com1&quot;&gt;           div1   &lt;/div&gt;      &lt;div id=&quot;com2&quot;&gt;           div2   &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>引用组件：</p><pre><code>//~&#123;&#125;:片段表达式&lt;div th:insert=&quot;~&#123;/component/coms::com1&#125;&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;~&#123;/component/coms::com1&#125;&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;~&#123;/component/coms::#com2&#125;&quot;&gt;&lt;/div&gt;</code></pre><p>Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 Spring MVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。</p></li></ol><h2 id="1-Thymeleaf-简介"><a href="#1-Thymeleaf-简介" class="headerlink" title="1. Thymeleaf 简介"></a>1. Thymeleaf 简介</h2><p>Thymeleaf 是新一代 Java 模板引擎，与 Velocity、FreeMarker 等传统 Java 模板引擎不同，Thymeleaf 支持 HTML 原型，其文件后缀为“.html”，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。</p><p>Thymeleaf 通过在 html 标签中，增加额外属性来达到“模板+数据”的展示方式，示例代码如下。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 为 Thymeleaf 属性，用于在展示文本--&gt;&lt;h1 th:text=&quot;迎您来到Thymeleaf&quot;&gt;欢迎您访问静态页面 HTML&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>当直接使用浏览器打开时，浏览器展示结果如下。</p><pre><code>欢迎您访问静态页面HTML</code></pre><p>当通过 Web 应用程序访问时，浏览器展示结果如下。</p><pre><code>迎您来到Thymeleaf</code></pre><h4 id="Thymeleaf-的特点"><a href="#Thymeleaf-的特点" class="headerlink" title="Thymeleaf 的特点"></a>Thymeleaf 的特点</h4><p>Thymeleaf 模板引擎具有以下特点：</p><ul><li>动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。</li><li>开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</li><li>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</li></ul><h2 id="2-Thymeleaf-语法规则"><a href="#2-Thymeleaf-语法规则" class="headerlink" title="2. Thymeleaf 语法规则"></a>2. Thymeleaf 语法规则</h2><p>在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间，示例代码如下。</p><pre><code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code></pre><blockquote><p>在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，即使我们不声明该命名空间，也不影响 Thymeleaf 的使用。</p></blockquote><p>Thymeleaf 作为一种模板引擎，它拥有自己的语法规则。Thymeleaf 语法分为以下 2 类：</p><ul><li>标准表达式语法</li><li>th 属性</li></ul><h3 id="2-1-标准表达式语法"><a href="#2-1-标准表达式语法" class="headerlink" title="2.1 标准表达式语法"></a>2.1 标准表达式语法</h3><p>Thymeleaf 模板引擎支持多种表达式：</p><ul><li>变量表达式：${...}</li><li>选择变量表达式：*{...}</li><li>链接表达式：@{...}</li><li>国际化表达式：#{...}</li><li>片段引用表达式：~{...}</li></ul><h4 id="2-1-1-变量表达式"><a href="#2-1-1-变量表达式" class="headerlink" title="2.1.1 变量表达式"></a>2.1.1 变量表达式</h4><p>使用 ${} 包裹的表达式被称为变量表达式，该表达式具有以下功能：</p><ul><li>获取对象的属性和方法</li><li>使用内置的基本对象</li><li>使用内置的工具对象</li></ul><p>① 获取对象的属性和方法</p><p>使用变量表达式可以获取对象的属性和方法，例如，获取 person 对象的 lastName 属性，表达式形式如下：</p><pre><code>$&#123;person.lastName&#125;</code></pre><p>② 使用内置的基本对象</p><p>使用变量表达式还可以使用内置基本对象，获取内置对象的属性，调用内置对象的方法。 Thymeleaf 中常用的内置基本对象如下：</p><ul><li>#ctx ：上下文对象；</li><li>#vars ：上下文变量；</li><li>#locale：上下文的语言环境；</li><li>#request：HttpServletRequest 对象（仅在 Web 应用中可用）；</li><li>#response：HttpServletResponse 对象（仅在 Web 应用中可用）；</li><li>#session：HttpSession 对象（仅在 Web 应用中可用）；</li><li>#servletContext：ServletContext 对象（仅在 Web 应用中可用）。</li></ul><p>例如，我们通过以下 2 种形式，都可以获取到 session 对象中的 map 属性：</p><pre><code>$&#123;#session.getAttribute(&#39;map&#39;)&#125;$&#123;session.map&#125;</code></pre><p>③ 使用内置的工具对象</p><p>除了能使用内置的基本对象外，变量表达式还可以使用一些内置的工具对象。</p><ul><li>strings：字符串工具对象，常用方法有：equals、equalsIgnoreCase、length、trim、toUpperCase、toLowerCase、indexOf、substring、replace、startsWith、endsWith，contains 和 containsIgnoreCase 等；</li><li>numbers：数字工具对象，常用的方法有：formatDecimal 等；</li><li>bools：布尔工具对象，常用的方法有：isTrue 和 isFalse 等；</li><li>arrays：数组工具对象，常用的方法有：toArray、length、isEmpty、contains 和 containsAll 等；</li><li>lists/sets：List/Set 集合工具对象，常用的方法有：toList、size、isEmpty、contains、containsAll 和 sort 等；</li><li>maps：Map 集合工具对象，常用的方法有：size、isEmpty、containsKey 和 containsValue 等；</li><li>dates：日期工具对象，常用的方法有：format、year、month、hour 和 createNow 等。</li></ul><p>例如，我们可以使用内置工具对象 strings 的 equals 方法，来判断字符串与对象的某个属性是否相等，代码如下。</p><pre><code>$&#123;#strings.equals(&#39;编程帮&#39;,name)&#125;</code></pre><h4 id="2-1-2-选择变量表达式"><a href="#2-1-2-选择变量表达式" class="headerlink" title="2.1.2 选择变量表达式"></a>2.1.2 选择变量表达式</h4><p>选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object 存储一个对象后，我们可以在其后代中使用选择变量表达式（*{...}）获取该对象中的属性，其中，“*”即代表该对象。</p><pre><code>&lt;div th:object=&quot;$&#123;session.user&#125;&quot; &gt;        &lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;&lt;/div&gt;</code></pre><blockquote><p>th:object 用于存储一个临时变量，该变量只在该标签及其后代中有效，在后面的内容“th 属性”中我详细介绍。</p></blockquote><h4 id="2-1-3-链接表达式"><a href="#2-1-3-链接表达式" class="headerlink" title="2.1.3 链接表达式"></a>2.1.3 链接表达式</h4><p>不管是静态资源的引用，还是 form 表单的请求，凡是链接都可以用链接表达式 （@{...}）。</p><p>链接表达式的形式结构如下：</p><ul><li>无参请求：@{/xxx}</li><li>有参请求：@{/xxx(k1=v1,k2=v2)}</li></ul><p>例如使用链接表达式引入 css 样式表，代码如下。</p><pre><code>&lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@&#123;/asserts/css/signin.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;</code></pre><h4 id="2-1-4-国际化表达式"><a href="#2-1-4-国际化表达式" class="headerlink" title="2.1.4 国际化表达式"></a>2.1.4 国际化表达式</h4><p>消息表达式一般用于国际化的场景。结构如下。</p><pre><code>th:text=&quot;#&#123;msg&#125;&quot;</code></pre><p>注意：此处了解即可，我们会在后面的章节中详细介绍。</p><h4 id="2-1-5-片段引用表达式"><a href="#2-1-5-片段引用表达式" class="headerlink" title="2.1.5 片段引用表达式"></a>2.1.5 片段引用表达式</h4><p>片段引用表达式用于在模板页面中引用其他的模板片段，该表达式支持以下 2 中语法结构：</p><ul><li>推荐：~{templatename::fragmentname}</li><li>支持：~{templatename::#id}</li></ul><p>以上语法结构说明如下：</p><ul><li>templatename：模版名，Thymeleaf 会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。</li><li>fragmentname：片段名，Thymeleaf 通过 th:fragment 声明定义代码块，即：th:fragment="fragmentname"</li><li>id：HTML 的 id 选择器，使用时要在前面加上 # 号，不支持 class 选择器。</li></ul><h3 id="2-2-th-属性"><a href="#2-2-th-属性" class="headerlink" title="2.2 th 属性"></a>2.2 th 属性</h3><p>Thymeleaf 还提供了大量的 th 属性，这些属性可以直接在 HTML 标签中使用，其中常用 th 属性及其示例如下表。</p><table><thead><tr><th>属性</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>th:id</td><td>替换 HTML 的 id 属性</td><td><code>&lt;input  id=&quot;html-id&quot;  th:id=&quot;thymeleaf-id&quot;  /&gt;</code></td></tr><tr><td>th:text</td><td>文本替换，转义特殊字符</td><td><code>&lt;h1 th:text=&quot;hello，bianchengbang&quot; &gt;hello&lt;/h1&gt;</code></td></tr><tr><td>th:utext</td><td>文本替换，不转义特殊字符</td><td><code>&lt;div th:utext=&quot;&#39;&lt;h1&gt;欢迎来到编程帮！&lt;/h1&gt;&#39;&quot; &gt;欢迎你&lt;/div&gt;</code></td></tr><tr><td>th:object</td><td>在父标签选择对象，子标签使用 *{…} 选择表达式选取值。 没有选择对象，那子标签使用选择表达式和 ${…} 变量表达式是一样的效果。 同时即使选择了对象，子标签仍然可以使用变量表达式。</td><td><code>&lt;div th:object=&quot;$&#123;session.user&#125;&quot; &gt;    &lt;p th:text=&quot;*&#123;fisrtName&#125;&quot;&gt;firstname&lt;/p&gt;&lt;/div&gt;</code></td></tr><tr><td>th:value</td><td>替换 value 属性</td><td><code>&lt;input th:value = &quot;$&#123;user.name&#125;&quot; /&gt;</code></td></tr><tr><td>th:with</td><td>局部变量赋值运算</td><td><code>&lt;div th:with=&quot;isEvens = $&#123;prodStat.count&#125;%2 == 0&quot;  th:text=&quot;$&#123;isEvens&#125;&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:style</td><td>设置样式</td><td><code>&lt;div th:style=&quot;&#39;color:#F00; font-weight:bold&#39;&quot;&gt;编程帮 www.biancheng.net&lt;/div&gt;</code></td></tr><tr><td>th:onclick</td><td>点击事件</td><td><code>&lt;td th:onclick = &quot;&#39;getInfo()&#39;&quot;&gt;&lt;/td&gt;</code></td></tr><tr><td>th:each</td><td>遍历，支持 Iterable、Map、数组等。</td><td><code>&lt;table&gt;    &lt;tr th:each=&quot;m:$&#123;session.map&#125;&quot;&gt;        &lt;td th:text=&quot;$&#123;m.getKey()&#125;&quot;&gt;&lt;/td&gt;        &lt;td th:text=&quot;$&#123;m.getValue()&#125;&quot;&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></td></tr><tr><td>th:if</td><td>根据条件判断是否需要展示此标签</td><td><code>&lt;a th:if =&quot;$&#123;userId == collect.userId&#125;&quot;&gt;</code></td></tr><tr><td>th:unless</td><td>和 th:if 判断相反，满足条件时不显示</td><td><code> &lt;div th:unless=&quot;$&#123;m.getKey()==&#39;name&#39;&#125;&quot; &gt;&lt;/div&gt;</code></td></tr><tr><td>th:switch</td><td>与 Java 的 switch case语句类似 通常与 th:case 配合使用，根据不同的条件展示不同的内容</td><td><code>&lt;div th:switch=&quot;$&#123;name&#125;&quot;&gt;    &lt;span th:case=&quot;a&quot;&gt;编程帮&lt;/span&gt;    &lt;span th:case=&quot;b&quot;&gt;www.biancheng.net&lt;/span&gt;&lt;/div&gt;</code></td></tr><tr><td>th:fragment</td><td>模板布局，类似 JSP 的 tag，用来定义一段被引用或包含的模板片段</td><td><code>&lt;footer th:fragment=&quot;footer&quot;&gt;插入的内容&lt;/footer&gt;</code></td></tr><tr><td>th:insert</td><td>布局标签； 将使用 th:fragment 属性指定的模板片段（包含标签）插入到当前标签中。</td><td><code>&lt;div th:insert=&quot;commons/bar::footer&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:replace</td><td>布局标签； 使用 th:fragment 属性指定的模板片段（包含标签）替换当前整个标签。</td><td><code>&lt;div th:replace=&quot;commons/bar::footer&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td>th:selected</td><td>select 选择框选中</td><td><code>&lt;select&gt;    &lt;option&gt;---&lt;/option&gt;    &lt;option th:selected=&quot;$&#123;name==&#39;a&#39;&#125;&quot;&gt;        编程帮    &lt;/option&gt;    &lt;option th:selected=&quot;$&#123;name==&#39;b&#39;&#125;&quot;&gt;        www.biancheng.net    &lt;/option&gt;&lt;/select&gt;</code></td></tr><tr><td>th:src</td><td>替换 HTML 中的 src 属性</td><td><code>&lt;img  th:src=&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; /&gt;</code></td></tr><tr><td>th:inline</td><td>内联属性； 该属性有 text、none、javascript 三种取值， 在 <script> 标签中使用时，js 代码中可以获取到后台传递页面的对象。</td><td><code>&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;    var name = /*[[$&#123;name&#125;]]*/ &#39;bianchengbang&#39;;    alert(name)&lt;/script&gt;</code></td></tr><tr><td>th:action</td><td>替换表单提交地址</td><td><code>&lt;form th:action=&quot;@&#123;/user/login&#125;&quot; th:method=&quot;post&quot;&gt;&lt;/form&gt;</code></td></tr></tbody></table><h2 id="3-Thymeleaf-公共页面抽取"><a href="#3-Thymeleaf-公共页面抽取" class="headerlink" title="3. Thymeleaf 公共页面抽取"></a>3. Thymeleaf 公共页面抽取</h2><p>在 Web 项目中，通常会存在一些公共页面片段（重复代码），例如头部导航栏、侧边菜单栏和公共的 js css 等。我们一般会把这些公共页面片段抽取出来，存放在一个独立的页面中，然后再由其他页面根据需要进行引用，这样可以消除代码重复，使页面更加简洁。</p><h3 id="3-1-抽取公共页面"><a href="#3-1-抽取公共页面" class="headerlink" title="3.1 抽取公共页面"></a>3.1 抽取公共页面</h3><p>Thymeleaf 作为一种优雅且高度可维护的模板引擎，同样支持公共页面的抽取和引用。我们可以将公共页面片段抽取出来，存放到一个独立的页面中，并使用 Thymeleaf 提供的 th:fragment 属性为这些抽取出来的公共页面片段命名。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><p>将公共页面片段抽取出来，存放在 commons.html 中，代码如下。</p><pre><code>&lt;div th:fragment=&quot;fragment-name&quot; id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="3-2-引用公共页面"><a href="#3-2-引用公共页面" class="headerlink" title="3.2 引用公共页面"></a>3.2 引用公共页面</h3><p>在 Thymeleaf 中，我们可以使用以下 3 个属性，将公共页面片段引入到当前页面中。</p><ul><li>th:insert：将代码块片段整个插入到使用了 th:insert 属性的 HTML 标签中；</li><li>th:replace：将代码块片段整个替换使用了 th:replace 属性的 HTML 标签中；</li><li>th:include：将代码块片段包含的内容插入到使用了 th:include 属性的 HTML 标签中。</li></ul><p>使用上 3 个属性引入页面片段，都可以通过以下 2 种方式实现。</p><ul><li>~{templatename::selector}：模板名::选择器</li><li>~{templatename::fragmentname}：模板名::片段名</li></ul><blockquote><p>通常情况下，<del>{} 可以省略，其行内写法为 [[</del>{...}]] 或 [(<del>{...})]，其中 [[</del>{...}]] 会转义特殊字符，[(~{...})] 则不会转义特殊字符。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><p>\1. 在页面 fragment.html 中引入 commons.html 中声明的页面片段，可以通过以下方式实现。</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;</code></pre><p>\2. 启动 Spring Boot，使用浏览器访问 fragment.html，查看源码，结果如下。</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div&gt;    &lt;div id=&quot;fragment-id&quot;&gt;        &lt;span&gt;公共页面片段&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div&gt;    &lt;div id=&quot;fragment-id&quot;&gt;        &lt;span&gt;公共页面片段&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="3-3-传递参数"><a href="#3-3-传递参数" class="headerlink" title="3.3 传递参数"></a>3.3 传递参数</h3><p>Thymeleaf 在抽取和引入公共页面片段时，还可以进行参数传递，大致步骤如下：</p><ol><li>传入参数；</li><li>使用参数。</li></ol><h4 id="3-3-1-传入参数"><a href="#3-3-1-传入参数" class="headerlink" title="3.3.1 传入参数"></a>3.3.1 传入参数</h4><p>引用公共页面片段时，我们可以通过以下 2 种方式，将参数传入到被引用的页面片段中：</p><ul><li>模板名::选择器名或片段名(参数1=参数值1,参数2=参数值2)</li><li>模板名::选择器名或片段名(参数值1,参数值2)</li></ul><blockquote><p>注：</p><ul><li>若传入参数较少时，一般采用第二种方式，直接将参数值传入页面片段中；</li><li>若参数较多时，建议使用第一种方式，明确指定参数名和参数值，。</li></ul></blockquote><p>示例代码如下：</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name(var1=&#39;insert-name&#39;,var2=&#39;insert-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id(var1=&#39;insert-id&#39;,var2=&#39;insert-id2&#39;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name(var1=&#39;replace-name&#39;,var2=&#39;replace-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id(var1=&#39;replace-id&#39;,var2=&#39;replace-id2&#39;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name(var1=&#39;include-name&#39;,var2=&#39;include-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id(var1=&#39;include-id&#39;,var2=&#39;include-id2&#39;)&quot;&gt;&lt;/div&gt;</code></pre><h4 id="3-3-2-使用参数"><a href="#3-3-2-使用参数" class="headerlink" title="3.3.2 使用参数"></a>3.3.2 使用参数</h4><p>在声明页面片段时，我们可以在片段中声明并使用这些参数，例如：</p><pre><code>&lt;!--使用 var1 和 var2 声明传入的参数，并在该片段中直接使用这些参数 --&gt;&lt;div th:fragment=&quot;fragment-name(var1,var2)&quot; id=&quot;fragment-id&quot;&gt;    &lt;p th:text=&quot;&#39;参数1:&#39;+$&#123;var1&#125; + &#39;-------------------参数2:&#39; + $&#123;var2&#125;&quot;&gt;...&lt;/p&gt;&lt;/div&gt;</code></pre><p>启动 Spring Boot，使用浏览器访问 fragment.html，结果如下图。</p><p>图1：参数传递效果图</p><h2 id="thymeleaf-基本对象"><a href="#thymeleaf-基本对象" class="headerlink" title="thymeleaf 基本对象"></a>thymeleaf 基本对象</h2><h3 id="ctx：上下文对象"><a href="#ctx：上下文对象" class="headerlink" title="#ctx：上下文对象"></a><strong>#ctx：上下文对象</strong></h3><p><strong>thymeleaf context：#ctx 是IContext 对象引用</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IContext</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Locale <span class="token function">getLocale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">containsVariable</span><span class="token punctuation">(</span>String var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    Set <span class="token function">getVariableNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Object <span class="token function">getVariable</span><span class="token punctuation">(</span>String var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>#ctx 使用$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>locale<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>varableNames<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>thymeleaf web context：#ctx 是 IWebContext 对象引用</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IWebContext</span> <span class="token keyword">extends</span> <span class="token class-name">IContext</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    HttpServletRequest <span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HttpServletResponse <span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HttpSession <span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ServletContext <span class="token function">getServletContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>#ctx 使用$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>request<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>response<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>session<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>$<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>#ctx<span class="token punctuation">.</span>servletContext<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>说明：#vars、#root 与 #ctx 作用相似，推荐使用 #ctx</strong></p><h3 id="locale：java-util-Locale-对象引用"><a href="#locale：java-util-Locale-对象引用" class="headerlink" title="#locale：java.util.Locale 对象引用"></a><strong>#locale：java.util.Locale 对象引用</strong></h3><hr><p><strong>param、session、application</strong></p><p><strong>WebEngineContext</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebEngineContext</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractEngineContext</span> <span class="token keyword">implements</span> <span class="token class-name">IEngineContext</span><span class="token punctuation">,</span> IWebContext <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PARAM_VARIABLE_NAME <span class="token operator">=</span> <span class="token string">"param"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String SESSION_VARIABLE_NAME <span class="token operator">=</span> <span class="token string">"session"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String APPLICATION_VARIABLE_NAME <span class="token operator">=</span> <span class="token string">"application"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> HttpServletRequest request<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> HttpServletResponse response<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> HttpSession session<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ServletContext servletContext<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> WebEngineContext<span class="token punctuation">.</span>RequestAttributesVariablesMap requestAttributesVariablesMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map requestParametersVariablesMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map sessionAttributesVariablesMap<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Map applicationAttributesVariablesMap<span class="token punctuation">;</span></code></pre><p> <strong>说明：</strong>web 环境中，<strong>param、session、application</strong>以 <strong>map 的形式</strong>存储到<strong>WebEngineContext</strong>中</p><p><strong>param ==> requestParametersVariablesMap</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>param.foo<span class="token entity" title="&#125;">&amp;#125;</span>                  //请求参数foo对应的value$<span class="token entity" title="&#123;">&amp;#123;</span>param.size()<span class="token entity" title="&#125;">&amp;#125;</span>               //请求参数的个数$<span class="token entity" title="&#123;">&amp;#123;</span>param.isEmpty()<span class="token entity" title="&#125;">&amp;#125;</span>            //请求参数是否为空$<span class="token entity" title="&#123;">&amp;#123;</span>param.containsKey('foo')<span class="token entity" title="&#125;">&amp;#125;</span>   //请求参数中是否含有名为foo的参数...</code></pre><p><strong>session</strong> <strong>==> sessionAttributesVariablesMap</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>session.foo<span class="token entity" title="&#125;">&amp;#125;</span>                 //获取session中key：foo的属性值$<span class="token entity" title="&#123;">&amp;#123;</span>session.size()<span class="token entity" title="&#125;">&amp;#125;</span>              //session中键值对个数$<span class="token entity" title="&#123;">&amp;#123;</span>session.isEmpty()<span class="token entity" title="&#125;">&amp;#125;</span>           //session中是否含有键值对$<span class="token entity" title="&#123;">&amp;#123;</span>session.containsKey('foo')<span class="token entity" title="&#125;">&amp;#125;</span>  //session中是否含有key：foo的键值对...</code></pre><p><strong>application</strong> <strong>==></strong> <strong>applicationAttributesVariablesMap</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>application.foo<span class="token entity" title="&#125;">&amp;#125;</span>                //application 中key：foo的属性值$<span class="token entity" title="&#123;">&amp;#123;</span>application.size()<span class="token entity" title="&#125;">&amp;#125;</span>             //application中存储的键值对的个数$<span class="token entity" title="&#123;">&amp;#123;</span>application.isEmpty()<span class="token entity" title="&#125;">&amp;#125;</span>          //application中是否存储键值对$<span class="token entity" title="&#123;">&amp;#123;</span>application.containsKey('foo')<span class="token entity" title="&#125;">&amp;#125;</span> //application中是否含有key为foo的键值对...</code></pre><p><strong>注意：param、session、application使用时没有 #</strong></p><hr><h3 id="request、-session、-servletContext"><a href="#request、-session、-servletContext" class="headerlink" title="#request、#session、#servletContext"></a><strong>#request、#session、#servletContext</strong></h3><p><strong>#request：javax.servlet.http.HttpServletRequest 对象引用</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>#request.getAttribute('foo')<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#request.getParameter('foo')<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#request.getContextPath()<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#request.getRequestName()<span class="token entity" title="&#125;">&amp;#125;</span>...</code></pre><p><strong>#session：javax.servlet.http.HttpSession 对象引用</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>#session.getAttribute('foo')<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#session.id<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#session.lastAccessedTime<span class="token entity" title="&#125;">&amp;#125;</span>...</code></pre><p><strong>#servletContext：javax.servlet.ServletContext</strong></p><pre class=" language-html"><code class="language-html">$<span class="token entity" title="&#123;">&amp;#123;</span>#servletContext.getAttribute('foo')<span class="token entity" title="&#125;">&amp;#125;</span>$<span class="token entity" title="&#123;">&amp;#123;</span>#servletContext.contextPath<span class="token entity" title="&#125;">&amp;#125;</span>...</code></pre><h2 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h2><p>修改须要带实体进行回显，而新增不须要，那么就会出现再新增的状况下Thymeleaf找不到实体对象blog</p><p>使用 ${xxx?.xxx?} 能够判断对象是否为空渲染</p><p>? 号 前的对象或者属性为空那么就再也不进行渲染，并且不会致使出现报错的状况im </p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>代码示例：    $&#123;#dates.format(dateVar, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.arrayFormat(datesArray, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.listFormat(datesList, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.setFormat(datesSet, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.createNow()&#125;    $&#123;#dates.createToday()&#125;    $&#123;#strings.isEmpty(name)&#125;    $&#123;#strings.arrayIsEmpty(nameArr)&#125;    $&#123;#strings.listIsEmpty(nameList)&#125;    $&#123;#strings.setIsEmpty(nameSet)&#125;    $&#123;#strings.startsWith(name,&#39;Don&#39;)&#125;                  // also array*, list* and set*    $&#123;#strings.endsWith(name,endingFragment)&#125;           // also array*, list* and set*    $&#123;#strings.length(str)&#125;     $&#123;#strings.equals(str)&#125;    $&#123;#strings.equalsIgnoreCase(str)&#125;    $&#123;#strings.concat(str)&#125;    $&#123;#strings.concatReplaceNulls(str)&#125;    $&#123;#strings.randomAlphanumeric(count)&#125;//产生随机字符串</code></pre><h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><p><a href="https://blog.csdn.net/liuminglei1987/article/details/106692004/">https://blog.csdn.net/liuminglei1987/article/details/106692004/</a></p><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>springboot+thymeleaf+mybatis+mysql</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>实现 emp 的增删改查和分页功能</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p>首页：</p><p>编辑页：</p><p>添加页：</p><p>删除提示：</p><h4 id="mysql数据"><a href="#mysql数据" class="headerlink" title="mysql数据"></a>mysql数据</h4><pre><code>/*MySQL BackupSource Server Version: 5.5.49Source Database: testDate: 2017/9/11 06:52:29*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------  Table structure for `dept`-- ----------------------------DROP TABLE IF EXISTS `dept`;CREATE TABLE `dept` (  `DEPTNO` int(11) NOT NULL,  `DNAME` varchar(14) DEFAULT NULL,  `LOC` varchar(13) DEFAULT NULL,  PRIMARY KEY (`DEPTNO`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------  Table structure for `emp`-- ----------------------------DROP TABLE IF EXISTS `emp`;CREATE TABLE `emp` (  `EMPNO` int(11) NOT NULL,  `ENAME` varchar(10) DEFAULT NULL,  `JOB` varchar(9) DEFAULT NULL,  `MGR` int(11) DEFAULT NULL,  `HIREDATE` date DEFAULT NULL,  `SAL` decimal(7,2) DEFAULT NULL,  `COMM` decimal(7,2) DEFAULT NULL,  `DEPTNO` int(11) DEFAULT NULL,  PRIMARY KEY (`EMPNO`),  KEY `FK_DEPTNO` (`DEPTNO`),  CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`DEPTNO`) REFERENCES `dept` (`DEPTNO`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------  Records -- ----------------------------INSERT INTO `dept` VALUES (&#39;10&#39;,&#39;ACCOUNTING&#39;,&#39;NEW YORK&#39;), (&#39;20&#39;,&#39;RESEARCH&#39;,&#39;DALLAS&#39;), (&#39;30&#39;,&#39;SALES&#39;,&#39;CHICAGO&#39;), (&#39;40&#39;,&#39;OPERATIONS&#39;,&#39;BOSTON&#39;);INSERT INTO `emp` VALUES (&#39;7369&#39;,&#39;SMITH&#39;,&#39;CLERK&#39;,&#39;7902&#39;,&#39;1980-12-17&#39;,&#39;800.00&#39;,NULL,&#39;20&#39;), (&#39;7499&#39;,&#39;ALLEN&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-02-20&#39;,&#39;1600.00&#39;,&#39;300.00&#39;,&#39;30&#39;), (&#39;7521&#39;,&#39;WARD&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-02-22&#39;,&#39;1250.00&#39;,&#39;500.00&#39;,&#39;30&#39;), (&#39;7566&#39;,&#39;JONES&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-04-02&#39;,&#39;2975.00&#39;,NULL,&#39;20&#39;), (&#39;7654&#39;,&#39;MARTIN&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-09-28&#39;,&#39;1250.00&#39;,&#39;1400.00&#39;,&#39;30&#39;), (&#39;7698&#39;,&#39;BLAKE&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-05-01&#39;,&#39;2850.00&#39;,NULL,&#39;30&#39;), (&#39;7782&#39;,&#39;CLARK&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-06-09&#39;,&#39;2450.00&#39;,NULL,&#39;10&#39;), (&#39;7788&#39;,&#39;SCOTT&#39;,&#39;ANALYST&#39;,&#39;7566&#39;,&#39;1987-06-13&#39;,&#39;3000.00&#39;,NULL,&#39;20&#39;), (&#39;7839&#39;,&#39;KING&#39;,&#39;PRESIDENT&#39;,NULL,&#39;1981-11-17&#39;,&#39;5000.00&#39;,NULL,&#39;10&#39;), (&#39;7844&#39;,&#39;TURNER&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-09-08&#39;,&#39;1500.00&#39;,&#39;0.00&#39;,&#39;30&#39;), (&#39;7876&#39;,&#39;ADAMS&#39;,&#39;CLERK&#39;,&#39;7788&#39;,&#39;1987-06-13&#39;,&#39;1100.00&#39;,NULL,&#39;20&#39;), (&#39;7900&#39;,&#39;JAMES&#39;,&#39;CLERK&#39;,&#39;7698&#39;,&#39;1981-12-03&#39;,&#39;950.00&#39;,NULL,&#39;30&#39;), (&#39;7902&#39;,&#39;FORD&#39;,&#39;ANALYST&#39;,&#39;7566&#39;,&#39;1981-12-03&#39;,&#39;3000.00&#39;,NULL,&#39;20&#39;), (&#39;7934&#39;,&#39;MILLER&#39;,&#39;CLERK&#39;,&#39;7782&#39;,&#39;1982-01-23&#39;,&#39;1300.00&#39;,NULL,&#39;10&#39;);</code></pre><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.4.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;springbootdemo1&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springbootdemo1&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.2.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><pre><code>server.port=8089spring.thymeleaf.cache=falseserver.servlet.context-path=/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root</code></pre><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>包：entity</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class Emp &#123;    private Integer empno;    private String ename;    private String job;    private Integer mgr;    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)    private Date hiredate;    private Double sal;    private Double comm;    private Dept dept;&#125;</code></pre><pre><code>@Data@NoArgsConstructor@AllArgsConstructorpublic class Dept &#123;    private Integer deptno;    private String dname;    private String loc;&#125;</code></pre><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><p>包：mapper</p><pre><code>public interface EmpMapper &#123;    @Insert(&#123;&quot;insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) &quot;,            &quot;values(#&#123;empno&#125;,#&#123;ename&#125;,#&#123;job&#125;,#&#123;mgr&#125;,#&#123;hiredate&#125;,#&#123;sal&#125;,#&#123;comm&#125;,#&#123;dept.deptno&#125;)&quot;&#125;)    public int insert(Emp emp);    @Update(&#123;&quot;update emp set ename = #&#123;ename&#125;,job=#&#123;job&#125;,mgr=#&#123;mgr&#125;,hiredate=#&#123;hiredate&#125;&quot;,            &quot;,sal=#&#123;sal&#125;,comm=#&#123;comm&#125;,deptno=#&#123;dept.deptno&#125;&quot;,            &quot; where empno = #&#123;empno&#125;&quot;&#125;)    public int update(Emp emp);    @Delete(&quot;delete from emp where empno = #&#123;empno&#125;&quot;)    public int delete(Integer empno);    @Select(&quot;select * from emp where empno = #&#123;empno&#125;&quot;)    @Results(id=&quot;basicMap&quot;,value = &#123;@Result(            property = &quot;dept&quot;,            column = &quot;deptno&quot;,            one = @One(select = &quot;com.neu.springbootdemo1.mapper.DeptMapper.getById&quot;)    )&#125;)    public Emp getById(Integer empno);    @Select(&quot;select * from emp&quot;)    @ResultMap(&quot;basicMap&quot;)    public List&lt;Emp&gt; getAll();&#125;</code></pre><pre><code>public interface DeptMapper &#123;    @Select(&quot;select * from dept&quot;)    List&lt;Dept&gt; getAll();    @Select(&quot;select * from dept where deptno = #&#123;deptno&#125;&quot;)    Dept getById(Integer deptno);&#125;</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>包：service</p><pre><code>public interface EmpService &#123;    public int insert(Emp emp);    public int update(Emp emp);    public int delete(Integer empno);    public Emp getById(Integer empno);    public List&lt;Emp&gt; getAll();    public PageInfo&lt;Emp&gt; getPaged(int pageNum,int pageSize);&#125;</code></pre><pre><code>public interface DeptService &#123;    List&lt;Dept&gt; getAll();    Dept getById(Integer deptno);&#125;</code></pre><p>实现类：</p><p>包：service.impl</p><pre><code>@Servicepublic class DeptServiceImpl implements DeptService &#123;    @Autowired    private DeptMapper deptMapper;    @Override    public List&lt;Dept&gt; getAll() &#123;        return deptMapper.getAll();    &#125;    @Override    public Dept getById(Integer deptno) &#123;        return deptMapper.getById(deptno);    &#125;&#125;</code></pre><pre><code>@Servicepublic class EmpServiceImpl implements EmpService &#123;    @Autowired    private EmpMapper empMapper;    @Override    public int insert(Emp emp) &#123;        return empMapper.insert(emp);    &#125;    @Override    public int update(Emp emp) &#123;        return empMapper.update(emp);    &#125;    @Override    public int delete(Integer empno) &#123;        return empMapper.delete(empno);    &#125;    @Override    public Emp getById(Integer empno) &#123;        return empMapper.getById(empno);    &#125;    @Override    public List&lt;Emp&gt; getAll() &#123;        return empMapper.getAll();    &#125;    @Override    public PageInfo&lt;Emp&gt; getPaged(int pageNum, int pageSize) &#123;        PageHelper.startPage(pageNum,pageSize);        List&lt;Emp&gt; emps = empMapper.getAll();        PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(emps);        return pageInfo;    &#125;&#125;</code></pre><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>包：controller</p><pre><code>@Controller//@RequestMapping(&quot;emp&quot;)public class EmpController &#123;    @Autowired    private EmpService empService;    @Autowired    private DeptService deptService;    @RequestMapping(&#123;&quot;/&quot;,&quot;/emp/getPaged&quot;&#125;)    public String getPaged(@RequestParam(defaultValue = &quot;1&quot;) int pageNum,@RequestParam(defaultValue = &quot;3&quot;) int pageSize, Model model)&#123;        PageInfo&lt;Emp&gt; pageInfo = empService.getPaged(pageNum, pageSize);        model.addAttribute(&quot;pageInfo&quot;,pageInfo);        return &quot;emp/paged&quot;;    &#125;    @RequestMapping(&quot;emp/delete&quot;)    public String delete(Integer empno)&#123;        int n = empService.delete(empno);        return &quot;redirect:/&quot;;    &#125;    @RequestMapping(&quot;emp/edit&quot;)    public String edit(Integer empno,Model model)&#123;        Emp emp = empService.getById(empno);        model.addAttribute(&quot;emp&quot;,emp);        List&lt;Dept&gt; deptList = deptService.getAll();        model.addAttribute(&quot;deptList&quot;,deptList);        return &quot;emp/edit&quot;;    &#125;    @RequestMapping(&quot;emp/update&quot;)    public String update(Emp emp)&#123;        empService.update(emp);        return &quot;redirect:/&quot;;    &#125;    @RequestMapping(&quot;emp/add&quot;)    public String add(Model model)&#123;        List&lt;Dept&gt; deptList = deptService.getAll();        model.addAttribute(&quot;deptList&quot;,deptList);        return &quot;emp/add&quot;;    &#125;    @RequestMapping(&quot;emp/insert&quot;)    public String insert(Emp emp)&#123;        int n = empService.insert(emp);        return &quot;redirect:/&quot;;    &#125;&#125;</code></pre><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><h4 id="源码结构图"><a href="#源码结构图" class="headerlink" title="源码结构图"></a>源码结构图</h4><h4 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h4><p>src/main/resources/templates/component/component1.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;            &lt;/head&gt;        &lt;tr id=&quot;tfoot&quot;&gt;        &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt;            第&lt;span th:text=&quot;$&#123;pageInfo.pageNum&#125;&quot;&gt;&lt;/span&gt;页/            共&lt;span th:text=&quot;$&#123;pageInfo.pages&#125;&quot;&gt;&lt;/span&gt;页            &lt;a th:if=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateFirstPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;第一页&lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateFirstPage-1&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;上一页&lt;/a&gt;            &lt;a                 th:href=&quot;$&#123;pageInfo.pageNum == num&#125;?&#39;#&#39;:|@&#123;/emp/getPaged(pageNum=$&#123;num&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;                 th:each=&quot;num:$&#123;pageInfo.navigatepageNums&#125;&quot;                 th:text=&quot;|[$&#123;num&#125;]|&quot;&gt;            &lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasNextPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.nextPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;下一页&lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasNextPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateLastPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;最后一页&lt;/a&gt;            跳转到：&lt;input type=&quot;text&quot; style=&quot;width:15px;&quot; onkeydown=&quot;goPage(this.value)&quot;&gt;            &lt;select onchange=&quot;changePageSize(this.value)&quot;&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 3&#125;&quot;&gt;3&lt;/option&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 5&#125;&quot;&gt;5&lt;/option&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 10&#125;&quot;&gt;10&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;                &lt;script th:inline=&quot;javascript&quot;  &gt;            function del(empno)&#123;            var b = confirm(&quot;是否删除&quot;);            if(b)&#123;            location.href=[[|@&#123;/emp/delete&#125;?empno=|]]+empno;            &#125;            &#125;            function goPage(num)&#123;                        if(event.keyCode == 13)&#123;            var url = [[@&#123;/emp/getPaged(pageSize=$&#123;pageInfo.pageSize&#125;)&#125;]]+&quot;&amp;pageNum=&quot;+num;            location.href= url;            &#125;                    &#125;                        function changePageSize(size)&#123;            var url = [[@&#123;/emp/getPaged?pageNum=1&#125;]]+&quot;&amp;pageSize=&quot;+size;        location.href= url;            &#125;        &lt;/script&gt;    &lt;/tr&gt;       &lt;div id=&quot;com2&quot;&gt;        &lt;p th:text=&quot;$&#123;#ctx.#request.getAttribute(&#39;msg&#39;)&#125;&quot;&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/html&gt;</code></pre><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>src/main/resources/statis/css/style1.css</p><pre><code>.bg&#123;   background-color:antiquewhite;&#125;</code></pre><h4 id="分页查询页"><a href="#分页查询页" class="headerlink" title="分页查询页"></a>分页查询页</h4><p>位置：/resources/templates/emp/paged.html</p><h5 id="使用组件版"><a href="#使用组件版" class="headerlink" title="使用组件版"></a>使用组件版</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;thymeleaf&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style1.css&#125;&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;a th:href=&quot;@&#123;/emp/add&#125;&quot;&gt;添加员工&lt;/a&gt;    &lt;table width=&quot;1200&quot; border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;岗位&lt;/th&gt;                &lt;th&gt;经理&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪水&lt;/th&gt;                &lt;th&gt;奖金&lt;/th&gt;                &lt;th&gt;部门&lt;/th&gt;                &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr                 th:each=&quot;emp,status:$&#123;pageInfo.list&#125;&quot;                 th:object=&quot;$&#123;emp&#125;&quot;                th:classappend=&quot;$&#123;status.index % 2 == 1?&#39;bg&#39;:&#39;&#39;&#125;&quot;            &gt;                &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;ename&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;job&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;sal&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;comm&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;mgr&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;dept.dname&#125;&quot;&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=&quot;#&quot; th:onclick=&quot;del([[*&#123;empno&#125;]])&quot;&gt;删除&lt;/a&gt;                    &lt;a th:href=&quot;|@&#123;/emp/edit&#125;?empno=*&#123;empno&#125;|&quot;&gt;编辑&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;        &lt;tfoot th:insert=&quot;~&#123;/component/component1 :: #tfoot&#125;&quot;&gt;&lt;/tfoot&gt;    &lt;/table&gt;   &lt;!--  &lt;script th:replace=&quot;~&#123;/component/component1:: #s1&#125;&quot;&gt;        &lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="不使用组件版"><a href="#不使用组件版" class="headerlink" title="不使用组件版"></a>不使用组件版</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;员工信息&lt;/title&gt;    &lt;style&gt;        .tr&#123;            background-color: antiquewhite;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a th:href=&quot;|$&#123;#request.contextPath&#125;/emp/add|&quot;&gt;添加员工&lt;/a&gt;    &lt;table width=&quot;1200&quot; border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;岗位&lt;/th&gt;                &lt;th&gt;经理&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪水&lt;/th&gt;                &lt;th&gt;奖金&lt;/th&gt;                &lt;th&gt;部门&lt;/th&gt;                &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr th:each=&quot;emp,status : $&#123;pageInfo.list&#125;&quot;                th:object=&quot;$&#123;emp&#125;&quot;                th:classappend=&quot;$&#123;status.odd&#125;?&#39;tr&#39;&quot;            &gt;                &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;ename&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;job&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;mgr&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;sal&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;comm&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;dept.dname&#125;&quot;&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=&quot;#&quot; th:onclick=&quot;del([[*&#123;empno&#125;]])&quot;&gt;删除&lt;/a&gt;                    &lt;a href=&quot;#&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/edit?empno=*&#123;empno&#125;|&quot;&gt;编辑&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;        &lt;tfoot&gt;            &lt;tr&gt;                &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isFirstPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=1&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;第一页&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isFirstPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;上一页&lt;/a&gt;                    &lt;a href=&quot;#&quot;                       th:each=&quot;pageNum : $&#123;#numbers.sequence(1,pageInfo.pages)&#125;&quot;                       th:text=&quot;|[$&#123;pageNum&#125;]|&quot;                       th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;                    &gt;&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isLastPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;下一页&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isLastPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;末页&lt;/a&gt;                    到：&lt;input type=&quot;text&quot; size=&quot;1&quot; id=&quot;pageNum&quot; onkeydown=&quot;goPage()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;go&quot; onclick=&quot;jumpToPage()&quot;&gt;                    &lt;select onchange=&quot;changePageSize(this.value)&quot;&gt;                        &lt;option value=&quot;3&quot; th:selected=&quot;$&#123;pageInfo.pageSize==3&#125;?true:false&quot;&gt;3&lt;/option&gt;                        &lt;option value=&quot;5&quot; th:selected=&quot;$&#123;pageInfo.pageSize==5&#125;?true:false&quot;&gt;5&lt;/option&gt;                        &lt;option value=&quot;8&quot; th:selected=&quot;$&#123;pageInfo.pageSize==8&#125;?true:false&quot;&gt;8&lt;/option&gt;                    &lt;/select&gt;                    总计: &lt;span th:text=&quot;$&#123;pageInfo.total&#125;&quot;&gt;&lt;/span&gt; 行                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tfoot&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&lt;script th:inline=&quot;javascript&quot;&gt;    function jumpToPage() &#123;        let pageNum = document.getElementById(&quot;pageNum&quot;).value;        location.href = [[|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=|]]+pageNum+&quot;&amp;pageSize=&quot;+[[$&#123;pageInfo.pageSize&#125;]];    &#125;    function changePageSize(pageSize) &#123;        location.href = [[|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=1|]]+&quot;&amp;pageSize=&quot;+pageSize;    &#125;    function goPage() &#123;        if(event.keyCode === 13)&#123;            jumpToPage();        &#125;    &#125;    function del(empno) &#123;        if(confirm(`是否删除id为：$&#123;empno&#125;的员工?`))&#123;            location.href = [[|$&#123;#request.contextPath&#125;/emp/delete?empno=|]]+empno;        &#125;    &#125;&lt;/script&gt;</code></pre><h4 id="编辑页"><a href="#编辑页" class="headerlink" title="编辑页"></a>编辑页</h4><p>位置：/resources/templates/emp/edit.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form th:action=&quot;@&#123;/emp/update(empno=$&#123;emp.empno&#125;)&#125;&quot; method=&quot;post&quot;&gt;    &lt;table th:object=&quot;$&#123;emp&#125;&quot;&gt;        &lt;tr&gt;            &lt;td&gt;员工编号：&lt;/td&gt;            &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工姓名：&lt;/td&gt;            &lt;td &gt;                &lt;input type=&quot;text&quot; name=&quot;ename&quot; th:value=&quot;*&#123;ename&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工岗位：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;job&quot; th:value=&quot;*&#123;job&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;入职日期：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;date&quot; name=&quot;hiredate&quot; th:value=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;经理编号：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;mgr&quot; th:value=&quot;*&#123;mgr&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;薪水：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;sal&quot; th:value=&quot;*&#123;sal&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;奖金：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;comm&quot; th:value=&quot;*&#123;comm&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;部门：&lt;/td&gt;            &lt;td&gt;                &lt;select name=&quot;dept.deptno&quot;&gt;                        &lt;option                        th:each=&quot;dept:$&#123;deptList&#125;&quot;                        th:object=&quot;$&#123;dept&#125;&quot;                        th:text=&quot;*&#123;dname&#125;&quot;                        th:value=&quot;*&#123;deptno&#125;&quot;                        th:selected=&quot;*&#123;deptno&#125; == $&#123;emp.dept.deptno&#125;&quot;                    &gt;                    &lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="添加页"><a href="#添加页" class="headerlink" title="添加页"></a>添加页</h4><p>位置：/resources/templates/emp/add.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;添加员工&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/emp/insert&#125;&quot; method=&quot;post&quot;&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;员工编号：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;empno&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工姓名：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;ename&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工岗位：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;job&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工经理：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;mgr&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;入职日期：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;date&quot; name=&quot;hiredate&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工薪水：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;sal&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工奖金：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;comm&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工部门：&lt;/td&gt;            &lt;td&gt;                &lt;select name=&quot;dept.deptno&quot;&gt;                    &lt;option                            th:each=&quot;dept : $&#123;deptList&#125;&quot;                            th:text=&quot;$&#123;dept.dname&#125;&quot;                            th:value=&quot;$&#123;dept.deptno&#125;&quot;                    &gt;&lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="测试Mapper"><a href="#测试Mapper" class="headerlink" title="测试Mapper"></a>测试Mapper</h3><pre><code>package com.neu.springbootdemo1;import com.neu.springbootdemo1.entity.Dept;import com.neu.springbootdemo1.entity.Emp;import com.neu.springbootdemo1.mapper.DeptMapper;import com.neu.springbootdemo1.mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.Date;import java.util.List;@SpringBootTestclass Springbootdemo1ApplicationTests &#123;    @Autowired    private DeptMapper deptMapper;    @Autowired    private EmpMapper empMapper;    @Test    void testEmpGetById()&#123;        Emp emp = empMapper.getById(7566);        System.out.println(emp);    &#125;    @Test    void testEmpGetAll()&#123;        List&lt;Emp&gt; emps = empMapper.getAll();        System.out.println(emps);    &#125;    @Test    void testEmpInsert()&#123;        Emp emp = new Emp(2000,&quot;marry&quot;,&quot;清洁工&quot;,7566,new Date(),3000d,100d,new Dept(10,null,null));        int n = empMapper.insert(emp);        System.out.println(n);    &#125;    @Test    void testEmpUpdate()&#123;        Emp emp = new Emp(2000,&quot;marry&quot;,&quot;清洁工&quot;,7566,new Date(),4000d,200d,new Dept(20,null,null));        int n = empMapper.update(emp);        System.out.println(n);    &#125;    @Test    void testEmpDelete()&#123;        int n = empMapper.delete(2000);        System.out.println(n);    &#125;        @Test    void testDeptGetAll() &#123;        List&lt;Dept&gt; depts = deptMapper.getAll();        System.out.println(depts);    &#125;    @Test    void testDeptGetById()&#123;        Dept dept = deptMapper.getById(10);        System.out.println(dept);    &#125;&#125;</code></pre></script></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Thymeleaf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot</title>
      <link href="/2022/052617366.html"/>
      <url>/2022/052617366.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>起步依赖：告诉springboot需要什么功能，它就能引入需要的库，起步依赖其实就是利用maven传递依赖解析，把常用的库聚合在一起，组成了几个为特定功能而定制的依赖</li><li>自动配置：针对很多spring应用程序常见的功能，spring提供了自动依赖扫描，并进行自动配置</li></ol><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li><p>Spring Initializr（springboot初始化器）</p></li><li><p>选择需要的功能</p><ul><li>Spring Web</li><li>mybatis</li><li>mysql驱动</li><li>lombok</li><li>devtools（开发工具）</li></ul></li><li><p>修改了 application.properties</p><pre><code>#配置web服务器的端口号server.port=8089#配置数据源参数spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/neusoft?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root#配置视图解析器spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp</code></pre></li><li><p>添加jsp支持</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>idea中解决不能添加jsp文件的问题：</p><img src="/2022/052617366/1.jpg" class></li><li><p>添加mapper扫描注解</p><pre><code>@SpringBootApplication@MapperScan(basePackages = &quot;com.neu.mapper&quot;)public class SpringbootDemo1Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootDemo1Application.class, args);    &#125;&#125;</code></pre></li></ol><h2 id="Mapper文件相关配置"><a href="#Mapper文件相关配置" class="headerlink" title="Mapper文件相关配置"></a>Mapper文件相关配置</h2><ol><li><p>把mapper.xml放到 resources目录下，与mapper接口对应的文件夹下，如</p><img src="/2022/052617366/2.jpg" class></li><li><p>修改pom.xml,并在maven窗口中执行刷新</p><pre><code>&lt;build&gt;       &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;&lt;/build&gt;</code></pre></li></ol><h2 id="mybatis执行时显示sql"><a href="#mybatis执行时显示sql" class="headerlink" title="mybatis执行时显示sql"></a>mybatis执行时显示sql</h2><p>在application.<a href="https://so.csdn.net/so/search?q=properties&spm=1001.2101.3001.7020">properties</a>或application.yml文件中配置对应mapper所在包的日志级别即可。</p><p><strong>示列：com.neu.springbootdemodd.mapper 指向mapper 接口包路径地址</strong></p><pre><code># 日志记录输出配置logging.level.com.neu.springbootdemodd.mapper=debug</code></pre><h2 id="mybatis分页插件"><a href="#mybatis分页插件" class="headerlink" title="mybatis分页插件"></a>mybatis分页插件</h2><ol><li><p>添加依赖</p><pre><code>&lt;!--分页插件 pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>@Test    void testGetPaged()&#123;        PageHelper.startPage(2,3);        List&lt;Dept&gt; list = deptMapper.getAll();        PageInfo&lt;Dept&gt; pageInfo = new PageInfo&lt;&gt;(list);        System.out.println(pageInfo);    &#125;   输出：PageInfo&#123;pageNum=2, pageSize=3, size=3, startRow=4, endRow=6, total=11, pages=4, list=Page&#123;count=true, pageNum=2, pageSize=3, startRow=3, endRow=6, total=11, pages=4, reasonable=false, pageSizeZero=false&#125;[Dept(deptno=30, dname=SALES, loc=沈阳), Dept(deptno=33, dname=hr5, loc=南京), Dept(deptno=37, dname=hr, loc=sy)], prePage=1, nextPage=3, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=8, navigateFirstPage=1, navigateLastPage=4, navigatepageNums=[1, 2, 3, 4]&#125;</code></pre></li><li><p>设置（可选）</p><pre><code>#分页pageHelperpagehelper:  helperDialect: mysql  reasonable: true  #为了使用输入页数为负或者超出最大页时候使页数为最小或最大值  supportMethodsArguments: true  params: count=countSql  pageSizeZero: true  ·helper-dialect:配置使用哪种数据库语言，不配置的话pageHelper也会自动检测·reasonable:配置分页参数合理化功能，默认是false。 #启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;总页数会查询最后一页； #禁用合理化时，如果pageNum&lt;1或pageNum&gt;总页数会返回空数据。·params:为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值; 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。·support-methods-arguments:支持通过Mapper接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。pageSizeZeropageSize=0 or RowBounds.Limit = 0的时候就不适用分页，但是返回对象还是PageInfo</code></pre></li></ol><h2 id="Spring对mybatis事务的支持"><a href="#Spring对mybatis事务的支持" class="headerlink" title="Spring对mybatis事务的支持"></a>Spring对mybatis事务的支持</h2><p>注意：mysql只有InnoDB引擎支持事务</p><pre><code>@Transactionalpublic int insert(Dept dept) &#123;    int n = deptMapper.insert(dept);    deptMapper.insert(dept);    return n;&#125;</code></pre><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ol><li><p>导入jar包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>编写切面类</p><pre><code>@Configuration@EnableAspectJAutoProxy//开启切面自动代理@Component@Aspect//切面public class AOPUtil &#123;        //定义切入点    @Pointcut(&quot;execution (* com.neu.controller.*.*(..))&quot;)    public void pointcut() &#123;            &#125;        @Before(&quot;pointcut()&quot;)    public void before() &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        System.out.println(f.format(new Date()));    &#125;&#125;</code></pre></li></ol><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><ol><li>引入配置</li></ol><pre><code>&lt;!-- SpringBoot 热部署组件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol start="2"><li>配置静态自动编译</li></ol><img src="/2022/052617366/3.jpg" class><ol start="3"><li><p>如何触发<a href="https://so.csdn.net/so/search?q=%E7%83%AD%E9%83%A8%E7%BD%B2&spm=1001.2101.3001.7020">热部署</a></p><ol><li><p>虽然idea会自动保存，但是触发时间不确定，可以手动触发保存 Ctrl + S</p></li><li><p>点击idea上面的 小锤子图标，build project也会触发热部署</p></li></ol></li></ol><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol><li><p>编写上传网页</p><pre><code>&lt;form         action=&quot;$&#123; pageContext.request.contextPath &#125;/emp/upload&quot;         method=&quot;post&quot;        enctype=&quot;multipart/form-data&quot;    &gt;        文件名：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;</code></pre></li><li><p>服务器端</p><pre><code>@RequestMapping(&quot;upload&quot;)    public void upload(MultipartFile file,HttpServletRequest request, HttpServletResponse response) throws IllegalStateException, IOException &#123;        String path = request.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);                if(file != null &amp;&amp; !file.isEmpty()) &#123;            String filename = file.getOriginalFilename();            File f = new File(path, filename);            //保存            file.transferTo(f);        &#125;                response.setContentType(&quot;text/html;charset=utf-8&quot;);        response.getWriter().append(&quot;文件上传成功！&quot;);    &#125;</code></pre></li><li><p>多文件上传</p><pre><code>&lt;form         action=&quot;$&#123; pageContext.request.contextPath &#125;/emp/upload&quot;         method=&quot;post&quot;        enctype=&quot;multipart/form-data&quot;    &gt;        文件名：&lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;&lt;br&gt;        文件名：&lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;&lt;br&gt;        文件名：&lt;input type=&quot;file&quot; name=&quot;files&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;</code></pre><pre><code>@RequestMapping(&quot;upload&quot;)    public void upload(@RequestParam(&quot;files&quot;) MultipartFile[] files,HttpServletRequest request, HttpServletResponse response) throws IllegalStateException, IOException &#123;        String path = request.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);                for(MultipartFile file : files) &#123;            if(file != null &amp;&amp; !file.isEmpty()) &#123;                String filename = file.getOriginalFilename();                File f = new File(path, filename);                //保存                file.transferTo(f);            &#125;        &#125;                        response.setContentType(&quot;text/html;charset=utf-8&quot;);        response.getWriter().append(&quot;文件上传成功！&quot;);    &#125;</code></pre></li><li><p>设置上传尺寸大小</p><pre><code>#每个文件最大尺寸spring.servlet.multipart.max-file-size=5MB#设置请求最大尺寸spring.servlet.multipart.max-request-size=10MB</code></pre></li></ol><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><ol><li><p>意义：更友好和更安全</p></li><li><p>代码：</p><pre><code>@ControllerAdvicepublic class GlobalExceptionHandle &#123;    @ExceptionHandler(Exception.class)    @ResponseBody    public String exceptionHandler(Exception ex) &#123;        if(ex instanceof MaxUploadSizeExceededException) &#123;            return &quot;文件超过规定大小&quot;;        &#125;                return &quot;服务器错误，请联系管理员！&quot;;    &#125;&#125;</code></pre></li></ol><h2 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h2><ol><li><p>导入依赖</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;            &lt;!-- &lt;version&gt;2.4.6&lt;/version&gt; --&gt;        &lt;/dependency&gt;</code></pre></li><li><p>在resources目录下，添加配置文件：log4j2.xml</p></li></ol><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ol><li><p>拦截器类似于Ｓｅｒｖｌｅｔ中的过滤器，用于对处理器进行预处理和后处理</p></li><li><p>创建一个拦截器</p><pre><code>public class LoginCheckInterceptor implements HandlerInterceptor &#123;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception &#123;                HttpSession session = request.getSession();                Object username = session.getAttribute(&quot;username&quot;);                if(username != null) &#123;            //表示放行，不拦截            return true;        &#125;                response.setContentType(&quot;text/html;charset=utf-8&quot;);        response.getWriter().print(&quot;没有权限，不能访问!!!&quot;);                        return false;    &#125;&#125;</code></pre></li><li><p>注册拦截器</p><pre><code>@Configurationpublic class SpringMVCConfig implements WebMvcConfigurer &#123;    @Override    public void addFormatters(FormatterRegistry registry) &#123;            &#125;        @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LoginCheckInterceptor())            .addPathPatterns(&quot;/**&quot;)            .excludePathPatterns(&quot;/&quot;,&quot;/user/login&quot;);    &#125;&#125;</code></pre></li></ol><h2 id="注册视图控制器"><a href="#注册视图控制器" class="headerlink" title="注册视图控制器"></a>注册视图控制器</h2><pre><code>@Configurationpublic class SpringMVCConfig implements WebMvcConfigurer &#123;            @Override    public void addViewControllers(ViewControllerRegistry registry) &#123;        registry.addViewController(&quot;/&quot;).setViewName(&quot;user/login&quot;);        registry.addViewController(&quot;/emp/getUpload&quot;).setViewName(&quot;emp/upload&quot;);    &#125;&#125;</code></pre><h2 id="RESTFul"><a href="#RESTFul" class="headerlink" title="RESTFul"></a>RESTFul</h2><ol><li><p>定义：Rest是一种规范，一种编程风格，简单的说，就是利用http协议通过Get、Post、Put、Patch、Delete来操作具有URI标识的服务器资源，返回统一格式的资源信息，包括：JSON、xml等</p></li><li><p>JSON：JavaScript对象表示法</p><ul><li>{“name”:”tom”,”age”:20}</li><li>[10,true,”tom”,{“name”:”tom”,”age”:20}]</li></ul></li><li><p>返回JSON数据</p><ul><li><pre><code>@Controller@RequestMapping(&quot;emp&quot;)public class EmpController &#123;    @RequestMapping(&quot;getAll2&quot;)    @ResponseBody    public List&lt;Emp&gt; getAll2() &#123;        List&lt;Emp&gt; list = empService.getAll();                return list;    &#125;&#125;</code></pre></li><li><pre><code>@RestController@RequestMapping(&quot;emp&quot;)public class EmpController &#123;    @RequestMapping(&quot;getAll2&quot;)    public List&lt;Emp&gt; getAll2() &#123;        List&lt;Emp&gt; list = empService.getAll();                return list;    &#125;&#125;</code></pre></li></ul><ol start="4"><li><p>Http method方法：</p><ul><li>get（select）：从服务器取出资源（一项或多项）</li><li>post(insert)：在服务器新建一个资源</li><li>put（update）：更新服务器资源（完整更新）</li><li>patch（update）：更新服务器资源（有选择更新）</li><li>delete(delete):删除服务器资源</li></ul></li><li><p>get请求</p><pre><code>@RestController@RequestMapping(&quot;dept2&quot;)public class RestDeptController &#123;    @Autowired    private DeptService deptService;    //dept2/10    @GetMapping(&quot;&#123;deptno&#125;&quot;)    public Dept getById(@PathVariable(&quot;deptno&quot;)int deptno) &#123;        return deptService.getById(deptno);    &#125;        @GetMapping    public List&lt;Dept&gt; getAll() &#123;        return deptService.getAll();    &#125;        @GetMapping(&quot;&#123;dname&#125;/&#123;loc&#125;&quot;)    public List&lt;Dept&gt; getById(@PathVariable(&quot;dname&quot;) String dname,@PathVariable(&quot;loc&quot;) String loc) &#123;        System.out.println(dname);        System.out.println(loc);        return deptService.getAll();    &#125;&#125;</code></pre></li><li><p>post请求</p><pre><code>@PostMappingpublic int insert(@RequestBody Dept dept) &#123;    return deptService.insert(dept);&#125;</code></pre></li><li><p>put请求</p><pre><code>@PutMappingpublic int update(@RequestBody Dept dept) &#123;    return deptService.update(dept);&#125;</code></pre></li></ol></li></ol><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li><p>打 jar 包</p><ul><li>关闭原来的项目</li><li>run as&#x3D;》maven build &#x3D;》 clean package</li><li>运行：java -jar jar包路径</li><li>测试：<a href="http://localhost:8089/dept/hr/sy">http://localhost:8089/dept/hr/sy</a></li></ul></li><li><p>打 war 包</p><ul><li><p>修改打包方式：war</p></li><li><p>添加启动配置类</p><pre><code>public class ServletInitializer extends SpringBootServletInitializer &#123;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;        return application.sources(Springbootdemo2Application.class);    &#125;&#125;</code></pre></li><li><p>run as&#x3D;》maven build &#x3D;》clean package</p></li><li><p>把生成的war包拷贝到 tomcat安装目录 &#x2F;webapps 文件夹下</p></li><li><p>启动 tomcat服务器 ： bin&#x2F;startup.bat</p></li><li><p>测试：<a href="http://localhost:9000/war%E5%8C%85%E5%90%8D/%E8%B5%84%E6%BA%90url">http://localhost:9000/war包名/资源url</a></p></li><li><p>停止tomcat服务</p></li><li><p>删除 war 包</p></li><li><p>可以把war包解压的所有内容剪切到 ROOT 文件夹下，把这个应用作为 根应用 </p></li><li><p>打包问题：</p><p>Invalid bound statement (not found): com.neu.mapper.DeptMapper.getById</p><pre><code>&lt;build&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;&lt;/build&gt;</code></pre></li></ul></li></ol><h2 id="springboot打成jar包无法访问jsp"><a href="#springboot打成jar包无法访问jsp" class="headerlink" title="springboot打成jar包无法访问jsp"></a>springboot打成jar包无法访问jsp</h2><p>背景<br>以前老项目迁成springboot项目，里面有jsp页面，但是在打成jar包后，使用java -jar xxx.jar 发现并不能访问jsp页面，但其他接口能正常使用。ps：项目如果是直接从启动类main方法启动是可以访问。</p><p>存在问题<br>一、jar包未含jsp文件<br>旧spring mvc项目 jsp 放在webapp目录下，spring-boot-maven-plugin 打包默认是不含该目录的，应在pon文件<build>里指将jsp页面目录加入 <resource>。</resource></build></p><p>二、包含jsp文件仍访问不了<br>需要把spring-boot-maven-plugin 版本改为 1.4.2.RELEASE，其它版本的都不可以。</p><p>详细方案<br>1）检查 pom 文件是否添加已对 jsp 页面的依赖：</p><pre><code>&lt;!-- tomcat JSP 的支持.--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><p>2）对jar包进行解压，进入解压目录查看是否有jsp页面，命令如下：</p><p>unzip xxx.jar<br>如果发现目录下没有jsp页面，则需要在pon文件<build>里指将jsp页面目录加入到 <resource>。</resource></build></p><p>3）指定 spring-boot-maven-plugin 版本为 1.4.2.RELEASE，其它版本的都不可以，具体原因不详，据说是个bug。</p><p>设置 targetPath 只能是 META-INF&#x2F;resources。然后用这个版本最好指定一下启动类main函数<mainClass>，否则当你项目里面存在多个main方法就会报错不知道用哪个。</mainClass></p><pre><code>&lt;!-- jsp加入resources，指定插件版本--&gt;&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;com.xxx.xxx.SpringbootApplication&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/webapp&lt;/directory&gt;            &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;            &lt;includes&gt;                &lt;include&gt;**/**&lt;/include&gt;            &lt;/includes&gt;        &lt;/resource&gt;    &lt;/resources&gt; &lt;/build&gt;</code></pre><p>4）在配置文件中加入前缀、后缀，这样项目启动就能正常访问到 jsp 页面了，此处项目目录为：</p><pre><code>spring:  mvc:    servlet:      load-on-startup: 1    view:      suffix: .jsp      prefix: /WEB-INF/views/ps：本地开发修改页面实时生效的配置：server:  port: 8181  servlet:    jsp:      init-parameters:        development: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/05254780.html"/>
      <url>/2022/05254780.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>问题：</p><ol><li>一个Servlet处理一个请求</li><li>请求参数获取与转换</li><li>硬编码了视图结果</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>是spring框架一个模块，与Spring无缝集成（SSH，Struts2）</li><li>是基于MVC设计模式实现的</li><li>是目前最流行的MVC框架</li><li>Spring3.0之后，全面超越了Struts2</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>导入jar</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>添加了一个SpringMVC组件配置类</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = &quot;com.neu.controller&quot;)public class SpringMVCConfig &#123;&#125;</code></pre></li><li><p>修改了web初始化器</p><p>Servlet 3.0 之后，web容器启动后会调用 META-INF&#x2F;services&#x2F;javax.servlet.ServletContainerInitializer文件中的类</p><p>在Tomcat8以上版本支持一个配置启动的东西，意思就是tomcat启动时会自动去扫描所有 jar 中目录为「 META-INF&#x2F;services&#x2F; 」中是否有个名字是「javax.servlet.ServletContainerInitializer」的配置文件，然后根据里面内容反编译启动等等一系列操作</p><img src="/2022/05254780/1.jpg" class><p><strong>如上图配置后tomcat启动时就会自动生成HelloServlet了，大概原理就这样，不过SpringMVC已经把上图中的基本配置已经搞定直接使用即可</strong></p><p>在 spring-web的jar包中查看</p><pre><code>org.springframework.web.SpringServletContainerInitializer</code></pre><pre><code>public class WebInitializer implements WebApplicationInitializer &#123;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        //创建spring容器        AnnotationConfigWebApplicationContext c =                 new AnnotationConfigWebApplicationContext();        //注册配置类        c.register(DBConfig.class);        c.register(MybatisConfig.class);        c.register(MybatisMapperScannerConfig.class);                //把spring容器的引用放到ServletContext        servletContext.addListener(new ContextLoaderListener(c));        //创建SpringMVC组件的容器（子容器，可以访问父容器）        AnnotationConfigWebApplicationContext childContext =                new AnnotationConfigWebApplicationContext();                childContext.register(SpringMVCConfig.class);                        Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(childContext));                servlet.addMapping(&quot;/&quot;);        //在启动web服务器的时候，直接创建这个前端控制器        servlet.setLoadOnStartup(1);    &#125;&#125;</code></pre></li><li><p>配置了一个视图解析器</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = &quot;com.neu.controller&quot;)public class SpringMVCConfig &#123;    //物理路径：/WEB-INF/jsp/hello.jsp    ///WEB-INF/jsp/hello.jsp    @Bean    public InternalResourceViewResolver viewResolver() &#123;        InternalResourceViewResolver r = new InternalResourceViewResolver();        //设置前缀        r.setPrefix(&quot;/WEB-INF/jsp/&quot;);        //设置后缀        r.setSuffix(&quot;.jsp&quot;);                return r;    &#125;&#125;</code></pre></li><li><p>创建业务逻辑控制器和处理器方法</p><pre><code>@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;hello&quot;)    public String hello() &#123;        System.out.println(&quot;hello!&quot;);        return &quot;hello&quot;;    &#125;&#125;</code></pre></li></ol><h2 id="SpringMVC详细配置"><a href="#SpringMVC详细配置" class="headerlink" title="SpringMVC详细配置"></a>SpringMVC详细配置</h2><ol><li><p>@RequestMapping</p><ul><li><p>既可以添加到类上，也可以添加到处理器方法上</p><ul><li>添加到类上的时候，提供初步的请求映射，路径相对于web应用程序根目录</li><li>添加到方法上，提供进一步的细分映射信息，相对于类定义处的url，若类定义处没有注解，则相对于web应用根目录</li></ul></li><li><p>method：表示能处理的请求方法，默认能处理get和post请求</p><pre><code>@RequestMapping(value=&quot;insert&quot;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)    public String insert() &#123;        return &quot;dept/getAll&quot;;    &#125;</code></pre></li><li><p>value:指定请求的url，默认属性</p></li><li><p>params:指定请求中必须包含某些请求参数或参数值</p><pre><code>@RequestMapping(value=&quot;insert&quot;,params = &#123;&quot;deptno=1&quot;,&quot;dname&quot;&#125;)    public String insert() &#123;        return &quot;dept/getAll&quot;;    &#125;</code></pre></li></ul></li><li><p>GetMapping:只处理get请求</p></li><li><p>PostMapping：只处理post请求</p></li><li><p>请求参数绑定</p><ul><li>定义：把请求参数的key&#x2F;value绑定到处理器方法的形参上，默认形参名与请求参数名相同，就会自动绑定</li><li>@RequestParam：手工映射请求参数<ul><li>value：请求参数名，默认属性</li><li>required：必须的，默认为：true,</li><li>defaultValue:默认值</li></ul></li></ul></li></ol><h2 id="请求参数中文处理"><a href="#请求参数中文处理" class="headerlink" title="请求参数中文处理"></a>请求参数中文处理</h2><ol><li><p>get</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;path&gt;/&lt;/path&gt;        &lt;port&gt;8089&lt;/port&gt;        &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre></li><li><p>post:修改web初始化器</p><pre><code>//注册编码过滤器javax.servlet.FilterRegistration.Dynamic filter             = servletContext.addFilter(&quot;charsetFilter&quot;, new CharacterEncodingFilter(&quot;utf-8&quot;));        filter.addMappingForUrlPatterns(null, false, &quot;/*&quot;);</code></pre></li></ol><h2 id="日期格式处理"><a href="#日期格式处理" class="headerlink" title="日期格式处理"></a>日期格式处理</h2><ol><li><p>定义了一个转换器</p><pre><code>public class DateConverter implements Converter&lt;String, Date&gt; &#123;    @Override    public Date convert(String source) &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        Date date = null;        try &#123;            date = f.parse(source);        &#125; catch (ParseException e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        return date;    &#125;&#125;</code></pre></li><li><p>注册转换器</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = &quot;com.neu.controller&quot;)public class SpringMVCConfig implements WebMvcConfigurer &#123;    @Override    public void addFormatters(FormatterRegistry registry) &#123;        //注册日期转换器        registry.addConverter(new DateConverter());    &#125;&#125;</code></pre><h2 id="跳转到其他请求的方式"><a href="#跳转到其他请求的方式" class="headerlink" title="跳转到其他请求的方式"></a>跳转到其他请求的方式</h2><pre><code>//请求转发//return &quot;forward:/dept/getAll&quot;;//重定向return &quot;redirect:/dept/getAll&quot;;</code></pre></li></ol><h2 id="处理器形参"><a href="#处理器形参" class="headerlink" title="处理器形参"></a>处理器形参</h2><ol><li><p>HttpServletRequest</p><pre><code>@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;hello&quot;)    public String hello(HttpServletRequest request) &#123;        String name = request.getParameter(&quot;name&quot;);        System.out.println(name);        return &quot;hello&quot;;    &#125;    &#125;</code></pre></li><li><p>HttpServletResponse</p><pre><code>@Controllerpublic class HelloController &#123;    @RequestMapping(&quot;hello&quot;)    public void hello(HttpServletRequest request,HttpServletResponse response) throws IOException &#123;        String name = request.getParameter(&quot;name&quot;);        System.out.println(name);                response.getWriter().append(name);//return &quot;hello&quot;;    &#125;    &#125;</code></pre></li><li><p>HttpSession</p><pre><code>@Controllerpublic class HelloController &#123;        @RequestMapping(&quot;/&quot;)    public String getLogin() &#123;        return &quot;login&quot;;    &#125;        @RequestMapping(&quot;login&quot;)    public String login(String username,String password,HttpSession session) &#123;                if(&quot;admin&quot;.equals(username) &amp;&amp; &quot;111&quot;.equals(password)) &#123;            session.setAttribute(&quot;username&quot;, username);            return &quot;forward:/dept/getAll&quot;;        &#125;else &#123;            return &quot;redirect:/&quot;;        &#125;    &#125;&#125;</code></pre></li></ol><h2 id="分页：使用Mybatis分页插件"><a href="#分页：使用Mybatis分页插件" class="headerlink" title="分页：使用Mybatis分页插件"></a>分页：使用Mybatis分页插件</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在mybatis配置类中，注册分页插件（拦截器）</p><pre><code>@Configuration@ComponentScan(basePackages = &#123;&quot;com.neu.mapper&quot;,&quot;com.neu.service&quot;,&quot;com.neu.utils&quot;&#125;)public class MybatisConfig &#123;    @Autowired    private DataSource dataSource;        @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();        factory.setDataSource(dataSource);        //创建一个分页拦截器        PageInterceptor interceptor = new PageInterceptor();                Properties prop =factory new Properties();        interceptor.setProperties(prop);        //注册拦截器        factory.setPlugins(new Interceptor[] &#123;interceptor&#125;);                return factory.getObject();    &#125;&#125;</code></pre></li><li><p>修改业务逻辑类</p><pre><code>@Override    public PageInfo&lt;Dept&gt; getPaged(int pageNum, int pageSize) &#123;        //分页方法，该方法会拦截该语句后的第一个查询，对该查询进行分页操作        PageHelper.startPage(pageNum, pageSize);                List&lt;Dept&gt; list = deptMapper.getAll();                PageInfo&lt;Dept&gt; pageInfo = new PageInfo&lt;Dept&gt;(list);        return pageInfo;    &#125;</code></pre></li><li><p>控制器</p><pre><code>@RequestMapping(&quot;getPaged&quot;)    public String getPaged(@RequestParam(defaultValue = &quot;1&quot;) int pageNum,@RequestParam(defaultValue = &quot;3&quot;) int pageSize,Model model) &#123;        PageInfo&lt;Dept&gt; pageInfo = deptService.getPaged(pageNum, pageSize);                System.out.println(pageInfo);        model.addAttribute(&quot;pageInfo&quot;, pageInfo);                return &quot;dept/paged&quot;;    &#125;</code></pre></li><li><p>jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    用户名：$&#123; username &#125;&lt;br&gt;    &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getinsertpage&quot;&gt;添加部门&lt;/a&gt;    &lt;form action=&quot;$&#123; pageContext.request.contextPath &#125;/dept/batchDelete&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;批量删除&quot;&gt;    &lt;table border=&quot;1&quot; width=&quot;900&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;        &lt;c:forEach items=&quot;$&#123; pageInfo.list &#125;&quot; var=&quot;dept&quot;&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;input type=&quot;checkbox&quot; name=&quot;deptno&quot; value=&quot;$&#123; dept.deptno &#125;&quot;&gt;            &lt;/td&gt;            &lt;td&gt;$&#123; dept.deptno &#125;&lt;/td&gt;            &lt;td&gt;$&#123; dept.dname &#125;&lt;/td&gt;            &lt;td&gt;$&#123; dept.loc &#125;&lt;/td&gt;            &lt;td&gt;                &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/delete?deptno=$&#123; dept.deptno &#125;&quot;&gt;删除&lt;/a&gt;                &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getById?deptno=$&#123; dept.deptno &#125;&quot;&gt;编辑&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;/c:forEach&gt;        &lt;/tbody&gt;        &lt;tfoot&gt;            &lt;td colspan=&quot;5&quot;&gt;                共$&#123; pageInfo.total &#125;记录                第 $&#123; pageInfo.pageNum &#125; 页/共$&#123; pageInfo.pages &#125;页                &lt;c:if test=&quot;$&#123; !pageInfo.isFirstPage &#125;&quot;&gt;                    &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=1&amp;pageSize=$&#123;pageInfo.pageSize&#125;&quot;&gt;第一页&lt;/a&gt;                    &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;&quot;&gt;上一页&lt;/a&gt;                &lt;/c:if&gt;                                &lt;c:forEach items=&quot;$&#123; pageInfo.navigatepageNums &#125;&quot; var=&quot;num&quot;&gt;                    &lt;c:if test=&quot;$&#123; num == pageInfo.pageNum &#125;&quot;&gt;                        &lt;a&gt;[$&#123; num &#125;]&lt;/a&gt;                    &lt;/c:if&gt;                    &lt;c:if test=&quot;$&#123; num != pageInfo.pageNum &#125;&quot;&gt;                        &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=$&#123; num &#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;&quot;&gt;[$&#123; num &#125;]&lt;/a&gt;                    &lt;/c:if&gt;                &lt;/c:forEach&gt;                                &lt;c:if test=&quot;$&#123; pageInfo.hasNextPage &#125;&quot;&gt;                    &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;&quot;&gt;下一页&lt;/a&gt;                &lt;/c:if&gt;                                &lt;c:if test=&quot;$&#123; !pageInfo.isLastPage &#125;&quot;&gt;                    &lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=$&#123;pageInfo.navigateLastPage&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;&quot;&gt;最后一页&lt;/a&gt;                &lt;/c:if&gt;                跳转到&lt;input type=&quot;text&quot; style=&quot;width:25px;&quot; id=&quot;page&quot;&gt;页                &lt;input type=&quot;button&quot; value=&quot;go&quot; onclick=&quot;goPage()&quot;&gt;                &lt;select onchange=&quot;changePageSize()&quot; id=&quot;pageSize&quot;&gt;                    &lt;option $&#123; pageInfo.pageSize == 3?&quot;selected&quot;:&quot;&quot; &#125;&gt;3&lt;/option&gt;                    &lt;option $&#123; pageInfo.pageSize == 5?&quot;selected&quot;:&quot;&quot; &#125;&gt;5&lt;/option&gt;                    &lt;option $&#123; pageInfo.pageSize == 10?&quot;selected&quot;:&quot;&quot; &#125;&gt;10&lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tfoot&gt;    &lt;/table&gt;    &lt;/form&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function goPage()&#123;            //得到文本框的值            var pageNum = document.getElementById(&quot;page&quot;).value;            //修改地址栏地址            location.href = &quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=&quot;+pageNum;        &#125;                function changePageSize()&#123;            var pageSize = document.getElementById(&quot;pageSize&quot;).value;            location.href = &quot;$&#123; pageContext.request.contextPath &#125;/dept/getPaged?pageNum=1&amp;pageSize=&quot;+pageSize;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h2 id="请求参数验证"><a href="#请求参数验证" class="headerlink" title="请求参数验证"></a>请求参数验证</h2><ol><li><p>JSR303是JavaBean数据合法性验证标准框架</p></li><li><p>Hibernate Validator 是JSR303的标准的实现</p></li><li><p>导入包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml&lt;/groupId&gt;    &lt;artifactId&gt;classmate&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在实体类的属性上添加验证注解</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class Dept &#123;    @NotNull(message = &quot;部门编号不能为空&quot;)    private Integer deptno;    private String dname;    private String loc;&#125;</code></pre></li><li><p>在控制器中的处理器方法的形参前添加@Valid注解</p><pre><code>@RequestMapping(&quot;insert&quot;)public String insert(@Valid Dept dept,Errors errors,Model model) &#123;    if(errors.hasErrors()) &#123;        model.addAttribute(&quot;errorList&quot;, errors.getAllErrors());        return &quot;dept/insert&quot;;    &#125;    //。。。&#125;</code></pre></li><li><p>jsp页面显示错误消息</p><pre><code>&lt;c:if test=&quot;$&#123; !(empty errorList) &#125;&quot;&gt;    &lt;c:forEach items=&quot;$&#123; errorList &#125;&quot; var=&quot;error&quot;&gt;        $&#123; error.defaultMessage &#125;&lt;br&gt;    &lt;/c:forEach&gt;&lt;/c:if&gt;</code></pre></li><li><p>验证注解</p><ul><li>@NotNull：不能为空，能验证任何对象</li><li>@NotBlank：表示注解的属性不能为null和空串，只能验证字符串</li><li>@Size（min&#x3D;2,max&#x3D;10,message&#x3D;””):验证字符串的长度</li><li>@Email：验证邮箱</li><li>@Post():必须是一个过去的日期</li><li>@Futrue：必须是一个未来的日期</li><li>@Min():最小值</li><li>@Max（）：最大值</li><li><code>@Pattern(regexp=&quot;^\\d&#123;3,8&#125;$&quot;)</code>：使用正则表达式验证</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok</title>
      <link href="/2022/052426635.html"/>
      <url>/2022/052426635.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Lombok项目是一个<a href="https://baike.baidu.com/item/Java/85979">Java</a>库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@<a href="https://baike.baidu.com/item/Data/7096603">Data</a>)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在开发工具中安装lombok插件</li><li>在项目中引入lombok.jar包</li><li>使用lombok注解（生成特定的代码）</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>作用在类上，是以下注解的集合：@ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor</p><pre><code>@Data@AllArgsConstructorpublic class Student &#123;        private Integer id;        private String name;        private Integer age;        private String schoolName ;&#125;</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>@NoArgsConstructor：生成无参数构造方法</li><li>@AllArgsConstructor：生成全参数的构造方法</li><li>@RequiredArgsConstructor：生成包含final和@NonNull注解成员变量的构造方法</li></ol><pre><code>//@NoArgsConstructor@AllArgsConstructor//生成包含final和@NonNull注解成员变量的构造方法@RequiredArgsConstructorpublic class Student &#123;    @NonNull    private Integer id;        private String name;        private Integer age;        private final String schoolName ;&#125;</code></pre><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><ul><li>这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：</li></ul><pre><code>//成员方法参数加上@NonNull注解public String getName(@NonNull Person p)&#123;    return p.getName();&#125;</code></pre><p>实际效果相当于：</p><pre><code>public String getName(@NonNull Person p)&#123;    if(p==null)&#123;        throw new NullPointerException(&quot;person&quot;);    &#125;    return p.getName();&#125;</code></pre><ul><li><p>用在成员变量上面，可以在生成Setter方法和构造方法的时候，检查对应形参是否为空</p><pre><code>@Datapublic class User &#123;    @NonNull    private Integer id;    private String name;    private Integer age;&#125;</code></pre></li></ul><h3 id="Getter-x2F-Setter"><a href="#Getter-x2F-Setter" class="headerlink" title="@Getter&#x2F;@Setter"></a>@Getter&#x2F;@Setter</h3><ul><li><p>作用在类上，生成所有成员变量的getter&#x2F;setter方法</p></li><li><p>作用在成员变量上，生成该成员变量的getter&#x2F;setter方法</p></li><li><p>可以设定访问权限</p></li></ul><pre><code>@Setter@Getter(value = AccessLevel.PROTECTED)public class Student &#123;    private Integer id;        private String name;        private Integer age;&#125;</code></pre><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>作用在类上，覆盖默认的toString()方法，可以通过 of 属性限定显示某些字段，通过 exclude 属性排除某些字段</p><pre><code>@ToString(exclude = &#123;&quot;age&quot;&#125;,of = &#123;&quot;id&quot;,&quot;name&quot;&#125;)public class Student &#123;    private Integer id;        private String name;        private Integer age;&#125;</code></pre><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>作用在类上，覆盖默认的equals和hashCode方法，可以通过 of 属性限定比较某些字段，通过 exclude 属性排除某些字段</p><pre><code>@EqualsAndHashCode(of = &#123;&quot;id&quot;&#125;)public class Student &#123;    private Integer id;        private String name;        private Integer age;&#125;</code></pre><h2 id="Lombok实现原理"><a href="#Lombok实现原理" class="headerlink" title="Lombok实现原理"></a>Lombok实现原理</h2><p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”（插件化注解处理API）规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p><p>Lombok就是一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><hr><ol><li><p>javac对源代码进行分析，生成一棵抽象语法树(AST)</p></li><li><p>javac编译过程中调用实现了JSR 269的Lombok程序</p></li><li><p>此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树    (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</p></li><li><p>javac使用修改后的抽象语法树(AST)生成字节码文件</p></li></ol><h2 id="Eclipse安装Lombok插件"><a href="#Eclipse安装Lombok插件" class="headerlink" title="Eclipse安装Lombok插件"></a>Eclipse安装Lombok插件</h2><p>1、下载lombok.jar，lombok.jar官方下载地址：<a href="https://projectlombok.org/download">https://projectlombok.org/download</a></p><p>2、双击下载好的lombak.jar，安装步骤如下：</p><p>2-1.关闭弹出的警告窗口，点击 Specify location..</p> <img src="/2022/052426635/1.jpg" class><p>2-2.选择eclipse的安装目录（确保该路径中不能有中文）</p> <img src="/2022/052426635/2.jpg" class><p>2-3.点击Install &#x2F; Update</p> <img src="/2022/052426635/3.jpg" class><p>2-4.点击Quit Installer，完成安装</p> <img src="/2022/052426635/4.jpg" class><p>3、安装完成之后，请确认eclipse安装路径下是否多了一个lombok.jar包，并且其<br>   配置文件eclipse.ini中是否 添加了如下内容:-javaagent:D:\build-env\eclipse\lombok.jar</p> <img src="/2022/052426635/5.jpg" class> <img src="/2022/052426635/6.jpg" class><p>4、重启eclipse或myeclipse</p><p>5、测试，建立如下类：</p><p>import lombok.Data;  </p><p>@Data<br>public class DataObject {<br>   private String id;<br>   private String name;<br>   private String userId;<br>   private String password;<br>}<br>备注：如过安装成功但是@Data等注解无效，可能是由于你的eclipse版本是新版本，你的lombok.jar版本太旧。那么请下载最新的lombok.jar再进行安装。</p><p>6、lombok注解介绍请参看：<a href="http://blog.csdn.net/sunsfan/article/details/53542374">http://blog.csdn.net/sunsfan/article/details/53542374</a></p>]]></content>
      
      
      <categories>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2022/052313919.html"/>
      <url>/2022/052313919.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>软件的半成品</p><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>是一个持久层框架，使用sql语句将实体类映射到数据表，是一个半自动的ORM实现</p><p>O：对象</p><p>R：关系型数据库</p><p>M：映射（自动映射）</p><p>Hibernate：全自动的ORM实现</p><p>SSH：Struts2、Spring，Hibernate</p><p>SSM：SpringMVC、Spring、MyBatis</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>最早是apache的一个开源项目iBatis，2010年更名为mybatis</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>外部化sql语句：把sql语句与java代码分离</p><p>封装化sql语句：把sql语句封装到单独的文件总，方便管理</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>创建一个maven项目</p></li><li><p>配置 pom.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;                    &lt;/plugins&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li><li><p>在resources目录下，添加SqlMapConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置一个环境，一个环境对应着一个数据库，default为某一个环境的id --&gt;    &lt;environments default=&quot;mysql&quot;&gt;        &lt;environment id=&quot;mysql&quot;&gt;            &lt;!-- 事务管理器，jdbc/managed(由外部容器管理，自己什么也不做) --&gt;            &lt;transactionManager type=&quot;jdbc&quot;&gt;&lt;/transactionManager&gt;            &lt;!-- 数据源，unpooled、pooled、jndi --&gt;            &lt;dataSource type=&quot;pooled&quot;&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai&quot;/&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name=&quot;com.neu.mapper&quot;&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li><li><p>Mapper映射文件</p><ul><li><p>编写实体类</p></li><li><p>创建一个包：com.neu.mapper</p></li><li><p>在Mapper包下，创建接口：DeptMapper，在该接口中添加增删改查的方法</p></li><li><p>使用mybatis mapper向导，生成接口的配置映射文件：配置文件的名与接口名相同</p></li><li><p>在生成的映射文件中（DeptMapper.xml）,namespace的名称为对应的接口的完全限定名（包名+接口名）</p></li><li><p>statement的id与接口中的方法名相同</p></li><li><p>如果statement为select类型，必须添加一个 resultType 或 resultMap 属性，resultType的值必须为方法返回值中实体类型名</p></li><li><p>注册 mapper（SqlMapConfig.xml）</p><pre><code>&lt;mappers&gt;        &lt;!-- &lt;mapper resource=&quot;com/neu/mapper/DeptMapper.xml&quot; /&gt; --&gt;        &lt;!-- &lt;mapper class=&quot;com.neu.mapper.DeptMapper&quot;/&gt; --&gt;        &lt;package name=&quot;com.neu.mapper&quot;&gt;&lt;/package&gt;&lt;/mappers&gt;</code></pre></li></ul></li><li><p>改进后的测试代码</p><pre><code>package com.neu.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.neu.mapper.DeptMapper;import com.neu.po.Dept;public class DeptMapperTest &#123;    private DeptMapper deptMapper;    private SqlSession sqlSession;        @Before    public void setup() throws IOException &#123;        //读取SqlMapConfig.xml文件        InputStream resource = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //创建SqlSessionFactory        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource);        //得到Sqlsession对象（相当于数据库连接）        sqlSession = sqlSessionFactory.openSession();        //得到DeptMapper接口的实现类        deptMapper = sqlSession.getMapper(DeptMapper.class);    &#125;        @After    public void after() &#123;        //关闭sqlSession，把连接放回到连接池        sqlSession.close();    &#125;        @Test    public void testInsert() throws IOException &#123;        int n = deptMapper.insert(new Dept(66,&quot;hr&quot;,&quot;sy&quot;));                System.out.println(n);        //提交事务        sqlSession.commit();    &#125;        @Test    public void testUpdate() throws IOException &#123;        int n = deptMapper.update(new Dept(66,&quot;hr&quot;,&quot;nj&quot;));                System.out.println(n);        //提交事务        sqlSession.commit();    &#125;        @Test    public void testDelete() throws IOException &#123;        int n = deptMapper.delete(66);                System.out.println(n);        //提交事务        sqlSession.commit();    &#125;        @Test    public void testGetById() throws IOException &#123;        Dept dept = deptMapper.getById(10);                System.out.println(dept);    &#125;        @Test    public void testGetAll() throws IOException &#123;        List&lt;Dept&gt; list = deptMapper.getAll();                System.out.println(list);    &#125;&#125;</code></pre></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>实现 Emp 的增删改查方法</p><h2 id="使用log4j生成日志"><a href="#使用log4j生成日志" class="headerlink" title="使用log4j生成日志"></a>使用log4j生成日志</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>&lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>拷贝log4j.properties配置文件到resources下</p><pre><code># Global logging configuration#\u751F\u4EA7\u73AF\u5883\u914D\u7F6Einfo   ERRORlog4j.rootLogger=DEBUG,stdout# MyBatis logging configuration...log4j.logger.org.mybatis.example.BlogMapper=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><h2 id="多参数的处理"><a href="#多参数的处理" class="headerlink" title="多参数的处理"></a>多参数的处理</h2><ol><li><p>使用参数名：arg0、arg1…</p><pre><code>&lt;select id=&quot;search&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;        select * from dept where dname = #&#123;arg0&#125; and loc = #&#123;arg1&#125;&lt;/select&gt;</code></pre></li><li><p>使用参数名：param1、param2</p><pre><code>&lt;select id=&quot;search&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;        select * from dept where dname = #&#123;param1&#125; and loc = #&#123;param2&#125;&lt;/select&gt;</code></pre></li><li><p>使用@Param注解（推荐）</p><pre><code>接口：List&lt;Dept&gt; search(@Param(&quot;dname&quot;) String dname,@Param(&quot;loc&quot;) String loc);mapper:select * from dept where dname = #&#123;dname&#125; and loc = #&#123;loc&#125;</code></pre></li><li><p>使用实体类封装多个参数</p><pre><code>接口：List&lt;Dept&gt; search2(Dept dept);mapper:select * from dept where dname = #&#123;dname&#125; and loc = #&#123;loc&#125;测试代码：List&lt;Dept&gt; list = deptMapper.search2(new Dept(null,&quot;hr&quot;,&quot;sy&quot;));</code></pre></li><li><p>使用map集合，封装多个参数（很灵活）</p><pre><code>接口：List&lt;Dept&gt; search3(Map&lt;String, String&gt; map);mapper：select * from dept where dname = #&#123;dname&#125; and loc = #&#123;loc&#125;测试代码：Map map = new HashMap&lt;&gt;();map.put(&quot;dname&quot;, &quot;hr&quot;);map.put(&quot;loc&quot;, &quot;sy&quot;);        List&lt;Dept&gt; list = deptMapper.search3(map);</code></pre></li></ol><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><ol><li><p>#{}:使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用</p></li><li><p>${}:使用拼接字符串的方式生成sql语句，参数为列名的时候，可以使用</p><pre><code>接口：//根据参数列名来排序List&lt;Dept&gt; order(String columnName);mapper:select * from dept order by $&#123;columnName&#125;</code></pre></li><li><p>模糊查询</p><ul><li><p>使用#{}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like #&#123;dname&#125;测试代码：List&lt;Dept&gt; list = deptMapper.search4(&quot;%h%&quot;);</code></pre></li><li><p>使用${}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like &#39;%$&#123;dname&#125;%&#39;测试代码：List&lt;Dept&gt; list = deptMapper.search4(&quot;h&quot;);</code></pre></li></ul></li></ol><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><ol><li><p><code>&lt;if test=&quot;表达式&quot;&gt;sql片段&lt;/if&gt;</code></p><p>当表达式为true的时候，输出sql片段，否则不输出</p><pre><code>List&lt;Dept&gt; find(Dept dept);mapper:&lt;select id=&quot;find&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;        select * from dept         where 1 = 1        &lt;if test=&quot;deptno != null&quot;&gt;            and deptno = #&#123;deptno&#125;        &lt;/if&gt;        &lt;if test=&quot;dname != null&quot;&gt;            and dname = #&#123;dname&#125;        &lt;/if&gt;        &lt;if test=&quot;loc != null&quot;&gt;            and loc = #&#123;loc&#125;        &lt;/if&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;trim prefix=&quot;前缀&quot; prefixOverrides=&quot;被覆盖的前缀&quot; suffixOverrides=&quot;被覆盖的后缀&quot;&gt;&lt;/trim&gt;</code></p><p>prefix:如果trim标签中内容不为空串，则添加该前缀，如果内容为空串，则不添加</p><p>prefixOverrides：如果trim标签内容最前面的部分是该属性的内容，则覆盖掉</p><p>suffixOverrides：如果trim标签内容最后面的部分是该属性的内容，则覆盖掉</p><pre><code>&lt;select id=&quot;find&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;        select * from dept         &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;            &lt;if test=&quot;deptno != null&quot;&gt;                and deptno = #&#123;deptno&#125;            &lt;/if&gt;            &lt;if test=&quot;dname != null&quot;&gt;                and dname = #&#123;dname&#125;            &lt;/if&gt;            &lt;if test=&quot;loc != null&quot;&gt;                and loc = #&#123;loc&#125;            &lt;/if&gt;        &lt;/trim&gt;&lt;/select&gt;&lt;update id=&quot;update2&quot;&gt;        update dept         &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;            &lt;if test=&quot;dname != null&quot; &gt;                dname = #&#123;dname&#125;,            &lt;/if&gt;            &lt;if test=&quot;loc != null&quot; &gt;                loc = #&#123;loc&#125;            &lt;/if&gt;        &lt;/trim&gt;        where deptno = #&#123;deptno&#125;    &lt;/update&gt;</code></pre></li><li><p><code>&lt;where&gt;&lt;/where&gt;</code>，相当于：<code>&lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot;&gt;</code></p><pre><code>&lt;select id=&quot;find&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;        select * from dept         &lt;where&gt;            &lt;if test=&quot;deptno != null&quot;&gt;                and deptno = #&#123;deptno&#125;            &lt;/if&gt;            &lt;if test=&quot;dname != null&quot;&gt;                and dname = #&#123;dname&#125;            &lt;/if&gt;            &lt;if test=&quot;loc != null&quot;&gt;                and loc = #&#123;loc&#125;            &lt;/if&gt;        &lt;/where&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;set&gt;&lt;/set&gt;</code>相当于：<code>&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;</code></p><pre><code>&lt;update id=&quot;update2&quot;&gt;        update dept         &lt;set&gt;            &lt;if test=&quot;dname != null&quot; &gt;                dname = #&#123;dname&#125;,            &lt;/if&gt;            &lt;if test=&quot;loc != null&quot; &gt;                loc = #&#123;loc&#125;            &lt;/if&gt;        &lt;/set&gt;        where deptno = #&#123;deptno&#125;&lt;/update&gt;</code></pre></li><li><p><code>&lt;foreach&gt;&lt;/foreach&gt;</code>:用来处理集合和数组</p><p>collection：list|conllection|array</p><p>item：引用集合或数组中的当前遍历元素</p><p>separator:分隔符</p><pre><code>接口：int batchInsert(List&lt;Dept&gt; list);mapper:&lt;insert id=&quot;batchInsert&quot;&gt;        insert into dept values        &lt;foreach collection=&quot;list&quot; item=&quot;dept&quot; separator=&quot;,&quot;&gt;            (#&#123;dept.deptno&#125;,#&#123;dept.dname&#125;,#&#123;dept.loc&#125;)        &lt;/foreach&gt;&lt;/insert&gt;</code></pre><p>open:要添加的开始字符串</p><p>close：要添加的结束字符串</p><pre><code>接口：int batchDelete（int[] ids）;mapper:&lt;delete id=&quot;batchDelete&quot;&gt;        delete from dept where deptno in        &lt;foreach collection=&quot;array&quot; item=&quot;deptno&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;            #&#123;deptno&#125;        &lt;/foreach&gt;&lt;/delete&gt;</code></pre><p>练习：编写Emp的动态sql</p></li></ol><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ol><li><p>定义：用来定义可以重复使用的sql代码段，可以包含在其他sql语句中</p></li><li><p>使用：</p><ul><li><p>定义sql片段</p><pre><code>&lt;sql id=&quot;selectAll&quot;&gt;    select * from dept&lt;/sql&gt;</code></pre></li><li><p>引用sql片段</p><pre><code>&lt;include refid=&quot;selectAll&quot;&gt;&lt;/include&gt;</code></pre></li></ul></li></ol><h2 id="得到插入的主键值"><a href="#得到插入的主键值" class="headerlink" title="得到插入的主键值"></a>得到插入的主键值</h2><p><code>&lt;selectKey&gt;</code>:</p><ul><li><p>order:决定了查询语句执行的先后</p><ul><li>after：先执行插入语句，后执行查询主键的sql语句（mysql）</li><li>before：先执行查询（生成）主键值的语句，再执行插入语句（oracle）</li></ul></li><li><p>keyProperty：键属性名，查询得到的主键值放到形参的哪个属性中</p></li><li><p>resultType：查询的主键值的类型</p></li></ul><p>使用：</p><pre><code>&lt;insert id=&quot;insert&quot;&gt;        &lt;selectKey order=&quot;AFTER&quot; keyProperty=&quot;deptno&quot; resultType=&quot;int&quot;&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into dept values(null,#&#123;dname&#125;,#&#123;loc&#125;)&lt;/insert&gt;</code></pre><h2 id="查询返回简单数据类型"><a href="#查询返回简单数据类型" class="headerlink" title="查询返回简单数据类型"></a>查询返回简单数据类型</h2><p>简单数据类型：基本数据类型（8种）、对应的包装类、String</p><pre><code>接口：//根据部门编号得到部门名称String getDname(int deptno);mapper:&lt;select id=&quot;getDname&quot; resultType=&quot;string&quot;&gt;        select dname from dept where deptno = #&#123;deptno&#125;&lt;/select&gt;</code></pre><pre><code>//得到部门总数int count();&lt;select id=&quot;count&quot; resultType=&quot;int&quot;&gt;    select count(*) from dept&lt;/select&gt;</code></pre><p>返回boolean类型：如果查询的记录数&gt;0,返回：true，等于0，返回：false</p><pre><code>//判断名称为参数执行的部门是否存在boolean exist(String dname);&lt;select id=&quot;exist&quot; resultType=&quot;boolean&quot;&gt;    select count(*) from dept where dname = #&#123;dname&#125;&lt;/select&gt;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code>//pageNum:第几页，pageSize：每页最多有多少行List&lt;Dept&gt; getPaged(@Param(&quot;pageNum&quot;) int pageNum,@Param(&quot;pageSize&quot;) int pageSize);&lt;select id=&quot;getPaged&quot; resultType=&quot;com.neu.po.Dept&quot;&gt;    select * from dept     limit $&#123;(pageNum - 1) * pageSize&#125;,#&#123;pageSize&#125;&lt;/select&gt;</code></pre><h2 id="列名与属性名不一致"><a href="#列名与属性名不一致" class="headerlink" title="列名与属性名不一致"></a>列名与属性名不一致</h2><ol><li><p>在sql语句中，为列起别名，别名与属性名一致</p><pre><code>select deptno,dname dname2,loc from dept</code></pre></li><li><p>使用<code>&lt;resultMap&gt;</code>来进行映射</p><pre><code>&lt;resultMap type=&quot;com.neu.po.Dept&quot; id=&quot;basicMap&quot;&gt;        &lt;!-- &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;/&gt; --&gt;                &lt;result column=&quot;dname&quot; property=&quot;dname2&quot;/&gt;        &lt;!-- &lt;result column=&quot;loc&quot; property=&quot;loc&quot;/&gt; --&gt;&lt;/resultMap&gt;&lt;select id=&quot;getById&quot; resultMap=&quot;basicMap&quot;&gt;        &lt;include refid=&quot;selectAll&quot;&gt;&lt;/include&gt; where deptno = #&#123;no&#125;&lt;/select&gt;</code></pre><p><code>&lt;id&gt;</code>:用来映射标识列（数据库中的主键）</p><p><code>&lt;result&gt;</code>：用来映射普通的结果（非主键）</p><p>column：列名</p><p>property：属性名</p></li></ol><h2 id="实体关联"><a href="#实体关联" class="headerlink" title="实体关联"></a>实体关联</h2><p><code>&lt;association&gt;</code>:关联（实体），表示一对一的关系（emp&#x3D;》dept）</p><pre><code>//Emp实体类...Dept dept;</code></pre><pre><code>mapper:&lt;mapper namespace=&quot;com.neu.mapper.EmpMapper&quot;&gt;    &lt;resultMap type=&quot;com.neu.po.Emp&quot; id=&quot;basicMap&quot;&gt;        &lt;id column=&quot;empno&quot; property=&quot;empno&quot; &gt;&lt;/id&gt;        &lt;result column=&quot;ename&quot; property=&quot;ename&quot;/&gt;        &lt;result column=&quot;job&quot; property=&quot;job&quot;/&gt;        &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;/&gt;        &lt;result column=&quot;sal&quot; property=&quot;sal&quot;/&gt;        &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;/&gt;        &lt;result column=&quot;comm&quot; property=&quot;comm&quot;/&gt;                &lt;association property=&quot;dept&quot; javaType=&quot;com.neu.po.Dept&quot;&gt;            &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;/&gt;            &lt;result column=&quot;dname&quot; property=&quot;dname2&quot;/&gt;            &lt;result column=&quot;loc&quot; property=&quot;loc&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getById&quot; resultMap=&quot;basicMap&quot;&gt;        SELECT e.*,dname,loc         FROM dept d JOIN emp e         ON d.deptno = e.deptno        where empno = #&#123;empno&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><pre><code>&lt;resultMap type=&quot;com.neu.po.Dept&quot; id=&quot;basicMap&quot;&gt;        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot; /&gt;        &lt;result column=&quot;dname&quot; property=&quot;dname1&quot;/&gt;        &lt;result column=&quot;loc&quot; property=&quot;loc&quot;/&gt;                &lt;collection property=&quot;emps&quot; ofType=&quot;com.neu.po.Emp&quot;&gt;            &lt;id column=&quot;empno&quot; property=&quot;empno&quot;/&gt;            &lt;id column=&quot;ename&quot; property=&quot;ename&quot;/&gt;            &lt;id column=&quot;job&quot; property=&quot;job&quot;/&gt;            &lt;id column=&quot;hiredate&quot; property=&quot;hiredate&quot;/&gt;            &lt;id column=&quot;sal&quot; property=&quot;sal&quot;/&gt;            &lt;id column=&quot;comm&quot; property=&quot;comm&quot;/&gt;            &lt;id column=&quot;mgr&quot; property=&quot;mgr&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getById&quot; resultMap=&quot;basicMap&quot;&gt;        select d.dname,d.loc,e.* from dept d left join emp e         on d.deptno = e.deptno          WHERE e.deptno = #&#123;deptno&#125;    &lt;/select&gt;</code></pre><p>实体关联的第二种实现方法：再执行一次查询，根据已有的列查询出需要的对象</p><pre><code>&lt;mapper namespace=&quot;com.neu.mapper.EmpMapper&quot;&gt;    &lt;resultMap type=&quot;com.neu.po.Emp&quot; id=&quot;basicMap&quot;&gt;        &lt;!-- column的值为emp表中的列名 --&gt;        &lt;association property=&quot;dept&quot; column=&quot;deptno&quot; select=&quot;com.neu.mapper.DeptMapper.getById&quot;&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;getById&quot; resultMap=&quot;basicMap&quot;&gt;        SELECT * FROM emp where empno = #&#123;empno&#125;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="关联集合"><a href="#关联集合" class="headerlink" title="关联集合"></a>关联集合</h2><p><code>&lt;collection&gt;</code>:关联集合，表示一对多的关系（dept&#x3D;》List<emp>）</emp></p><pre><code>&lt;resultMap type=&quot;com.neu.po.Dept&quot; id=&quot;basicMap&quot;&gt;        &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;/&gt;                &lt;result column=&quot;dname&quot; property=&quot;dname2&quot;/&gt;        &lt;!-- &lt;result column=&quot;loc&quot; property=&quot;loc&quot;/&gt; --&gt;        &lt;!-- column列的值为：Dept表中的deptno --&gt;        &lt;collection property=&quot;emps&quot; column=&quot;deptno&quot; select=&quot;com.neu.mapper.EmpMapper.getByDeptno&quot;&gt;&lt;/collection&gt;&lt;/resultMap&gt;</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><pre><code>CREATE TABLE role(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL) CHARSET=utf8;INSERT INTO role VALUES(1,&#39;管理员&#39;);INSERT INTO role VALUES(2,&#39;普通用户&#39;);CREATE TABLE myuser(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL,    roleId INT NOT NULL) CHARSET=utf8;INSERT INTO myuser VALUES(1,&#39;tom&#39;,1);INSERT INTO myuser VALUES(2,&#39;scott&#39;,2);INSERT INTO myuser VALUES(3,&#39;marry&#39;,2);</code></pre><p>功能：</p><ol><li>查询所有用户的信息（包括用户的角色信息）</li><li>根据角色名称查询该角色的信息及该角色下的所有用户信息</li></ol><h2 id="使用注解替代Mapper文件"><a href="#使用注解替代Mapper文件" class="headerlink" title="使用注解替代Mapper文件"></a>使用注解替代Mapper文件</h2><ol><li><p>使用注解</p><pre><code>@Update(&quot;update dept set dname = #&#123;dname2&#125; ,loc = #&#123;loc&#125; where deptno = #&#123;deptno&#125;&quot;)int update(Dept dept);</code></pre></li><li><p>长sql语句的写法</p><pre><code>@Update(&quot;update dept set dname = #&#123;dname2&#125; ,loc = #&#123;loc&#125; &quot;+        &quot;where deptno = #&#123;deptno&#125;&quot;)int update(Dept dept);@Update(&#123;&quot;update dept set dname = #&#123;dname2&#125; ,loc = #&#123;loc&#125; &quot;,          &quot;where deptno = #&#123;deptno&#125;&quot;&#125;)int update(Dept dept);</code></pre></li><li><p>ResultMap（mybatis 3.5.4）</p><pre><code>@Select(&quot;select * from dept where deptno = #&#123;deptno&#125;&quot;)@Results(id = &quot;basicMap&quot;,value= &#123;            @Result(column = &quot;deptno&quot;,property = &quot;deptno&quot;,id = true),            @Result(column = &quot;dname&quot;,property = &quot;dname2&quot;,id = false),            @Result(column = &quot;loc&quot;,property = &quot;loc&quot;,id = false),            @Result(column = &quot;deptno&quot;,property = &quot;emps&quot;,many=@Many(select = &quot;com.neu.mapper.EmpMapper.getByDeptno&quot;))                &#125;)Dept getById(int deptno);</code></pre></li></ol><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ol><li><p>定义：在数据与对象进行mapping操作时，只有在真正使用该对象的时候，才进行mapping操作，以减少数据库开销，从而提高系统性能</p></li><li><p>默认情况下，mybatis没有开启延迟加载功能，如果要开启，需要配置SqlMapConfig.xml文件</p><pre><code>&lt;settings&gt;        &lt;!-- 开启延迟加载 --&gt;        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;        &lt;!-- 取消积极加载 --&gt;        &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;&lt;/settings&gt;</code></pre></li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li><p>定义：是一种“以空间换时间”的设计理念，利用内存或硬盘空间来提高数据检索速度的有效手段之一。</p></li><li><p>一级缓存：默认开启，把数据缓存到当前会话中（SqlSession）</p><pre><code>@Testpublic void testGetById() throws IOException &#123;    Dept dept = deptMapper.getById(10);    System.out.println(dept.getDname2());    dept = deptMapper.getById(10);    System.out.println(dept.getDname2());&#125;</code></pre></li><li><p>二级缓存：默认没有开启，需要手工开启，修改SqlMapConfig.xml文件，把数据缓存到SqlSessionFactory中</p><pre><code>&lt;!-- 开启二级缓存 --&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code></pre><p>在需要缓存的mapper文件中：</p><pre><code>&lt;cache&gt;&lt;/cache&gt;</code></pre><p>注意：缓存对象要实现可序列化接口（Serializable）</p></li></ol><h2 id="MBG"><a href="#MBG" class="headerlink" title="MBG"></a>MBG</h2><ol><li><p>定义：是一个MyBatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;  &lt;context id=&quot;context1&quot; targetRuntime=&quot;Mybatis3Simple&quot;&gt;    &lt;jdbcConnection connectionURL=&quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf8&quot; driverClass=&quot;com.mysql.jdbc.Driver&quot; password=&quot;root&quot; userId=&quot;root&quot; /&gt;    &lt;javaModelGenerator targetPackage=&quot;com.neu.po&quot; targetProject=&quot;mybatisdemo2&quot; /&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;mybatisdemo2&quot;&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;mybatisdemo2&quot; type=&quot;XMLMAPPER&quot; /&gt;           &lt;table schema=&quot;root&quot; tableName=&quot;dept&quot;&gt;      &lt;!-- &lt;columnOverride column=&quot;???&quot; property=&quot;???&quot; /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li></ul></li></ol><p>排序：</p><pre><code>example.setOrderByClause(&quot;ename desc&quot;);</code></pre><h2 id="Example练习"><a href="#Example练习" class="headerlink" title="Example练习"></a>Example练习</h2><ol><li>查询员工姓名等于“smith”并且sal大于等于3000的员工信息</li><li>查询员工编号为：7783和7876的员工信息</li><li>查询奖金（comm）不是null的所有员工信息</li><li>更新员工编号为7783的薪水，薪水增加200元</li><li>查询工资小于2000元或部门编号为10的所有员工信息</li><li>根据部门名称查询该部门所有员工（组合DeptExample和EmpExample查询）</li></ol><h2 id="Idea-中使用-Free-mybatis-plugin"><a href="#Idea-中使用-Free-mybatis-plugin" class="headerlink" title="Idea 中使用 Free mybatis plugin"></a>Idea 中使用 Free mybatis plugin</h2><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><ol><li><p>在idea中连接数据库</p><ul><li>添加数据源，选mysql</li></ul> <img src="/2022/052313919/1.jpg" class><ul><li><p>配置数据库连接参数</p><img src="/2022/052313919/2.jpg" class></li><li><p>在Advanced 中 配置 serverTimezone：Asia&#x2F;Shanghai</p><img src="/2022/052313919/3.jpg" class></li><li><p>测试连接</p><img src="/2022/052313919/4.jpg" class></li><li><p>查看数据表</p><img src="/2022/052313919/5.jpg" class></li></ul></li></ol><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><ol><li><p>选择表</p><img src="/2022/052313919/6.jpg" class></li><li><p>输入参数</p><img src="/2022/052313919/7.jpg" class></li></ol><h2 id="Idea环境中pom-xml"><a href="#Idea环境中pom-xml" class="headerlink" title="Idea环境中pom.xml"></a>Idea环境中pom.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo3&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;!--&lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;--&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--&lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;--&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="Idea中代码生成"><a href="#Idea中代码生成" class="headerlink" title="Idea中代码生成"></a>Idea中代码生成</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>创建 maven 项目，导入依赖和插件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;mbgdemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;--&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--mybatis-generator插件--&gt;            &lt;plugin&gt;                &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>在 src&#x2F;main&#x2F;resources&#x2F; 创建文件：generatorConfig.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;  &lt;classPathEntry location=&quot;D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar&quot;/&gt;  &lt;context id=&quot;context1&quot; targetRuntime=&quot;Mybatis3&quot;&gt;    &lt;jdbcConnection         connectionURL=&quot;jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai&quot;         driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;         password=&quot;root&quot;         userId=&quot;root&quot; &gt;        &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;    &lt;/jdbcConnection&gt;    &lt;!-- 实体类 --&gt;    &lt;javaModelGenerator targetPackage=&quot;com.neu.po&quot; targetProject=&quot;src/main/java&quot; /&gt;    &lt;!-- 生成Mapper.xml --&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;&lt;/sqlMapGenerator&gt;    &lt;!-- java的Mapper接口 --&gt;    &lt;javaClientGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot; /&gt;            &lt;table schema=&quot;root&quot; tableName=&quot;role&quot;&gt;        &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;mysql&quot; identity=&quot;true&quot;/&gt;          &lt;/table&gt;      &lt;!--      &lt;table schema=&quot;root&quot; tableName=&quot;user&quot;&gt;          &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;mysql&quot; identity=&quot;true&quot;/&gt;          &lt;columnOverride column=&quot;useType&quot; property=&quot;role&quot; javaType=&quot;Role&quot; /&gt;      &lt;/table&gt;      --&gt;        &lt;!--&lt;table schema=&quot;root&quot; tableName=&quot;Department&quot; domainObjectName=&quot;Department&quot;&gt;        &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;mysql&quot; identity=&quot;true&quot;/&gt;                  &lt;columnOverride column=&quot;DeptCode&quot; property=&quot;deptCode&quot;&gt;&lt;/columnOverride&gt;        &lt;columnOverride column=&quot;DeptName&quot; property=&quot;deptName&quot;&gt;&lt;/columnOverride&gt;        &lt;columnOverride column=&quot;DeptCategoryID&quot; property=&quot;deptCategory&quot; javaType=&quot;ConstantItem&quot;&gt;&lt;/columnOverride&gt;        &lt;columnOverride column=&quot;DeptType&quot; property=&quot;deptType&quot; javaType=&quot;ConstantItem&quot;&gt;&lt;/columnOverride&gt;        &lt;columnOverride column=&quot;DelMark&quot; property=&quot;delMark&quot;&gt;&lt;/columnOverride&gt;    &lt;/table&gt;--&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>生成代码</p><img src="/2022/052313919/8.jpg" class></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>使用 <code>MyBatisCodeHelpPro</code> 插件，生成 xml配置文件</p><img src="/2022/052313919/9.jpg" class></li><li><p>修改 xml 配置文件，内容同方法一一样</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration    PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;    &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry location=&quot;D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar&quot;/&gt;    &lt;context id=&quot;Mybatis3Context&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;jdbcConnection                connectionURL=&quot;jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai&quot;                driverClass=&quot;com.mysql.cj.jdbc.Driver&quot;                password=&quot;root&quot;                userId=&quot;root&quot; &gt;            &lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot;/&gt;        &lt;/jdbcConnection&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;javaModelGenerator targetPackage=&quot;com.neu.po&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;table schema=&quot;root&quot; tableName=&quot;role&quot;&gt;            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;mysql&quot; identity=&quot;true&quot;/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>修改 pom.xml文件，添加 maven 插件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;mgb2&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--mybatis-generator插件--&gt;            &lt;plugin&gt;                &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/MybatisGenerator.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>生成代码（同方法一）</p></li></ol><h1 id="Idea中生成Mapper"><a href="#Idea中生成Mapper" class="headerlink" title="Idea中生成Mapper"></a>Idea中生成Mapper</h1><ol><li><p>在 mapper 接口上 alt + enter</p><img src="/2022/052313919/10.jpg" class></li><li><p>选择：Generate mapper of xml</p></li><li><p>选择mapper 位置</p><img src="/2022/052313919/11.jpg" class></li></ol><h1 id="MyBatis中TypeHandler"><a href="#MyBatis中TypeHandler" class="headerlink" title="MyBatis中TypeHandler"></a>MyBatis中TypeHandler</h1><p>在Mybatis中可以定义一个TypeHandler类型，通过它可以实现Java类型跟数据库类型的相互转换。</p><p>需求：把java实体类中的String[],转换为数据库中的varchar类型（例如保存用户的多个爱好）　</p><ol><li><p>数据库</p><pre><code>CREATE TABLE myuser(    id INT PRIMARY KEY AUTO_INCREMENT,    username VARCHAR(30) NOT NULL,    PASSWORD VARCHAR(30) NOT NULL,    interests VARCHAR(100) )</code></pre></li><li><p>实体类</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class MyUser &#123;    private int id;      private String username;      private String password;      private String[] interests;&#125;</code></pre></li><li><p>类型转换器</p><pre><code>package com.neu.util;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Date;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedJdbcTypes;import org.apache.ibatis.type.MappedTypes;@MappedJdbcTypes(JdbcType.VARCHAR)@MappedTypes(String[].class)public class StringArrayTypeHandler extends BaseTypeHandler&lt;String[]&gt; &#123;    private String[] getStringArray(String columnValue) &#123;       if (columnValue == null)           return null;       return columnValue.split(&quot;,&quot;);    &#125;         @Override    public String[] getNullableResult(ResultSet rs, String columnName)           throws SQLException &#123;       return getStringArray(rs.getString(columnName));    &#125;     @Override    public String[] getNullableResult(ResultSet rs, int columnIndex)           throws SQLException &#123;       return this.getStringArray(rs.getString(columnIndex));    &#125;     @Override    public String[] getNullableResult(CallableStatement cs, int columnIndex)           throws SQLException &#123;       return this.getStringArray(cs.getString(columnIndex));    &#125;     @Override    public void setNonNullParameter(PreparedStatement ps, int i,           String[] parameter, JdbcType jdbcType) throws SQLException &#123;       //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了       StringBuffer result = new StringBuffer();       for (String value : parameter)           result.append(value).append(&quot;,&quot;);       result.deleteCharAt(result.length()-1);       ps.setString(i, result.toString());    &#125;       &#125;</code></pre><p>1.@MappedJdbcTypes定义是JdbcType类型，必须要是枚举类org.apache.ibatis.type.JdbcType所枚举的数据类型<br>2.@MappedTypes定义的是JavaType的数据类型，描述哪些Java类型可被拦截。<br>3.在我们启用了自定义的这个TypeHandler之后，数据的读写都会被这个类所过滤<br>4.在setNonNullParameter方法中，重新定义要写往数据库的数据。<br>5.在另外三个方法中我们将从数据库读出的数据类型进行转换。</p></li><li><p>注册 TypeHandler（SqlMapConfig.xml）</p><pre><code>&lt;typeHandlers&gt;   &lt;package name=&quot;com.neu.util&quot;/&gt;&lt;/typeHandlers&gt;或&lt;typeHandlers&gt;   &lt;typeHandler handler=&quot;com.neu.util.StringArrayTypeHandler&quot;/&gt;&lt;/typeHandlers&gt;</code></pre></li><li><p>接口</p><pre><code>public interface MyUserMapper &#123;    MyUser getById(int id);        int insert(MyUser user);        int update(MyUser user);&#125;</code></pre></li><li><p>mapper（可以不配置 typeHandler 属性，由mybatis自动选择）</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.neu.mapper.MyUserMapper&quot;&gt;    &lt;resultMap type=&quot;com.neu.po.MyUser&quot; id=&quot;basicMap&quot;&gt;        &lt;result column=&quot;interests&quot; property=&quot;interests&quot; typeHandler=&quot;com.neu.util.StringArrayTypeHandler&quot; /&gt;    &lt;/resultMap&gt;    &lt;!-- 可以使用 resultMap 进行手工映射 --&gt;    &lt;select id=&quot;getById&quot; resultType=&quot;com.neu.po.MyUser&quot;&gt;        select * from myuser where id = #&#123;id&#125;    &lt;/select&gt;        &lt;insert id=&quot;insert&quot;&gt;        insert into myuser values(            #&#123;id&#125;,            #&#123;username,javaType=String,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.StringTypeHandler&#125;,            #&#123;password&#125;,#&#123;interests,typeHandler=com.neu.util.StringArrayTypeHandler&#125;        )    &lt;/insert&gt;        &lt;update id=&quot;update&quot;&gt;        update myuser set username = #&#123;username&#125;,password= #&#123;password&#125;,interests=#&#123;interests&#125;        where id = #&#123;id&#125;    &lt;/update&gt;&lt;/mapper&gt;</code></pre></li><li><p>测试代码</p><pre><code>public class MyUserMapperTest &#123;    private SqlSession session;    private MyUserMapper myuserMapper;        @Before    public void setup() throws IOException &#123;        //ctrl+2 L        //读取配置文件        InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);        //创建SqlSessionFactory        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //创建连接，相当于Connection        session = sessionFactory.openSession();        //返回DeptMapper接口的实现类        myuserMapper = session.getMapper(MyUserMapper.class);    &#125;        @After    public void after() &#123;        //关闭会话        session.close();    &#125;    @Test    public void testInsert() &#123;        int n = myuserMapper.insert(new MyUser(33,&quot;tom&quot;,&quot;111&quot;,new String[]&#123;&quot;游泳&quot;,&quot;爬山&quot;&#125;));                System.out.println(n);                session.commit();    &#125;        @Test    public void testGetById() &#123;        MyUser user = myuserMapper.getById(10);        System.out.println(user);    &#125;        @Test    public void testUpdate() &#123;        int n = myuserMapper.update(new MyUser(33,&quot;marry&quot;,&quot;222&quot;,new String[]&#123;&quot;游泳&quot;,&quot;爬山&quot;,&quot;钓鱼&quot;&#125;));                System.out.println(n);                session.commit();    &#125;&#125;</code></pre></li></ol><p>mybatis中 在  <code>TypeHandlerRegistry</code> 注册内置拦截器</p><pre><code>public TypeHandlerRegistry(Configuration configuration) &#123;    this.unknownTypeHandler = new UnknownTypeHandler(configuration);    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());    register(Byte.class, new ByteTypeHandler());    register(byte.class, new ByteTypeHandler());    register(JdbcType.TINYINT, new ByteTypeHandler());    register(Short.class, new ShortTypeHandler());    register(short.class, new ShortTypeHandler());    register(JdbcType.SMALLINT, new ShortTypeHandler());    register(Integer.class, new IntegerTypeHandler());    register(int.class, new IntegerTypeHandler());    register(JdbcType.INTEGER, new IntegerTypeHandler());    register(Long.class, new LongTypeHandler());    register(long.class, new LongTypeHandler());    register(Float.class, new FloatTypeHandler());    register(float.class, new FloatTypeHandler());    register(JdbcType.FLOAT, new FloatTypeHandler());    register(Double.class, new DoubleTypeHandler());    register(double.class, new DoubleTypeHandler());    register(JdbcType.DOUBLE, new DoubleTypeHandler());    register(Reader.class, new ClobReaderTypeHandler());    register(String.class, new StringTypeHandler());    register(String.class, JdbcType.CHAR, new StringTypeHandler());    register(String.class, JdbcType.CLOB, new ClobTypeHandler());    register(String.class, JdbcType.VARCHAR, new StringTypeHandler());    register(String.class, JdbcType.LONGVARCHAR, new StringTypeHandler());    register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCLOB, new NClobTypeHandler());    register(JdbcType.CHAR, new StringTypeHandler());    register(JdbcType.VARCHAR, new StringTypeHandler());    register(JdbcType.CLOB, new ClobTypeHandler());    register(JdbcType.LONGVARCHAR, new StringTypeHandler());    register(JdbcType.NVARCHAR, new NStringTypeHandler());    register(JdbcType.NCHAR, new NStringTypeHandler());    register(JdbcType.NCLOB, new NClobTypeHandler());    register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler());    register(JdbcType.ARRAY, new ArrayTypeHandler());    register(BigInteger.class, new BigIntegerTypeHandler());    register(JdbcType.BIGINT, new LongTypeHandler());    register(BigDecimal.class, new BigDecimalTypeHandler());    register(JdbcType.REAL, new BigDecimalTypeHandler());    register(JdbcType.DECIMAL, new BigDecimalTypeHandler());    register(JdbcType.NUMERIC, new BigDecimalTypeHandler());    register(InputStream.class, new BlobInputStreamTypeHandler());    register(Byte[].class, new ByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.LONGVARBINARY, new BlobByteObjectArrayTypeHandler());    register(byte[].class, new ByteArrayTypeHandler());    register(byte[].class, JdbcType.BLOB, new BlobTypeHandler());    register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.BLOB, new BlobTypeHandler());    register(Object.class, unknownTypeHandler);    register(Object.class, JdbcType.OTHER, unknownTypeHandler);    register(JdbcType.OTHER, unknownTypeHandler);    register(Date.class, new DateTypeHandler());    register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());    register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());    register(JdbcType.TIMESTAMP, new DateTypeHandler());    register(JdbcType.DATE, new DateOnlyTypeHandler());    register(JdbcType.TIME, new TimeOnlyTypeHandler());    register(java.sql.Date.class, new SqlDateTypeHandler());    register(java.sql.Time.class, new SqlTimeTypeHandler());    register(java.sql.Timestamp.class, new SqlTimestampTypeHandler());    register(String.class, JdbcType.SQLXML, new SqlxmlTypeHandler());    register(Instant.class, new InstantTypeHandler());    register(LocalDateTime.class, new LocalDateTimeTypeHandler());    register(LocalDate.class, new LocalDateTypeHandler());    register(LocalTime.class, new LocalTimeTypeHandler());    register(OffsetDateTime.class, new OffsetDateTimeTypeHandler());    register(OffsetTime.class, new OffsetTimeTypeHandler());    register(ZonedDateTime.class, new ZonedDateTimeTypeHandler());    register(Month.class, new MonthTypeHandler());    register(Year.class, new YearTypeHandler());    register(YearMonth.class, new YearMonthTypeHandler());    register(JapaneseDate.class, new JapaneseDateTypeHandler());    // issue #273    register(Character.class, new CharacterTypeHandler());    register(char.class, new CharacterTypeHandler());  &#125;</code></pre><p>mybatis 类型别名 注册：TypeAliasRegistry</p><pre><code>说明：https://blog.csdn.net/lgl782519197/article/details/109066243</code></pre><pre><code>public TypeAliasRegistry() &#123;    registerAlias(&quot;string&quot;, String.class);    registerAlias(&quot;byte&quot;, Byte.class);    registerAlias(&quot;long&quot;, Long.class);    registerAlias(&quot;short&quot;, Short.class);    registerAlias(&quot;int&quot;, Integer.class);    registerAlias(&quot;integer&quot;, Integer.class);    registerAlias(&quot;double&quot;, Double.class);    registerAlias(&quot;float&quot;, Float.class);    registerAlias(&quot;boolean&quot;, Boolean.class);    registerAlias(&quot;byte[]&quot;, Byte[].class);    registerAlias(&quot;long[]&quot;, Long[].class);    registerAlias(&quot;short[]&quot;, Short[].class);    registerAlias(&quot;int[]&quot;, Integer[].class);    registerAlias(&quot;integer[]&quot;, Integer[].class);    registerAlias(&quot;double[]&quot;, Double[].class);    registerAlias(&quot;float[]&quot;, Float[].class);    registerAlias(&quot;boolean[]&quot;, Boolean[].class);    registerAlias(&quot;_byte&quot;, byte.class);    registerAlias(&quot;_long&quot;, long.class);    registerAlias(&quot;_short&quot;, short.class);    registerAlias(&quot;_int&quot;, int.class);    registerAlias(&quot;_integer&quot;, int.class);    registerAlias(&quot;_double&quot;, double.class);    registerAlias(&quot;_float&quot;, float.class);    registerAlias(&quot;_boolean&quot;, boolean.class);    registerAlias(&quot;_byte[]&quot;, byte[].class);    registerAlias(&quot;_long[]&quot;, long[].class);    registerAlias(&quot;_short[]&quot;, short[].class);    registerAlias(&quot;_int[]&quot;, int[].class);    registerAlias(&quot;_integer[]&quot;, int[].class);    registerAlias(&quot;_double[]&quot;, double[].class);    registerAlias(&quot;_float[]&quot;, float[].class);    registerAlias(&quot;_boolean[]&quot;, boolean[].class);    registerAlias(&quot;date&quot;, Date.class);    registerAlias(&quot;decimal&quot;, BigDecimal.class);    registerAlias(&quot;bigdecimal&quot;, BigDecimal.class);    registerAlias(&quot;biginteger&quot;, BigInteger.class);    registerAlias(&quot;object&quot;, Object.class);    registerAlias(&quot;date[]&quot;, Date[].class);    registerAlias(&quot;decimal[]&quot;, BigDecimal[].class);    registerAlias(&quot;bigdecimal[]&quot;, BigDecimal[].class);    registerAlias(&quot;biginteger[]&quot;, BigInteger[].class);    registerAlias(&quot;object[]&quot;, Object[].class);    registerAlias(&quot;map&quot;, Map.class);    registerAlias(&quot;hashmap&quot;, HashMap.class);    registerAlias(&quot;list&quot;, List.class);    registerAlias(&quot;arraylist&quot;, ArrayList.class);    registerAlias(&quot;collection&quot;, Collection.class);    registerAlias(&quot;iterator&quot;, Iterator.class);    registerAlias(&quot;ResultSet&quot;, ResultSet.class);  &#125;</code></pre><h1 id="使用注解替代mapper文件"><a href="#使用注解替代mapper文件" class="headerlink" title="使用注解替代mapper文件"></a>使用注解替代mapper文件</h1><ol><li><p>使用注解</p><pre><code>@Select(&quot;select * from dept&quot;)List&lt;Dept&gt; getAll();@Insert(&quot;insert into dept values(#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;)&quot;)int insert(Dept dept);</code></pre></li><li><p>长 SQL 语句的写法</p><pre><code>@Select(&quot;select * from dept &quot;+        &quot;where deptno = #&#123;deptno&#125;&quot;)Dept getById(int deptno);@Select(&#123;&quot;select * from dept &quot;,         &quot;where deptno = #&#123;deptno&#125;&quot;&#125;)Dept getById(int deptno);</code></pre></li><li><p>ResultMap</p><ul><li><p>直接在接口方法上添加@Results注解</p><pre><code>//mybatis的版本号：3.5.4，支持@Results中的id属性@Select(&#123;&quot;select * from dept &quot;,            &quot;where deptno = #&#123;deptno&#125;&quot;&#125;)    @Results(id=&quot;basicMap&quot;, value= &#123;            @Result(column = &quot;deptno&quot;,property = &quot;deptno&quot;,id = true),            @Result(column = &quot;dname&quot;,property = &quot;dname&quot;),            @Result(column = &quot;loc&quot;,property = &quot;loc&quot;),            @Result(property = &quot;emps&quot;,column = &quot;deptno&quot;,many = @Many(select = &quot;com.neu.mapper.EmpMapper.getByDeptno&quot;))    &#125;)    Dept getById(int deptno);        @Select(&quot;select * from emp where empno = #&#123;empno&#125;&quot;)    @Results(value= &#123;            @Result(                    property = &quot;dept&quot;,                    column = &quot;deptno&quot;,                    one = @One(select = &quot;com.neu.mapper.DeptMapper.getById&quot;            ))    &#125;)    Emp getById(int empno);</code></pre></li><li><p>使用@ResultMap注解，引用@Results</p><pre><code>//basicMap可以是@Results的id或对应mapper.xml文件中&lt;resultMap&gt;的id属性@Select(&quot;select * from dept&quot;)@ResultMap(&quot;basicMap&quot;)List&lt;Dept&gt; getAll();</code></pre></li></ul><ol start="4"><li><p>得到自增主键值</p><pre><code>@Insert(&quot;insert into dept values(null,#&#123;dname&#125;,#&#123;loc&#125;)&quot;)    @SelectKey(        statement = &quot;select last_insert_id()&quot;,        resultType = Integer.class,        keyProperty = &quot;deptno&quot;,        before = false    )    int insert(Dept dept);</code></pre></li></ol></li></ol><h1 id="查询补充"><a href="#查询补充" class="headerlink" title="查询补充"></a>查询补充</h1><pre><code>//接口List&lt;Map&lt;String,Object&gt;&gt; report();//mapper&lt;select id=&quot;report&quot; resultType=&quot;map&quot;&gt;        select ename,job,hiredate,dname,loc        from emp e join dept d        on e.deptno = d.deptno&lt;/select&gt;</code></pre><h1 id="MBG-Mybatis-Generator"><a href="#MBG-Mybatis-Generator" class="headerlink" title="MBG(Mybatis Generator)"></a>MBG(Mybatis Generator)</h1><ol><li><p>定义：是一个Mybatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p></li><li><p>修改模板：</p><ul><li><p>改为使用“简单模板”</p><pre><code>&lt;context id=&quot;context1&quot; targetRuntime=&quot;Mybatis3Simple&quot;&gt;</code></pre></li><li><p>使用默认模板</p><pre><code>&lt;context id=&quot;context1&quot; &gt;</code></pre></li></ul></li><li><p>修改配置</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;  &lt;context id=&quot;context1&quot; targetRuntime=&quot;Mybatis3Simple&quot;&gt;    &lt;jdbcConnection connectionURL=&quot;jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;amp;characterEncoding=utf8&quot; driverClass=&quot;com.mysql.jdbc.Driver&quot; password=&quot;root&quot; userId=&quot;root&quot; /&gt;    &lt;javaModelGenerator targetPackage=&quot;com.neu.po&quot; targetProject=&quot;mybatismbg&quot; /&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;mybatismbg&quot;&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage=&quot;com.neu.mapper&quot; targetProject=&quot;mybatismbg&quot; type=&quot;XMLMAPPER&quot; /&gt;        &lt;table schema=&quot;root&quot; tableName=&quot;dept&quot;&gt;      &lt;!-- &lt;columnOverride column=&quot;???&quot; property=&quot;???&quot; /&gt; --&gt;    &lt;/table&gt;    &lt;table schema=&quot;root&quot; tableName=&quot;emp&quot;&gt;      &lt;!-- &lt;columnOverride column=&quot;???&quot; property=&quot;???&quot; /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>生成代码（配置文件右键）</p></li><li><p>如果有实体关联，修改xml配置文件</p><ul><li><p>修改生成xml配置文件</p><pre><code>//generatorConfig.xml&lt;table schema=&quot;root&quot; tableName=&quot;emp&quot;&gt;    &lt;columnOverride column=&quot;deptno&quot; property=&quot;dept&quot; javaType=&quot;com.neu.po.Dept&quot; /&gt;&lt;/table&gt;</code></pre></li><li><p>修改生成的mapper文件</p><pre><code>&lt;!-- &lt;result column=&quot;deptno&quot; jdbcType=&quot;INTEGER&quot; property=&quot;dept&quot; /&gt; --&gt;    &lt;association property=&quot;dept&quot; column=&quot;deptno&quot; select=&quot;com.neu.mapper.DeptMapper.selectByPrimaryKey&quot;&gt;&lt;/association&gt;</code></pre><p>修改 dept &#x3D;》 dept.deptno(注意：别修改列名)</p></li></ul></li></ul><ol start="3"><li><p>使用Mybatis3模板</p><ul><li><p>生成的接口中有11个方法</p><ul><li>方法名中包含 primaryKey：根据主键进行相应的操作</li><li>方法名中包含example：根据Example生成where语句来操作</li><li>方法名中包含Selective：对部分列进行有选择操作（动态sql）</li></ul></li><li><p>Example的作用：生成where语句</p><pre><code>@Test    public void testGetByExample() throws IOException &#123;        EmpExample example = new EmpExample();//example.or().andEnameEqualTo(&quot;SMITH&quot;).andSalGreaterThan(new BigDecimal(700));//example.or().andEnameLike(&quot;%S%&quot;);//example.or().andSalBetween(new BigDecimal(1500), new BigDecimal(2000));//List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//list.add(7369);//list.add(7499);////example.or().andEmpnoIn(list);                Dept dept = new Dept();        dept.setDeptno(10);                example.or().andDeptEqualTo(dept);                List&lt;Emp&gt; list2 = empMapper.selectByExample(example);        System.out.println(list2);    &#125;    //修改EmpExamplepublic Criteria andDeptEqualTo(Dept value) &#123;   addCriterion(&quot;deptno =&quot;, value.getDeptno(), &quot;dept&quot;);   return (Criteria) this;&#125;</code></pre></li></ul><p>练习：</p><ol><li>生成Role和MyUser实体类、接口、mapper文件</li><li>根据角色Id查询该角色的所有用户信息</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统输入/输出管理</title>
      <link href="/2022/052237860.html"/>
      <url>/2022/052237860.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入-输出管理管理"><a href="#输入-输出管理管理" class="headerlink" title="输入-输出管理管理"></a>输入-输出管理管理</h1><img src="/2022/052237860/1.jpg" class>  <h2 id="IO管理概述"><a href="#IO管理概述" class="headerlink" title="IO管理概述"></a>IO管理概述</h2><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备</p><ul><li><p>按照使用特性分为以下类型：<br>人机交互类外部设备：打印机，显示器，键鼠等。数据交换速度慢，通常以字节为单位数据交换。<br>存储设备：磁盘，光盘等。用于数据交换，速度快，通常以多字节组成的块为单位数据交换。<br>网络通信设备：网络接口等。速度介于前两者之间，用于远程设备通信。<br>除了以上分类方式，还可以按照以下方法分类：</p></li><li><p>按传输速率分类：<br>①低速设备：键鼠等。<br>②中速：打印机等。<br>③高速：磁带机，光盘机，磁盘机等。  </p></li><li><p>按信息交换的单位分类：<br>①块设备：属于有结构设备，如磁盘，基本特征就是传输速率高，可寻址即随机读写。<br>②字符设备：用于IO的设备，传输基本单位是字符，无结构类型，如打印机等，基本特征是传输速率低，不可寻址，IO采用中断驱动方式。  </p><h3 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h3><img src="/2022/052237860/101.jpg" class>   <img src="/2022/052237860/102.jpg" class>   <img src="/2022/052237860/103.jpg" class>   <img src="/2022/052237860/104.jpg" class>   <h3 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h3><p>外围设备和内存之间IO控制方式有4种。  </p></li><li><p>程序直接控制方式：<br>计算机从外部设备读取数据到存储区，每次读取一个字的数据，每个字CPU都需要对于外设状态进行循环检查(轮询！！！)，由于CPU的高速性和IO设备的低速性，使得CPU绝大多数时间等待IO设备完成循环测试。该方法易于实现，但CPU利用率低。  </p><img src="/2022/052237860/105.jpg" class>   <img src="/2022/052237860/106.jpg" class>   </li><li><p>中断驱动方式：<br>允许IO设备主动打断CPU运行并请求服务，从而“解放”CPU，使其向IO控制器发送读指令后可以继续做其他有用工作。从IO设备角度看，IO设备从CPU接收一个读指令，从外围设备读取数据，一旦数据读入该IO控制器的数据寄存器，便使得通过控制线给CPU发出一个中断信号，表示数据已经准备好等待CPU请求数据，然后收到CPU发出的取数据请求之后，把数据放到数据总线上，传到CPU的寄存器中。而CPU角度看，CPU发出读指令，保存当前程序上下文，转去执行其他程序，接到IO设备中断时，CPU保存其他程序的上下文，转去执行中断处理程序，这时CPU从IO控制器读取一个字的数据传送到寄存器。中断驱动的方法比直接控制有效，但由于数据的每个字在存储器与IO控制器之间的传输都必须经过CPU，导致CPU时间依然被大量浪费。  </p><img src="/2022/052237860/107.jpg" class>   </li><li><p>DMA方式:<br>在IO设备与内存之间开辟直接的数据交换通路，彻底解放CPU。特点如下：①基本单位是数据块。②所传送的数据是从设备直接送入内存的（或相反）。③仅在数据块传送的开始和结束，才需要CPU的干预，整块数据的传送时在DMA控制器的控制下完成的。<br>工作过程就是：CPU接到IO设备请求，给IO设备控制器发送一条指令，启动DMA控制器，然后继续其他工作。之后CPU把控制操作委托给DMA控制器，其直接与存储器交互，传送整个数据块，每次传送一个字，过程不需要CPU参与，完成之后DMA控制器发送一个中断信号给CPU。  </p><img src="/2022/052237860/2.jpg" class>  <img src="/2022/052237860/108.jpg" class>   <img src="/2022/052237860/109.jpg" class>   <img src="/2022/052237860/110.jpg" class>   </li><li><p>通道控制方式：<br>IO通道是专门负责IO的处理机，是DMA的发展，进一步减少CPU干预。CPU只需要向IO通道发送一条IO指令，给出其所要执行的通道程序的首地址和要访问的IO设备，通道程序即可执行CPU指定任务，数据传送结束时间向CPU发中断请求。<br>IO通道与一般处理机区别是：通道指令类型单一，没有自己内存，通道执行的程序放在主机内存中。<br>IO通道和DMA区别是：DMA方式需要CPU来控制传输数据块大小，传输内存位置，而通道中这些信息由通道控制的。  </p><img src="/2022/052237860/3.jpg" class>   <img src="/2022/052237860/111.jpg" class>   <img src="/2022/052237860/112.jpg" class>   </li><li><p>总结：  </p><img src="/2022/052237860/113.jpg" class>   <h3 id="IO子系统的层次结构"><a href="#IO子系统的层次结构" class="headerlink" title="IO子系统的层次结构"></a>IO子系统的层次结构</h3><p>IO软件涉及面很广，跟硬件，用户都由直接交互，与进程管理，存储管理等都有联系，他们都可能需要IO软件来实现IO操作。IO软件普遍采用层次式结构，每层利用下层服务，完成某些功能，并屏蔽细节向上层提供服务。  </p><img src="/2022/052237860/4.jpg" class>   </li><li><p>用户层IO软件：用户交互的接口，用户直接调用。  </p></li><li><p>设备独立性软件：用户程序与设备驱动器的统一接口，设备命令，设备保护，设备分配和释放等。设备独立性也称无关性，使得应用程序独立于使用物理设备，为实现设备独立性而引入了逻辑设备和物理设备这两个概念。应用程序中，使用逻辑设备名来请求某类设备，实际执行时必须把逻辑设备名改为物理设备名使用。  </p></li><li><p>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。 </p></li><li><p>中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并且恢复被中断进程的现场，返回到被中断环境。  </p></li><li><p>硬件设备：IO设备通常包括一个机械部件和电子部件。  </p><img src="/2022/052237860/114.jpg" class>   <h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><h3 id="IO子系统概述"><a href="#IO子系统概述" class="headerlink" title="IO子系统概述"></a>IO子系统概述</h3><p>由于IO设备种类繁多，功能和传输速率差异巨大，因此需要多种方法来进行设备控制，这些方法共同组成了OS内核的IO子系统，把内核的其他方面从繁重的IO设备管理中解放，其中IO核心子系统提供的服务主要有IO调度，缓冲与高速缓存，设备分配和回收，假脱机，设备保护和差错处理等。  </p><img src="/2022/052237860/115.jpg" class>   <h3 id="IO调度概念"><a href="#IO调度概念" class="headerlink" title="IO调度概念"></a>IO调度概念</h3><p>IO调度就是确定一个好的顺序执行这些IO请求，来改善系统整体性能，使得进程之间公平的共享设备访问，减少IO完成的时间。OS通过为每个设备维护一个请求队列来实现调度，当一个应用程序执行阻塞IO系统调用时，该请求就添加到相应设备的队列上，IO调度会重新安排队列顺序，以改善系统总体效率和平均响应时间。  </p><h3 id="高速缓存和缓冲区"><a href="#高速缓存和缓冲区" class="headerlink" title="高速缓存和缓冲区"></a>高速缓存和缓冲区</h3></li><li><p>磁盘高速缓存：<br>OS中使用磁盘高速缓存技术来提高磁盘IO速度，对于高速缓存复制的访问比原始数据访问更高效，例如：正在运行的进程的指令既存储在磁盘上，又存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。  </p></li><li><p>缓冲区Buffer：<br>设备管理子系统中引入缓冲区的目的是：<br>①缓和CPU与IO设备之间速度不匹配的矛盾。<br>②减少对CPU的中断频率，放款对CPU中断响应时间的限制。<br>③解决基本数据单元大小不匹配的问题。<br>④提高CPU和IO设备之间的并行性。<br>缓冲区的特点：缓冲区的数据非空时不能往中冲入数据，智能把缓冲区把数据传输，为空时可以冲入数据，但必须充满之后才能把数据传出。<br>单缓冲，双缓冲，循环缓冲，缓冲池。  </p></li><li><p>高速缓存和缓冲区的对比：  </p><img src="/2022/052237860/5.jpg" class>   <h3 id="SPOOLing技术（假脱机技术）"><a href="#SPOOLing技术（假脱机技术）" class="headerlink" title="SPOOLing技术（假脱机技术）"></a>SPOOLing技术（假脱机技术）</h3><p>为了缓和CPU高速性和IO设备低速性之间的矛盾，引入了脱机IO技术，该技术利用专门的外围控制机，把低速IO设备上的数据传送到高速磁盘上，或相反。SPOOLing的意思就是外部设备同时联机操作，又称假脱机IO操作，是一种把独占设备改为共享设备的技术。  </p><img src="/2022/052237860/8.jpg" class>   <img src="/2022/052237860/116.jpg" class>   <p>①输入井和输出井：<br>输入井模拟脱机输入时的磁盘，用于收容IO设备输入的数据。<br>输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。<br>②输入缓冲区和输出缓冲区：<br>输入缓冲区暂存输入设备送来的数据，以后再传送到输入井。<br>输出缓冲区暂存从输出井传来的数据，以后再传送到输出设备。<br>③输入进程和输出进程：<br>输入进程模拟脱机输入时的外围控制机，把用户要求数据从输入机通过输入缓冲区送到输入井，当CPU需要输入数据时，直接把输入井数据读入内存。<br>输出进程模拟脱机输出时的外围控制机，把用户要求输出数据从内存送到输出井，待输出设备空闲时，再输出井中数据经过输出缓冲区送到输出设备。<br>共享打印机就是一个SPOOLing的一个实例。特点就是：提高IO速度，把独占设备改造成共享设备，实现了虚拟设备功能。（CPU要向打印机输出要打印的数据之后，去做其他事情，若此时打印机被占用则SPOOLing系统就把这个打印请求挂到等待队列上，待打印机有空再打印出来，向磁盘输出数据速度比向打印机输出数据速度快，因此节约了时间）</p><h3 id="设备分配和回收"><a href="#设备分配和回收" class="headerlink" title="设备分配和回收"></a>设备分配和回收</h3></li><li><p>设备分配概述：<br>根据用户的IO请求分配所需的设备，原则就是充分发挥设备的使用效率，尽可能让设备忙碌起来，又要避免由于不合理分配方法造成进程死锁，从设备特性分三类：<br>①独占式设备：比如打印机。<br>②分时式共享设备：设备没有独占要求时，可以通过分时共享使用提高利用率。<br>③以SPOOLing方式使用外部设备：SPOOLing技术即假脱机IO技术，用于对设备的操作，实质上就是对IO操作进行批处理，实质上是空间换时间的技术。（而页置换就是时间换空间）  </p></li><li><p>设备分配的数据结构：<br>主要有设备控制表DCT，控制器控制表COCT，通道控制表CHCT，系统设备表SDT。<br>①设备控制表DCT：一个表代表一个设备，表项就是设备各属性：  </p><img src="/2022/052237860/6.jpg" class>  <img src="/2022/052237860/117.jpg" class>  <p>②现在IO控制都采用通道控制。设备控制器控制设备与内存交换数据，而设备控制器有需要请求通道为它服务，因此每个COCT必定有一个表项存放指向相应通道控制表CHCT的指针，而一个通道可以为多个设备控制器服务，因此CHCT中必然有一个指针指向一个表，这个表上的信息表达的是CHCT提供服务的几个设备控制器。CHCT和COCT是一对多的关系。   </p><img src="/2022/052237860/118.jpg" class>  <img src="/2022/052237860/119.jpg" class>  <p>③系统设备表SDT：系统只有一张，记录所有设备情况，每个表目代表一个设备。  </p><img src="/2022/052237860/7.jpg" class>   <img src="/2022/052237860/120.jpg" class>   <p>分配步骤:  </p>   <p>由于系统中进程大于资源数目，引起资源竞争，因此要有一套合理的分配原则，主要考虑因素是：IO设备固有属性，分配算法，安全性，独立性。  </p><img src="/2022/052237860/122.jpg" class>   </li><li><p>设备分配的策略：<br>①原则：根据设备特性，用户要求和系统配置情况。总原则就是：既要充分发挥设备使用效率，又要避免造成进程死锁，还要把用户程序和具体设备隔离开。<br>②分配方式：动态和静态分配。<br>静态分配主要是独占是设备分配，在作业执行前系统一次性分配该作业要求全部设备，一旦分配就不可更改，分配方式不会出现死锁，但设备使用效率低。<br>动态分配在进程执行过程中根据执行需要进行，当进程需要设备时，通过系统调用命令向系统提出设备请求，根据策略给其分配设备，用完立即释放，动态分配有利于提高设备的利用率，若分配算法使用不当有可能造成死锁。<br>③设备分配算法：<br>主要是先请求先分配和优先级高者优先。  </p></li><li><p>设备分配安全性：<br>指的是设备分配中应防止发生进程死锁。<br>①安全分配方式：进程发出IO请求便进入阻塞态，直到IO请求完成才被唤醒。所以一旦进程获得某种设备后便进入阻塞，不请求任何资源。优点就是设备分配安全，缺点就是CPU和IO设备是串行工作的。<br>②不安全分配方式：进程在发出IO请求后继续发出第二个等，仅当进程请求设备已被另一个进程占用时才进入阻塞态，优点就是一个进程可以同时操作多个涉笔，缺点就是可能死锁。  </p></li><li><p>逻辑设备名到物理设备名的映射：<br>为了提高设备分配灵活性和设备利用率，方便实现IO重定向，引入了设备独立性（应用程序独立于具体使用的物理设备），为了实现特性系统中设置了一张逻辑设备表LUT，用于把逻辑设备名映射到物理设备名。LUT表项包括逻辑设备名，物理设备名，设备驱动程序入口地址，进程用逻辑设备名请求设备时，系统分配相应物理设备，并且在LUT建立表项，以后系统在利用逻辑设备名时查找LUT即可找到相应物理设备和驱动程序。可以整个系统一张LUT（单用户系统），也可以一个用户一张LUT。   </p></li><li><p>总结：</p><img src="/2022/052237860/123.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统文件管理</title>
      <link href="/2022/052139833.html"/>
      <url>/2022/052139833.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><img src="/2022/052139833/1.jpg" class>   <h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h3><ul><li>文件的定义：<br>以计算机硬盘为载体的存储在计算机上的信息集合。系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入输出中，则以文件为基本单位。当用户把文件用于用户程序的输入输出时，希望还可以访问，修改，保存文件等，实现对于文件的维护管理，需要OS中的文件系统。<br>文件由存储空间中的数据，分类和索引信息，访问权限信息组成。用户通过文件系统建立文件，提供程序的输入输出，对资源进行管理，首先了解文件结构，通过自底向上的方式来定义：<br>①数据项：文件系统中最低级的数据组织形式，分为基本数据项（描述一个对象某个值，是数据中可命名的最小逻辑数据单元，即原子数据）和组合数据项（由多个基本数据项组成）。<br>②记录：一组相关数据项集合，描述一个对象在某方面的属性（考生信息一系列域）。<br>③文件：指由创建者所定义的一组相关信息集合，逻辑上分为有结构文件（文件由一组相似记录组成，又叫记录式文件）和无结构文件（视为一个字符流，又称流式文件）。  <img src="/2022/052139833/101.jpg" class>   </li><li>文件的属性：<br>系统不同属性也不同，但通常包括：<br>①名称：文件名称唯一，以易读取形式保存。<br>②标识符：标识文件系统内文件的唯一标签，通常为数字，对人不可读。<br>③类型：被支持不同类型的文件系统所使用。<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小，也可包括文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息。<br>⑦时间，日期和用户标识：文件创建，上次修改，上次访问的相关信息，用于保护跟踪文件使用。<br>所有文件的信息都保存在目录结构中，目录结构保存在外存中，文件信息需要时才调入内存，通常，目录条目包括文件名称以及唯一标识符，二标识符定位其他属性信息。  </li><li>文件的基本操作：<br>OS提供系统调用，对文件进行创建，写，读，重定位，删除，截断等操作。（基本操作组合可以执行其他文件操作）<br>①创建文件（create系统调用）：①文件系统为文件找到空间。②目录中为文件创建新条目，记录文件名称和标识符等其他信息。<br>②写文件（write系统调用）：执行系统调用，指明文件名称和要写内容，系统维护一个写位置的指针，写操作时更新写指针。<br>③读文件（read系统调用）：执行系统调用，指明文件内容和要读文件快的内存位置，系统维护一个读位置的指针，读操作时更新读指针，读写使用同一个指针。<br>④文件重定位：按照某条件搜索目录，把当前文件位置设置为给定值，并且不会读写文件。<br>⑤删除文件（delete系统调用）：从目录找出删除文件的目录项，实质称为空项目，回收文件存储空间。<br>⑥截断文件：允许文件所有属性不变，并删除文件内容，即长度设置为0并释放其空间。  <img src="/2022/052139833/102.jpg" class>   </li><li>文件打开open和关闭close：<br>许多系统要求首次使用文件时，系统调用open将指明文件的属性从外存复制到内存，打开文件表的一个条目，把表目编号返回给用户，OS维护一个包含所有打开文件信息的表（打开文件表），需要文件操作时可以通过该表的一个索引指定文件，省略搜索环境，不再使用可以关闭它，OS打开文件表删除这个条目。open会根据文件名搜索牡蛎，并把目录条目复制到打开文件表，open返回一个指向打开文件表中的一个条目的指针，通过这个指针进行所有IO操作，之后对于文件任何操作不需要文件名字，只需要open调用返回的指针。<br>通常OS还用一个文件打开计数器Open Count，记录多少进程打开了该文件，打开计数器为0标识不再使用，系统回收系统资源。若文件被修改过，文件写回外存，并把打开文件表相应条目删除，最后释放文件的文件控制块FCB。  <img src="/2022/052139833/114.jpg" class>   <img src="/2022/052139833/115.jpg" class>   每个打开文件都有相关关联信息：<br>①文件指针：文件当前位置的指针，打开文件某个进程是唯一的。<br>②文件打开计数：上文解释过。<br>③文件磁盘位置：绝大数文件操作要求改变文件，该信息保存在内存中，以免每个操作都从磁盘中获取。<br>④访问权限：每个进程打开文件都要有访问模式（创建，只读，读写等），该信息保存在进程打开文件表中，以便OS可以允许&#x2F;拒绝IO请求。   <h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3></li><li>逻辑结构就是用户观点看到的文件组织形式。物理结构则是实现观点出发看到的文件在外存上的存储组织形式。逻辑结构上，文件划分无结构文件和有结构文件两种：</li><li>无结构文件（流式文件）：<br>最简单的文件组织形式，把数据按照顺序组织成记录并积蓄保存，它是有序相关信息项的集合，以字节为单位。记录访问只能穷举搜索，适用于对基本信息单位操作不多的文件（如源程序文件，目标代码文件等）  </li><li>有结构文件（记录式文件）：<br>按照记录的组织形式可以分为：<br>①顺序文件：记录顺序排列，通常是定长的，可以顺序&#x2F;链式存储，访问时顺序搜索文件。有两种结构：第一种是串结构：存入时间先后排列。第二种是顺序结构：按照关键字顺序排列。对于记录批量操作时，顺序文件操作效率最高，此外也只有顺序文件才能存在磁带上，但对于单条记录操作就比较困难。  <img src="/2022/052139833/103.jpg" class>   ②索引文件：对于定长记录文件和可变长记录文件，查找第i条记录地址不一样。变长记录文件只能顺序查找，系统开销大，为此可以建立一张索引表加速检索。  <img src="/2022/052139833/2.jpg" class>   <img src="/2022/052139833/104.jpg" class>   ③索引顺序文件：顺序和索引两种组织形式结合，把顺序文件所有记录分为若干组，建立一张索引表，表为每组第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。同一组的关键字可以无序，但组索引必须有序，先找到组再顺序查找。  <img src="/2022/052139833/3.jpg" class>   <img src="/2022/052139833/105.jpg" class>   提高了查找效率，但配置索引表增加了存储空间。<br>甚至可以建立多级索引表<br>④直接文件&#x2F;散列文件（Hash File）：给定记录的键值&#x2F;通过散列函数转换的键值直接决定记录的物理地址，没有顺序的特性，有很高的存取速度但有冲突。  <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3></li><li>包含文件信息，这些信息由OS管理。用户角度：目录需要在文件名和文件之间有映射，目录存取效率直接影响系统性能，所以要提高用户检索速度，共享系统中，目录还需要提供用于控制访问文件的信息，重名也是合理的要求，通过树形结构来解决和实现。  </li><li>文件控制块和索引结点：<br>为了实现目录管理，OS引入了文件控制块的数据结构。<br>①文件控制块FCB，用来存放控制文件所需要各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项，创建新文件则分配一个FCB并存放在文件目录中，成为目录项。主要包括：基本信息（名字，物理位置，逻辑结构等），存取控制信息（文件存取权限等），使用信息（创建修改时间等）。<br>②索引结点：检索目录文件过程中，只用到了文件名，仅当找到一个目录项时，才需要从该目录读取其物理地址，也就是其他描述信息没用到，所以有的OS采用文件名和描述分开方法，描述信息单独形成一个称为索引结点的数据结构，在文件目录中每个目录项仅由文件名和指向该文件的所对应i结点的指针构成。存放在磁盘上的索引结点称为磁盘索引结点，UNIX每个文件都由一个唯一的磁盘索引结点，主要包括：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度（以字节为单位），文件链接计数（指向该文件的指针计数），文件存取时间。<br>文件被打开时，磁盘索引结点复制到内存的索引结点以便于使用，在内存索引节点又增加了内容：索引结点编号（标识内存索引结点），状态（结点是否上锁或修改），访问计数，逻辑设备号，链接指针。  <img src="/2022/052139833/106.jpg" class>   </li><li>目录结构：<br>考虑目录层次的操作:搜索，创建文件，删除文件，显示目录，修改目录。考虑以下几种目录结构：<br>①单级目录结构：<br>整个文件系统只有一个目录表，每个文件占一个目录项。  <img src="/2022/052139833/4.jpg" class>   访问文件，先按照文件名找到对应FCB，创建文件必须检索所有目录项以确保没有重名，删除文件回收存储空间再清楚目录项。单级目录实现了“按名存取”，但速度慢，无重名，不便于用户共享。<br>②两级目录结构：<br>把文件目录分为主文件目录MFD和用户文件目录UFD。  <img src="/2022/052139833/5.jpg" class>   主文件目录记录用户名和相应文件目录所在存储位置，而用户文件目录记录相应用户文件目录的FCB信息，当用户相对其文件访问时只需要搜索该用户对应的UFD，解决了重名问题，保证安全，但缺乏灵活性，不能对文件分类。<br>③多级目录结构（树形目录结构）：<br>用户访问某个文件，用文件路径名标识文件，用“&#x2F;”分隔开，从根目录出发的路径为绝对路径。而从当前目录出发到所找文件通路的路径为相对路径。  <img src="/2022/052139833/6.jpg" class>   很方便对于文件分配，层次清晰，但查找时需要逐次访问中间结点，增加磁盘访问次数，影响速度。<br>④无环图目录结构：<br>树形结构不利于文件共享，所以在树形结构基础上增加指向同一结点的有向边，使得整个目录成为一个有向无环图，为了实现文件共享。  <img src="/2022/052139833/7.jpg" class>   <h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3>使多个用户共享同一个文件，系统只需要保留一个副本。常用两种方法：  </li><li>基于索引结点的共享方式（硬链接）：<br>在树形结构目录中，当两个或多个用户要共享一个子目录&#x2F;文件时，必须把共享文件或子目录链接到这些用户目录中，才能方便找到该文件。<br>文件的其他信息都放在索引结点中，而目录中只有文件名和指向相应索引节点的指针，索引节点还有count来计数链接到本索引结点的用户目录项数。  <img src="/2022/052139833/8.jpg" class>   <img src="/2022/052139833/116.jpg" class>   </li><li>利用符号链实现文件共享（软链接）：<br>系统创建一个LINK类型的新文件，写入共享用户B的目录中，实现B的目录与文件F的链接，新文件中只包含被链接文件的路径名，这种方法称为符号链接。新文件中的路径名视为符号链，根据路径名读取文件，从而实现对文件的共享。<br>在利用符号链方式实现文件共享时，只有文件拥有者才拥有指向其索引节点的指针，而共享该文件的其他用户只有该文件的路径名。但仍然有一点问题，删除该文件且再次创建一样文件，软链接仍然有效。有个优点就是网络共享只需要提供该文件所在及其的网络地址及该及其中的文件路径。<br>类似于快捷方式。删除源文件则软链接失效。  <h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读，写，执行的许可问题，为此必须在文件系统中建立相应的文件保护机制。文件保护通过口令保护，加密保护，访问控制等方式实现，其中口令和加密为了防止用户文件被他人存取或窃取，而访问控制用于控制用户对于文件访问方式。  </li><li>访问类型：<br>读，写，执行（文件装入内存并执行），添加，删除，列表清单（列出文件名和属性），还有其他高级操作（通过掉哟个底层系统调用来实现）。</li><li>访问控制：<br>最常用方法就是根据用户身份进行控制，为每个文件FCB增加一个访问控制列表ACL，以规定每个用户名及其所允许的访问类型，精简的访问列表有：拥有者（创建文件用户），组（一组内需要共享文件且具有类似访问的用户），其他（系统内的所有其他用户）。用三个域列出访问表三类用户访问权限。  <img src="/2022/052139833/117.jpg" class>   </li><li>口令和密码时另外两种访问控制：<br>①口令指用户建立一个文件时提供一个口令，系统为其建立FCB时附上口令，且告诉共享文件的其他用户，用户请求访问时必须提供相应口令，缺点是口令存在系统内部不安全。<br>②密码则是对文件加密，访问需要密钥，保密性强但编码和译码需要花费时间。</li><li>总结：  <img src="/2022/052139833/118.jpg" class>   <h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3>现代OS有很多种文件系统类型，因此文件系统层次结构也不尽相同。  <img src="/2022/052139833/9.jpg" class>   </li><li>用户调用接口：<br>文件系统为用户提供与文件及目录有关的调用。此层由若干程序模块组成，每个模块对应一条系统调用，用户发出一条调用，控制即转入相应的模块。  </li><li>文件目录系统：<br>管理文件目录，任务有管理活跃文件目录表，管理读写状态信息表，打开文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块。  </li><li>存取控制验证模块：<br>实现文件保护主要由该级软件完成，把用户访问和FCB中访问控制权限进行比较，确认合法性。  </li><li>逻辑文件系统和文件信息缓冲区：<br>根据文件逻辑把用户读写的记录转换成文件逻辑结构内相应块号。  </li><li>物理文件系统：<br>把逻辑记录所在的相对块号转换成实际物理地址。  </li><li>辅助分配模块：<br>管理辅存空间。  </li><li>设备管理程序模块：<br>分配设备，分配设备读写缓冲区，磁盘调度，启动设备，处理设备中断等。  <img src="/2022/052139833/10.jpg" class>   <img src="/2022/052139833/119.jpg" class>   <img src="/2022/052139833/120.jpg" class>   <h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3>常用基本方法是线性列表和哈希表两种，目录实现的目的就是为了查找，因此对应线性查找和哈希查找。查询通过磁盘反复搜索完成的，开销大，复制进内存降低磁盘操作次数，提高系统速度。    </li><li>线性列表：<br>使用存储文件名和数据块指针的线性表。  </li><li>哈希表：<br>根据文件名得到值，返回一个指向线性列表中元素的指针。  <h3 id="文件实现——文件分配方式"><a href="#文件实现——文件分配方式" class="headerlink" title="文件实现——文件分配方式"></a>文件实现——文件分配方式</h3>文件分配对应文件的物理结构，如何为文件分配磁盘块，常见分配有连续分配，链接分配，索引分配。文件分配方式——对于磁盘非空闲块的管理。  <img src="/2022/052139833/107.jpg" class>   <img src="/2022/052139833/108.jpg" class>   </li><li>连续分配：<br>要求每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序，这种排序使得作业访问磁盘需要的寻道数和时间最小。一个文件目录条目包括开始的块的地址和长度。连续分配支持顺序访问和直接访问，优点就是实现简单，存取速度快，缺点就是文件长度不宜动态增加，反复增删产生外部碎片。   <img src="/2022/052139833/11.jpg" class>   </li><li>链接分配：<br>离散分配的方式，消除外部碎片，增删改查方便，分为隐式链接和显式链接两种形式：<br>①隐式链接：<br>每个文件对应一个磁盘块链表，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的，目录包括文件的第一块指针和最后一块指针。创建新文件时，目录中增加一个新条目，每个目录项都有指向文件首块的指针，该指针初始化为NULL以表示空文件，写文件会同空闲空间管理系统找到空闲块，把该块链接到文件尾部，读文件则通过块间指针顺序读块。缺点就是无法直接访问，只能顺序访问，且软件&#x2F;硬件错误导致指针丢失也会使得数据丢失。  <img src="/2022/052139833/12.jpg" class>   ②显式链接：<br>指把用于连接文件各物理块的指针，从物理块末尾提取出来放在链接表中，仅一张称为文件分配表FAT，每个表项存放对应块的下一块指针，即下一个块号，第一个块号存在目录中，后续通过FAT查找得到。用-1表示文件最后一块，-2表示这个磁盘块是空闲的。因此FAT不仅记录了文件各块先后关系，还标记了空闲磁盘块。FAT在系统启动的时候就被读入内存，因此查找FAT是在内存中进行的，不仅显著提高了检索速度，而且减少了访问磁盘次数。  <img src="/2022/052139833/13.jpg" class>   ③总结：  <img src="/2022/052139833/109.jpg" class>   </li><li>索引分配：<br>链接分配不能解决直接访问，而索引分配解决了这个问题，它把每个文件所有盘块号都集中放在一起形成索引块。每个文件都由其索引块，这是一个磁盘块地址的数组，目录条目包括索引块的地址，第i块就是第i个条目的指针来查找和读入所需的块。创建文件时，所有索引块的指针都设置为空，首次写入第i块时需要从空闲空间中取得一个块，然后把其地址写入索引块的第i个条目。    <img src="/2022/052139833/14.jpg" class>   索引块大小很重要，每个文件必须有一个索引块，尽可能小，但太小无法支持大文件，采用以下机制解决问题：<br>①链接方案：多个索引块链接起来处理大文件。<br>②多层索引：第一层索引指向第二次，以此类推。<br>③混合索引：多种索引分配方式结合的分配方式（有索引直接地址，有一级间接，二级间接）</li><li>三种文件分配方式比较：  <img src="/2022/052139833/15.jpg" class>   <h3 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h3></li><li>文件存储器空间的划分与初始化：<br>一般来说，一个文件存储在一个文件卷中，文件卷可以是物理盘一部分，也可以是整个物理盘。一个文件卷中，文件数据信息的空间和存放文件控制信息FCB的空间时分离的。  <img src="/2022/052139833/16.jpg" class>   <img src="/2022/052139833/110.jpg" class>   </li><li>文件存储器空间管理：<br>文件存储设备分成大小相同的物理块，并以块为单位交换信息，因此文件存储设备的管理实质上是对空闲块的组织和管理，包括空闲块的组织，分配，回收等问题。  </li><li>空闲表法：<br>连续分配方式，为每个文件分配一块连续的内存空间，系统为外存的所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，包括表项序号，该空闲区第一个盘块好，块数等信息，再递增排列。空闲盘区的分配和内存动态分配类似，同样采用首次适应算法&#x2F;循环首次适应算法等。系统对用户释放的存储空间进行回收时，也采取类似用于内存回收的方法，考虑回收区是否和空闲表中插入点的前区和后区相邻接，对相邻接者予以合并。    <img src="/2022/052139833/17.jpg" class>   <img src="/2022/052139833/111.jpg" class>   </li><li>空闲链表法：<br>所有空闲盘区拉成一条空闲链，根据构成链所有基本元素不同，分为两种形式：空闲盘块链和空闲盘区链。<br>①空闲盘块链：把磁盘上所有空闲空间以盘块为单位拉成一条链，当用户因为创建文件而请求分配存储空间时，从链首开始一次摘下合适数目空闲盘块分配给用户，删除则把回收盘块放在链末尾。<br>②空闲盘区链：把磁盘上所有空闲空间以盘区为单位拉成一条链，盘区含有指向下一个盘区指针和盘区大小信息，分配和内存动态分配一样，采用首次适应算法，回收时也是把回收区和相邻接的空闲盘区合并。  </li><li>位示图法：<br>利用二进制的一位表示磁盘中的一个盘块的使用情况，0表示空闲，1表示已分配。分配和回收只需要修改二位数组的1&#x2F;0即可。  <img src="/2022/052139833/18.jpg" class>   <img src="/2022/052139833/112.jpg" class>   </li><li>成组链接法：<br>UNIX使用，结合空闲表和空闲链表，克服表太大的缺点。思想:顺序的n个空扇区地址保存在第一个空扇区中，其后一个空闲扇区则保存另一个顺序空闲扇区的地址，之后一个空闲扇区内则保存另一个顺序空闲扇区的地址，如此继续，直到所有空闲扇区链接完成。  <img src="/2022/052139833/19.jpg" class>   <img src="/2022/052139833/113.jpg" class>   <h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><img src="/2022/052139833/20.jpg" class>   <img src="/2022/052139833/121.jpg" class>   <img src="/2022/052139833/122.jpg" class>   <img src="/2022/052139833/123.jpg" class>   </li><li>磁盘分类：  <img src="/2022/052139833/124.jpg" class>   <img src="/2022/052139833/125.jpg" class>   <h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3>一次磁盘读写操作时间由寻道时间，旋转延迟时间，传输时间决定。  <img src="/2022/052139833/126.jpg" class>   </li><li>寻道时间，活动头磁盘读信息之前，把磁头移动到指定磁道所需要的时间，这个时间除了跨越n条道的时间外，还包括启动磁臂的时间。  </li><li>旋转延迟时间，磁头定位到某磁道的扇区需要时间，设磁盘旋转速度为r，则t&#x3D;1&#x2F;2r。  </li><li>传输时间，从磁盘读出或向磁盘写入数据经历的时间，取决于每次读写字节数b和磁盘旋转速度t&#x3D;b&#x2F;rN。<br>其中寻道时间和磁盘调度算法相关，而其他都与磁盘旋转速度有关。以下几种磁盘调度算法：  </li><li>先来先服务FCFS：<br>按照先后顺序进行访问磁盘调度。  <img src="/2022/052139833/127.jpg" class>   </li><li>最短寻找时间优先算法SSTF：<br>与当前磁道最近的磁道优先调度，但会产生“饥饿现象”。  <img src="/2022/052139833/128.jpg" class>   </li><li>扫描算法SCAN：<br>在当前移动方向上寻找与当前磁头最近的对象，就是SSTF基础上规定了磁头运动方向。  <img src="/2022/052139833/129.jpg" class>   </li><li>循环扫描算法C-SCAN：<br>扫描算法基础上规定磁头单项移动来提供服务，返回直接快速移动到起始端而不服务请求。   <img src="/2022/052139833/131.jpg" class>   </li><li>LOOK算法：<br>扫描算法就是磁头严格一个方向从一端到另一端，而改进之后磁头移动只需要到达最远端而不需要到达磁盘端点，这就是LOOK算法。（默认SCAN为LOOK算法）   <img src="/2022/052139833/130.jpg" class>   </li><li>C-LOOK算法：<br>对应C-SCAN类似，到达最远端点之后直接移动到起始端点而不提供服务请求。（默认C-SCAN为C-LOOK算法）   <img src="/2022/052139833/132.jpg" class>   </li><li>算法比较：  <img src="/2022/052139833/21.jpg" class>   <h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3></li><li>磁盘初始化：<br>磁盘存储数据之前，必须分成扇区以便磁盘控制器能进行读和写的操作，这个过程称为低级格式化。低级格式化为磁盘的每个扇区采用特别的数据结构，每个扇区的数据结构通常由头，数据区域，尾部组成。为了使得磁盘存储文件，OS还需要把自己的数据结构记录在磁盘上，第一步把磁盘分为由一个或多个柱面组成的分区（C盘，D盘等），第二部对物理分区进行逻辑格式化（创建文件系统），OS把初始文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配空间及一个初始为空的目录。  <img src="/2022/052139833/133.jpg" class>   </li><li>引导块：计算机启动时运行初始化程序，初始化各类资源等，接着就启动OS。引导的这个自举程序的磁盘称为启动磁盘&#x2F;系统磁盘。   <img src="/2022/052139833/134.jpg" class>    </li><li>坏块：硬件故障，OS处理不了。    <img src="/2022/052139833/135.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/052018155.html"/>
      <url>/2022/052018155.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>MVC设计模式：当拿到任何一个需求的时候，都可以从MVC三个方面进行拆分</p><ul><li><p>M：Model，模型，处理数据</p></li><li><p>V：View，视图，接收和显示数据</p></li><li><p>C：Controller，控制器，由谁来接收和显示数据，有谁来处理数据</p></li></ul><p>三层结构：企业级应用的要求</p><ul><li>表示层</li><li>业务逻辑层</li><li>数据访问层</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>spring是一个开源框架，是为了解决企业级应用开发的复杂性而设计的</li><li>spring最根本的使命：全方位的简化java开发</li><li>核心思想：<ul><li>IoC：控制反转，就是把依赖对象创建的控制权交给第三方（Spring容器）来管理</li><li>DI：依赖注入，组件之间的依赖关系，在程序运行期间，由第三方动态注入</li></ul></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>添加 spring 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>添加spring容器的配置类，并添加组件</p><pre><code>@Configurationpublic class AppConfig &#123;        @Bean(name = &#123;&quot;empDao1&quot;,&quot;empDao2&quot;&#125;)    public EmpDao empDao() &#123;        return new EmpDaoImpl();    &#125;&#125;</code></pre></li><li><p>测试</p><pre><code>public class EmpDaoTest &#123;        @Test    public void testInsert() &#123;        //启动容器        ApplicationContext c =                new AnnotationConfigApplicationContext(AppConfig.class);        //得到组件        //EmpDao empDao = c.getBean(EmpDao.class);        //通过组件名得到组件,默认是方法名        EmpDao empDao = (EmpDao)c.getBean(&quot;empDao2&quot;);        //调用业务方法        empDao.insert();        //关闭容器        ((AnnotationConfigApplicationContext)c).close();    &#125;&#125;</code></pre></li><li><p>组件装配</p><pre><code>@Getter@Setterpublic class EmpServiceImpl implements EmpService &#123;    private EmpDao empDao ;    @Override    public int insert() &#123;                return empDao.insert();    &#125;&#125;</code></pre><p>属性注入：</p><pre><code>@Configurationpublic class AppConfig &#123;        @Bean(name = &#123;&quot;empDao1&quot;,&quot;empDao2&quot;&#125;)    public EmpDao empDao() &#123;        return new EmpDaoImpl();    &#125;        @Bean    public EmpService empService() &#123;        EmpServiceImpl service = new EmpServiceImpl();        //依赖注入        service.setEmpDao(empDao());                return service;    &#125;&#125;</code></pre><p>构造注入：</p><pre><code>@Getter@Setterpublic class EmpServiceImpl implements EmpService &#123;    public EmpServiceImpl() &#123;            &#125;        public EmpServiceImpl(EmpDao empDao) &#123;        this.empDao = empDao;    &#125;    private EmpDao empDao ;    @Override    public int insert() &#123;                return empDao.insert();    &#125;&#125;</code></pre><pre><code>@Bean    public EmpService empService() &#123;        EmpServiceImpl service = new EmpServiceImpl(empDao());                        return service;    &#125;</code></pre><p>依赖注入三种方式：</p><ul><li>属性注入</li><li>构造注入</li><li>接口注入（Spring不支持该方式）</li></ul></li></ol><h2 id="Bean说明"><a href="#Bean说明" class="headerlink" title="Bean说明"></a>Bean说明</h2><ol><li><p>@Scope:作用域（单例：singleton（默认的），原生：prototype）</p><pre><code>@Bean@Scope(&quot;prototype&quot;)public EmpService empService() &#123;    EmpServiceImpl service = new EmpServiceImpl(empDao());    return service;&#125;</code></pre></li><li><p>@Lazy：懒加载（延迟加载，在getBean()的时候再加载），默认值@Lazy（false）</p><p>注意：在@Scope(“prototype”)的时候，一定是懒加载的</p><pre><code>    @Bean//@Scope(&quot;prototype&quot;)    @Lazy(true)    public EmpService empService() &#123;        EmpServiceImpl service = new EmpServiceImpl(empDao());                return service;    &#125;</code></pre></li><li><p>组件扫描</p><ul><li><p>在配置类上添加组件扫描注解</p><pre><code>@Configuration@ComponentScan(basePackages = &#123;&quot;com.neu.dao&quot;,&quot;com.neu.service&quot;&#125;)public class AppConfig &#123;&#125;</code></pre></li><li><p>在需要成为组件的类上添加@Component注解（组件默认名字为：类名首字母小写）</p><pre><code>//组件@Componentpublic class EmpDaoImpl implements EmpDao &#123;&#125;</code></pre></li></ul></li><li><p>自动装配</p><pre><code>//默认按照类型装配@Autowiredprivate EmpDao empDao ;</code></pre></li><li><p>解决自动装配冲突（使用组件名装配）</p><pre><code>@Autowired@Qualifier(&quot;empOracleDaoImpl&quot;)//注解参数就是组件名，默认为类名首字母小写private EmpDao empDao ;</code></pre></li><li><p>修改组件的默认名</p><pre><code>@Component(value = &quot;oracleemp&quot;)public class EmpOracleDaoImpl implements EmpDao &#123;&#125;</code></pre></li></ol><h2 id="使用Spring的测试模块"><a href="#使用Spring的测试模块" class="headerlink" title="使用Spring的测试模块"></a>使用Spring的测试模块</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>//设置配置文件@ContextConfiguration(classes = &#123;AppConfig.class&#125;)//相当于测试框架与Spring的一个接口@RunWith(SpringJUnit4ClassRunner.class)public class EmpTest &#123;    @Autowired    private EmpService empService;        @Test    public void testInsert() &#123;        empService.insert();    &#125;&#125;</code></pre></li></ol><h2 id="Spring对持久层的支持"><a href="#Spring对持久层的支持" class="headerlink" title="Spring对持久层的支持"></a>Spring对持久层的支持</h2><h3 id="在Spring中使用数据库连接池"><a href="#在Spring中使用数据库连接池" class="headerlink" title="在Spring中使用数据库连接池"></a>在Spring中使用数据库连接池</h3><ol><li><p>导入连接池及数据库驱动</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.22&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义一个属性文件（db.properties）,在其中配置数据库连接池需要的参数</p><pre><code>jdbc.username=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/neusoft?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.maxActive=20jdbc.maxWait=2000jdbc.maxIdle=5</code></pre></li><li><p>定义一个配置类，读取数据库连接属性文件</p><pre><code>package com.neu;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;@Configuration//配置属性源文件@PropertySource(&quot;classpath:db.properties&quot;)public class DBConfig &#123;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;        @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;        @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;        @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)    private String driverClassName;        @Value(&quot;$&#123;jdbc.maxActive&#125;&quot;)    private int maxActive;        @Value(&quot;$&#123;jdbc.maxWait&#125;&quot;)    private int maxWait;        @Value(&quot;$&#123;jdbc.maxIdle&#125;&quot;)    private int maxIdle;        @Bean    public DataSource dataSource() &#123;        BasicDataSource ds = new BasicDataSource();        ds.setUsername(username);        ds.setPassword(password);        ds.setUrl(url);        ds.setDriverClassName(driverClassName);                ds.setMaxActive(maxActive);        ds.setMaxIdle(maxIdle);        ds.setMaxWait(maxWait);                return ds;    &#125;&#125;</code></pre></li><li><p>测试</p><pre><code>@ContextConfiguration(classes = &#123;AppConfig.class,DBConfig.class&#125;)//相当于测试框架与Spring的一个接口@RunWith(SpringJUnit4ClassRunner.class)public class EmpTest &#123;    @Autowired    private EmpService empService;        @Autowired    private DataSource dataSource;        @Test    public void testDataSource() throws SQLException &#123;        Connection connection = dataSource.getConnection();        System.out.println(&quot;连接成功！&quot;);        connection.close();    &#125;        @Test    public void testInsert() &#123;        empService.insert();    &#125;&#125;</code></pre><h2 id="Spring与Mybatis集成"><a href="#Spring与Mybatis集成" class="headerlink" title="Spring与Mybatis集成"></a>Spring与Mybatis集成</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置SqlSessionFactory</p><pre><code>@Configuration@ComponentScan(basePackages = &#123;&quot;com.neu.service&quot;,&quot;com.neu.mapper&quot;&#125;)public class MybatisConfig &#123;    @Autowired    private DataSource dataSource;        @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception &#123;        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();        factory.setDataSource(dataSource);                return factory.getObject();    &#125;&#125;</code></pre></li><li><p>配置 mapper 扫描</p><pre><code>@Configurationpublic class MybatisMapperScannerConfig &#123;    @Bean    public MapperScannerConfigurer mapperScannerConfigurer() &#123;        MapperScannerConfigurer c = new MapperScannerConfigurer();        c.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;);                c.setBasePackage(&quot;com.neu.mapper&quot;);                return c;    &#125;&#125;</code></pre></li></ol></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol><li>spring+mybatis实现如下功能（使用单元测试，业务逻辑层+数据访问层）：<ul><li>查询所有员工信息</li><li>添加员工</li><li>删除员工</li><li>分页查询员工（每页显示3条记录，打印第2页数据）</li></ul></li></ol><h2 id="Spring-Mybatis-Servlet"><a href="#Spring-Mybatis-Servlet" class="headerlink" title="Spring+Mybatis+Servlet"></a>Spring+Mybatis+Servlet</h2><ol><li><p>修改打包方式：war</p></li><li><p>导入相关web依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ol><li><p>定义：面向切面编程，模块化横切关注点（把相同的代码加到关注的方法上）</p></li><li><p>导入包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;    &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义一个类，实现切面的功能（类定义在com.neu.utils包下，要把该包添加到组件的扫描路径中）</p><pre><code>@Configuration@EnableAspectJAutoProxy//开启切面自动代理@Component@Aspect//切面public class AOPUtil &#123;    //切点(切入点):加入相同代码的一组关注点(连接点)    @Pointcut(&quot;execution (* com.neu.mapper.*.*(..))&quot;)    public void pointcut() &#123;            &#125;        //通知    @Around(&quot;pointcut()&quot;)    public Object around(ProceedingJoinPoint p) throws Throwable &#123;        long startTime = System.nanoTime();        //调用代理的方法        Object object = p.proceed();                long m = System.nanoTime() - startTime;                System.out.println(m);                return object;    &#125;    &#125;</code></pre><ul><li>连接点（joinPoint)：程序执行过程中的特定点</li><li>通知（Advice）：在特定连接点加入的代码</li><li>切入点（pointcut）：加入相同通知的一组连接点</li><li>切面（aspect）：通知与切入点的组合</li></ul></li><li><p>前置通知</p><pre><code>@Before(&quot;pointcut()&quot;)    public void before() &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = f.format(new Date());                System.out.println(&quot;开始执行方法：&quot;+format);            &#125;</code></pre></li><li><p>返回后通知：执行了return语句后执行的代码</p><pre><code>@AfterReturning(&quot;pointcut()&quot;)    public void afterReturning() &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = f.format(new Date());                System.out.println(&quot;方法正常结束：&quot;+format);            &#125;</code></pre></li><li><p>异常通知：</p><pre><code>@AfterThrowing(&quot;pointcut()&quot;)    public void afterThrowing() &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = f.format(new Date());                System.out.println(&quot;抛出异常：&quot;+format);            &#125;</code></pre></li><li><p>最终通知</p><pre><code>@After(&quot;pointcut()&quot;)    public void after() &#123;        SimpleDateFormat f = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String format = f.format(new Date());                System.out.println(&quot;方法最终结束时间：&quot;+format);            &#125;</code></pre></li><li><p>环绕通知</p><pre><code>@Around(&quot;pointcut()&quot;)    public Object around(ProceedingJoinPoint p) throws Throwable &#123;        long startTime = System.nanoTime();        //调用代理的方法        Object object = p.proceed();                long m = System.nanoTime() - startTime;                System.out.println(m);                return object;    &#125;</code></pre></li></ol><h2 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h2><ol><li><p>添加事务管理器</p><pre><code>@Beanpublic PlatformTransactionManager transactionManager() &#123;    return new DataSourceTransactionManager(dataSource());&#125;</code></pre></li><li><p>启用事务管理器</p><pre><code>@Configuration//配置属性源文件@PropertySource(&quot;classpath:db.properties&quot;)@EnableTransactionManagement//启用事务管理器public class DBConfig &#123;&#125;</code></pre></li><li><p>在业务逻辑类上或方法上添加@Transactional</p><p>当添加了事务注解的方法中，抛出异常，则回滚事务，否则，提交事务</p><pre><code>@Transactional    public int insert(Dept dept) &#123;        deptMapper.insert(dept);        return deptMapper.insert(dept);    &#125;</code></pre></li></ol><h2 id="使用静态资源"><a href="#使用静态资源" class="headerlink" title="使用静态资源"></a>使用静态资源</h2><ol><li><p>在 webapp 目录下，新建一个文件夹：staitc，在其中放入静态资源（css、js）</p><p>例如：&#x2F;webapp&#x2F;static&#x2F;css&#x2F;style1.css</p></li><li><p>配置资源注册</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = &quot;com.neu.controller&quot;)public class SpringMVCConfig implements WebMvcConfigurer &#123;    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;        registry.addResourceHandler(&quot;/static/**&quot;).addResourceLocations(&quot;/static/&quot;);//访问的静态资源    &#125;&#125;</code></pre></li><li><p>在 jsp 中引入css</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123; pageContext.request.contextPath &#125;/static/css/style1.css&quot;&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理</title>
      <link href="/2022/05198490.html"/>
      <url>/2022/05198490.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="/2022/05198490/1.jpg" class>   <h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><ul><li>内存是存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理。内存中有程序段和数据段，也就是指令和数据。一个内存地址对应一个存储单元，存储单元大小由计算机编址决定。    <img src="/2022/05198490/101.jpg" class>   </li><li>尽管内存不断增大，但仍然不可能把所有用户进程和系统所需要的全部程序与数据放入主存，因此OS必须对内存空间进行合理划分和有效动态分配。<br>定义：OS对内存的划分和动态分配。  </li><li>功能有：<br>①内存空间的分配和回收：OS完成主存空间分配和管理，使人工不负责分配。<br>②地址转换：把程序逻辑地址转换为物理地址。<br>③内存空间的扩充：利用虚拟存储技术&#x2F;自动覆盖技术，逻辑上扩充内存。<br>④存储保护：保证各作业在各自内存空间内运行，互不干扰。  </li><li>在具体内存管理之前，首先要了解进程运行基本原理和要求：<br>①程序装入和链接：  <img src="/2022/05198490/102.jpg" class>   创建进程首先要将程序和数据装入内存，把用户源程序变成内存中执行程序：<br>Ⅰ编译：编译程序把用户源代码编译成若干目标模块。<br>Ⅱ链接：链接程序把编译好的一组目标模块以及所需要的库函数链接在一起，形成一个完整装入模块。<br>Ⅲ装入：装入程序将装入模块装入内存中。   <img src="/2022/05198490/2.jpg" class>   程序链接有三种方式：<br>Ⅰ静态链接：程序运行之前，各模块及所需库函数链接成一个完整可执行程序，不再拆开。<br>Ⅱ装入时动态链接：把用户源程序编译后得到一组目标模块，装入时采用边装边链接。<br>Ⅱ运行时动态链接：对于某些目标模块的链接是在程序执行中需要该目标模块时才进行的，优点就是便于修改更新，便于实现对于目标模块的共享。<br>内存的装入也有三种方式：<br>Ⅰ绝对装入：编译时若知道程序所留内存位置，则编译程序之间产生绝对地址目标代码，装入模块中地址，且程序中逻辑地址和实际地址完全相同，因此不需要对于程序和数据的地址进行修改。绝对装入方式只适合于单道程序环境。  <img src="/2022/05198490/103.jpg" class>     Ⅱ可重定位装入：多道程序环境下，多个目标模块的起始地址通常从0开始，程序中的其他地址都是相对于起始地址的，此时应该采用可重定位装入方式，根据内存当前情况装入适当位置，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成，又称静态重定位，特点就是一个作业装入内存时必须有所需全部内存空间，否则不能装入该作业，一旦进入内存，整个运行期间不能移动，也不能再申请内存空间。  <img src="/2022/05198490/104.jpg" class>   Ⅲ动态运行时装入：也是动态重定位，程序在内存中若发生移动，则需要采用动态装入方式，装入内存后不立马把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行，因此钻杆如内存后所有地址为相对地址，需要要一个重定位寄存器支持。特点：可以把程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。   <img src="/2022/05198490/3.jpg" class>   <img src="/2022/05198490/105.jpg" class>   ②逻辑地址空间与物理地址空间：<br>编译后，每个目标模块都从0开始编址，称为该目标模块的相对地址（逻辑地址），当链接程序链接成一个完整可执行程序时，链接程序顺序依次按照各个模块的相对地址构成统一的0号单元开始编址的逻辑地址空间。<br>而物理地址空间指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后通过物理地址从主存中获取，当装入程序将可执行代码装入内存时必须把逻辑地址转换为物理地址，这个过程称为重定位。<br>③内存保护：<br>内存分配前，保护OS不受用户进程影响，同时保护用户进程不受其他进程影响：<br>Ⅰ在CPU中设置上，下限寄存器，存放用户作业在主存中的上下限地址，每当CPU访问地址分别和上下限对比，判断是否越界。  <img src="/2022/05198490/106.jpg" class>   Ⅱ采用重定位寄存器和界地址实现保护：重定位寄存器含最小物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。  <img src="/2022/05198490/4.jpg" class>   <h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3>多道程序环境下扩充内存的两种方法。</li><li>覆盖：由于程序运行时不是任何时候都需要访问程序和数据各个部分，所以把用户空间分成一个固定区和若干覆盖区，活跃部分放在固定区，其余部分按照调用关系进行分段，把即将访问的段放入覆盖区，其他段放入外存，需要调用再调入覆盖区，替换覆盖区中原有段。<br>特点就是打破了全部信息装入内存后才能运行的限制，但同时运行代码大于主存的时候仍然不能运行，此外内存更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。  <img src="/2022/05198490/107.jpg" class>     </li><li>交换：把处于等待状态的程序从内存转到辅存，把内存空间腾出来，称为换出。把准备竞争CPU运行的程序从辅存移动到内存，这一过程又称为换入。（中级调度就是交换技术）PCB仍然在内存中<br>特点就是主要在不同进程之间进行，而覆盖是同一个进程中。   <h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3></li><li>指为一个用户程序分配一个连续的内存空间，包括单一连续分配和固定分区分配和动态分区分配。  </li><li>单一连续分配：系统分为系统区和用户区，系统区仅仅让OS使用，通常在低地址部分。这种方式无须内存保护，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。优点就是简单，无外部碎片，可以用覆盖技术。缺点是只用于单道程序系统。  <img src="/2022/05198490/108.jpg" class>  </li><li>固定分区分配：最简单的多道程序存储管理方式，把用户内存空间划分为若干固定大小区域，每个分区只装入一道作业，当有空闲分区时便可以再从后备作业队列选择适当大小作业装入分区，而划分分区还有两种方法：①分区大小相等②分区大小不等（多个小分区，适量中分区，少量大分区）<br>为了便于内存分配，通常按分区大小排队，建立分区说明表（包括每个分区起始地址，大小，状态是否分配）  <img src="/2022/05198490/5.jpg" class>   问题：程序可能大到任何分区装不下。且主存利用率低，当程序小于固定分区大小的时候也浪费了分区空间（称为内部碎片）。  <img src="/2022/05198490/109.jpg" class>  <img src="/2022/05198490/110.jpg" class>  </li><li>动态分区分配：进程装入内存时根据内存大小动态建立分区，使得分区大小合适进程。分区的大小和数目都是可变的。开始分配时是好的，但随着分配进行会产生若干小的内存块，这些小的内存块称为外部碎片，为了克服外部碎片通过“紧凑”技术来解决（OS对于进程的移动和整理）<br>记录空闲分区：  <img src="/2022/05198490/111.jpg" class>  分配空闲分区：<br>首次进程装入主存，OS确定分配哪个内存块给进程使用，分配策略算法：<br>①首次适应算法（First Fit）：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到第一个大小满足要求的第一个空闲分区。<br>②最佳适应算法（Best Fit）：空闲分区按照容量递增形成分区链，找到第一个满足要求的空闲分区。会产生越来越多外部碎片。<br>③最坏适应算法（Worst Fit）：空闲分区按照容量递减形成分区链，找到第一个满足要求的空闲分区。大进程到来的时候没有空间存放。<br>④邻近适应算法（Next Fit）：由首次适应算法演变而来，分配内存时从上次查找结束的位置开始继续查找。<br>！！！首次适应算法效果最好！！！<img src="/2022/05198490/113.jpg" class>  <img src="/2022/05198490/6.jpg" class>   <img src="/2022/05198490/112.jpg" class>  <h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3></li><li>允许一个程序分散装入不相邻的内存区，也根据分区大小是否固定，分为分页存储管理方式和分段存储管理方式。</li><li>分页存储模式又根据运行作业时是否把作业所有页面都撞入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式，只介绍基本分页存储管理方式。<br>①基本分页存储管理方式：<br>固定分区产生内部碎片，动态分区产生外部碎片，内存利用率都比较低。为了避免碎片产生，引入分页思想：把主存空间划分为大小相等且固定的块，作为主存的基本单位，进程也以块为单位进行划分，进程在执行以块为基本单位逐个申请主存中的块空间。<br>类似于固定分区，但本质不同：块大小比分区小很多，而且进程也按照块进行划分，所以即使有内部碎片也是很小的（页内碎片）。</li></ul><p>–几个基本概念：<br>Ⅰ页面和页面大小：进程中的块称为“页”，内存中的块称为“页帧Page Frame”。外存也以同样的单位进行划分，直接称为块Block，进程执行需要申请主存空间，即要为每个页面分配主存中可用页帧，产生了页和页帧的一一对应。为了方便地址转换，页面大小应该是2的整数幂，大小适中。页面太小会使得进程页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面转入转出的效率。页面过大又会使页内碎片增多，降低内存利用率，所以大小应该适中，要在空间效率和时间效率间抉择。  </p><img src="/2022/05198490/114.jpg" class>  <p>Ⅱ地址结构：页号P和页内偏移量W。地址长度为32位，0-11为页内地址，每页大小为4KB，12-31位为页号，地址空间最多允许2的20次方页。  </p><img src="/2022/05198490/115.jpg" class>   <img src="/2022/05198490/116.jpg" class>  <p>Ⅲ页表：为了便于内存中查找进程每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般放在内存中。页表由页表项组成的，第一部分是页号，第二部分与地址结构的第二部分共同组成物理地址。配置页表之后，进程执行时，通过查找该表，找到每页在内存中的物理块号。  </p><img src="/2022/05198490/9.jpg" class>   <img src="/2022/05198490/117.jpg" class>  <p>–基本地址变换机构：<br>地址变换机构的任务是将逻辑地址转换为内存中的物理地址，地址变换是借助页表实现的。页表寄存器（存放页表起始地址，存放页表长度）  </p><img src="/2022/05198490/7.jpg" class>   <p>每次访问存储操作都需要从逻辑地址到物理地址，转换地址过程必须足够快，否则访问速度会降低。每个进程引入页表，用户存储映射机制，页表不能太大否则内存利用率降低。  </p><img src="/2022/05198490/118.jpg" class> <p>–具有快表的地址变换机构：<br>局部性原理：  </p><img src="/2022/05198490/119.jpg" class>  <p>若页表全部放在内存中，存取一个数据&#x2F;指令至少访问两次内存，第一次是访问页表获取物理地址，第二次是存取数据&#x2F;指令，显然比通常执行指令慢了一半。<br>为此增设了一个并行查找能力的告诉缓冲存储器——快表，又称TLB，用来存放当前访问的若干页表项，加速地址变化的过程，而主存中的页表常称为慢表。  </p><img src="/2022/05198490/8.jpg" class>   <img src="/2022/05198490/120.jpg" class>   <p>–两级页表：<br>整个页表需要连续存储内存中，但一级页表可能太大了，所以定义了两级页表。<br>逻辑结构是一级页号+二级页号+页内偏移。为了压缩页表，进一步延申页表映射的思想。  </p><img src="/2022/05198490/121.jpg" class>  <p>②基本分段存储管理方式：<br>分页管理目的为了提高内存利用率，通过硬件实现。而分段提出考虑了用户和程序员，满足方便编程，信息保护和共享，动态增长，等多方面需要。  </p><img src="/2022/05198490/122.jpg" class>  <p>Ⅰ分段：按照用户进程中的自然段划分逻辑空间。每段从0开始编址，并且分配一段连续的地址空间，其逻辑地址由段号S和段内偏移量W两部分组成。段号16为，偏移量16位，一个作业最多2的16次方&#x3D;65536段，最大段长为64KB。（页系统的S和W对于用户透明，而端系统则是由用户提供的）  </p><img src="/2022/05198490/10.jpg" class>   <img src="/2022/05198490/123.jpg" class>  <p>Ⅱ段表：每个进程都有一个逻辑空间与内存空间映射的段表。  </p><img src="/2022/05198490/11.jpg" class>   <p>配置表之后，执行中的进程可以通过查找段表，找到每段所对应的内存区。  </p><img src="/2022/05198490/12.jpg" class>   <img src="/2022/05198490/124.jpg" class>  <p>Ⅲ地址变换机构：实现进程从逻辑地址到物理地址的变换功能，再系统设置了段表寄存器，用于存放段表起始位置F和段表长度M。段表寄存器（段表起始地址，段表长度）   </p><img src="/2022/05198490/13.jpg" class>   <img src="/2022/05198490/125.jpg" class>   <p>Ⅳ段的共享和保护：通过两个作业的段表中响应表项指向被共享的段的同一个物理副本来实现的，不能修改的数据和代码可以共享。  </p><ul><li>分段分页对比：  <img src="/2022/05198490/126.jpg" class>   ③段页式管理方式：<br>作业地址空间首先分成若干逻辑段，每段都有自己段号，段分成若干大小固定的页，内存仍然分成和页面大小相同的块。   <img src="/2022/05198490/127.jpg" class>   <img src="/2022/05198490/128.jpg" class>  <img src="/2022/05198490/129.jpg" class>   <h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3></li><li>传统存储方式特征：①一次性：作业一次性装入内存，才可以运行，但如果作业大无法装入，且大量作业同时运行无法满足只能少部分作业先运行，多道程序度降低。②驻留性：作业装入之后不换出 ，可能长期等待状态。  </li><li>局部性原理：高速缓存依赖的就是局部性原理，有两方面：①时间局部性：程序中指令和数据可能大量循环执行。②空间局部性：程序访问某个存储单元，不久之后附近的存储单元也将被访问，即程序一段时间内访问的地址可能是集中在一定范围内。<br>时间局部性通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存层次结构实现。空间局部性通常使用较大的高速缓存，并把预处理机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器机构，利用局部性原理实现高速缓存。  <img src="/2022/05198490/130.jpg" class>   </li><li>虚拟存储器的定义和特征：<br>基于局部性原理，程序装入时，把程序的一部分装入内存，其余部分留在外存，就可以启动程序运行。在程序执行过程中，当所访问信息不在内存时，由OS将所需的部分调入内存继续执行程序，OS把不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这时系统好像为用户提供了一个比实际内存大得多的存储器称为虚拟存储器。<br>只是由于系统提供了部分装入，请求调出和置换功能之后，给用户感觉像存在一个比实际内存大得多的存储器。大小由计算机地址结构决定，并不是内存+外存，特征有：①多次性：作业无须一次性全部装入内存，允许多次调入内存运行。②对换性：作业无须一直等待在内存中， 允许换进换出。③虚拟性：逻辑上扩充内存容量。  </li><li>虚拟内存技术实现：<br>允许一个作业多次调入内存，所以采用连续分配方式时使得相当一部分内存处于空闲，所以需要建立在离散分配的内存管理方式的基础上。<br>有三种方式：请求分页存储管理，请求分段存储管理，请求段页式存储管理。但无论哪种方式都需要硬件支持：一定容量内存和外存，页表机制，中断机构，地址变换机构。<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3></li><li>建立在基本分页系统基础上，为了支持虚拟存储区功能而增加了“请求调页”和“页面置换”功能，也是最常用的方法。请求分页管理方式中：只要求让当前需要的一部分页面装入内存便可开始运行作业，当访问页面内存中不存在时，再通过调页功能将其调入，同时还可以通过页置换功能把暂时不用的页面换出到外存，腾出内存空间。  </li><li>页表机制：  <img src="/2022/05198490/14.jpg" class>  比基本分页管理中页表项多个4个字段：<br>①状态位P：用于指示该页是已经调入内存。<br>②访问字段A：记录本页一段时间内被访问次数（页置换时使用）。<br>③修改位M：标识该页调入内存中是否被修改过。<br>④外存地址：该页外存上的地址，通常是物理块号。   <img src="/2022/05198490/131.jpg" class>   </li><li>缺页中断机构：<br>访问页面不在内存中，便产生缺页中断，请求操作系统把所缺少的页调入内存，此时应该把缺页的进程阻塞，若内存有空闲块，则分配一个块，把调入的页传入该块，并修改页表中相应页表项，无空闲块则要淘汰某页（淘汰的页如果修改过则要写回外存）。<br>缺页中断作为中断，同样经历中断的几个步骤，但有两个明显区别：①在指令执行期间而非之后产生和处理中断信号，属于内部中断。②一条指令执行期间，可能产生多次缺页中断。  </li><li>地址变换机构：<br>是在分页系统地址变换机构的基础上，为实现虚拟内存，增加了某些功能而形成的。地址变换时，先检索快表。  <img src="/2022/05198490/15.jpg" class>   <img src="/2022/05198490/132.jpg" class>   <h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3></li><li>进程运行访问页面不在内存中而需要把它调入，但内存已无空闲空间，就需要从内存中调出一页程序或数据送入磁盘的对换区。选择调出的页面算法就是页置换算法，好的页置换算法应该有较低的页面置换频率。追求最少的缺页率！！！      </li><li>最佳置换算法OPT：<br>选择淘汰的页面是以后永不使用的页面，或是在最长时间内不再访问的页面，以保证最低的缺页率（但未知进程下不知道哪个是最长不被访问的，所以无法实现），但可以用作评价其他置换算法。  <img src="/2022/05198490/16.jpg" class>   </li><li>先进先出页面置换算法FIFO：<br>优先淘汰先进入内存的页面，即留在内存最长时间的页面，但算法跟实际运行规律不符。<br>而且FIFO算法还会产生所分配的物理块增大而页故障数不减反增的异常现象（Belady异常），而LRU和OPT算法不会出现Belady异常。   <img src="/2022/05198490/17.jpg" class>   </li><li>最近最久未使用置换算法LRU：<br>选择最长时间为访问过的页面淘汰，过去时间未访问过的页面将来也不会访问。OPT是向后看，而LRU是向前看。LRU性能较好。   <img src="/2022/05198490/18.jpg" class>   </li><li>时钟置换算法CLOCK：<br>LRU实现困难，开销大，且性能接近OPT。因此试图使用较小的开销但性能接近LRU的算法，都是CLOCK的变体。简单CLOCK算法给每帧关联一个附加位，称为使用位。当该页首次装入主存，使用位为1，随后再次被访问到时也为1。用于替换的候选帧集合视为一个循环缓冲区，并有一个指针与之关联，当某页被替换时该指针被设置指向缓冲区的下一帧，当需要替换一页时，OS把该位重新置为0。若开始过程时，缓冲区所有帧为0，则选择遇到第一个帧替换，若全为1，则指针在缓冲区完整循环一周，把所有使用位置为0，并停留在最初的位置，替换该帧的页，又称为最近未用算法(NRU)。<br>通过增加使用位数目，可以使得CLOCK算法更高效，再增加一个修改位，得到改进型CLOCK置换算法，则出现四种情况：<br>①最近未被访问，也未被修改（u&#x3D;0，m&#x3D;0）<br>②最近被访问，但也未被修改（u&#x3D;1，m&#x3D;0）<br>③最近未被访问，但被修改（u&#x3D;0，m&#x3D;1）<br>④最近被访问，也被修改（u&#x3D;1，m&#x3D;1）<br>算法步骤如下：<br>①指针从当前位置开始，扫描帧缓冲区，对使用位不作任何修改，选择遇到的第一个帧（u&#x3D;0，m&#x3D;0）用于替换。<br>②若①失败，则重新扫描，查找（u&#x3D;0，m&#x3D;1）的帧，选择第一个这样的帧替换，对于每个跳过的帧，使用位都设置为0.<br>③若②失败，则指针回到最初位置，且集合中所有帧使用位为0，重复①，若有必要重复②。  <h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3></li><li>“调多少，啥时候调，哪里调”</li><li>驻留集大小：给进程分配的物理块集合<br>对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程所有页读入主存，因此OS决定读取多少页，即决定给特定的进程分配几个页框，就是这个进程的驻留集，考虑以下几点：<br>①分配给一个进程存储量越小，任何时候驻留在主存中的进程数越多，提高处理机时间利用率。<br>②一个进程主存中页数过少，则尽管有局部性原理，但页错误率仍然较高。<br>③页数过多，则局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显影响。</li></ul><p>基于这些因素，OS常采用三种策略：<br>①固定分配局部置换：物理块数量固定，数目不好确定，太少频繁缺页中断，太多资源利用率下降。<br>②可变分配全局置换：易实现，进程分配一定物理块，OS内也有空间物理块，发生缺页就去拿一个物理块给进程，并调页进其中，更加灵活。但盲目加物理块导致多道程序并发能力下降。<br>③可变分配局部置换：从该进程在内存的页面中选出一页换出，频繁换页则分配物理块，若缺页率低则减少物理块。不仅动态增加，还能减少，保证系统均衡。  </p><ul><li><p>调入页面时机：<br>两种策略：<br>①预调页策略：根据局部性定理，一次调入若干页可能比逐次搞笑，但调入很多未访问则是低效。所以预测为基础的预调页策略，预计不久之后被访问的页面预先调入内存。<br>②请求调页策略：进程运行中需要请求调页。缺点就是一次只能调一页。<br>实际上预调页就是运行前调入，请求调页就是运行期间调入，一般两种策略同时使用。  </p></li><li><p>从何处调入页面：<br>请求分页系统中的外存分为两部分：用于存放文件的文件去和用于存放兑换页面的对换区。对换区常用连续分配方式，文件区用离散分配方式，因此对换区IO速度比文件区更快，有三种情况：<br>①系统拥有足够对换区空间：可以全部从对换区调入页面，提高调页速度，所以进程运行前把所有的所需文件从文件区复制到对换区。<br>②系统缺少足够对换区空间：凡是不会被修改的文件都直接从文件区调入，修改的部分需要调入对换区，再从对换区调入内存。<br>③UNIX方式：与进程有关文件都放在文件区，因此未运行过的页面都在文件区调入，曾经运行过的放在对换区，因此下次调入时应从对换区调入。  </p><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>页面置换时一种最糟糕情形是刚刚换出页面马上换入主存，频繁的页面调入行为就是抖动&#x2F;颠簸，若一个进程在换页时间多于执行时间，则这个进程就在颠簸。主要原因就是，某个进程频繁访问的页面数目高于可用的物理页帧数（分配的物理块不够，太多降低并发度）。  </p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>指某段时间间隔内，进程要访问的页面集合，可用最近访问过的页面确定工作集。一般说，工作集W可由时间t和工作窗口大小来确定。   </p><img src="/2022/05198490/19.jpg" class>   <img src="/2022/05198490/133.jpg" class>   <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/05198490/20.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/051838008.html"/>
      <url>/2022/051838008.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>Apache Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p></li><li><p>项目管理工具：编译、测试、运行、打包（jar、war）、部署</p></li><li><p>依赖管理</p></li><li><p>下载</p><p>地址：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><img src="/2022/051838008/1.jpg" class>   </li><li><p>安装、配置</p><ul><li><p>直接解压即可</p></li><li><p>配置环境变量：</p><ul><li>M2_HOME&#x3D;&gt;maven解压目录</li><li>修改 path&#x3D;》添加 %M2_HOME%\bin</li></ul></li><li><p>测试：mvn -v</p></li></ul></li><li><p>maven仓库</p><ul><li>本地仓库：本地的一个文件夹</li><li>中央仓库：世界唯一，由maven社区维护（网站）</li><li>远程仓库：是位于web服务器上的一个私有仓库，由自己公司创建和维护</li><li>镜像仓库：是中央仓库的镜像（副本），目的是加快依赖jar包的下载速度</li></ul></li><li><p>修改maven配置</p><ul><li><p>修改：maven安装目录下的 conf&#x2F;settings.xml</p><ul><li><p>修改本地仓库位置：</p><pre><code>&lt;localRepository&gt;D:\mavenrepository&lt;/localRepository&gt;</code></pre></li><li><p>配置阿里云镜像</p></li></ul><pre><code>&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;nexus-aliyun&lt;/id&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;name&gt;Nexus aliyun&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre></li></ul></li><li><p>在 Idea 中配置</p><ul><li><p>进入 settings</p><img src="/2022/051838008/2.jpg" class>   </li><li><p>配置maven</p><img src="/2022/051838008/3.jpg" class></li></ul></li><li><p>Eclipse配置配置</p><ul><li><p>配置maven位置：</p><img src="/2022/051838008/4.jpg" class>   </li><li><p>配置maven的配置文件：</p><p>首选项&#x3D;》maven&#x3D;》User settings &#x3D;》选择settings.xml文件</p><img src="/2022/051838008/5.jpg" class></li></ul></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>maven的目录结构</p><p>src：源程序目录</p><p>​main：源程序</p><p>​java：程序</p><p>​resources：资源文件(配置文件)</p><p>​webapp:web项目（不是web项目没有）</p><p>​test：测试代码</p><p>target：项目生成的结果</p></li><li><p>创建maven项目</p><ul><li><p>maven project 向导</p></li><li><p>配置三个坐标（定位唯一的jar包）</p><ul><li>groupId：组织或公司的域名</li><li>artifactId：组件名（项目名）</li><li>version：版本号</li></ul></li><li><p>打包方式</p><ul><li>jar（默认打包方式，控制台项目或window项目）</li><li>war（web项目）</li><li>pom（maven的管理项目）</li></ul></li><li><p>配置 pom.xml</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.neu&lt;/groupId&gt;  &lt;artifactId&gt;test3&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;path&gt;/&lt;/path&gt;                    端口号                    &lt;port&gt;8089&lt;/port&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;webResources&gt;                        &lt;resource&gt;                            &lt;excludes&gt;                                &lt;exclude&gt;**/WEB-INF/web.xml&lt;/exclude&gt;                            &lt;/excludes&gt;                            &lt;directory&gt;src/main/webapp&lt;/directory&gt;                        &lt;/resource&gt;                    &lt;/webResources&gt;                   &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li></ul><ol start="3"><li><p>端口号冲突，解决方法</p><ul><li><p>把原来使用该端口的程序关闭</p><ul><li>在eclipse中关闭</li><li>在任务管理器中关闭 java 进程 或 javaw进程</li></ul></li><li><p>修改当前tomcat服务的端口号，改成与之前冲突不一样即可</p><pre><code>&lt;port&gt;8089&lt;/port&gt;</code></pre></li></ul></li><li><p>web项目</p><ul><li><p>打包方式</p><pre><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></pre></li><li><p>idea中运行</p><ul><li>maven面板中，选中项目</li><li>在 plugins 中选择 tomcat7 &#x3D;》tomcat7：run&#x3D;》右键&#x3D;》Run Maven Build</li></ul></li><li><p>eclipse中运行</p><p>maven build</p><pre><code>tomcat7:run</code></pre></li><li><p>配置 tomcat插件</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;path&gt;/&lt;/path&gt;        &lt;!-- 端口号 --&gt;        &lt;port&gt;8089&lt;/port&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre></li></ul><ol start="5"><li><p>从maven仓库中搜索并添加jar包</p><ul><li>进入maven中央仓库网站（<a href="https://mvnrepository.com/%EF%BC%89">https://mvnrepository.com/）</a></li><li>在搜索栏中输入关键字</li><li>在列表中查找需要的版本</li><li>拷贝“maven”中内容到pom.xml的 <dependencies>中</dependencies></li></ul></li><li><p>使用 JSTL</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;    &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt;    &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>测试：</p><pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    你好！    &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;pageNum&quot;&gt;        $&#123;pageNum&#125;    &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol></li></ol></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>clean：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。 </p></li><li><p>validate：验证工程是否正确，所有需要的资源是否可用。 </p></li><li><p>compile：编译项目的源代码。</p></li><li><p>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 </p></li><li><p>Package：把已编译的代码打包成可发布的格式，比如jar。</p></li><li><p>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</p></li><li><p>verify：运行所有检查，验证包是否有效且达到质量标准。</p></li><li><p>install：把包安装在本地的repository中，可以被其他工程作为依赖来使用。</p></li><li><p>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 </p></li><li><p>site：为项目生成文档站点。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程管理</title>
      <link href="/2022/051537005.html"/>
      <url>/2022/051537005.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><img src="/2022/051537005/1.jpg" class>  <h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><ul><li>进程的概念：多道程序环境下，允许多个程序并发执行，此时他们失去封闭性，并且具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</li><li>为了使参与并发执行的程序能独立运行，必须为之配备一个专门的数据结构称为进程控制块PCB，描述进程的基本情况和运行状态，进而控制和管理进程，由程序段，相关数据段和PCB三部分组成了进程映像。所谓创建进程，实质上是创建进程映像中的PCB，而撤销进程实际上也是撤销PCB，即PCB是进程存在的唯一标志。</li><li>定义：进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个单位。就是“时间片”分配的独立单位。  </li><li>组织：  <img src="/2022/051537005/101.jpg" class>  </li><li>特征：进程是由多道程序的并发执行引出的，它和程序完全不同：<br>①动态性：进程是程序的一次执行，有着创建，活动，暂停，终止等过程，有生命周期，动态性是其最基本特征。<br>②并发性：指多个进程同时存在内存中，可以同时运行。<br>③独立性：指进程实体是一个能够独立运行，获得资源和接收调度的基本单位，必须有PCB。<br>④异步性：由于进程相互制约，进程具有执行的间断性，即按照各自独立不可预知的速度前进，异步性导致结果不可再现性，为此必须配置相应的进程同步性。<br>⑤结构性：每个进程都配置一个PCB进行描述，结构上看进程实体由程序段，数据段，PCB组成。  <h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3></li><li>三种基本状态：  <img src="/2022/051537005/102.jpg" class>  </li><li>进程动态性，环境动态性，通常5种状态：<br>①运行态：正在运行单处理机环境下，只有一个进程处于运行状态。<br>②就绪态：进程已经获得了除处理机外所有资源，一旦得到处理机可以立即执行，通常有多个就绪进程为就绪队列。<br>③阻塞态&#x2F;等待态：进程等待某个事件，即使处理机空闲也无法执行。<br>④创建态：正在被创建：首先申请PCB，向PCB填写一些控制和管理进程的信息，然后由系统为该进程分配运行时必要资源，最后把该进程转成就绪态。<br>⑤结束态：进程正在消失，可能是进程正常结束或其他原因中断退出运行。先置为结束态再释放资源和回收等工作。</li><li>五种状态转换：<br>①就绪态-&gt;运行态：就绪态进程被调度指挥，获得处理机资源进入运行态。<br>②运行态-&gt;就绪态：时间片用完了，让出处理机转为就绪态，还有可能是更高优先级的进程就绪的时候抢占处理机。<br>③运行态-&gt;阻塞态：进程请求某资源的使用和分配或等待某事件发生时，从运行态变为阻塞态。<br>④阻塞态-&gt;就绪态：进程等待的事件到来，只等处理机了。  <img src="/2022/051537005/2.jpg" class>  <img src="/2022/051537005/103.jpg" class>  <h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3></li><li>主要功能就是对系统中所有进程有效管理，具有创建，撤销，状态转换等功能。一般进程控制的程序段称为原语，特点就是原子性，不可分割的基本单位。  <img src="/2022/051537005/104.jpg" class>   </li><li>如何实现控制：  <img src="/2022/051537005/105.jpg" class>   <img src="/2022/051537005/106.jpg" class>   使用原语只做三件事情：更新PCB信息，把PCB插入合适队列，分配&#x2F;回收资源</li><li>进程创建：<br>允许一个进程创建另一个，父子进程。子进程继承父进程的资源，撤销时归还给父进程，撤销父进程时撤销所有子进程。过程：<br>①为新进程分配一个唯一进程标识号，申请空白PCB。PCB申请失败则创建失败。<br>②为进程分配资源，必要的内存，若资源不足，进程进入阻塞态等待内存资源。<br>③初始化PCB，包括初始化标志信息，初始化处理机状态信息，控制信息，进程优先级等。<br>④若进程就绪队列能够接纳新进程，就插入就绪队列等待被调度运行。  <img src="/2022/051537005/107.jpg" class>   </li><li>进程终止：<br>引起终止的事件有：①正常结束。②异常结束（非法指令，运行超时，IO故障）。③外界干扰（外界请求终止，人工干预&#x2F;父进程撤销等），过程：<br>①根据进程标识符，检索PCB，读出进程状态。<br>②若处于执行状态，立即终止，把资源分配给其他进程。<br>③若有子孙进程，全部终止。<br>④把所有资源，归还给父进程或OS。<br>⑤把PCB删除。  <img src="/2022/051537005/108.jpg" class>   </li><li>进程阻塞和唤醒：<br>阻塞（主动）就是运行态中等待某事件发生，调用原语Block，过程：<br>①找到进程标识号和PCB。<br>②若执行态则保护现场，转为阻塞态。<br>③把该PCB插入相应事件的等待队列，把处理机分配给其他进程。<br>等待事件发生，调用原语Awake，过程：<br>①找到进程标识号和PCB。<br>②从等待队列移除，变为就绪态。<br>③把该PCB插入就绪队列，等待调度程序调度。  <img src="/2022/051537005/109.jpg" class>   </li><li>进程切换：<br>处理机从一个进程运行转到另一个进程运行，过程：<br>①保存处理机上下文，包括程序计数器和其他寄存器。<br>②更新PCB信息。<br>③把进程的PCB移入相应队列，如就绪队列，等待队列等。<br>④选择另一个进程执行，更新其PCB。<br>⑤更新内存管理的数据结构。<br>⑥恢复处理机上下文。  <img src="/2022/051537005/110.jpg" class>   <h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3></li><li>PCB：进程存在唯一标志，通过PCB管理控制进程。  <img src="/2022/051537005/3.jpg" class>  ①进程描述信息：进程标识符（标识各个进程，唯一），用户标识符（标识进程归属用户）<br>②进程控制和管理信息：进程当前状态（状态信息，作为分配调度的依据），进程优先级。<br>③资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的IO设备信息。<br>④处理机相关信息：主要处理处理机中各寄存器值，当进程切换时，处理机状态信息必须保存在PCB中，重新执行可以从断点继续执行。  </li><li>程序段：能够被进程调度程序调度到CPU执行的程序代码段，多个程序可能有同一个代码段。  </li><li>数据段：可以是进程对应程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。  <h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3></li><li>定义：进程之间信息交换。<br>高级通信方法有三类：共享存储，消息传递，管道通信。  </li><li>共享存储：  <img src="/2022/051537005/111.jpg" class>   </li><li>管道通信：  <img src="/2022/051537005/112.jpg" class>   </li><li>消息传递：  <img src="/2022/051537005/113.jpg" class>   <h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3></li><li>线程的基本概念：<br>引入进程目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。而引入线程的目的是减小程序在并发执行时所付出的时空开销，提高OS的并发性能。线程最直接的理解就是轻量级“进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID，程序计数器，寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调用和分派的基本单位，线程自己不具有系统资源，只拥有一点运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程中的全部资源，一个线程可以创建&#x2F;撤销另一个线程，也可以并发执行，也有三种状态：就绪，阻塞和运行。引入线程之后，进程只作为CPU之外系统资源分配单元，而线程是处理机分配单元，由于一个进程内部多个线程，则线程切换开销小。   <img src="/2022/051537005/114.jpg" class>    </li><li>比较：<br>①调度：线程是独立调度的基本单位，进程是拥有资源的基本单位。<br>②拥有资源：进程是拥有资源的基本单位，而线程没有，但可以访问隶属进程的资源，提出线程就是为了切换线程时开销小，否则没有意义。<br>③并发性：进程线程均可以并发执行，使得操作系统更好的并发性，提高系统吞吐量。<br>④系统开销：由于进程增删，系统都要分配回收资源，开销远大于线程增删。进程切换的时候，涉及当前执行进程的CPU环境保存和新调度进程CPU环境读取，线程切换只需要保存和设置少量寄存器内容，开销很小。且线程同步与通信很容易实现。<br>⑤地址空间和其他资源：进程的地址空间相互独立，而同一个进程内线程共享。<br>⑥通信方面：进程之间通过线程同步和互斥手段辅助，而线程之间读写进入程序数据段来通信。  </li><li>线程的属性：<br>多线程OS把线程作为独立运行的基本单位，此时进程不是基本可执行实体，但仍然具有执行状态，所谓的“执行”状态，就是其中线程在执行，线程主要属性如下：<br>①线程是一个情形实体，不拥有系统资源，但每个线程有唯一标识符和线程控制块（记录线程执行的寄存器和栈等现场状态）<br>②不同线程可以执行相同程序，即同一个程序不同用户调用也是不同线程。<br>③同一个进程中各个线程资源共享。<br>④线程是处理机的独立调度基本单位，多个线程可以并发执行。<br>⑤线程创建之后开启生命周期，直至终结。  <img src="/2022/051537005/115.jpg" class>    </li><li>线程的实现方式：<br>两类实现方式用户级线程（ULT），内核级线程（KLT）。<br>①用户级线程：有关线程管理的工作都应用程序完成，内核意识不到线程存在，应用程序可以通过使用线程库设计成多线程程序，通常应用程序从单线程程序开始，在该线程中运行，运行任何时刻都可以调用线程库中创建新线程。<br>②内核级线程：线程管理所有工作都由内核完成，应用程序通过调用接口。内核为进程及其内部的每个线程维护上下文信息，调用也在内核基于线程构架基础上完成。<br>③组合方式：线程创建，调度，同步在用户空间，映射到一些内核级线程上。  <img src="/2022/051537005/4.jpg" class>  </li><li>多线程模型：<br>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的联机方式。<br>①多对一模型：多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见。<br>②一对一模型：每个用户级线程映射到一个内核级线程。<br>③多对多模型：把n个用户级线程映射到m个内核级线程。m小于等于n。  <img src="/2022/051537005/116.jpg" class>    <h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3></li><li>基本概念：从就绪队列中按照一定算法选择一个进程并把处理机分配给它运行，以实现进程并发地执行。  </li><li>调度的层次：一个作业从提交到开始，往往经历三级调度：<br>①作业调度：又称高级调度，其主要任务是按一定的原则从外存上处于后备的作业中挑选作业给他们分配资源，建立相应的进程，使得他们获得竞争处理机的机会，就是内存与辅存之间的调度。执行频率低，几分钟一次。<br>②中级调度：又称内存调度，其作用是提高内存利用率和系统吞吐量，为此应将那些暂时不能运行的进程调至外存等待，此时进程状态为挂起态，当他们已经具备运行条件且内存又稍有空闲的时候，由中级调度决定把外存上那些就绪进程调入内存，修改其状态为就绪态，在就绪队列上等待。<br>④进程调度：又称低级调度，主要任务就是按照某些策略从就绪队列中选取一个进程分配处理机，频率很高，几十毫秒一次。  <img src="/2022/051537005/5.jpg" class>   </li><li>三种调度联系：<br>作业调度从外存的后备队列选择一批作业进入内存，为他们建立进程，送入就绪队列，进程调度从就绪队列选出一个进程运行，把CPU分配给它。而中级调度是为了提高内存利用率，系统将那些暂时不运行的进程挂起来，当内存宽松的时候，通过中级调度选择具备运行条件的进程唤醒。（进程调度不可或缺，最基本的）  <img src="/2022/051537005/117.jpg" class>    <h3 id="调度的时机，切换和过程"><a href="#调度的时机，切换和过程" class="headerlink" title="调度的时机，切换和过程"></a>调度的时机，切换和过程</h3></li><li>进程调度和切换程序是OS内核程序，现代OS中不可以进行进程调度和切换的情况有：<br>①处理中断过程中。<br>②进程在OS内核程序临界区中，临界区独占式访问共享数据，并行程序无法进入。<br>③其他需要完全屏蔽中断的原子操作过程中。  </li><li>应发生调度和切换的情况有：<br>①发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换，非剥夺调度。<br>②中断处理结束或trap处理结束，返回被中断进程的用户态程序执行现场签，可以马上进行进程调度和切换，剥夺调度。  <img src="/2022/051537005/118.jpg" class>    <h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3>指当某个进程正在处理机上执行，若有更重要的进程需要处理，则优先权更高的进程进入就绪队列，此时应该如何分配处理机，通常两种方式：<br>①非抢占方式：正在执行任务执行完再给更重要的任务配分。即一旦把CPU分配给一个进程，就会保持CPU直到终结或等待态。优点就是实现简单，开销小，适用于大多数批处理系统，单不用于分时系统和大多数实时系统。<br>②抢占方式：立即暂停正在执行进程，把处理机给更重要的进程。对于提高系统吞吐量和响应效率都有益处，但必须有原则地进行抢占。  <h3 id="调度的基本准则-x2F-评价指标"><a href="#调度的基本准则-x2F-评价指标" class="headerlink" title="调度的基本准则&#x2F;评价指标"></a>调度的基本准则&#x2F;评价指标</h3>调度算法考虑的评价准则，主要考虑以下几种：<br>①CPU利用率：使CPU尽可能忙。<br>②系统吞吐量：单位时间内CPU完成作业数量，长作业需要长时间处理，降低系统吞吐量，而短作业提高吞吐量，所以不同调度方式对于吞吐量影响大。<br>③周转时间：指从作业提交到完成经历时间，是作业等待，在就绪队列排队和处理机上运行及IO花费时间总和。<br>④等待时间：指进程处于等待处理机时间之和，单纯考虑等待时间即可评判算法好坏。<br>⑤响应时间：指从用户提交请求到系统首次响应所用的时间。<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3></li></ul><p>———–早期批处理系统———–   </p><ul><li>先来先服务调度算法FCFS：<br>最简单的算法，最先进入队列的作业调入内存分配资源，创建进程并放入就绪队列。  <img src="/2022/051537005/6.jpg" class>   属于非抢占算法，所有作业公平，但长作业会使得后边的短作业等待时间过长，所以不能作为分时系统和实时系统的策略，但常跟其他策略结合。算法简单，效率低，有利于CPU繁忙型作业，不利于IO繁忙型作业。  <img src="/2022/051537005/119.jpg" class>    </li><li>短作业优先调度算法SJF：<br>从后备队列中选择若干运行时间短的作业把处理机分配给它，使之立即执行，直到完成&#x2F;发生某事件而阻塞时才释放处理机。（抢占式和非抢占式，默认非抢占式）  <img src="/2022/051537005/7.jpg" class>  该算法对于长作业不利，长作业出现可能长期都不被调度的“饥饿”现象。而且完全不考虑作业紧迫程度。作业时长是估计的并不准确，有可能长作业缩短很多，并不一定做到最短优先。  <img src="/2022/051537005/120.jpg" class>    </li><li>高响应比优先调度算法：<br>对于FCFC和SJF的平衡，考虑每个作业的等待时间和估计的运行时间。每次进行作业调度时先计算后备队列中每个作业响应比，找出最高的投入运行。响应比Rp&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间。<br>则作业等待时间相同的时候短作业有利，要求服务时间相同时先来先服务有利，对于长作业等待时间增大响应比就可以增大到很大，克服了“饥饿”现象。  <img src="/2022/051537005/121.jpg" class></li></ul><p>———–交互式操作系统———–</p><ul><li>时间片轮转调度算法：<br>主要适用分时系统，系统把所有就绪进程按到达时间排列FCFS，但仅仅有一个时间片，使用完时间片就让下一个进程使用。时间片大小对于系统性能影响很大，时间片很大所有进程都能在一个时间片内完成，则就是FCFS算法，时间片很小则处理机在进程之间频繁切换，使得开销增大，真正用于运行用户进程的时间减少，因此时间片大小应该选择适当。  <img src="/2022/051537005/122.jpg" class>    </li><li>优先级调度算法：<br>优先级就是作业紧迫程度。从后备队列中选择优先级最高的若干作业调入内存，分配资源创建进程放入就绪队列，每次只分配给当前优先级最高的作业处理机。<br>根据是否能抢占，又分为两种：非剥夺式优先级调度算法和剥夺式优先级调度算法，且进程优先级是否可以改变又把进程优先级分为两种：静态优先级（不改变，但确定优先级需要根据进程类型，对资源要求等）和动态优先级（改变，确定根据进程占有CPU时间长短，就绪过程等待CPU长短等）。<br>一般来说，进程优先级设置参照原则：<br>①系统进程&gt;用户进程。<br>②交互式进程&gt;非交互式进程。<br>③IO型进程&gt;计算型进程。  <img src="/2022/051537005/123.jpg" class>    </li><li>多级反馈队列调度算法（UNIX使用）：<br>融合了时间片轮转法和优先级调度算法，通过动态调整优先级和时间片大小。  <img src="/2022/051537005/8.jpg" class>   思想：<br>①设计多个就绪队列，每个队列不同优先级，优先级逐次降低。<br>②赋予各个队列进程执行时间片大小各不相同，优先级越高的队列时间片越小，时间片成1倍线性增长.<br>③一个新进程进入内存之后，首先把它放入第1级队列末尾，按照FCFS原则排队等待，若时间片内完成则撤离系统否则进入第2级队列末尾，同样进行下去。<br>④仅当第1级队列为空时，才调度第2级队列进行，若处理机正在第i级队列处理进程，1-i-1的队列加入优先级高的队列就会抢占当前处理机。<br>优点：<br>①终端型作业用户：短作业优先。<br>②短批处理作业用户：周转时间短。<br>③长批处理作业用户：经过前几个队列得到部分执行，不会出现“饥饿”现象。   <img src="/2022/051537005/124.jpg" class>   <h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3></li><li>异步性：各并发执行的进程以各自独立，不可预知的速度向前推进。为了解决异步，所以产生同步。    </li><li>多道程序环境下，进程是并发的，不同进程之间存在制约关系，为了协调进程之间的制约关系，所以出现了同步。（2+3*1，一定要让加法发生在乘法之后）  </li><li>同步：<br>同步亦称直接制约关系，指的是为了完成某种任务而建立起的若干进程，需要在某些位置上协调他们的工作次序而等待，传递信息所产生的制约关系。  </li><li>互斥：<br>互斥是间接制约关系，当一个进程进入临界区另一个就需要等待。  <img src="/2022/051537005/125.jpg" class>   </li><li>临界资源：<br>多个进程可以共享系统资源，但许多资源只能有一个进程独占，我们把一次仅允许一个进程使用的资源称为临界资源。（许多物理设备和变量数据）对于临界资源的访问必须互斥地进行，每个进程中访问临界资源的那段代码称为临界区，把访问临界资源分为四个部分：<br>①进入区：进入临界区使用临界资源，检查是否可以进，能进则设置正在访问标志，阻止其他进程访问临界区。<br>②临界区：访问临界资源的代码，又称临界段。<br>③退出区：把正在访问临界区的标志删除。<br>④剩余区：代码其余部分。   <img src="/2022/051537005/9.jpg" class>   <h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3></li><li>软件检查法：在进入区设置并检查一些标志来表明是否有进程在临界区，若有则循环检查进行等待，进程离开临界区后则在退出区修改标志。<br>①单标志法：设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。即turn&#x3D;0，允许P0进入临界区，每次只有一个进程进入临界区，而且两个进程必须交替进入，否则另一个进程也无法进入临界区，因为标志一直不变了。（违背“空则让进”）  <img src="/2022/051537005/10.jpg" class>   ②双标志先检测法：每个进程访问临界区之前，先查看临界资源是否被访问，正在访问则等待，否则可以进入临界区，设置flag[i]，false标识Pi未进入临界区，true标识进入临界区。（违背“忙则等待”）  <img src="/2022/051537005/11.jpg" class>   ③双标志后检测法：先检测可能同时进入，所以先把自己设置为true，再检测对方的状态，对方为true则等待，否则进入临界区。（违背“空则让进”）  <img src="/2022/051537005/12.jpg" class>   ④Peterson算法：防止两个进程为了进入临界区无期限等待，设置turn，每个进程先设置自己标志再设置turn，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时想进入临界区时只有一个能进入。设置自己flag为true，把turn设置为其他进程，然后检测是否其他进程为true，是则等待，否则进入临界区。利用flag解决临界资源的互斥访问，利用turn解决“饥饿”现象，但有“忙等”现象！！！。   <img src="/2022/051537005/13.jpg" class>      </li><li>硬件实现方法：通过硬件支持实现临界问题的方法称为低级方法&#x2F;元方法，三种方法都有“忙等”现象！！！。<br>①中断屏蔽方法：当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入就禁止一切中断发生，或称之为屏蔽中断，关中断（CPU只在中断的时候进行进程切换）<img src="/2022/051537005/14.jpg" class>   <img src="/2022/051537005/126.jpg" class>   ②硬件指令方法：  <img src="/2022/051537005/127.jpg" class>   <img src="/2022/051537005/128.jpg" class>   <img src="/2022/051537005/15.jpg" class>   ③硬件方法优点：任意数目进程都可以，简单，支持进程多个临界区。  <h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3></li><li>为了操作一气呵成不被打断，使用一对原语来实现进程互斥和同步。  </li><li>用来解决互斥问题的，只能被两个标准原语wait（S）和signal（S）访问，也就是P操作（占用资源）和V操作（释放资源）。原语是指完成某种功能且不被分割，不被中断执行的操作序列，通常硬件实现，<br>①整形信号量：仍然有“忙等”现象！！！wait——当s&lt;&#x3D;0则陷入循环，否则自减，signal——自增。<br>②记录型信号量：解决“忙等”现象！！！，wait——当s.value&lt;&#x3D;0则资源分配完毕，自我阻塞block，否则自减，分配资源。而signal——自增，释放一个资源wakeup，资源数增加1。<br>③利用信号量实现同步（信号量初始为0先V后P），互斥（信号量初始为1先P后V），前驱关系（先V后P）：设置一个进程公用的信号量S，并且根据需求进行初始化，V加P减，举例如下：  <img src="/2022/051537005/16.jpg" class>   <h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3>重在理解，信号量和缓冲区的运用。</li><li>生产者-消费者问题（多生产者-多消费者问题）  </li><li>读者-写者问题 </li><li>哲学家就餐问题  </li><li>吸烟者问题<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3></li><li>大量分散的同步操作麻烦且容易死锁，所以产生进程同步工具——管程，保证了进程互斥，无须人工实现，降低死锁发生可能性，同时提供了条件变量，程序员灵活实现同步。  </li><li>定义：系统中硬软件资源均可用数据结构描述其资源特性，对该结构实施的操作定义为一组过程。进程对共享资源的申请，释放等操作都通过这组过程实现，还可以根据资源情况或接收阻塞进程访问，确保每次仅有一个进程使用共享资源，这就可以统一管理共享资源访问，实现进程互斥，这个资源管理程序，就是管程。定义了一个数据结构和能为并发进程所执行的一组操作，能够同步进程和改变管程中的数据。  </li><li>组成：名称，局部与管程内部的共享数据结构说明，操作的一组过程，初始化语句。  </li><li>管程很像一个类CLASS，能够把共享资源封装起来，且每次允许一个进程进入管程，从而实现互斥。  <img src="/2022/051537005/129.jpg" class>   <img src="/2022/051537005/130.jpg" class>  <h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3></li><li>定义：多个进程并发执行带来死锁这个问题，多个进程因竞争资源而造成的相互等待的僵局。  </li><li><img src="/2022/051537005/131.jpg" class>  </li><li>产生原因：<br>①系统资源的竞争：<br>通常是系统中不可剥夺资源，数量不足需求，比如打印机。（不剥夺资源竞争不会死锁）<br>②进程推进顺序非法：<br>进程运行中请求和释放资源顺序不当，也会死锁（两个进程各自占着对面需要的资源），信号量也会产生死锁。（两个进程等待对方发来的消息）<br>③信号量使用不当也会造成死锁</li><li>死锁产生必要条件：<br>产生死锁必须同时满足4个条件：<br>Ⅰ：互斥条件：只有一个进程能够拥有该资源。<br>Ⅱ：不剥夺条件：资源未使用完不可被剥夺。<br>Ⅲ：请求并保持条件：进程至少已经保持了一个资源，并且提出了请求资源（该资源已被占有），此时请求失败，但还不放弃自己已经得到的资源。<br>Ⅳ：循环等待条件：存在一种进程资源的循环等待链，相当于一个环（12345，1的请求资源被2占有。。。5的资源被1占有）（循环等待存在不一定死锁，同类资源大于一个就不会死锁）  <img src="/2022/051537005/17.jpg" class>   <h3 id="死锁处理策略："><a href="#死锁处理策略：" class="headerlink" title="死锁处理策略："></a>死锁处理策略：</h3></li><li>死锁预防：设置某些限制条件，破坏4个必要条件，防止发生死锁。  </li><li>避免死锁：动态分配资源中，使用某种方法防止进入不安全状态，进而避免死锁。  </li><li>死锁检测和解除：允许死锁，及时检测并且接触即可。  <img src="/2022/051537005/18.jpg" class>   <h3 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h3></li><li>破坏互斥条件：不可行（肯定有资源是互斥的，有的可以，比如SPOOLing技术）  </li><li>破坏不剥夺条件：一个保持资源的进程得不到需要的资源就把拥有的全部资源释放。  </li><li>破坏请求并保持条件：设备申请就申请所有需要的资源，也就是说没有资源才可以申请。  </li><li>破坏循环等待条件：给系统中资源编号，每个进程必须按照递增顺序请求资源，即申请大于自己编号的资源。  <h3 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h3></li><li>系统安全状态：系统能够按照某种进程的推进顺序为每个进程分配所需资源，直到满足每个进程对于资源的最大需求，使每个进程都顺序完成，此时进程序列为安全序列，若系统中没有一个安全序列，则系统是不安全状态。并非不安全状态就是死锁状态，只是有可能是死锁状态，但只要是安全状态，系统就可以避免死锁状态。</li><li>银行家算法：最著名的死锁避免算法：三个矩阵一个向量（可用资源向量Available，最大需求矩阵Max，分配矩阵Allocation，需求矩阵Need，其中Need&#x3D;Max-Allocation），先分配资源，检查是否处于安全状态（安全性算法，求一个安全序列），安全则确定分配，不安全则取消分配。一定掌握！！！  <h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3></li><li>资源分配图：圆圈代表进程，框代表资源，其中从进程到资源的有向边称为请求边，反向则是分配边。  </li><li>死锁定理：<br>简化资源分配图就可以检测系统状态S是否为死锁，不可完全简化就是死锁的。（依次消除不阻塞进程结点所有边，完全简化只有孤点则无死锁）  <img src="/2022/051537005/19.jpg" class>    </li><li>死锁解除：<br>①资源剥夺法：挂起死锁进程，抢占其资源，把资源分配给其他死锁进程。<br>②撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源，撤销原则按照优先级和撤销进程代价高低进行。<br>③进程回退法：让一个&#x2F;多个进程回退到足够避免死锁的地步，要求系统保持历史状态，设置还原点。  <img src="/2022/051537005/132.jpg" class>  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/051537005/20.jpg" class>   </li><li>进程同步和互斥：<br>并发进程执行会产生相互制约的关系：一种是进程之间竞争使用临界资源，但只有一个能用，这是互斥，是竞争关系。而进程之间协同完成任务，某点上进程需要等待另一个进程发来的消息，以便协同一致，是一种协作关系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统计算机系统概述</title>
      <link href="/2022/051418462.html"/>
      <url>/2022/051418462.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><img src="/2022/051418462/5.jpg" class>   <h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><ul><li>软件是计算机系统的灵魂，而软件核心是操作系统。  </li><li>计算机系统从上到下分四个部分：硬件，操作系统，应用程序，用户。</li><li>操作系统管理各种计算机硬件，并且为应用程序提供基础，充当计算机硬件与用户之间的中介。</li><li>硬件比如：CPU，内存，IO设备等提供基本计算资源。应用程序如：字处理程序，编译器，浏览器等规定按照何种方式来使用这些计算资源解决用户的计算问题。操作系统就负责控制和协调各个用户的应用程序对硬件的分配和使用。  </li><li>定义：OS就是控制和管理整个计算机系统硬件与软件资源，合理组织和调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的集合，也是计算机系统中最基本的系统软件。 <h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3></li><li>OS是一种系统软件，但与其他系统软件和应用软件有很大不同，它有自己的特殊性即基本特征：并发，共享，虚拟，异步。（并发和共享是OS最基本特征，相互依赖，互为存在条件，没有共享性则不可能实现并发性，没有并发性则就没有共享性）   </li><li>并发Concurrence：<br>两个或多个事件在同一个时间间隔内发生，OS具有处理和调度多个程序同时执行的能力，同时引入进程的目的就是让程序可以并发执行。<br>注意同一时间间隔（并发）和同一时刻（并行）的区别：单个时刻单处理机环境下实际只能有一个程序执行，因此微观上这些程序仍然是分时交替执行的，OS的并发性也是通过分时实现的。  <img src="/2022/051418462/105.jpg" class>   </li><li>共享sharing：<br>即资源共享，系统中资源可以供内存中多个并发执行的进程共同使用，分两种方式：<br>①互斥共享方式：<br>系统中某些资源某段时间内只允许一个进程访问资源。把这种资源成为临界资源&#x2F;独占资源。计算机系统大多物理设备及某些软件中的栈，变量，表格都是临界资源，只允许一个正在使用的进程。<br>②同时访问方式：<br>宏观上是“同时”，微观上进程可能是交替地对资源进行访问即“分时共享”的，可供多个进程“同时”访问的资源是磁盘设备。  <img src="/2022/051418462/106.jpg" class>   </li><li>虚拟virtual：<br>把物理上的实体变成若干逻辑上的对应物，技术成为虚拟技术，OS利用多种虚拟技术实现虚拟处理器，虚拟内存，虚拟外部设备等。<br>虚拟处理器技术通过多道程序设计技术，采用让多道程序并发执行的方法，分时使用一个处理器，一个物理CPU虚拟成为多个逻辑的CPU，成为虚拟处理器。（同理虚拟内存，虚拟外部设备）<br>虚拟技术归纳为时分复用技术，空分复用技术。  <img src="/2022/051418462/107.jpg" class>   </li><li>异步asynchronism：<br>多道程序允许多个程序并发执行，但资源有限，进程执行并不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性。  <img src="/2022/051418462/108.jpg" class>   </li><li>小结：  <img src="/2022/051418462/109.jpg" class>   <h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3></li><li>OS应该具有以下功能：处理机管理，存储器管理，设备管理， 文件管理，且必须向用户提供接口。  </li><li>操作系统作为计算机系统资源的管理者：<br>①处理机管理：<br>处理机分配和运行都以进程为基本单位，也就是对进程的管理：主要包括进程控制，进程同步，进程通信，进程通信，死锁处理，处理机调度等。<br>②存储器管理：<br>给多道程序运行提供环境，方便用户使用及提高内存利用率，包括内存分配和回收，地址映射，内存保护和共享，内存扩充等功能。<br>③文件管理：<br>信息都以文件形式存储，负责管理文件部分为文件系统，包括文件存储空间管理，目录管理，文件读写管理和保护。<br>④设备管理：<br>设备管理主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，提高设备利用率，包括缓冲管理，设备分配，设备处理，虚拟设备等。   <img src="/2022/051418462/101.jpg" class>  </li><li>操作系统作为用户与计算机硬件系统之间的接口：<br>两类接口：<br>①命令接口：用户利用命令组织控制作业的执行。两种控制作业的方式为联机控制方式和脱机控制方式，所以把接口分为联机命令接口和脱机命令接口。<br>联机命令接口：又叫交互式命令接口，适用分时&#x2F;实时系统的接口。（多次输入命令逐次处理）<br>脱机命令接口：又叫批处理命令接口，适用于批处理系统的接口。（一次输入逐次处理）<br>②程序接口：编程人员使用他们请求操作系统服务。由一组系统调用组成，用户通过程序中使用这些系统调用来请求OS服务，比如GUI。   <img src="/2022/051418462/102.jpg" class>  </li><li>操作系统作为扩充机器：<br>没有任何软件支持计算机成为裸机，为物理基础，而实际应该使用OS把裸机改造成功能更强，使用更方便的机器，因此覆盖了软件的机器称为扩充机器&#x2F;虚拟机。   <img src="/2022/051418462/103.jpg" class>  </li><li>小结：  <img src="/2022/051418462/104.jpg" class>   <h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3></li><li>计算机计算过程需要人工干预，缺点：①用户独占全机，资源利用率低。②CPU等待手工操作，CPU利用率低。  <h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3></li><li>为了解决人际矛盾及CPU和IO设备矛盾，出现了批处理系统，分为单道批处理系统和多道批处理系统。  </li><li>单道批处理系统：（监督程序——OS雏形）<br>①自动性：作业自动逐行运行，无须人工干预。<br>②顺序性：作业完成顺序就是进入内存顺序，先进入先完成。<br>③单道性：内存中只有一道程序运行，结束才让其他程序进入。<br>④但高速CPU仍然等待低速I&#x2F;O完成状态。  </li><li>多道批处理系统：（OS正式诞生）<br>允许多个程序同时进入内存，允许他们在CPU交替运行，共享系统资源。一道程序因为I&#x2F;O请求等待，CPU就可以处理其他程序，使得资源利用率提高。<br>①多道：计算机内存中同时存多道程序。<br>②宏观上并行：同时进入内存的程序都处于运行中，但实际是先后运行。<br>③微观上串行：内存中多道程序轮流占用CPU，交替执行。<br>④优点是资源利用率高，系统吞吐量大，资源保持忙碌状态。<br>⑤缺点是用户响应时间长，没有人机交互。<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3>分时技术：把处理器运行时间分为时间片，轮流分配给作业使用，作业只利用自己的时间片完成计算，没有完成的也停止，也支持多道程序，但是包括人机交互的。<br>①同时性：允许多个终端用户同时使用计算机。<br>②交互性：用户通过终端采用人机对话方式控制程序<br>③独立性：多个用户彼此独立操作互不干扰。<br>④及时性：短时间内响应用户请求，一个计算机服务多个终端，所以响应及时。<br>⑤尽管解决了人机交互问题，但短时间反映问题还需要处理，所以出现实时操作系统。  <h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3></li><li>某个时间限制内完成某些紧急任务而不需要时间片排队，分两种情况：<br>①硬实时系统：某个动作必须绝对在规定时刻发生，则称为硬实时系统。（飞行器控制系统）<br>②软实时系统：能够接收偶尔违反实践规定且不会引起永久性损害。（飞机订票系统）  <h3 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h3></li><li>网络操作系统是把计算机网络各台计算机有机结合起来，提供一对一，经济有效的使用各台计算机方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。  </li><li>分布式计算机系统组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息，每台计算机地位平等，资源所有用户共享，任意计算机都可以构成一个子系统，任何工作都可以分布在几台计算机上，由他们并行工作，协同完成。系统称为分布式计算机系统，特点就是分布性和并行性。  <h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3>目前最广泛的操作系统，如Windows，Linux等<img src="/2022/051418462/1.jpg" class>   </li><li>小结：  <img src="/2022/051418462/110.jpg" class>   <h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3></li><li>预备知识：<br>指令：就是CPU能识别和执行的最基本的命令，分为特权指令和非特权指令。为了识别特权指令，所以CPU有两种状态，用户态和核心态。所以分为两种程序：内核程序和应用程序。  <img src="/2022/051418462/111.jpg" class>   </li><li>计算机系统中，CPU通常执行两种不同性质的程序：一种是OS内核程序，一种是用户自编程序（应用程序）。对于OS来说前者是后者的管理者，因此需要特权指令比如：IO指令，置中断指令等指令。实现上把CPU划分为用户态（只能执行非特权指令）和核心态（可以执行特权指令），应用程序运行在用户态，而OS内核程序运行在核心态。  </li><li>内核是计算机最底层软件，是计算机功能延申，不同系统对于内核定义不同，但大多包括4方面内容：<br>①时钟管理：<br>时钟是最关键的设备，第一功能是计时，向用户提供标准系统时间。通过时钟中断的管理实现进程切换（时间片轮转等），因此系统依赖时钟。<br>②中断机制：<br>引入中断目的是提高多道程序运行环境中的CPU的利用率，逐步发展形成多种类型，成为OS各项操作的基础。例如：键鼠信息输入，进程调度，设备驱动等。现代OS就是靠中断驱动的软件。<br>③原语：<br>OS底层一些可以被调用的小程序，各自完成一定操作，特点：①处于OS最底层，最接近硬件的部分。②程序具有原子性。③运行时间短，而且调用频繁。<br>具有这些特点的程序就是原语，定义原语的直接方法就是关闭中断，让所有动作不可分割完成之后再中断，系统中的设备驱动，CPU切换，进程通信等过程就是原语，成为内核组成部分。<br>④系统控制的数据结构和处理：<br>系统中登记状态信息的数据结构很多，如作业控制块，进程控制块PCB，设备控制块，各类链表，消息队列，缓冲区，空闲区登记表，内存分配表等，常见操作有：进程管理，存储器管理，设备管理。  <img src="/2022/051418462/112.jpg" class>   <img src="/2022/051418462/113.jpg" class>   <h3 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h3></li><li>为了多道程序并发执行，发明了OS，引入中断机制。本质上就是发生中断意味着需要OS介入开始管理工作（CPU从用户态转换为核心态，中断是唯一途径。而核心态转换为用户态则通过执行一个特权指令，把程序状态字PSW的标志位设置为“用户态”）。  </li><li>中断和异常的定义：<br>中断Interruption，也称外中断，来自CPU执行指令以外的事情发生（IO设备中断表示输入输出完毕发生下一个请求；时钟中断表示固定时间片到期），通常是指与当前指令无关的事件。<br>异常Exception，也称内中断，例外，陷入trap。指源自CPU指令内部的事情引起的事件（算术溢出，地址越界，非法操作等），对异常处理一般要依赖当前程序运行现场，且异常不能被屏蔽，一旦出现必须处理。<br>分辨两种中断：<br>信号来源不同：外中断信号来自CPU外部，与当前执行指令无关。而内中断来自CPU内部，与当前执行指令有关。  <img src="/2022/051418462/2.jpg" class>   <img src="/2022/051418462/116.jpg" class>   </li><li>中断处理过程：  <img src="/2022/051418462/3.jpg" class>   <img src="/2022/051418462/117.jpg" class>   <h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3></li><li>指用户在程序调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统内各种共享资源都有OS掌管，在用户程序中，凡是跟资源有关操作都需要系统调用的方式向OS提出服务请求，请OS代为完成，通常这种指令有很多条，分为几大类：设备管理，文件管理，进程控制，进程通信，内存管理。  <img src="/2022/051418462/118.jpg" class>   </li><li>系统调用相关功能涉及系统资源管理，进程管理等操作，需要特权指令，所以系统调用处理需要由操作系统欸和程序负责完成运行在核心态。用户程序可以执行trap命令发起系统调用，请求OS服务，相当于把CPU使用权交给OS内核程序。用户程序不能直接执行对系统影响很大的操作，必须通过系统调用的方式请求OS执行，以便保证系统稳定性和安全性，防止用户程序随意更改&#x2F;访问重要的系统资源，影响其他进程执行。  </li><li>OS运行环境理解为：用户通过OS上层程序，而这个程序依赖OS底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序，也可能是程序运行出现异常情况，被动需要管理程序服务，通过异常处理来进入核心态，管理程序运行结束时，用户程序需要继续运行，此时通过响应的保存的程序现场退出中断处理程序&#x2F;异常处理程序，返回断点处继续执行。  <img src="/2022/051418462/4.jpg" class>  <h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3></li><li>大内核：把OS主要模块作为一个紧密相连的整体运行在核心态，从而为应用提供高性能的系统服务，因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以性能有优势。</li><li>微内核：随着功能需求不断增多，大内核难以维护，所以出现微内核。它把内核中最基本的功能保留在内核，而那些不需要在核心态执行的功能移到用户态执行，从而减低了内核设计的复杂性，那些移出内核的OS的代码根据分层的原则被划分成若干服务程序，它们执行相互独立，交互则都借助于微内核进行通信。有效分离了内核与服务，服务与服务，接口更清晰，维护代价降低，各部分都可以独立优化和演进，保证了OS可靠性。但问题就是因为频繁在核心态和用户态之间切换，OS执行开销相当大。  <img src="/2022/051418462/114.jpg" class>   <img src="/2022/051418462/115.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger</title>
      <link href="/2022/051238097.html"/>
      <url>/2022/051238097.html</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p><a href="https://blog.csdn.net/u013735734/article/details/103249989">https://blog.csdn.net/u013735734/article/details/103249989</a></p><p>前言<br>目前来说，在 Java 领域使用 Springboot 构建微服务是比较流行的，在构建微服务时，我们大多数会选择暴漏一个 REST API 以供调用。又或者公司采用前后端分离的开发模式，让前端和后端的工作由完全不同的工程师进行开发完成。不管是微服务还是这种前后端分离开发，维持一份完整的及时更新的 REST API 文档，会极大的提高我们的工作效率。而传统的文档更新方式（如手动编写），很难保证文档的及时性，经常会年久失修，失去应有的意义。因此选择一种新的 API 文档维护方式很有必要，这也是这篇文章要介绍的内容。</p><h2 id="OpenAPI-规范介绍"><a href="#OpenAPI-规范介绍" class="headerlink" title="OpenAPI 规范介绍"></a>OpenAPI 规范介绍</h2><img src="/2022/051238097/2019112609090982.png" class title="img"><p>OpenAPI Specification 简称 OAS，中文也称 OpenAPI 描述规范，使用 OpenAPI 文件可以描述整个 API，它制定了一套的适合通用的与语言无关的 REST API 描述规范，如 API 路径规范、请求方法规范、请求参数规范、返回格式规范等各种相关信息，使人类和计算机都可以不需要访问源代码就可以理解和使用服务的功能。</p><p>下面是 OpenAPI 规范中建议的 API 设计规范，基本路径设计规范。</p><img src="/2022/051238097/image-20220613214902679.png" class title="image-20220613214902679"><p>对于传参的设计也有规范，可以像下面这样：</p><p>路径参数, 例如 &#x2F;users&#x2F;{id}<br>查询参数, 例如 &#x2F;users?role&#x3D;未读代码<br>header 参数, 例如 X-MyHeader: Value<br>cookie 参数, 例如 Cookie: debug&#x3D;0; csrftoken&#x3D;BUSe35dohU3O1MZvDCU<br>OpenAPI 规范的东西远远不止这些，目前 OpenAPI 规范最新版本是 3.0.2，如果你想了解更多的 OpenAPI 规范，可以访问下面的链接。<br>OpenAPI Specification (<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md</a>)</p><h2 id="Swagger-介绍"><a href="#Swagger-介绍" class="headerlink" title="Swagger 介绍"></a>Swagger 介绍</h2><img src="/2022/051238097/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3MzU3MzQ=,size_16,color_FFFFFF,t_70.png" class title="img"><p>很多人都以为 Swagger 只是一个接口文档生成框架，其实并不是。 Swagger 是一个围绕着 OpenAPI Specification（OAS，中文也称 OpenAPI规范）构建的一组开源工具。可以帮助你从 API 的设计到 API 文档的输出再到 API 的测试，直至最后的 API 部署等整个 API 的开发周期提供相应的解决方案，是一个庞大的项目。 Swagger 不仅免费，而且开源，不管你是企业用户还是个人玩家，都可以使用 Swagger 提供的方案构建令人惊艳的 REST API。</p><p>Swagger 有几个主要的产品。</p><p>Swagger Editor – 一个基于浏览器的 Open API 规范编辑器。<br>Swagger UI – 一个将 OpenAPI 规范呈现为可交互在线文档的工具。<br>Swagger Codegen – 一个根据 OpenAPI 生成调用代码的工具。<br>如果你想了解更多信息，可以访问 Swagger 官方网站 <a href="https://swagger.io./">https://swagger.io。</a></p><ol start="3"><li>Springfox 介绍<br>源于 Java 中 Spring 框架的流行，让一个叫做 Marrty Pitt 的老外有了为 SpringMVC 添加接口描述的想法，因此他创建了一个遵守 OpenAPI 规范（OAS）的项目，取名为 swagger-springmvc，这个项目可以让 Spring 项目自动生成 JSON 格式的 OpenAPI 文档。这个框架也仿照了 Spring 项目的开发习惯，使用注解来进行信息配置。</li></ol><p>后来这个项目发展成为 Springfox，再后来扩展出 springfox-swagger2 ，为了让 JSON 格式的 API 文档更好的呈现，又出现了 springfox-swagger-ui 用来展示和测试生成的 OpenAPI 。这里的 springfox-swagger-ui 其实就是上面介绍的 Swagger-ui，只是它被通过 webjar 的方式打包到 jar 包内，并通过 maven 的方式引入进来。</p><p>上面提到了 Springfox-swagger2 也是通过注解进行信息配置的，那么是怎么使用的呢？下面列举常用的一些注解，这些注解在下面的 Springboot 整合 Swagger 中会用到。</p><img src="/2022/051238097/image-20220613215215709.png" class title="image-20220613215215709"><p>更多的 Springfox 介绍，可以访问 Springfox 官方网站。</p><p>Springfox Reference Documentation (<a href="http://springfox.github.io/">http://springfox.github.io</a>)</p><h2 id="Springboot-整合-Swagger"><a href="#Springboot-整合-Swagger" class="headerlink" title="Springboot 整合 Swagger"></a>Springboot 整合 Swagger</h2><p>就目前来说 ，Springboot 框架是非常流行的微服务框架，在微服务框架下，很多时候我们都是直接提供 REST API 的。REST API 如果没有文档的话，使用者就很头疼了。不过不用担心，上面说了有一位叫 Marrty Pitt 的老外已经创建了一个发展成为 Springfox 的项目，可以方便的提供 JSON 格式的 OpenAPI 规范和文档支持。且扩展出了 springfox-swagger-ui 用于页面的展示。</p><p>需要注意的是，这里使用的所谓的 Swagger 其实和真正的 Swagger 并不是一个东西，这里使用的是 Springfox 提供的 Swagger 实现。它们都是基于 OpenAPI 规范进行 API 构建。所以也都可以 Swagger-ui 进行 API 的页面呈现。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><pre><code>import io.swagger.annotations.ApiOperation;import org.springframework.boot.SpringBootConfiguration;import org.springframework.context.annotation.Bean;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.oas.annotations.EnableOpenApi;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;@SpringBootConfiguration@EnableOpenApipublic class Swagger3Config &#123;        /**     * ture 启用Swagger3.0， false 禁用（生产环境要禁用）     */    Boolean swaggerEnabled=true;    @Bean    public Docket createRestApi()&#123;        return new Docket(DocumentationType.OAS_30)                .apiInfo(apiInfo())                // 是否开启                .enable(swaggerEnabled)                .select()                // 扫描的路径使用@Api的controller                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))                // 指定路径处理PathSelectors.any()代表所有的路径                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo apiInfo()&#123;        return new ApiInfoBuilder()                .title(&quot;东软人力资源管理系统接口文档&quot;)                .description(&quot;使用springboot实现后端内容&quot;)                //作者信息                .contact(new Contact(&quot;鲍晖&quot;,&quot;http://www.neusoft.com/&quot;, &quot;pcbhyy@163.com&quot;))                .version(&quot;1.0&quot;)                .build();    &#125;&#125;</code></pre><h3 id="注解类和方法"><a href="#注解类和方法" class="headerlink" title="注解类和方法"></a>注解类和方法</h3><pre><code>package com.neu.springbootdemo1.controller;import com.neu.springbootdemo1.entity.Dept;import com.neu.springbootdemo1.entity.Result;import com.neu.springbootdemo1.service.DeptService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;@Api(tags = &quot;部门管理&quot;)@RestController@RequestMapping(&quot;dept&quot;)public class DeptController &#123;    @Resource    private DeptService deptService;    @ApiOperation(&quot;查询所有部门&quot;)    @GetMapping(&quot;getAll&quot;)    public Result getAll()&#123;        return new Result(deptService.getAll());    &#125;    @ApiOperation(&quot;根据部门编号查询部门&quot;)    @GetMapping(&quot;&#123;deptno&#125;&quot;)    public Dept getById(@PathVariable(&quot;deptno&quot;) long deptno)&#123;        return deptService.selectByPrimaryKey(deptno);    &#125;    @ApiOperation(&quot;添加部门&quot;)    @PostMapping    public Result insert(@RequestBody Dept dept)&#123;        return new Result(deptService.insert(dept));    &#125;    @ApiOperation(&quot;修改部门&quot;)    @PutMapping    public Result update(@RequestBody Dept dept)&#123;        return  new Result(deptService.updateByPrimaryKey(dept));    &#125;    @ApiOperation(&quot;修改部门部分值&quot;)    @PatchMapping    public int updateByPrimaryKeySelective(@RequestBody Dept dept)&#123;        return deptService.updateByPrimaryKeySelective(dept);    &#125;    @ApiOperation(&quot;根据部门编号删除部门&quot;)    @DeleteMapping(&quot;&#123;deptno&#125;&quot;)    public Result delete(@PathVariable(&quot;deptno&quot;) long deptno)&#123;        return new Result(deptService.deleteByPrimaryKey(deptno));    &#125;    &#125;</code></pre><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><pre><code>http://localhost:8086/swagger-ui/index.html</code></pre><img src="/2022/051238097/image-20220613220028731.png" class title="image-20220613220028731"><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>新建一个maven项目</p></li><li><p>配置pom.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.example&lt;/groupId&gt;    &lt;artifactId&gt;swagger_demo&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!-- 部署路径，如：/e3mall,表明部署到/e3mall路径下 --&gt;                    &lt;path&gt;/&lt;/path&gt;                    &lt;!-- 端口号 --&gt;                    &lt;port&gt;8089&lt;/port&gt;                    &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;4.0.9.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;            &lt;version&gt;2.9.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;            &lt;version&gt;2.9.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.9.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;            &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;            &lt;version&gt;1.6&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li><li><p>配置 resources 目录下的 spring-mvc.xml文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;    &lt;!-- 启用mvc注解驱动 --&gt;    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;    &lt;!-- 组件扫描 --&gt;    &lt;context:component-scan base-package=&quot;com.neu.controller&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 配置视图解析器,把逻辑视图名转换为物理视图名 --&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=&quot;com.neu.SwaggerConfig&quot; /&gt;    &lt;mvc:resources mapping=&quot;swagger-ui.html&quot; location=&quot;classpath:/META-INF/resources/&quot; /&gt;    &lt;mvc:resources mapping=&quot;/webjars/**&quot; location=&quot;classpath:/META-INF/resources/webjars/&quot; /&gt;&lt;/beans&gt;</code></pre></li><li><p>配置 web.xml 文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;    version=&quot;3.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;        &lt;url-pattern&gt;/swagger/*&lt;/url-pattern&gt;        &lt;url-pattern&gt;/api-docs&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre></li><li><p>添加 配置类 SwaggerConfig</p><pre><code>package com.neu;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableWebMvc@EnableSwagger2public class SwaggerConfig&#123;    @Bean    public Docket api() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .select()            .apis(RequestHandlerSelectors.withClassAnnotation(Api.class))                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))                .build()                .apiInfo(apiInfo());    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;监管平台-国际版API&quot;)                .description(&quot;http不对外开放接口&quot;)                .version(&quot;1.0.0&quot;)                .termsOfServiceUrl(&quot;http://xxx.xxx.com&quot;)                .license(&quot;假装这里有license&quot;)                .licenseUrl(&quot;http://xxx.xxx.com&quot;)                .build();    &#125;&#125;</code></pre></li><li><p>编写控制器（没有与接口内容对应匹配）</p><pre><code>package com.neu.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;@Api(value = &quot;User控制器&quot;)@RestControllerpublic class HelloController &#123;    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)    @RequestMapping(value=&quot;hi&quot;,method = &#123;RequestMethod.GET&#125;)    public String hi()&#123;        return &quot;hi&quot;;    &#125;&#125;</code></pre></li><li><p>测试：</p><pre><code>http://localhost:8089/swagger/swagger-ui.html或http://localhost:8089/doc.html</code></pre><img src="/2022/051238097/image-20210820092725302.png" class title="image-20210820092725302"></li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>注解属性备注</p><h3 id="Api"><a href="#Api" class="headerlink" title="@Api"></a>@Api</h3><p>用于类上，说明该类的作用。可以标记一个Controller类做为swagger 文档资源</p><p>示例：</p><p>@Api(value &#x3D; “xxx”, description &#x3D; “xxx”)</p><pre><code> valueurl的路径值 tags如果设置这个值、value的值会被覆盖 description对api资源的描述 basePath基本路径可以不配置 position如果配置多个Api 想改变显示的顺序位置 producesFor example, &quot;application/json, application/xml&quot; consumesFor example, &quot;application/json, application/xml&quot; protocolsPossible values: http, https, ws, wss. authorizations高级特性认证时配置 hidden配置为true 将在文档中隐藏</code></pre><h3 id="ApiOperation"><a href="#ApiOperation" class="headerlink" title="@ApiOperation"></a>@ApiOperation</h3><p>用于方法上，说明方法的作用，每一个url资源的定义</p><p>示例：</p><p>@ApiOperation(value &#x3D; “xxx”,httpMethod&#x3D;”POST”, notes&#x3D; “xxx”,response&#x3D;String.class)</p><pre><code> valueurl的路径值 tags如果设置这个值、value的值会被覆盖 notes对api资源的描述 position如果配置多个Api 想改变显示的顺序位置 producesFor example, &quot;application/json, application/xml&quot; consumesFor example, &quot;application/json, application/xml&quot; protocolsPossible values: http, https, ws, wss. authorizations高级特性认证时配置 hidden配置为true 将在文档中隐藏 response返回的对象 responseContainer这些对象是有效的 &quot;List&quot;, &quot;Set&quot; or &quot;Map&quot;.，其他无效 httpMethod&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot; and &quot;PATCH&quot; codehttp的状态码 默认 200 extensions扩展属性</code></pre><h3 id="ApiParam"><a href="#ApiParam" class="headerlink" title="@ApiParam"></a>@ApiParam</h3><p>用于方法、参数、字段上，请求属性</p><p>示例：<br>public ResponseEntity<User> createUser(@RequestBody @ApiParam(value &#x3D; “Created user object”, required &#x3D; true)  User user)</User></p><pre><code> name属性名称 value属性值 defaultValue默认属性值 allowableValues可以不配置 required是否属性必填 access  allowMultiple默认为false hidden隐藏该属性 example示例</code></pre><h3 id="ApiResponse"><a href="#ApiResponse" class="headerlink" title="@ApiResponse"></a>@ApiResponse</h3><p>用于方法上，响应配置</p><p>示例：</p><p>@ApiResponse(code &#x3D; 400, message &#x3D; “Invalid user supplied”)</p><pre><code> codehttp的状态码 message描述 response默认响应类 Void reference参考ApiOperation中配置 responseHeaders参考 ResponseHeader 属性配置说明 responseContainer参考ApiOperation中配置</code></pre><h3 id="ApiResponses"><a href="#ApiResponses" class="headerlink" title="@ApiResponses"></a>@ApiResponses</h3><p>用于方法上，响应集配置</p><p>示例：</p><p> @ApiResponses({ @ApiResponse(code &#x3D; 400, message &#x3D; “Invalid Order”) })</p><pre><code> value多个ApiResponse配置</code></pre><h3 id="ResponseHeader"><a href="#ResponseHeader" class="headerlink" title="@ResponseHeader"></a>@ResponseHeader</h3><p>用于方法上，响应头设置</p><p>示例：</p><p>@ResponseHeader(name&#x3D;”head1”,description&#x3D;”response head conf”)</p><pre><code> name响应头名称 description头描述 response默认响应类 Void responseContainer参考ApiOperation中配置</code></pre><h3 id="ApiImplicitParams"><a href="#ApiImplicitParams" class="headerlink" title="@ApiImplicitParams"></a>@ApiImplicitParams</h3><p>用于方法上，包含一组参数说明</p><h3 id="ApiImplicitParam"><a href="#ApiImplicitParam" class="headerlink" title="@ApiImplicitParam"></a>@ApiImplicitParam</h3><p>用于方法上，用在@ApiImplicitParams注解中，指定一个请求参数的各个方面<br>     paramType参数放在哪个地方<br>            · header 参数在request headers 里边提交（@RequestHeader）<br>            · query 直接跟参数完成自动映射赋值（@RequestParam）<br>            · path 用于restful接口，以地址的形式提交数据（@PathVariable）<br>            · body 以流的形式提交 仅支持POST（@RequestBody）<br>            · form 以form表单的形式提交 仅支持POST<br>     name参数名<br>     value参数的汉字说明、解释<br>     dataType参数类型，默认String，其它值dataType&#x3D;”Integer”   ，无用<br>     required 是否必要<br>     defaultValue参数的默认值</p><h3 id="ApiModel"><a href="#ApiModel" class="headerlink" title="@ApiModel"></a>@ApiModel</h3><p>用于类上，描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候</p><h3 id="ApiModelProperty"><a href="#ApiModelProperty" class="headerlink" title="@ApiModelProperty"></a>@ApiModelProperty</h3><p>用于方法、字段上，描述一个model的属性</p><h3 id="ApiIgnore"><a href="#ApiIgnore" class="headerlink" title="@ApiIgnore"></a>@ApiIgnore</h3><p>用于类，属性，方法上，忽略某项api,使用@ApiIgnore</p><h2 id="WMS配置Swagger"><a href="#WMS配置Swagger" class="headerlink" title="WMS配置Swagger"></a>WMS配置Swagger</h2><ol><li><p>找到pom.xml中找到，并修改版本号，<code>&lt;classmate.version&gt;1.3.1&lt;/classmate.version&gt;</code></p></li><li><p>修改web.xml,添加如下内容：</p><pre><code>&lt;servlet-mapping&gt;    &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt;    &lt;url-pattern&gt;/swagger/*&lt;/url-pattern&gt;    &lt;url-pattern&gt;/api-docs&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre></li><li><p>修改 spring-mvc.xml ，添加内容如下：</p><pre><code>&lt;bean class=&quot;com.zzjee.swagger.SwaggerConfig&quot; /&gt;&lt;mvc:resources mapping=&quot;swagger-ui.html&quot; location=&quot;classpath:/META-INF/resources/&quot; /&gt;&lt;mvc:resources mapping=&quot;webjars/**&quot; location=&quot;classpath:/META-INF/resources/webjars/&quot; /&gt;</code></pre></li><li><p>修改 spring-mvc.xml ，添加内容如下：</p><img src="/2022/051238097/image-20210821084537817.png" class title="image-20210821084537817"></li><li><p>修改登录页代码</p><img src="/2022/051238097/image-20210821084741334.png" class title="image-20210821084741334"></li><li><p>测试</p><pre><code>http://localhost:8081/jeewms/swagger/swagger-ui.html</code></pre><p>内部执行了如下操作：</p><img src="/2022/051238097/image-20210821085041544.png" class title="image-20210821085041544"><p>结果如图：</p><img src="/2022/051238097/image-20210821085124481.png" class title="image-20210821085124481"></li></ol><pre><code>&lt;!-- 此插件生成markdown、ASCIIDOC、wiki格式--&gt;            &lt;!--  执行命令 mvn swagger2markup:convertSwagger2markup--&gt;            &lt;plugin&gt;                &lt;groupId&gt;io.github.swagger2markup&lt;/groupId&gt;                &lt;artifactId&gt;swagger2markup-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;!-- api-docs访问url --&gt;                    &lt;swaggerInput&gt;http://localhost:8081/jeewms/swagger/v2/api-docs&lt;/swaggerInput&gt;                    &lt;!-- 生成为单个文档，输出路径--&gt;                    &lt;outputFile&gt;src/docs/api&lt;/outputFile&gt;                    &lt;!-- 生成为多个文档，输出路径 --&gt;                    &lt;!--&lt;outputDir&gt;src/docs/&lt;/outputDir&gt;--&gt;                    &lt;config&gt;                        &lt;!-- wiki格式文档 --&gt;                        &lt;!--&lt;swagger2markup.markupLanguage&gt;CONFLUENCE_MARKUP&lt;/swagger2markup.markupLanguage&gt;--&gt;                        &lt;!-- ascii格式文档 --&gt;                        &lt;swagger2markup.markupLanguage&gt;ASCIIDOC&lt;/swagger2markup.markupLanguage&gt;                        &lt;!-- markdown格式文档 --&gt;                        &lt;!--&lt;swagger2markup.markupLanguage&gt;MARKDOWN&lt;/swagger2markup.markupLanguage&gt;--&gt;                        &lt;swagger2markup.pathsGroupedBy&gt;TAGS&lt;/swagger2markup.pathsGroupedBy&gt;                    &lt;/config&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!--此插件生成HTML和PDF--&gt;            &lt;!-- 执行命令 mvn generate-resources --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;                &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1.0&lt;/version&gt;                &lt;!-- Include Asciidoctor PDF for pdf generation --&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;                        &lt;artifactId&gt;asciidoctorj-pdf&lt;/artifactId&gt;                        &lt;version&gt;1.5.4&lt;/version&gt;                    &lt;/dependency&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.jruby&lt;/groupId&gt;                        &lt;artifactId&gt;jruby-complete&lt;/artifactId&gt;                        &lt;version&gt;9.2.17.0&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;                &lt;!-- Configure generic document generation settings --&gt;                &lt;configuration&gt;                    &lt;sourceDirectory&gt;src/docs&lt;/sourceDirectory&gt;                    &lt;!-- &lt;sourceHighlighter&gt;coderay&lt;/sourceHighlighter&gt;--&gt;                    &lt;attributes&gt;                        &lt;toc&gt;left&lt;/toc&gt;                    &lt;/attributes&gt;                &lt;/configuration&gt;                &lt;!-- Since each execution can only handle one backend, run                     separate executions for each desired output type --&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;output-pdf&lt;/id&gt;                        &lt;phase&gt;generate-resources&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;process-asciidoc&lt;/goal&gt;                        &lt;/goals&gt;                        &lt;configuration&gt;                            &lt;backend&gt;pdf&lt;/backend&gt;                            &lt;outputDirectory&gt;src/docs/pdf/&lt;/outputDirectory&gt;                        &lt;/configuration&gt;                    &lt;/execution&gt;                    &lt;execution&gt;                        &lt;id&gt;output-html&lt;/id&gt;                        &lt;phase&gt;generate-resources&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;process-asciidoc&lt;/goal&gt;                        &lt;/goals&gt;                        &lt;configuration&gt;                            &lt;backend&gt;html5&lt;/backend&gt;                            &lt;outputDirectory&gt;src/docs/html/&lt;/outputDirectory&gt;                        &lt;/configuration&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2022/050732155.html"/>
      <url>/2022/050732155.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络应用层"><a href="#计算机网络应用层" class="headerlink" title="计算机网络应用层"></a>计算机网络应用层</h1><img src="/2022/050732155/1.jpg" class>  <h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-x2F-服务器类型"><a href="#客户-x2F-服务器类型" class="headerlink" title="客户&#x2F;服务器类型"></a>客户&#x2F;服务器类型</h3><ul><li>C&#x2F;S模型中，一个总是打开的主机为服务器，服务于其他称为客户机的主机请求，工作流程如下：<br>①服务器处接收请求状态。<br>②客户机发出服务请求，并等待结果。<br>③服务器收到请求之后，分析请求，进行必要的处理，得到结果并发送给客户机。  </li><li>客户程序必须知道服务器程序的地址，服务器程序不用知道客户程序的地址。主要特征就是客户是服务请求方，服务器是服务提供方，典型应用包括：Web，文件传输协议FTP，远程登陆TELNET，电子邮件E-mail。  </li><li>主要特点还有：<br>①网络中计算机地位不平等。<br>②客户机之间不能直接通信。<br>③可扩展性不佳。  <h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3></li><li>思想是整个网络中传输内容不在中心服务器上，而是每个结点都有下载，上传的功能，任意一对计算机称为对等方Peer，可以直接通信，典型应用包括：PPLive，Bittorrent和电驴等。  </li><li>相比C&#x2F;S，主要优点是：<br>①减轻服务器计算压力，消除了对某个服务器完全依赖，任务分配在各个结点上，大大提高系统效率和资源利用率。<br>②多个客户机共享文档。<br>③可扩展性号，传统服务器有响应和带宽，因此只能接收一定数量请求。<br>④网络健壮性强，一个结点失效不会影响其他结点。  </li><li>也有缺点：获取服务的时候也要给其他结点服务，占用较多内存，影响整机速度。    <img src="/2022/050732155/2.jpg" class>  <h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2></li><li>因特网使用的命名系统，用来把便于人们记忆具有特定含义的主机名转化为便于机器处理的IP地址，使用C&#x2F;S，运行在UDP之上，使用53号端口。分为三部分：层次域名空间，域名服务器，解析器。    <h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3></li><li>采用层次树状命名方法，任何一个连接到因特网的主机或路由器都有一个唯一层次标识，即域名。域是名字空间中可以被管理的部分。域还可以划分子域，还能继续划分，形成了顶级域，二级域，三级域等。每个域名都有由标号序列组成，各个标号都由.隔开。  <img src="/2022/050732155/3.jpg" class>  </li><li>注意点：<br>①标号中英文不区分大小写。<br>②标号中除了-之外不能使用其他符号。<br>③每个标号不超过63字符，多标号不超过255字符。<br>④级别最低域名在最左边，最高在最右边。  </li><li>顶级域名TLD有三类：<br>①国家顶级域名：“.cn”表示中国。<br>②通用顶级域名：“。com”表示公司。<br>③基础结构域名：这种顶级域名只有一个arpa，用于反向域名解析，又称反向域名。    </li><li>国家下的二级域名由该国家自行确定，展示树状结构：  <img src="/2022/050732155/4.jpg" class>  </li><li>每个域名可以由不同组织进行管理组织也可以再分成一定数目的子域去管理。  <h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3></li><li>因特网的域名系统被设计成一个联机分布式服务器，用C&#x2F;S模型，域名到IP地址解析是用由运行在域名服务器上的程序完成的，一个服务器负责管辖称为区，每个区都有响应权限域名服务器，用来保存该区所有主机的域名到IP地址的映射。每个域名服务器不但能够映射IP地址，还能连接其他域名服务器，当自己不能够映射出IP地址的时候找其他域名服务器。DNS使用大量域名服务器，以层次方式组织，所有映射分布在所有的DNS上，主要有4种类型域名服务器：<br>①根域名服务器：<br>最高层次域名服务器，所有根域名服务器都知道所有的顶级域名服务器的IP地址，共有13个，通常它不把域名直接转换成IP地址，而是告诉本地域名服务器下一步应该找哪个顶级域名服务器。<br>②顶级域名服务器：<br>负责管理在该顶级域名服务器注册的所有二级域名，收到DNS查询请求的时候给出相应应答（有可能是结果，也有可能是下一步找哪个域名服务器的IP地址）<br>③授权域名服务器（权限域名服务器）：<br>每台主机必须在授权域名服务器处登记，为了更可靠工作，一台主机最好有至少两个。<br>④本地域名服务器：<br>每个ISP&#x2F;大学&#x2F;院系甚至都有一个本地域名服务器，当一个主机发送DNS请求的时候，这个查询请求报文发送给该主机的本地域名服务器。  <img src="/2022/050732155/5.jpg" class>   <h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3></li><li>把域名解析成IP地址为正向解析，或者反向解析。客户机需要域名解析的时候，通过本机DNS构造一个DNS请求报文以UDP数据报形式发往本地域名服务器。  </li><li>域名解析有两种方式：递归查询和迭代与递归结合查询。  <img src="/2022/050732155/6.jpg" class>    <img src="/2022/050732155/7.jpg" class>    <h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3></li><li>FTP是因特网是商用最广泛的文件传输协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，适合在异构网络任意计算机之间传送文件。  </li><li>提供以下功能：<br>①提供不同种类主机系统之间的文件传输能力。<br>②以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力。<br>③以匿名FTP的方式提供公用文件共享的能力。  </li><li>使用TCP，C&#x2F;S模型，一个FTP服务器进程可同时为多个客户进程提供服务，FTP服务器进程由两大部分组成：一个主进程负责接收新请求，若干从属进程，负责处理单个请求。  </li><li>工作步骤：<br>①打开熟知端口21，使得客户进程能够连接上。<br>②等待客户进程发来连接请求。<br>③启动丛书进程处理客户进程发来的请求，主进程和从属进程并发执行，从属进程对客户进程的请求处理完毕后终止。<br>④回到等待状态，继续接收其他客户进程的请求。</li><li>FTP服务器必须在整个会话期间保留用户的状态信息，特别是必须把指定用户和控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。  <h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3></li><li>FTP工作使用两个并行TCP，一个控制连接（端口21），一个数据连接（端口20），使用两个不同端口使得协议更加简单和容易实现。  </li><li>控制连接：<br>21端口，等待客户连接，建立在这个端口上称为控制连接，用来传输控制信息（连接请求，传送请求等），不用来传送文件，一直保持打开状态。  </li><li>数据连接：<br>20端口，服务器端的控制进程在接收到FTP客户发来的文件传输请求之后，创建“数据传送进程”和“数据连接”，数据连接来连接C和S的数传送进程，而进程实际完成文件的传送，结束关闭“数据传送连接”并结束运行。<br>数据连接两种模式：主动PORT，被动PASV。<br>①PORT工作原理：客户端连接到21，登陆成功读取数据时，客户端随机开一个端口，并发送命令告知服务器，服务器收到PORT命令和端口号，通过20端口和客户端开放的端口号连接，发送数据。<br>②PASV不同点是：客户端读取数据，发送PASV到服务器，服务器随机开一个端口告知客户端，客户端再连接到服务器开放的端口进行书传书。<br>但两种模式，选择权都在客户端，主动模式就是服务器连接到客户端端口，被动模式就是客户端连接到服务器端口。  <h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3></li><li>一个电子邮件系统最主要三个组成构件：用户代理，邮件服务器，电子邮箱使用的协议（如SMTP，POP3或IMAP）等。  </li><li>用户代理：用户与电子邮件系统的接口，用户代理给用户提供一个友好接口发送接收邮件，通常情况下就是一个运行在PC上的程序，比如Foxmail等。  </li><li>邮件服务器：功能就是收发邮件，同时向发信人报告邮件传送情况，采用C&#x2F;S模型工作，但它必须都能充当C和S。  </li><li>邮件发送协议和读取协议：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP。邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3。且SMTP用的是PUSH的方式，即用户代理向邮件服务器发送邮件以及邮件服务器之间转发邮件时，SMTP客户把邮件”推“向服务器，而POP3则是”拉“（PULL），读取邮件，用户代理向服务器发出请求，拉取用户邮箱中的邮件。  <img src="/2022/050732155/8.jpg" class>   <h3 id="电子邮箱格式与MIME"><a href="#电子邮箱格式与MIME" class="headerlink" title="电子邮箱格式与MIME"></a>电子邮箱格式与MIME</h3></li><li>电子邮箱格式：<br>分为信封和内容两大部分，内容又分为首部和主题两部分。RFC 822规定了邮件的首部格式，而邮件的主题部分则让用户自由撰写。用户写好首部之后，邮件系统自动地把信封所需的信息提取出来写在信封上，用户不需要亲自填写信封上的信息。<br>邮件内容首部包含一些首部行，每个首部行由一个关键字后跟冒号再根值组成，有些关键字必须的，有些则是可选的，最重要的是To：，Subject：。<br>To是必须关键字，后面填入一个&#x2F;多个收件人电子邮件，规定格式为：收件人邮件名@邮件所在主机域名。Subject是可选关键字，是邮件主题，反映了邮件主要内容。From也是必须，但它通常被邮件系统自动填入，从上到下Form，To，Subject，组成了首部。  </li><li>多用途网际邮件扩充MIME：<br>SMTP只能传送一定长度的ASCII码，许多非英语国家文字无法传送，且无法传送可执行文件及其他二进制对象，一次提出了MIME。MIME并非取代SMTP或改动它，而是增加了邮件主题的结构，定义了传送非ASCII码的编码规则。  <h3 id="SMTP和POP3"><a href="#SMTP和POP3" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3></li><li>SMTP:<br>简单邮件传输协议SMTP，可靠有效的电子邮件传输协议，控制两个相互通信的SMTP进程交换信息，由于SMTP使用C&#x2F;S模型，因此负责发送邮件的SMTP进程就是SMTP客户，负责接收的SMTP进程就是SMTP服务器，用TCP连接，端口号为25。有三个阶段：<br>①连接建立：<br>发件人邮件发送到发送方邮件服务器邮件缓存中，SMTP每个一段时间骚猫一次，有邮件则用25端口与接收方邮件的SMTP服务器建立TCP连接，之后接收方服务器发出220 Service ready，然后SMTP客户向SMTP服务器发出HELO指令，附上发送方的主机名。<br>②邮件传送：<br>连接建立之后，开始传送邮件，邮件从MAIL命令开始，若SMTP服务器已经准备好接收邮件，则回答250 OK，接着SMTP客户端发送一个或多个RCPT命令，格式为RCPT TO&lt;收件人地址&gt;，每发送一个RCPT命令，都应有相关信息从STMP服务器返回，如250 OK或者550 No such user here。（RCPT命令作用是先弄清服务器是否已经做好接收邮件准备，再发送邮件，不至于白发送错误地址）。<br>获取OK回答之后，客户端使用DATA命令，表示要开始传输邮件的内容，正常SMTP服务器回复信息是354 Start mail input;end with CRLF.CRLF。此时SMTP客户端就可以开始传送邮件内容。<br>③连接释放：<br>SMTP客户应发送QUIT命令，服务器返回221，表示SMTP同意释放连接。  </li><li>POP3和IMAP：<br>POP3：邮局协议POP是一个简单但功能有限的邮件读取协议，采用PULL的方式，用户读取邮件则向服务器发出请求，拉取用户邮箱中的邮件。也是用C&#x2F;S模型，使用TCP，端口110。有两种运行方式：”下载并保留“和”下载并删除“。<br>IMAP：它比POP复杂很多，为用户提供了创建文件夹，不同文件夹移动邮件等命令，为此IMAP服务器维护了会话用户的状态信息。IMAP另一个特性就是允许用户代理只读部分内容。  <h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="WWW的概念与组成结构"><a href="#WWW的概念与组成结构" class="headerlink" title="WWW的概念与组成结构"></a>WWW的概念与组成结构</h3></li><li>万维网是一个分布式，联机式的信息存储空间，万物有一个全域同一资源定位符URL标识，资源通过超文本传输协议HTTP传送给使用者，后者通过单机链接获取资源。万维网的内核部分由三个标准组成：<br>①统一资源定位符URL：标识万维网上各种文档，且每个都有URL。<br>②超文本传输协议HTTP：使用TCP链接，万维网客户程序和服务器程序之间交互必须遵循的规则。<br>③超文本标记语言HTML：一种文档结构标记语言，使用一些约定的标记对页面信息，格式进行描述。  </li><li>URL格式：协议：&#x2F;&#x2F;主机：端口&#x2F;路径。  </li><li>万维网以C&#x2F;S方式工作，浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则是运行服务器程序，称为万维网服务器，工作流程是：<br>①Web用户使用浏览器指定URL与Web服务器建立连接，并发送浏览请求。<br>②Web服务器把URL转换为文件路径，并返回给Web浏览器。<br>③通信完成，关闭连接。<br>万维网是无数个网站和网页集合，构成了因特网最主要的部分。   <h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2></li><li>HTTP定义浏览器怎么向万维网服务器请求万维网文档，以及服务器怎么把文档传给浏览器，是面向事务的应用层协议。  </li><li>HTTP操作过程：<br>浏览器访问WWW服务器，首先完成对WWW域名解析获得IP地址，通过TCP向服务器发送连接。大致工作过程：每个万维网站点有一个服务器进程，不断监听TCP端口80，监听到连接请求就建立连接，然后，浏览器通过向服务器发送请求获取某个Web页面的HTTP请求，服务器返回Web页面必须信息，通过HTTP响应返回给浏览器，浏览器再进行信息解释，然后把Web页面显示给用户，最后TCP连接释放。  <img src="/2022/050732155/9.jpg" class>    </li><li>HTTP特点：<br>①使用TCP保证可靠传输。<br>②HTTP无状态，服务器不记住HTTP状态，但可以通过Cookie加数据库的方式来跟踪用户活动。<br>③HTTP既可以使用非持久连接，也可以使用持久连接。<br>对于非持久连接，每个网页对象都需要单独TCP连接，万维网服务器负担重。<br>对于持久连接，万维网服务器发送响应之后仍然保持这链接，同一个客户和该服务器可以继续在这条连接上 传送后续HTTP请求和响应报文。  <img src="/2022/050732155/10.jpg" class>     </li><li>HTTP报文结构：<br>①面向文本的，每个字段都是ASCII码串，每个字段长度不固定，有两类:请求报文（客户向服务器发）和响应报文（服务器到客户的回答）。<br>②HTTP两个报文都是三部分组成：开始行，首部行，实体主体<img src="/2022/050732155/11.jpg" class>  </li><li>常见应用层协议小结：  <img src="/2022/050732155/12.jpg" class>  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>互联网，因特网，万维网：<br>互联网：泛指多个计算机网络按照一定通信协议相互连接而成的一个大型计算机网络。<br>因特网：世界最大全球性互联网络，最大的互联网。<br>万维网：无数网站和网页集合，构成因特网最主要部分。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络传输层</title>
      <link href="/2022/05076519.html"/>
      <url>/2022/05076519.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络传输层"><a href="#计算机网络传输层" class="headerlink" title="计算机网络传输层"></a>计算机网络传输层</h1><img src="/2022/05076519/1.jpg" class>  <h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><ul><li>传输层向应用层提供通信服务，属于面向通信的最高层，也是用户功能的最低层。它为运行在不同主机的进程之间提供了逻辑通信，而网络层则是不同主机之间的网络通信，即使网络层协议不可靠，传输层同样能为应用程序提供给可靠的服务。   </li><li>网络边缘部分的两台主机使用网络核心部分的功能进行端到端通信，只有主机的协议栈才有传输层和应用层，而路由器转发分组用了下三层的功能，如图：   <img src="/2022/05076519/2.jpg" class>  </li><li>功能：<br>①传输层提供应用进程之间的逻辑通信，而网络层提供主机之间的逻辑通信。（应用进程之间的通信实际是“端到端的逻辑通信”，实际上逻辑通信就是好像沿着水平方向传输数据，但物理上并没有一条物理连接。）<br>②复用和分用：复用指的是发送方不同应用进程都可以使用同一个传输层协议传输数据。分用指的是接收方的传输层剥去报文的首部之后能够把这些数据正确交付到目的应用进程。（网络层也有复用分用，复用是把发送方不同协议数据都可以封装成IP数据报发送出去，分用是把接收方的网络层剥去首部后把数据交付给相应协议。）<br>③传输层还要对收到的报文进行差错检测（首部和数据部分），而网络层只监测IP数据报的首部，不检查数据部分。<br>④提供两种不同协议UDP和TCP，而网络层无法同时实现两种协议。（要么面向连接虚电路，要么无连接数据报。）  <h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3></li><li>端口的作用：<br>①端口可以让应用层的各个应用进程将其数据通过该端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的相应进程。端口就是传输层服务访问点（TSAP），它在传输层作用类似于IP地址在网络层&#x2F;MAC地址在数据链路层，只不过IP&#x2F;MAC标记的是主机，而端口标识的是主机中的应用进程。<br>②硬件端口是不同硬件设备进行交互的端口，软件端口是应用层各种协议进程与传输实体进行层间交互的一种地址。   </li><li>端口号：<br>应用进程之间通过端口号进行标识，长度为16比特，能够标识2的16次方个进程，只有本地意义，即端口号只标记本计算机应用层的各种进程，分两类：<br>①服务器端使用的端口号，又分为两类：一类是熟知端口号，0——1023，派发给最重要的应用程序，另一类是等级端口号，1024——49151，提供给其他应用程序使用。<br>一些熟知端口号：FTP——21，TELNET——23，SMTP——25，DNS——53，TFTP——69，HTTP——80，SNMP——161。<br>②客户端使用的端口号，49152——65535。由于这类端口号仅在客户进程运行时才动态选择，又称为短暂端口号，通信结束后更用过的客户端端口号不复存在，该端口就可以重新使用。  </li><li>套接字：<br>IP标识不同主机，端口号标识不同进程，则端口号拼接到IP地址即套接字。<br>socket&#x3D;（IP地址：端口号）  <h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3></li><li>TCP是面向连接的服务，在传送数据之前必须建立连接，数据传送结束后释放连接，不提供组播&#x2F;广播，不可避免的增加许多开销（确认，流量控制，计时器，连接管理），适用于可靠性更重要的场合，如：文件传输协议FTP，超文本传输协议HTTP，远程登录TELNET等。  </li><li>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查。IP知道投放哪个主机但不知道哪个进程。UDP比较简单，因此执行速度快，实时性好，如：小文本传送协议TFTP，DNS，SNMP，实时传输协议RTP等。</li><li>IP数据报和UDP数据报区别：IP数据报在网络层要经过路由存储转发，而UDP数据报在传输层端到端的逻辑信道中传输，封装成IP数据报在网络层传输时对外不可见。  </li><li>TCP和网络层虚电路区别：TCP报文在传输层抽象的逻辑信道中传输，对路由器不可见，虚电路经过交换节点必须保存虚电路状态信息，则网络层使用虚电路则无法提供无连接服务，而传输层采用TCP不影响网络层提供无连接服务。  <h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3></li><li>UDP概述：<br>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查，应用程序几乎直接与IP打交道。<br>优点：<br>①无须连接，没有建立连接时延。<br>②无连接状态，不跟踪确认等参数，因此使用UDP的时候可以支持更多的活动客户机。<br>③分组首部开销小，TCP有20B的首部开销，UDP只有8B的开销。<br>④应用层更好控制要发送的数据和发送时间。<br>⑤支持1-1，1-N，N-1，N-N的服务。<br>常用于一次性传输较少的网络应用，如DNS，SNMP等，如果用TCP则开销大（数据少性价比低）。UDP常用于多媒体应用等，因为可靠性不是最重要的，实时性才是。<br>UDP不保证可靠传输，不意味着应用对于数据要求是不可靠的，维护可靠性工作交给应用层来做。<br>UDP是面向报文的，发送方UDP对应用层交下来的报文，在添加首部之后就向下交付给IP层，一次发送一个报文，不合并不拆分，保留报文边界。一次交付一个完整报文，因此报文不可分割，是UDP数据报的最小单位。因此应用程序必须选择大小合适的报文，太长则会分片，太短则首部相对太长，两者都会降低IP层的效率。  </li><li>UDP首部格式：<br>首部有8B，四个字段组成，每个长为2B：<br>①源端口：源端口号，需要对方回信的时候，不需要可以为0。<br>②目的端口：目的端口号，在终点交付报文时必须用到。<br>③长度：UDP数据报长度，最小数8（仅有首部，没有数据）。<br>④校验和：监测UDP数据报传输中是否出错，出错丢弃，当不想校验时可使字段为0。  <img src="/2022/05076519/3.jpg" class>    当传输层从IP获得UDP数据报的时候，就根据首部中目的端口号传送给相应端口进行分用。如果UDP发现收到端口号不正确，则丢弃该报文且由ICMP发送“端口不可达”给发送方。  <h3 id="UDP校验："><a href="#UDP校验：" class="headerlink" title="UDP校验："></a>UDP校验：</h3>计算校验和时，需要在UDP首部加上12B伪首部，得到一个临时UDP数据报，单纯为了计算校验和。检查首部和数据部分。<img src="/2022/05076519/4.jpg" class>     计算过程：<br>发送方把全0放入校验和字段并添加伪首部，把UDP数据报视为许多16位字符串连接起来，若UDP数据报数据部分不是偶数个字节，需要填充一个全0字节（但不发送），按照二进制反码运算16位字的和，把此和的二进制反码写入校验和字段并发送。<br>接收方收到UDP数据报加上伪首部后，按二进制反码求16位字的和，无差错则全是1，否则有差错丢弃数据报。  <img src="/2022/05076519/5.jpg" class>   注意：<br>校验时，若UDP数据报数据部分长度不是偶数，则填充一个偶数字节。<br>这种检错能力不强，但优点是简单，处理速度快。  <h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h3></li><li>TCP在不可靠IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠，有序，无丢失，不重复，特点如下：<br>①TCP是面向连接的。<br>②每条TCP只有两个端点，只能是点对点的。<br>③TCP传输的可靠，有序，无丢失，不重复。<br>④TCP提供全双工通信，两端都有发送和接收缓存，临时存放双向通信的数据。<br>其中发送缓存存放的是：①发送应用程序传送给发送发TCP准备发送的数据。②TCP以发送但尚未收到确认的数据。<br>接收缓存存放的是：①按序到达但未被接收应用程序读取的数据。②不按序到达的数据。<br>⑤TCP是面向字节流的，虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅视为玉莲船的无结构的字节流。  </li><li>TCP和UDP在发送报文时采用的方式完全不同，UDP报文的长度由发送应用程序决定，而TCP报文长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。如果应用程序传送到TCP缓存数据块太长了，TCP就把它划分短一些再传送，太短也可以积累到组成够多字节再组成报文段发送出去。  <h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3></li><li>TCP传送的数据单元是报文段，既可以来运送数据，又可以建立连接，释放连接和应答。一个TCP报文段分为首部，数据两部分，整个TCP报文段作为IP数据报的数据部分。首部前20B都是固定的，最短20B。  <img src="/2022/05076519/6.jpg" class>  </li><li>各个字段意义：<br>源端口和目的端口：各占2B，端口是运输层和应用层的服务接口，运输层的复用和分用都需要通过端口实现。<br>序号：占4B，一共2的32次方个序号，TCP面向字节流，所以每个字节都需要按顺序编号，指的是本报文段所发送的数据的第一个字节的序号。<br>确认号：占4B，期望收到对方下一个报文段的第一个数据字节的序号，若确认号为N，咋表明N-1的所有数据都已经正确收到。<br>数据偏移：占4位，指出TCP报文段数据起始位置距离TCP报文段的起始处有多远。单位是32位，因此字段为15的时候，TCP首部最大长度是60B.<br>保留：占6位，保留位今后使用，先置为0.<br>紧急位URG：为1时标识紧急指针字段有效，告诉系统此报文段由紧急数据，应尽快传送，但需要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。<br>确认位ACK：仅当ACK&#x3D;1时确认号字段才有效，当为0的时候，确认号无效。TCP规定，连接建立之后所有报文段都是ACK&#x3D;1。<br>推送位PSH：接收方TCP收到PSH&#x3D;1的报文段，尽快把它交付给应用程序，不等到缓存充满再交付。<br>复位位RST：RST&#x3D;1时表明TCP连接中出现严重差错，必须释放连接，然后再重新连接。<br>同步位SYN：SYN&#x3D;1时表明这是一个连接请求，当SYN&#x3D;1且ACK&#x3D;0的时候表明这是一个请求连接报文，对方同意连接则响应报文中SYN&#x3D;1，ACK&#x3D;1。<br>终止位FIN：释放一个连接，当FIN&#x3D;1，表明此报文段的发送方的数据以及发送完毕，并要求释放连接。<br>窗口：占2B，指出现允许对方发送的数据量，接收方的数据缓存有限，因此用窗口值作为接收方让发送方设置其发送窗口的依据。（设为1000，说明接收缓存空概念还有1000字节数据）<br>校验和：占2B，校验和检验数据部分和首部，和UDP一样，加入12B的伪首部。<br>紧急指针：占2B，紧急指针仅在URG&#x3D;1时有意义，指出在本报文段中紧急数据共多少字节。<br>选项：长度可变，TCP最初只规定了一个选项，即最大报文长度MSS。（数据部分最大长度）<br>填充：为了使得整个首部长度是4B的整数倍。  <h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3></li><li>三个阶段：连接建立，数据传送，连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。  </li><li>TCP连接建立过程，解决三个问题：<br>①使得每一方都能够确知对方存在。<br>②允许双方协商一些参数。<br>③能够对运输实体资源进行分配。<br>TCP连接两端的端口为套接字socket或插口，每条TCP被唯一的两个套接字确定，采用C&#x2F;S方式，主动发起连接建立的应用进程称为客户Client，而被动等待连接建立的应用进程称为服务器Server。  </li><li>TCP连接建立：“三次握手”  <img src="/2022/05076519/7.jpg" class>  连接建立之前，服务器进程属于LISTEN状态等待客户连接请求。<br>①客户机的TCP首先向服务器的TCP发送连接请求报文段，这个特殊报文段的首部中的同步位SYN&#x3D;1，同时选择一个初始序号seq&#x3D;x。TCP规定，SYN报文段不可以携带数据，但要消耗掉一个序号。这时，TCP客户端进程进入SYN-SENT状态。<br>②服务器的TCP收到连接请求报文段后，如果同意连接，则向客户机发挥确认，并为该TCP连接分配缓存和变量。在确认报文段中，把SYN和ACK都置为1，确认号是ack&#x3D;x+1，同时也为字节选择的一个初始序号seq&#x3D;y。注意，确认报文段不能携带数据，但也消耗一个序号。这时，TCP服务器进程进入SYN-RCVD状态。<br>③当客户机收到确认报文的时候，还要向服务器给出确认，并且为该TCP分配缓存和变量，确认报文段的ACK为1，确认号ack&#x3D;y+1，序号为seq&#x3D;x+1。该报文段可以携带数据，若不携带数据则不消耗序号。这时TCP客户进程进入了ESTABLISHED状态。<br>之上三步就连理了TCP连接，接下来就可以传送应用层数据了，全双工通信。值得注意的是：服务器端分配资源是在第二次握手的时候分配的，客户端的资源是在第三次握手时分配的。  </li><li>TCP连接的释放：“四次挥手”  <img src="/2022/05076519/8.jpg" class>   ①客户机打算关闭连接，向TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文端的终止位FIN&#x3D;1，序号seq&#x3D;u，它等于前面已经传送过的数据的最后一个字节的序号+1，FIN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FIN-WAIT-1状态，但TCP全双工，即一条TCP连接上有两条数据通路，发送FIN的一端不可以发送数据，即关闭了一条数据通路，但对面还可以发送数据。<br>②服务器收到连接释放报文段后即发出确认，确认号ack&#x3D;u+1，序号seq&#x3D;v，等于前面已经传送过的数据的最后一个字节的序号+1，然后服务器进入CLOSE-WAIT状态，此时从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态，但服务器若发送数据，客户机仍要接受，即从服务器到客户机这个方向的连接并未关闭。<br>③若服务器已没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN&#x3D;1的连接释放报文段，设该报文段的序号为w，还须重复上次已经发送的确认号ack&#x3D;u+1。这时服务器进入LAST-ACK状态。<br>④客户机收到连接释放报文段之后，必须发出确认，把确认报文段中的确认位ACK置为1，确认号ack&#x3D;w+1，序号seq&#x3D;u+1.此时TCP连接还未释放，必须经过时间等待计时器设置的时间为2MSL（最长报文段寿命）后，客户机才进入CLOSED状态。  </li><li>总结：  <img src="/2022/05076519/9.jpg" class>    <h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3>保证接收方进程从缓存区读取的字节流和发送方发出的字节流完全一致。使用了校验，序号，确认，重传的机制来达到这个目的（校验和UDP一样，不赘述）。  </li><li>序号：<br>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。每个字节都有编号，但序号字段指的是本报文所发送的数据的第一个字节的序号。  </li><li>确认：<br>TCP首部的确认号是期望收到对方下个报文段的数据的第一个字节的序号，TCP默认使用累计确认，即只确认数据流中至第一个丢失字节为止的字节。（即使已经收到了6-7字节，但3字节丢失，确认号仍然是3）  </li><li>重传：<br>有两种事件导致TCP对报文段进行重传：超时和冗余ACK。<br>①超时：<br>TCP每发送一个报文段，就会设置一次计时器，重传时间到期仍未收到确认就重传。<br>由于路由选择变化大，时延方差很大，所以为了计算重传时间，TCP使用自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（RTT），保留RTT加权平均往返时间RTTs，随着样本变化而变化，显然超时计时器设置的超时重传时间RTO应该略大于RTTs，但也不能太多，否则丢失时不能很快重传，导致数据传输时延过大。<br>②冗余ACK：<br>超时重传存在问题就是超时周期太长。但发送方可以在超时事件发生前通过注意所谓的荣誉ACK来较好地监测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方已经受到过该报文段的确认。TCP规定每当比期望序号大的失序报文段到达的时候，就发送i给冗余ACK，指明下一个期待字节的序号。当收到同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失，这属于快速重传技术。  <h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3></li><li>TCP流量控制来消除发送方使接收方缓冲区溢出的可能性，因此可以说流量控制是一个速度匹配服务。提供一种基于滑动窗口协议的流量控制机制，在通信过程中，接收方根据字节接收缓存的大小，动态调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，限制发送方向网络注入报文速率，同时发送方根据对齐当前网络拥塞程度估计而确定窗口值，称为拥塞窗口cwnd，其大小与网络带宽和时延密切相关。   <img src="/2022/05076519/10.jpg" class>     </li><li>传输层和数据链路层的流量控制区别：<br>传输层定义端到端之间的流量控制，数据链路层定义两个中间相邻结点之间的流量控制，且数据链路层滑动窗口协议的窗口大小不能动态变化，而传输层的可以动态变化。  <h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3></li><li>拥塞控制是防止过多的数据注入网络，保证网络中的路由器&#x2F;链路不至于过载。</li><li>拥塞控制与流量控制区别：拥塞控制让网络能够承受现有的网络负荷，是一个全局性过程，涉及所有的主机，路由器，以及与降低网络传输性能有关的所有因素，相反，流量控制则是点对点通信量控制，是端到端的维妮塔，只要抑制发送方速率以便于接收方来得及接收。  </li><li>因特网定义了拥塞控制的4种算法：慢开始，拥塞避免，快重传，快恢复。  </li><li>发送方确定发送报文段速率的时候，既要根据接收方接收能力，又要全局考虑不要使网络发生拥塞，因此TCP协议要求发送方维护以下两个窗口：<br>①接收窗口rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量，由接收方根据其放在TCP报文的首部窗口字段通知发送方。<br>②拥塞窗口cwnd，发送方根据自己估算的拥塞程度而设置的窗口值，反映当前容量，只要网络未出现拥塞，就可以把拥塞窗口再增大一些，以便把更多的分组发送出去，但只要网咯出现拥塞，拥塞窗口就减小一些。<br>③发送窗口上限&#x3D;两者中小的那个。  </li><li>慢开始：<br>当TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd&#x3D;1，即一个最大报文段长度MSS，每收到一个对新报文段的确认cwnd就加一。这个慢开始的“慢”并不是cwnd增加速度慢，而是开始先发送第一个报文段，然后开始逐渐增大cwnd，这对防止网络出现拥塞是一个非常有力的措施。使用慢开始算法后，每经历一个RTT，cwnd都会加倍，即指数型增长，这样，慢开始增到一个规定的慢开始门限ssthresh，然后改用拥塞避免算法。  </li><li>拥塞避免算法：<br>思路就是让拥塞窗口cwnd缓慢增大，具体做法是，没经历一个RTT，要把发送方的拥塞窗口+1，而不是加倍，线性缓慢增长，根据cwnd大小执行不同算法，可归纳如下：<br>①cwnd小于ssthresh，使用慢开始算法。<br>②cwnd大于ssthresh，停止使用慢开始算法改用拥塞避免算法。<br>③cwnd等于ssthresh，两者均可以使用，通常使用拥塞避免算法。 </li><li>网络拥塞处理：<br>无论慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到通知），就要把慢开始门限ssthresh设置为拥塞发送方的cwnd值的一半，然后把cwnd重新设置为1，执行慢开始算法，目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。  <img src="/2022/05076519/11.jpg" class>     拥塞控制不能完全避免，是使网络不容易出现拥塞。  </li><li>快重传：<br>快重传使用冗余ACK监测丢包发生，而且冗余ACK也用于网络拥塞，当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待报文段重传计时器。  </li><li>快恢复：<br>原理：当发送方连续收到三个重复的ACK报文时，执行“乘法减小”算法，把慢开始门限ssthresh设置为此时发送方cwnd的一半。这是为了预防网络发生拥塞，但放生发认为现在网络没有发生拥塞，否则不会有几个报文段连续到达接收方，也不会连续收到重复确认，因此与慢开始不同的是，它把cwnd值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法（“加法增大”），跳过了从cwnd&#x3D;1开始过程，所以称为“快恢复”。  <img src="/2022/05076519/12.jpg" class>    </li><li>总结：TCP建立连接和网络超时时，采用慢开始和拥塞避免，当发送发接收到冗余ACK时，采用快重传和快恢复。快重传和快恢复是对慢开始和拥塞避免的一种改进。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>MSS设置太小，：网络利用率很低，如果TCP报文段只有1B数据，40B首部，则效率小于1&#x2F;41，到了链路层还要进行开销，利用率进一步降低。<br>MSS设置太大：IP层传输进行分片，终端还要重组，传输有差错还要进行重传，都会增大开销。<br>所以，MSS应该尽量大些，只要到IP层不需要分片就行，最佳MSS很难确定，一般默认536B。  </li><li>最后一次挥手等待2MSL时间：<br>①保证A发送的最后一个确认报文段能够到达B，如果A不等待2MSL，若A返回最后确认报文段丢失，B就不能进入正常关闭状态，而A已经关闭无法重传。<br>②防止出现“已失效的连接请求报文段”，A发送最后一个确认报文段后，经过2MSL保证本连接持续时间内所有报文段从网络中消失。  </li><li>TCP和GBN区别：TCP正确收到但失序的报文不会丢弃而是缓存起来，并且发送冗余ACK指明期望收到的下一个报文段。而GBN就丢弃了。  </li><li>超时时间之后cwnd变为1，是因为拥塞程度更严重。<br>收到3个冗余ACK时cwnd减半，因为拥塞程度不是很严重，能收到冗余ACK。  </li><li>为什么不用“两次握手”建立连接？<br>为了防止两次握手情况下，已经失效的连接请求突然传送到服务器而产生错误。如果客户A向服务器B发出TCP连接请求，第一个连接请求报文长时间滞留，A超时认为丢失则重传，B收到之后建立连接，数据传输完毕断开连接，此时这个丢失的连接请求到达服务器B，而B认为A又发来连接请求，若使用“三次握手”，则B向A返回确认报文段，由于是一个失效的请求，因此A不予理睬，建立连接失败。  </li><li>TCP每次建立连接选择初始序号一定和前面的一些连接所用的序号不同。  </li><li>若网络不发生错误，无差错，TCP是不是多余？<br>不多余！！！<br>①数据到达目的结点会失序。<br>②由于路由计算错误，IP数据报在互联网中转圈，TTL&#x3D;0，被丢弃。<br>③某个路由器通信量大处理不及时，有的数据报被丢弃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2022/050628245.html"/>
      <url>/2022/050628245.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>有一个排列P1P2P3PiPjPn，若Pi&gt;Pj，则称Pi和Pj为逆序，一个排列中所有逆序的全体叫做逆序数。  </p>  ]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网络层</title>
      <link href="/2022/05033405.html"/>
      <url>/2022/05033405.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络网络层"><a href="#计算机网络网络层" class="headerlink" title="计算机网络网络层"></a>计算机网络网络层</h1><img src="/2022/05033405/1.jpg" class><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p>网络层设计思路就是，向上提供简单灵活，无连接，尽最大努力交付的数据报服务。如果主机中进程之间的通信需要可靠的，可以由更高层的传输层负责。  </p><h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><ul><li>把全球网络互联需要解决不同的问题，网络层任务之一就是互联它们。所谓互联就是把两个及以上计算机网络通过一定方法，用一种&#x2F;多种通信设备互相连接成为更大的网络系统，中间设备又称为中间系统&#x2F;中继系统。  </li><li>中继系统分为四种：①物理层中继系统：中继器，集线器。②数据链路层中继系统：网桥，交换机。③网络层中继系统：路由器。④网络层以上的中继系统：网关。</li><li>但物理层的中继系统只是扩大网络，不算是互联，因此网络互联指的是路由器进行网络互连和路由选择。</li><li>由于参加互联的网络都使用相同的网际协议（Internet Protocol,IP）,因此把互联后的计算机网络视为全部连接到一个虚拟的IP网络，看不见网络异构的细节。  <h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3></li><li>路由器珠岙两个功能：路由选择，分组转发。</li><li>路由选择：根据特定路由选择协议构造出路由表，同时经常和相邻路由器交换信息不断更新维护路由表。得到整个网络拓扑变化情况，动态改变所选择路由。  </li><li>分组转发：转发表查询，转发，已经相关队列管理和任务调度等。由转发表把用户IP数据报从合适端口转发出去。</li><li>路由表根据路由选择算法计算出的，而转发表是从路由表得出的，转发表的结构应当使得查找最优化，路由表则需要对网络拓扑变化的计算最优化，往往笼统都是用路由表一词。<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3></li><li>通信子网中过量分组引起网络性能下降称为拥塞。一旦分组到达路由器速率到达带宽附近则时延就急剧增加，且大量分组被丢弃。</li><li>判断是否进入拥塞方法：看网络吞吐量与负载的关系。如果随着网络负载增加，吞吐量明显小于正常，则轻度拥塞，吞吐量减小则可能已经拥塞，吞吐量讲到零则进入死锁状态。</li><li>作用就是：确保子网能够承载所达到的流量，全局性的过程，涉及各方面的行为：主机，路由器及路由器内部的转发处理等过程。单一增加资源并不能解决拥塞控制。</li><li>拥塞控制与流量控制区别：流量是两端点对点通信量的控制，只需要限制发送速率。而拥塞控制必须保证通信子网能够传送待传送的数据，是全局性的，涉及所有主机，路由器以及导致网络传输能力下降的所有因素。</li><li>方法有两种：<br>①开环控制：设计网络前把因素考虑周到，力求网络工作不产生拥塞，这是静态预防的方法，一旦系统启动就不修改。手段包括：何时确定可接收新流量，何时丢弃分组，丢弃哪些分组，确定调度策略等，总之不考虑当前网络状态。静态的方法。<br>②闭环控制：设计网络前不考虑因素，采用监测系统及时监测哪里发生拥塞，把拥塞信息传送到合适地方，调整整个系统运行，动态的方法。<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h3></li><li>路由器转发分组通过路由表转发，而表则从算法得到的，路由算法分两类：<br>①静态路由算法（非自适应路由算法）：需要网络管理员手工配置的路由信息，网络拓扑结构或链路状态发生变化的时候，需要手工配置，不能及时更新网络状态，适用于简单小型网络。<br>②动态路由算法（自适应路由算法）：路由器相邻之间彼此交换信息，按照一定比例游湖出来，则这些路由信息在一定时间间隙不断更新，随时获得最优寻路效果。</li><li>静态路由简单开销小，拓扑变化不大的网络效果好。动态路由算法负责增加网络负担，反应太快引起震荡，太慢引起路由不一致。动态有两种方法：距离-向量路由算法，链路状态路由算法。<h3 id="距离-向量路由算法（DV）"><a href="#距离-向量路由算法（DV）" class="headerlink" title="距离-向量路由算法（DV）"></a>距离-向量路由算法（DV）</h3></li><li>所有结点都定期把它的路由选择表传送给所有与之直接相连的结点，路由选择表包括每条路径目的地和代价。所有结点都监听从其他结点传来的路由选择更新信息：<br>①当被通告一条新的路由，该路由在本结点路由表中不存在，此时本地系统加入这条新路由。<br>②当发来的路由信息中有一个到达某个目的地路由更短距离（更小代价）则替代原路由。  </li><li>实质是：迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短通路。但更新信息与子网结点个数成正比。  </li><li>最常见的距离-向量路由算法是RIP算法，采用”跳数“作为距离度量。  <h3 id="链路状态路由算法（LS）"><a href="#链路状态路由算法（LS）" class="headerlink" title="链路状态路由算法（LS）"></a>链路状态路由算法（LS）</h3></li><li>要求每个参与结点都具有完全的网络拓扑信息，执行两步骤：①主动测试所有临界点状态，②定期把链路状态传播给所有其他结点。一个结点检查链路状态，并把状态信息传给全网所有结点（不是相邻结点），每个结点都通过这种方式接收状态信息，通过这些状态信息来更新自己网络拓扑和状态图，一旦链路发生变化，则利用Dijkstra算法重新计算路由，计算单源最短路径。最常用的链路状态路由算法是OSPF算法。</li><li>三个特征：<br>①向本自治系统的所有路由器发送信息，使用泛洪法Flooding，即路由器通过所有端口向相邻路由器发送信息，而接收到之后又重复该过程（但不发给刚才发给自己的那个路由器）。<br>②发送的信息是与路由器相邻的所有路由器的链路状态，所谓”链路状态“就是本路由器与哪些路由器相邻以及链路的”度量“。对于OSPF算法，”度量“则是费用，距离，时延，带宽等。<br>③当链路状态发生改变才发送信息。  </li><li>优点：每个路由都独立计算自己的信息。链路信息不改变进行传播，易于查找故障。当一个结点接到所有其他节点的信息则可以计算自己的信息。<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3></li><li>当网络规模扩大时，路由表成比例扩大，不仅消耗路由器缓冲区空间，而且需要CPU更多时间来扫描路由表，更多带宽交换路由状态信息，因此必须按照层次方式进行。  </li><li>因特网把互联网划分许多小自治系统，每个系统都自主决定系统内采用何种路由选择协议，则两系统间通信就需要协议来屏蔽差异。</li><li>路由选择协议划分两大类：<br>①自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体有RIP和OSPF。<br>②自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也成为域间路由选择，具体有BGP。  </li><li>使用层次路由的时候，OSPF把自治系统再划分若干区域，每个路由器只需要自导自己区域如何路由即可。<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h3></li><li>IPv4即现在普遍使用的IP，IP定义数据传送的基本单元——IP分组以及确切的数据格式，也包括规则，指明分组如何处理，错误如何控制。特别是IP还包含了非可靠投递的思想，以及于此关联的分组路由选择的思想。</li><li>IPv4分组的格式：如图：  <img src="/2022/05033405/11.jpg" class>  重要字段含义：<br>版本：IP的版本号，通常为4。<br>首部长度：占4位，最大进制15。<br>总长度：占16位，指的是首部和数据之和的长度，单位为字节，因此数据包最大长度为2的16次方-1&#x3D;65535B，以太网MTU&#x3D;1500B，因此IP数据报封装成帧的时候一定小于MTU。<br>标识：占16位。它是一个计数器，每产生一个数据报就加1，并且赋值给标识字段，但它并不是序号，因为IP不可靠服务，当一个数据报长度超过网络MTU时，必须分片，此时每个数据报片都需要复制一次标识号，以便能重新组装成原数据报。<br>标志：占3位，标志字段最低位为MF，MF&#x3D;1表示后面还有分片，MF&#x3D;0表示是最后一个分片，标志字段中间为DF，当DF为0的时候才允许分片。<br>片偏移：占13位，它指出较长的分组在分片之后，某片在原分组中的相对位置，片偏移以8个字节位偏移单位，每个分片的长度一定是8B的整数倍。<br>生存时间TTL：占8位数据报在网络中可以通过的路由器数量最大值，标识分组在网络中寿命，以确保不会永远在网络中循环。路由器在转发分组前，先把TTL减一，TTL&#x3D;0丢弃分组。<br>协议：占8位，指出此分组携带的数据使用什么协议，即分组的数据部分应该交给那个传输层协议，如TCP，UDP等，其中值为6表示TCP，17表示UCP。<br>首部校验和：占16位，IP数据报首部校验和只校验分组的首部，不校验数据部分。<br>源地址字段：占4B，发送方IP地址。<br>目的字段：占4B，接收方IP地址。  </li><li>IP数据报分片：<br>①一个数据链路层数据报能承受的最大数据量为MTU，因为IP数据报被封装在链路层数据报中，因此MTU限制着IP数据报的长度。而且在IP数据报目的&#x2F;源地可能不同的数据链路层协议，有不同的MTU。这时把IP数据报中数据分装在多个小的IP数据报中，称为片。<br>②片在目的地网络层被重新组装，目的主机使用IP首部标识，标志，片偏移字段来重组片，创建一个IP数据报的时候，源主机为该数据报加一个标识号，每个片的表示号一样，目的主机通过标识号来确定哪些片属于原始数据报。而IP首部中的标志位有3比特，但只有后2比特有意义，分别是MF和DF，DF为0时IP数据报才允许分片，MF&#x3D;0代表后边还有片，MF&#x3D;1代表是最后一片。目的主机重组的时候通过片偏移来确定数据报的各个片的位置。<br>③计算过程：  <img src="/2022/05033405/2.jpg" class>   </li><li>网络层转发分组流程：<br>①从数据报首部提取目的主机IP地址D，得出目的网络地址N。<br>②若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这成为路由器的直接交付，否则是间接交付执行③。<br>③若路由器有目的地址为D的特定主机路由，则把数据报交给路由表中指定的下一跳路由器，否则执行④<br>④若路由表中有到达网络N的路由，则把数据报传给路由表中指定的下一跳路由器，否则执行⑤<br>⑤若路由表有一个默认路由，则把数据报传送给默认路由器，否则执行⑥<br>⑥报告转发分组出错。  <h3 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h3></li><li>IPv4地址：<br>①连接到互联网的每台主句都分配了一个32比特的全球唯一标识符，即IP地址，传统IP地址是分类的地址，分为ABCDE五类。由网络号+主机号组成，网络和标志主机所连接到的网络，一个网络号在整个互联网必须是唯一的，主机号标志该主机，主机号在该网络号范围内必须是唯一的，所以整个IP地址就是唯一的。<br>②五类IP地址：  <img src="/2022/05033405/3.jpg" class>  ③各类IP地址有的不能用：<br>主机号全0表示网络本身，如202.98.174.0<br>主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255</li></ul><p>127.0.0.0保留为环回自检地址，表示任意主机本身，目的地址为该地址的IP数据报用不会出现网络上。<br>32位全为0，0.0.0.0表示本网络上的本主机。<br>32位全为1，255.255.255.255表示整个TCP&#x2F;TP网络的广播地址，但由于路由器隔离广播域，则认为它为本网络的广播地址。<br>④常用ABC网络IP地址使用范围：  </p><img src="/2022/05033405/4.jpg" class>   <p>⑤重要特点：<br>IP是分等级的地址结构，好处是：IP地址管理机构分配IP地址时只分配网络号，而主机号由网络自行分配。路由器根据网络号转发分组，不考虑主机号，减小路由器所占存储空间。<br>IP地址标志一条主机和一条链路的接口，当主机同时连接两个网络的时候必须有两个IP地址，则一个路由器必然至少有两个IP地址。<br>IP地址所有分配到网络号的网络都是平等的。  </p><ul><li>网络地址转换：<br>①Network Address Translation，NAT，通过把专用网络地址转换为公用网络地址，对外隐藏内部管理的IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网连通，由于本机IP地址可以重用，大大节省了IP地址消耗，同时隐藏内部网络结构，降低风险。<br>②为了网络安全，画出了部分IP地址为私有，私有IP地址只用于LAN，不用于WANianj，并且允许私有IP地址被LAN重复使用。在因特网中，路由器对于私有地址一律不予转发，称私有地址为专用互联网&#x2F;本地互联网，<br>③使用NAT需要在专用互联网连接到因特网的路由器上安装NAT软件，NAT路由器至少有i一个有效的外部全球地址，NAT路由器使用NAT转换表把本地地址转换为全球地址或反向，这两个地址在转发表中是映射关系，可以多个私有IP地址映射到同一个全球地址。  <h3 id="子网划分与子网掩码，CIDR："><a href="#子网划分与子网掩码，CIDR：" class="headerlink" title="子网划分与子网掩码，CIDR："></a>子网划分与子网掩码，CIDR：</h3>①子网划分：<br>使得两级IP地址变为三级IP地址。子网划分属于内部事情，对外仍然表现为没有划分子网的网络，从主机号借用若干比特作为子网号，当然主机号也相应减少了相同的比特，三级IP地址&#x3D;网络号+子网号+主机号。同样的路由器转发分组的时候现根据子网号找子网，再转发给目的主机。<br>注意：子网划分是把主机号再进行划分，不改变网络号。<br>②子网掩码：<br>对ABC类网络进行子网划分，必须使用子网掩码表示对于源网络中主机号的借位。它是一个32比特的二进制串，由一串1和跟随的0组成，1对应IP地址中网络号及其子网号，而0对应主机号，计算机只需要把它的IP地址和其对应的子网掩码逐位“与”就可以得到子网IP地址。未进行划分子网的有默认子网掩码：A类255.0.0.0，B类255.255.0.0，C类255.255.255.0。<br>子网掩码属于重要属性，所以路由器必须在相互交换路由信息的时候必须把自己所在的网络的子网掩码告诉对方，路由器每个条目，除了给出目的网络地址和下一跳地址外，还要给出目的网络的子网掩码。<br>③无分类域间路由选择（CIDR）：<br>无分类域间路由选择是在变长子网掩码基础上提出的一种消除传统ABC类网络划分，并且可以在软件支持下实现超网构造的一种IP地址划分方法。<br>特点：<br>CIDR使用网络前缀+主机号，即变成了无分类的IP地址。使用斜线技法——IP地址&#x2F;网络前缀所占比特数。把网络前缀相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，称为路由聚合，使得原来多个传统网络分类地址的路由变成现在一个，减少路由器之间的路由选择信息的交换，提高网络性能。<br>优点在于网络前缀长度的灵活性，且使用最长前缀匹配。  <h3 id="ARP，DHCP，ICMP："><a href="#ARP，DHCP，ICMP：" class="headerlink" title="ARP，DHCP，ICMP："></a>ARP，DHCP，ICMP：</h3>①IP地址和硬件地址：<br>IP地址是网络层使用的分层地址。硬件地址则是数据链路层使用的平面式的地址（MAC地址），IP地址放在IP数据报的首部，而MAC地址放在MAC数据帧首部，通过数据封装把IP数据报分组封装成MAC帧之后，数据链路层看不见数据报分组中的IP地址。<br>由于路由器隔离，IP只能通过IP地址寻址，依靠路由表跳转到目标网络，改为在目标LAN中通过数据链路层的MAC地址以广播方式寻址。（路由器只根据目的地IP地址的网络号进行路由选择）<br>在局域网数据链路层只能看见MAC帧，通过路由器转发IP分组的时候，此IP分组在每个网络中都被路由器解封装和重新封装，因此MAC地址不断改变，所以MAC地址无法夸网络通信。<br>②地址解析协议ARP：<br>无论网络层使用什么协议，在实际网络的链路上传送数据帧的时候，最终必须使用硬件地址，所以需要从IP转化为MAC，这就是地址解析协议ARP，每台主机都有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表，使用ARP来动态维护此表。<br>工作在网络层：原理如下：主机A想向B发送数据报，先在其ARP告诉缓存中查看有无主机B的IP地址，有则查其MAC地址，再写入MAC帧，通过局域网发送到此MAC地址。没有则使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并且广播ARP请求分组，使得同一个局域网里所有主机收到ARP请求。主机B收到ARP请求之后向主机A发出响应ARP分组，分组包含B的IP和MAC映射关系，A收到之后写入缓存，然后按照查询的MAC发送分组。（用于解决同一个局域网上的IP与MAC映射关系，不在同一个局域网就要通过ARP找到一个位于本局域网的路由器MAC地址，由这个路由器进行分组转发给下一个网络）<br>③动态主机配置协议（DHCP）：<br>常用给主机动态分配IP地址，提供了即插即用的机制，允许一台计算机加入新网络和获取IP地址而不用手工参与，是应用层协议，基于UDP。<br>工作原理：使用C&#x2F;S方式，需要IP地址的主机向DHCP服务器广播发送发现报文成为其客户，本地网络上所有主机都能收到此广播报文，但只有DHCP服务器能回复，DHCP服务器在其数据库查找是否有该计算机配置，有则返回信息，无则从服务器IP地址取一个地址分配给该计算机，称为提供报文。<br>DHCP服务器可能多个，客户端只需要挑选一个接收信息即可，通常是最先到达的。且分配的IP地址为临时的，称为租用期，数值应该由DHCP服务器自己决定，DHCP客户也可以进行要求。通过广播方式进行交互，因为客户端不知道服务器IP地址，而客户端没有IP地址，从而必须广播，且为UDP，因为没有IP地址无法使用TCP建立连接。<br>④网际控制报文协议（ICMP）：<br>为了提高IP数据报交付成功的机会，网络层使用ICMP让主机&#x2F;路由器报告差错和异常情况，ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。有两种：ICMP差错报告报文和ICMP询问报文。  </li><li>差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，有五类：<br>终点不可达：路由器&#x2F;主机不能交付数据报时。<br>源点抑制： 路由器&#x2F;主机由于拥塞丢失数据报，应该把数据报的发送速率降低。<br>时间超过：路由器收到TTL&#x3D;0的数据报时，除了丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定时间内不能收到一个数据报全部数据报片的时候就把已经收到的全部丢弃，并向源点发送时间超过报文。<br>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确的时候，就丢弃数据报，并向源点发送参数问题报文。<br>改变路由：路由器把改变路由报文发送给主机，让主机知道通过更好路由发送给另外的路由器。    </li><li>询问报文：有四种，回送请求和回答报文，时间戳请求和回答报文，掩码地址请求和回答报文，路由器询问和回答报文。  </li><li>ICMP常见的应用是分组网间探测PING（用来测试两台主机之间连通性）和Traceroute（跟踪分组经过路由），其中PING用了回送请求和回答报文，Traceroute使用了ICMP时间超过报文。PING工作在应用层，直接使用网络层ICMP，而Traceroute工作在网络层。  <h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6的主要特点"><a href="#IPv6的主要特点" class="headerlink" title="IPv6的主要特点"></a>IPv6的主要特点</h3>解决IP耗尽问题有三种：①采用CIDR无类别编址，使得IP地址分配更加合理。②采用网络地址转换NAT方法节省全球IP地址。③采用更大地址空间新版本IPv6。<br>IPv6特点：<br>①有更大地址空间，32位变成128位，字节数16B是4B的平方。<br>②扩展的地址层次。<br>③灵活的首部格式。<br>④改进的选项。<br>⑤允许协议继续扩充。<br>⑥即插即用（自动配置）。<br>⑦支持资源预分配。<br>⑧不允许分片。<br>⑨首部长度为8B的整数倍，而IPv4是4B的整数倍。<br>⑩增大了安全性，身份验证和保密功能是IPv6的整数倍。  <h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3>IPv6的数据报目的地址是：单播（传统点对点），多播（一对多，分组给一组计算机的每个），任播（IPv6增加的类型，数据报只交付给一组计算机的一台最近的计算机）。<br>使用了分级概念，三个等级：公共拓扑，单个场点，单个网络接口。  <h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3>AS，单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同度量来确定分组在该AS的路由，同时使用一种AS之间的路由选择协议来确定分组在AS之间的路由。一个自治系统的所有网络都由一个单位管线，且所有路由器都联通。  <h3 id="域间路由和域内路由"><a href="#域间路由和域内路由" class="headerlink" title="域间路由和域内路由"></a>域间路由和域内路由</h3>自治系统内部路由选择称为域内路由选择，外部称为域间路由选择。<br>①内部网关协议（Interior Gateway Protocol，IGP）：有RIP和OSPF。<br>②外部网关协议（External Gateway Protocol，EGP）：<br>若源站和目的站处于不同AS，则传送数据报的时候就需要使用一种协议把路由信息传递给另一个系统，这样的协议就是EGP，使用最多的就是BGP-4。  <img src="/2022/05033405/5.jpg" class>    <h3 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h3>基于距离向量的路由选择协议（DV），最大优点就是简单。<br>①RIP规定：<br>网络中每个路由器都需要维护从它自身到其他每个目的网络的距离记录。<br>距离也称为跳数，每经过一个路由+1。<br>RIP认为好的路由就是跳数小，允许最多15跳，大于15则不可达，所以只使用小型互联网。<br>RIP默认两个使用RIP路由器之间每30s一次广播路由更新信息，以便建立更新维护路由表。<br>②RIP特点：<br>只和自己相邻路由器交换信息。<br>路由器交换信息是当前路由器所知道的全部信息，即自己的路由表。<br>按照固定时间间隔交换路由信息，如每隔30s。<br>③距离向量算法：<br>路由表有三个关键数据：目的网络N，距离d，下一跳路由器地址X。则每个RIP报文执行：  </li><li>地址X相邻路由器发来报文，修改此报文所有项目，把下一跳改为X，距离+1。  </li><li>对于修改后的RIP报文中每个项目要：当前路由表中没有目的网络N，则添加。有目的网络N且下一跳路由器是X则替换。有目的网络N且下一跳路由器不是X且新距离短则替换，距离长则不做改变。  </li><li>若180s没有收到更新路由表，把相邻路由器记作不可达路由器，距离设置为16。   </li><li>返回。<br>④优缺点：<br>优点就是实现简单，开销小，收敛过程快。<br>缺点就是RIP限制网络规模，能够使用最大距离为15。路由器之间交换的是完整路由表，网络规模越大开销越大。网络出现故障的时候出现慢收敛现象。<br>RIP是应用层协议，使用UDP传送数据，路径一定是路由器最少的路径，但不一定是时间最短的路径。  <h3 id="开放最短路径优先协议（OSPF）"><a href="#开放最短路径优先协议（OSPF）" class="headerlink" title="开放最短路径优先协议（OSPF）"></a>开放最短路径优先协议（OSPF）</h3>①OSPF的特点：</li><li>与RIP区别：<br>OSPF使用洪泛法向所有路由器发送信息。而RIP向相邻路由器发送信息。<br>OSPF发送信息是与本路由器相邻所有路由器的链路状态。而RIP是整个路由表。<br>OSPF当链路发生变化的时候才更新路由器。而RIP是定期更新。<br>OSPF是网络层协议，使用IP数据报传送。而RIP是应用层协议，使用UDP传送。  </li><li>OSPF还有自己的特点：<br>OSPF对于不同链路根据IP分组不同服务类型而设置不同代价，因此计算出不同路由，很灵活。<br>如果对同一个目的网络有多条代价相同的路径，则可以把通信量分配给这几条路径，称为多路径之间的负载平衡。<br>所有在OSPF路由器之间的交换分组都有鉴别功能，保证了仅在可信赖路由器之间交换链路状态信息。<br>支持可变长子网划分和无分类编址CIDR。<br>每个链路状态都有自己32位序号，序号越大，状态越新。<br>②OSPF基本原理：<br>各路由器之间频繁交换链路状态，因此都可以建立一个链路状态数据库，就是全网拓扑图，在全网范围内是一致的，然后用Dijkstra计算单源最短路径，构造自己路由表，更新之后继续计算构造新路由表即可。<br>为了使得OSPF能够用于更大的网络，需要把AS再次划分称为更小范围的区域，减小了通信量。<br>③OSPF的五种分组类型：<br>问候分组：用来发现和维持邻站的可达性。<br>数据库描述分组：向邻站给出自己链路状态数据库中信息。<br>链路状态请求分组：向对方请求发送某些链路状态项目的详细信息。<br>链路状态更新分组：用洪泛法对全网更新状态。<br>链路状态确认分组：对链路更新分组的确认。<br>通常10s，两个相邻路由器交换一次问候分组，知道哪些可达。路由器开始工作的时候，OSPF让每个路由器使用数据库描述分组和相邻交换本数据库中的信息，然后路由器使用链路状态请求分组，向对方请求发送自己缺少的某些链路状态项目的详细信息。经过一系列的分组交换，建立全网同步的链路状态数据库。<img src="/2022/05033405/6.jpg" class>  <h3 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h3></li><li>常用于互联网网关之间，只求能找到一条到达目的网络且较好的路由，并非最佳路由，使用的是路径向量DV，BGP是应用层协议，基于TCP。  </li><li>工作原理如下：每个自治系统管理员选择一个路由器（可以多个）作为发言人，发言人之间交换路由信息（建立TCP连接），当所有的发言人都相互交换信息之后就可以找到各个自治系统的较好路由。  </li><li>特点：<br>AS数量级就是BGP的节点数量级，比AS中的网络数量小很多。<br>发言人数量很少，使得AS间的路由选择不复杂。<br>BGP支持CIDR。  </li><li>BGP一共使用4种报文：<br>①打开报文（Open），用来与相邻的另一个BGP发言人建立关系。<br>②更新报文（Update），用来发送某一路由的信息，以及列出要撤销的多条路由。<br>③保活报文（Keepalive），用来确认打开报文并周期性地证实邻站关系。<br>④通知报文（Notification），用来发送检测到的差错。<h3 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h3><img src="/2022/05033405/7.jpg" class>  <h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP组播的概念"><a href="#IP组播的概念" class="headerlink" title="IP组播的概念"></a>IP组播的概念</h3></li><li>让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被他们正确接收。组播一定仅应用于UDP，TCP一对一不适用。让源主机把单个分组发送给一个组播地址，该组播地址标识一组地址，而一个主机可以属于多个组。  </li><li>主机使用IGMP协议加入组播组，它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组愿望。  </li><li>主机组播仅仅发送一份数据，路径分叉的时候才复制，因此大大减轻网络负载和发送者负担，组播需要路由器支持才能实现，能够运行组播协议的路由器称为组播路由器。  </li><li>组播和单播区别：  <img src="/2022/05033405/12.jpg" class>  <h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3></li><li>使用D类地址，前四位1110，因此D类范围为224.0.0.0———239.255.255.255，每个IP地址标志一个组播组。  </li><li>组播数据报和IP数据报区别是：前者使用D类IP地址作为目的地址，并且首部协议字段为2，使用IGMP，需要注意的是：<br>①组播数据报是不可靠的，尽最大努力交付的。<br>②组播地址只能用于目的地址，不能用于源地址。<br>③对于组播数据报不产生ICMP差错报文，因此PING命令不响应。<br>④并非所有D类地址都可以是组播地址。  </li><li>组播地址分两种：本局域网内硬件组播，因特网内组播。  <h3 id="IGMP与组播路由算法"><a href="#IGMP与组播路由算法" class="headerlink" title="IGMP与组播路由算法"></a>IGMP与组播路由算法</h3></li><li>要使路由器知道组播成员信息，需要利用因特网组管理协议IGMP，连接到局域网上的组播路由器必须和因特网上其他组播路由器协同工作，以便把组播数据报以最小代价传送给所有组成员，所以使用组播路由选择协议。  </li><li>IGMP不知道IP组播包含的成员，而是让连接在本地局域网上的组播路由器知道主机是否参加&#x2F;退出了某个组播组。  </li><li>IGMP工作两个阶段：<br>①某台主机加入新组买主机应该向组播组的组播地址发送一个IGMP报文，声明自己要成为成员，本地组播路由器收到以后，把组成员关系转发给因特网上的其他组播路由器。<br>②组成员是动态的，本地组播路由器周期性探询主机，看看是否还是成员。  </li><li>组播路由实际就是找出以源主机为根结点的组播转发树。  <h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h3 id="移动IP的概念"><a href="#移动IP的概念" class="headerlink" title="移动IP的概念"></a>移动IP的概念</h3></li><li>支持移动性的因特网体系结构与协议称为移动IP，为了满足移动结点在移动中保持连接性而设计的。确切的说，移动IP技术是指移动结点以固定IP地址跨越不同网段的漫游功能，且保证网络权限不发生改变。</li><li>基于IPv4的移动IP定义三种功能实体：<br>①移动结点：具有永久IP地址的移动结点。<br>②本地代理：一个网络环境中一个结点永久的“居所”称为归属网络，在归属网络中代表结点执行移动管理功能的实体为本地代理。<br>③外部代理：外部网络中帮助结点完成移动管理功能的实体为外部代理。  <h3 id="移动IP的通信过程"><a href="#移动IP的通信过程" class="headerlink" title="移动IP的通信过程"></a>移动IP的通信过程</h3></li><li>移动结点本地地址唯一且不变，所以本地网络链路上每个本地结点需要本地代理为它维护当前位置信息，需要引入转交地址。当移动结点连接到外地网络链路上时，转交地址用来标识结点现在所处位置，以便进行路由选择。移动结点本地地址和转交地址的联合称为移动绑定&#x2F;绑定，当移动结点获得一个新的转交地址，通过绑定向本地代理注册，以便让本地代理了解移动结点所处位置。  </li><li>通信过程如下：<br>①移动结点连接本地网使用传统TCP&#x2F;IP通信。<br>②漫游到外地网络，需要向本地代理注册当前位置地址，这个位置地址是转交地址。<br>③本地代理接收注册之后，构建一条通向转交地址的隧道，把截获的发给移动结点的分组通过隧道传给转交地址处。<br>④转交地址接触封装，回复原始IP分组，最后送到移动结点。<br>⑤移动结点在外网通过路由器&#x2F;外部代理向通信对端发送数据包。<br>⑥移动结点来到另一个外网时，需要向本地代理更新注册的转交地址，就可以继续通信。<br>⑦移动结点回到本地网时，移动结点向本地代理注销转交地址，继续以TCP&#x2F;TP进行通信。  </li><li>移动IP为主机设置两个IP地址，主地址和辅地址（转交地址）。移动结点本地网用主地址，移动另外网络使用临时辅地址，主地址不变。  <h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h3></li><li>路由器是一个具有多个输入&#x2F;输入端口的专用计算机，任务是连接不同网络并完成路由转发。同一个网络传递无须路由器的参与，而跨网络通信必须通过路由器进行转发。</li><li>从结构上看，路由器由路由选择和分组转发两部分构成，路由器是网络层设备，实现了网络模型的下三层，即物理层，数据链路层，网络层。  <img src="/2022/05033405/8.jpg" class>   </li><li>路由选择部分也叫控制部分，核心构建是路由选择处理机，其任务是根据所选定的路由选择协议构造出路由表，同时经常或者定期地和相邻路由交换路由信息不断更新维护路由表。  </li><li>分组转发部分由三部分组成：交换结构，一组输入和一组输入端口。输入端口从物理层接收到的比特流中提取出数据链路层的帧，从帧中提取出网络层数据报，输出端口则执行恰好相反的操作。交换结构则是关键部件，根据转发表对分组处理，把某个输入端口进入的分组从一个合适的端口转发出去，有三种常见方法：通过存储器进行交换， 通过总线进行交换，通过互联网络进行交换。  <h3 id="路由表和路由转发"><a href="#路由表和路由转发" class="headerlink" title="路由表和路由转发"></a>路由表和路由转发</h3>标准路由表有四个项目：目的网络IP地址，子网掩码，下一跳IP地址，接口。  <img src="/2022/05033405/9.jpg" class>  转发表是由路由表得到的，格式不同，含有目的地址和下一跳MAC地址。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>尽最大努力的交付含义：有可能有差错，有可能不按时，有可能不按序，有可能重复，有可能意外丢失数据报。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络数据链路层</title>
      <link href="/2022/050135078.html"/>
      <url>/2022/050135078.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络数据链路层"><a href="#计算机网络数据链路层" class="headerlink" title="计算机网络数据链路层"></a>计算机网络数据链路层</h1><img src="/2022/050135078/1.jpg" class> <h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，把其可能出错的物理连接改造为逻辑上无差错的物理链路，使之对于网络层表现为一条无差错的链路。功能如下：</p><ul><li>为网络层提供服务：<br>①对于网络层，链路层基本任务就是把原机器来自网络层数据传输到目的机器网络层，提供三种服务。<br>②无确认的无连接服务：不需要连接，不发送确认，丢失帧不负责，适用于实时性强误码率低的通信信道，如以太网。<br>③有确认的无连接服务：不需要连接，但发送确认，源机器长时间没收到确认就重传帧，适用于误码率高的通信信道，如无线通信。<br>④有确认的面向连接服务：需要建立连接，每个帧都需要确认，适用于通信要求高的场合。<br>⑤有连接一定要有确定，不存在无确认的无连接服务。</li><li>链路管理：<br>数据链路层连接的建立，维持，释放的过程称为链路管理，主要用于面向连接服务，链路两端结点进行通信，必须首先确认对方已处于就绪状态，交换信息对帧序号初始化之后才能建立连接。多个站点公用一个物理信道如何分配和管理信号也属于管理范畴。  </li><li>帧定界，帧同步，透明传输：<br>①主机之间传输信息把网络层分组封装成帧，分别添加首部尾部，都包含很多控制信息，为了确定帧的界限，即帧定界。<br>②帧同步指的是接收方能够从接收到的二进制比特流中区分帧的起止。<br>③为了提高帧传输效率，应该使得数据部分长度尽可能大于首部和尾部，但每个协议都规定数据部分长度上限——最大传送单元MTU。<br>④数据部分恰好出现与帧定界相同的比特组合会误认为结束了，则采用透明传输————不管什么样的数据部分都能在链路上传送。</li><li>流量控制：<br>①由于收发双方各自工作速率和缓存空间差异，可能出现发送能力高于接收能力，如果不调整发送速率会使得未被接收的帧被后来的帧淹没而丢失，因此，流量控制就是限制发送方的数据流量，使得其发送速率不超过接收方的接收能力。<br>②需要反馈机制使得发送方知道接收方能否跟得上自己，需要知道何时才能发送下一帧，何时暂停发送。<br>③流量控制并不是链路层特有的功能，许多高层协议也有该功能，控制对象不同。链路层控制的是两结点之间的数据链路上的流量，运输层是端之间的流量。  </li><li>差错控制：<br>①由于噪声等因素，帧会出错，则用以使得发送方确定接收方是否正确收到其发送的数据的方法为差错控制，错误可以分为位错和帧错。<br>②位错使用循环冗余校验（CRC）的方法，通过自动重传请求（Automatic Repeat reQuest，ARQ）方式进行重传出错的帧。具体做法是：发送方的帧中包含一定CRC冗余码一并发送，接收方根据检错码对帧进行验证，错误就丢弃，发送方超时而重传，这种方法叫ARQ，只需要回复少量的控制信息就可以确定帧是否正确接收。<br>③帧错误包括丢失，重复，失序等，在链路层引入定时器和编号机制，超时或者编号缺少则重传，保证每帧都能传到目的结点。<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2>数据链路层为啥组帧——出错时只重发出错的帧而不是全部数据，提高效率。为了能够监测错误，必须依照一定规则把网络层的分组组帧。组帧解决帧定界，帧同步，透明传输等问题，有四个方法组帧：</li><li>字符计数法：帧头部有一个计数字段，缺点：如果头部出错就失去了帧边界，无法判断结束和下一个帧开始，直接失去同步，造成灾难性后果。</li><li>字符填充的首尾定界法：特殊字符定界开始和结束，数据中如果出现结束符，则在前边加上一个标识符比秒结束，接收方遇见标识符删去即可得到原来数据。 <img src="/2022/050135078/2.jpg" class> </li><li>零比特填充的首尾标志法：还能进行透明传输，如图：  <img src="/2022/050135078/3.jpg" class> </li><li>违规编码法：物理层进行比特编码的时候常用违规编码法，借用违规的编码序列来标志开始和结尾，不需要任何填充技术，便实现透明传输，只适用于冗余编码的特殊编码环境。  </li><li>目前常用比特填充和违规编码法。<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2>实际通信传输中可能产生比特差错，通常利用编码技术进行差错控制，主要有两类：自动重传请求ARQ和前向纠错FEC。在ARQ中接收端检测出错的时候通知重发直到正确，FEC中可以确定比特串错误位置进行纠正，因此可以分为检错编码和纠错编码。</li><li>检错编码：检错编码都是采用荣誉编码技术，核心思想就是在有效数据发送前按照某种关系附加一定冗余位，构成一个符合某规则的码之后再发送，当发送数据发送变化的时候，相应冗余位也变化，常见的有奇偶校验码和循环冗余码。<br>①奇偶校验码：由n-1位信息元和1位校验元组成，如果是奇校验码则n个码字中1的个数为奇数，偶校验码则为偶数。只能校验是否出错，不知道出错情况。<br>②循环冗余码：CRC，熟练掌握计算过程！！！给定一个m位的帧&#x2F;报文，发送器生成一个r位的序列称为帧检验序列FCS，形成的帧由m+r位组成，事先双方商定一个G（x）作为检验，可以被整除无余数即可认为无差错。（其实CRC有纠错功能，但链路层没用到）</li><li>纠错编码：最常见的就是海明威码，熟练掌握计算过程！！！原理是有效信息位中加入几个校验位形成海明码，并且把海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错之后会引起有关的几个校验位的值发生变化，不但能发现错位还能找到其位置，为自动纠错提供依据。<h2 id="流量控制与可靠性传输机制"><a href="#流量控制与可靠性传输机制" class="headerlink" title="流量控制与可靠性传输机制"></a>流量控制与可靠性传输机制</h2></li><li>流量控制，可靠传输与滑动窗口机制：<br>①流量控制对帧的发送速率，以便接收方有足够的缓冲空间来接收每个帧。基本方法由接收方控制发送方发送速率，常见方法有两种：停止-等待协议和滑动窗口协议。<br>②停止-等待协议：基本原理就是发送方每发送一帧都要等待接收方应答才发送下一帧，接收方同理，不反馈则会一直等待，因此效率很低。<br>③滑动窗口协议： 在任意时刻，发送方都维持一组连续的允许发送的帧的序号，为发送窗口，同理接收方的接收窗口。而发送窗口大小指的是接收方未发送确认信息前还能发送多少个数据帧。同时接收窗口只有收到数据帧序号落入接收窗口内才能把帧收下，窗口外直接丢弃。同时发送方每收到一个确认帧就前移一个位置，当发送窗口没有可以发送的帧的时候就停止直到收到确认，接收方也是收到数据帧之后前移并发回确认帧。<br>滑动窗口特性：<br>只有接收窗口前移，发送窗口才能前移。<br>接收窗口大小为1的时候可以保证帧的有序接收。<br>窗口大小在传输过程中是固定的。<br>④可靠传输机制：经常使用确认和超时重传两种机制完成，ARQ就是处理差错的方法之一，常见ARQ有：停止等待ARQ，后退N帧ARQ，选择性重传ARQ。在数据链路层中，流量控制和可靠性传输交织在一起。  <img src="/2022/050135078/4.jpg" class>  <img src="/2022/050135078/5.jpg" class>  </li><li>单帧滑动窗口和停止等待协议：<br>①停止等待是发送和接收窗口均为1的滑动窗口，单帧。<br>②除了数据帧丢失之外，还存在两种差错：帧遭到破坏和数据帧正确确认帧错误。<br>③帧遭到破坏被检测出来之后丢弃，发送方有计时器，长时间未接到确认就重复发送直到成功。<br>④信道利用率太低，所以产生了后退N帧协议和选择重传协议。<img src="/2022/050135078/6.jpg" class>  </li><li>多帧滑动窗口和后退N帧协议（GBN）：<br>①发送方无须收到上一个帧确认才发送下一个帧，而是可以连续发送，当接收方检测到失序的帧时要求发送方发送最后一个正确接收的帧和之后的所有未被确定的帧，也就是————接收方只能按照顺序接收帧。<br>②为了节省开销，接收窗口并不是接到一个帧就确认一个，而是几个帧再确认，说明最后一个帧之前的所有帧都收到了。<br>③接收窗口&#x3D;1，保证按顺序接收帧，提高信道利用率，但重传有时候把自己传输正确的帧也重传了，这种做法又使得传输效率降低，所以信道质量差的时候效率不一定比停止等待协议高。</li><li>多帧滑动窗口和选择重传协议（SR）：<br>①为了提高信道利用率，设法只重传出错的数据帧&#x2F;计时器超时的数据帧，但必须加大接收窗口大小，以便先收下发送序号不连续但仍在接收窗口中的那些帧，等到所缺的帧收到之后再一并送交主机。<br>②每个发送缓冲区对应一个计时器，超时就会把缓冲区内重传。接收和发送窗口大小均&gt;1，一般来说大小相同，使用累计确认的方法。<br>③SR确实避免了重传正确的帧，但需要在接收方缓冲区存储正确的帧，缓冲区的数目大小等于窗口的大小。</li><li>从滑动窗口概念来看，停止等待协议的发送窗口大小&#x3D;1，接收窗口大小&#x3D;1。后退N帧协议的发送窗口大小&gt;1，接收窗口大小&#x3D;1。选择重传协议的发送窗口大小&gt;1，接收窗口大小&gt;1。 <h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2>介质访问控制为了使用介质每个结点隔离来自同一信道其他结点传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制层子层（Medium Access Control，MAC）。若干结点如果使用同一个信道可能会相互干扰。常见方法有：信道划分介质访问控制（静态划分方法），随机访问介质访问控制（动态划分方法），轮询访问介质访问控制（动态划分方法）。</li><li>信道划分介质访问：<br>①将使用介质的每个设备与其他设备通信隔离开，把时域和频域资源合理分配给网络上设备。<br>②多路复用：当介质带宽超过传输单个信号所需要的带宽时，人们通过在一条介质上传输多个传输信号的方法提高信道利用率。采用多路复用技术可以把多个输入通道信息整合到一个复用通道里，接收端把收到的信息分离出来并传送到对应的输出通道。<img src="/2022/050135078/7.jpg" class>   ③信道划分的实质是分时，分频，分码等方法把原来的一条广播信道逻辑上分为若干条互不干扰子信道，实际是把广播变成点对点信道。<br>④频分多路复用FDM：把信道总带宽划分为单个信号带宽相同的子信道，每个子信道传输一种信号。每个子信道带宽可以不相同，但总和必须小于总带宽，为了防止相互干扰加入“保护频带”，优点就是充分利用带宽，系统效率搞，技术简单实现容易。<br>⑤时分多路复用TDM：时分多路复用把物理信道按照时间分为若干时间片，轮流分配给多个信号使用，每个时间片由复用的一个信号占用，其中STDM是动态分配信道时间（一个用户可以占用全部时间片，效率加倍）。  <img src="/2022/050135078/8.jpg" class> ⑥波分多路复用WDM：即光的频分多路复用，波长（频率）不同，互不干扰。<br>⑦码分多路复用CDM：不同编码区分各路原始信号，举个例子：<br>实际上也叫码分多址CDMA，把比特时间划分为m个端的时间槽，称为码片，通常m为64&#x2F;128。举例m为8，每个站点被指派了一个唯一的m位的码片序列，发送1时站点发送它的码片序列，0时也方该码片序列的反码，当两个站点同时发送的时候，各路数据在信道中线性相加。为了分理出各路信号，要求各个站点码片序列相互正交。优点：频谱利用率高，抗干扰能力强，保密性强等。<img src="/2022/050135078/9.jpg" class> </li><li>随机访问介质访问：<br>不采用集中控制方式解决发送信息次序，所有用户都能偶根据自己意愿随机发送信息，占用信道全部速率。总线型网络中，两个或以上用户发送信息的时候产生冲突，为了解决冲突，每个用户需要按照规则反复重传他的帧，直到无碰撞的通过。常用的协议有：ALOHA，CSMA，CSMA&#x2F;CD，CSMA&#x2F;CA，核心思想都是胜利者获得权力发送信息，因此又称为挣用型协议。实质上随机访问介质访问把广播信道转化为了点到点信道。<br>①ALOHA协议：<br>又分为两种——纯ALOHA和时隙ALOHA。<br>纯ALOHA：基本思想时当网络中任何一个站点需要发送数据时，可以不经检测直接发送数据，如果在一段时间内未收到确认，那么该站点就认为传输过程中发生冲突，发送站点需要等待一段时间再发送数据，直至发送成功。重传策略则是各站等待随机时间进行重传。但吞吐量低，改进得到时隙ALOHA。<br>时隙ALOHA：把所有站点时间同步起来，把时间划分为登场时隙SLOT，规定只能在每个时隙开始时发送一个帧，避免随意性，减少冲突可能，提高信道利用率。重传策略和ALOHA相似。吞吐量比ALOHA大一倍。<br>②CSMA协议：<br>如果每个站点发送前都侦听一下信道，空闲再发送就大大减少冲突的可能，从而提高信道利用率，载波侦听多路访问（Carrier Sense Multiple Access，CSMA）就是这个思想，比ALOHA多了一个载波侦听装置。而CSMA又分三种：<br>1-坚持CSMA：侦听到信道空闲则发送，忙则继续侦听直到空闲，如果冲突则随机等待一个时间重复上述过程。但传播延迟使得1-坚持CSMA仍然会发生冲突。<br>非坚持CSMA：侦听到信道空闲则发送，忙则放弃侦听，随机等待一个时间重复过程。侦听到忙碌就放弃了，降低了冲突概率。<br>p-坚持CSMA：用于时分信道，侦听到信道空闲则发送，忙则继续侦听直到空闲，空闲则有p的概率发送给数据，以1-p的概率推迟到下一个时隙，下一个时隙重复该过程。<img src="/2022/050135078/10.jpg" class>   ③CSMA&#x2F;CD协议：<br>载波侦听多路访问&#x2F;碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA&#x2F;CD）是CSMA改进方案，适用于总线型网络&#x2F;半双工网络，而碰撞监测则是边发送边侦听，判断是否其他站点也在发送数据。工作过程概括为“先听后发，边听边发，冲突停发，随机重发”————只能半双工通信，不能同时收发。<br>为了确保发送数据同时监测是否碰撞，需要发送之前就能收到自己发送出去的数据，即帧传输时延至少两倍于信号在总线上的传播时延，才能保证无碰撞，所以CSMA&#x2F;CD总线中所有数据帧都需要大于一个最小帧长，小于最小帧长当作无效帧丢弃（非要发就需要填充字段到最小帧长），最小帧长&#x3D;总传播时延X数据传输速率X2。<br>除此之外，CSMA&#x2F;CD冲突之后采用退避算法解决碰撞问题，第k次重传，就从0-2的k次方-1之间抽随机数，随机数乘以争用期得到重传的时间。该算法求出的时间随着重传时间增大而增大，降低发生碰撞概率。  <img src="/2022/050135078/11.jpg" class> ④CSMA&#x2F;CA协议：<br>CSMA&#x2F;CD协议已经成功用于有线连接局域网。无线网中并不适用，所以802.11标准则定义了CSMA&#x2F;CA，其中CA为Collision Avoidance碰撞避免，尽量避免碰撞发生。为了尽量避免，802.11规定所有站发送完之后必须等一段时间才发送下一帧，称为帧间间隔（InterFrame Space,IFS），其长短取决于帧类型，有三种：SIFS(短IFS)，PIFS（点协调IFS），DIFS（分布式协调IFS）。<br>⑤CSMA&#x2F;CA与CSMA&#x2F;CD区别：<br>CSMA&#x2F;CD可以监测冲突但没法避免，CSMA&#x2F;CA尽量避免但有可能冲突。<br>传输介质不同：CSMA&#x2F;CD用于总线型以太网，CSMA&#x2F;CA用于无线局域网802.11 a&#x2F;b&#x2F;g&#x2F;n等。<br>监测方式不同：CSMA&#x2F;CD通过电缆中电压变化监测，而CSMA&#x2F;CA通过能量监测，载波监测，能力载波混合监测三种监测方式。<br>总结：CSMA&#x2F;CD基本思想先侦后发，边发边侦，而CSMA&#x2F;CA则是发送前先广播告知其他结点短时间内别发数据，以免出现碰撞。  </li><li>轮询访问介质访问控制：令牌传递协议<br>①用户不能随机发送信息，而是通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道分配，信道只有一个结点使用。 典型的就是令牌传递协议——用于令牌环局域网中。<br>②令牌传递协议中，令牌以固定次序交换，它是一组特殊比特组成的帧。环上的站希望传送帧时必须等令牌，收到令牌即可发送数据。令牌上包括目的地址，标示这哪个站点接收，令牌在环上进行传送。不需要发送数据的时候，令牌就在环形网上游荡，令牌只有一个，不会冲突。网络中物理拓扑不是一个环，逻辑上是一个环，适合负载高的广播信道，用其他的协议则会冲突概率很大，没有共享空间和时间。<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h3>①局域网（Local Area Network，LAN）指的是较小的地理范围内，把各种计算机，外部设备，数据库系统通过双绞线，同轴电缆等介质相互连接起来，组成资源和信息共享的计算机互联网络。<br>②特点：<br>一个单位所拥有，地理范围站点数目有限。<br>所有站点共享较高的总带宽。<br>较低的时延和较低的误码率。<br>各站为平等关系而非主从关系。<br>能进行广播和组播。<br>③拓扑结构，传输介质，介质访问控制方式决定了局域网技术特性。<br>拓扑结构有：星形结构，环形结构，总线型结构，星型和总线型复合结构。<br>传输介质有：双绞线，铜缆，光纤等，双绞线为主流。<br>介质访问控制方式有：CSMA&#x2F;CD，令牌总线，令牌环，前两种方式用于总线型，后一种为环形局域网。<br>④三种特殊局域网：<br>以太网：目前适用范围最广局域网，逻辑拓扑总线形结构，物理拓扑是星型&#x2F;拓展星型。<br>令牌环：逻辑拓扑环形结构，物理拓扑是星型。<br>FDDI：逻辑拓扑环形，物理拓扑是双环形。<br>IEEE 802标准把数据链路层拆为两个子层逻辑链路控制层LLC和媒体接入控制层MAC。其中与接入传输媒体有关内容都在MAC，它向上屏蔽物理层访问差异，提供对物理层同意统一接口，主要功能有：组帧和拆卸帧，比特传输差错检测，透明传输，而LLC向网络层提供无确认无连接，有确认无连接，有确认有连接，告诉传送四种不同连接服务。<h3 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h3>以太网采用总线型拓扑结构，所有计算机共享总线，信息以广播形式发送，以太网简化CSMA&#x2F;CD进行访问控制。802.3局域网简称以太网。以太网采用两种方式简化通信：①采用无连接工作方式，不可靠服务，纠错由上层完成。②使用曼彻斯特编码，每个码元中间出现一次电压转换，利用其提取出来同步信号。<br>①以太网传输介质与网卡：<br>常用传输介质由粗缆，细缆，双绞线，光纤，各种介质适用情况见下表：  <img src="/2022/050135078/12.jpg" class> 计算机与局域网连接通过主机箱内插入的一块网络接口板（网络适配器Adapter或网络接口卡NIC），网卡上有处理器和存储器，工作在链路层的组件。网卡不仅实现与传输介质之间的物理连接和电信号匹配，还涉及到帧的发送和接收，帧的封装和拆封，介质访问控制，数据编码与解码，数据缓存等功能。每块网卡有一个独一无二的介质访问控制地址（MAC地址），数据链路层都是用MAC地址。<br>②以太网的MAC帧：<br>也称物理地址，长度为6字节，由12个16进制数表示。由于使用总线广播，则检查MAC帧，符合就接收否则丢弃。帧格式有两种：DIX Ethernet V2标准和IEEE 802.3标准。<br>Ⅰ：DIX Ethernet V2标准：<br>前导码：使接收端和发送端时钟同步，在帧前面插入的8个字节可以再分为两个字段，一个字段7字节为前同步码，第二个是帧开始定界符，表示后边的信息是MAC帧。<br>地址：通常使用6字节地址MAC地址。<br>类型：2字节，指出数据应该用哪个协议实体处理。<br>数据：46-1500字节，包含高层协议信息，由于CSMA&#x2F;&#x2F;CD协议长度限制最小为64，不够需要填充。（64-18&#x3D;46，首尾共18字节）<br>填充：0-64字节。<br>校验码FCS：4字节，范围从目的地址段到数据末尾，采用32位CRC码，不但检验MAC帧数据部分，还有目的地址，源地址，类型字段，但不校验前导码。 <img src="/2022/050135078/13.jpg" class>  Ⅱ：IEEE 802.3标准：不同之处就是长度域代替了DIX帧中的类型域，指出数据域长度。<br>③高速以太网：<br>速度超过100Mb&#x2F;s的以太网。有三种：<br>Ⅰ： 100BASE-T以太网：双绞线上传送100Mb&#x2F;s基带信号的星形拓扑结构以太网，使用CSMA&#x2F;CD协议，全双工&#x2F;半双工均可，全双工不用CSMA&#x2F;CD。<br>Ⅱ：吉比特以太网：1G&#x2F;s下全双工&#x2F;半双工工作，半双工使用CSMA&#x2F;CD。<br>Ⅲ：10吉比特以太网：10G&#x2F;s下使用光纤作为传输媒体，只全双工。  <h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3>无线局域网分为两类：有固定基础设施无线局域网和无固定基础设施移动自组织网络。<br>①有固定基础设施无线局域网：<br>对于有固定基础设施，IEEE指定了802.11系列协议标准。802.11使用星形拓扑，中心称为接入点（Access Point，AP），MAC层使用CSMA&#x2F;CA协议，又称Wi-Fi。<br>无线局域网最小构件是基本服务集BSS（Basic Service Set，BSS），包括一个基站和若干移动站，BSS内部之间通信，外部则通过基站通信，AP就是基站，安装AP时需要给它分配一个不超过32字节的服务集标识符SSID和一个信道，一个BSS覆盖范围称为一个基本服务区BSA，一般不超过100m。<br>一个基本服务区BSA可以独立，也可以通过AP连接到一个分配系统DS，然后连接到另一个基本服务集，构成扩展的服务集ESS，通过一种叫做Portal（相当于网桥）的设备为无限用户提供有线连接的以太网接入。如图，A想要连接B则经过AP1和AP2即，A-&gt;AP1-&gt;AP2-&gt;B，注意AP1和AP2是有线传输。  <img src="/2022/050135078/14.jpg" class> ②无固定基础设施移动自组织网络：<br>又叫做自组网络，一些平等状态的移动站相互动心组成的临时网络，各节点地位平等，中间结点为转发结点，都有路由器的功能。<br>通常可移动设备发现附近有其他可移动设备，要求进行通信，网络中每个移动站都参与其他移动站的路由的维护和发现。  <h3 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h3>令牌环网每一站都通过电缆与环接口干线耦合器TCU连接（TCU为了传递所有经过的帧，为介入站发送接收数据提供接口，有收听状态和发送状态），数据总在一个方向上从一个TCU到另一个TCU传输。只有一个结点独占信道，不发生碰撞，令牌Token就是一个数据帧。<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>覆盖范围广的长距离网络，是因特网核心部分。因此连接广域网结点的交换机为高速链路，且容量足够大便于以后扩充。广域网不等于互联网（互联网可以连接不同类型网络，使用路由器），广域网是由结点交换机和连接交换机的链路组成。（交换机不是路由器，结点交换机和路由器均转发分组，而交换机在单个网络中转发，路由器则是多个网络构成的互联网中转发），交换机存储转发分组，一个交换机与多个相连。<br>局域网和广域网区别于联系：  <img src="/2022/050135078/15.jpg" class> <h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3>①Point-to-Point Protocol,是使用串行线路通信的的面向字节的协议，直接应用在两个结点的链路上，目的通过拨号&#x2F;专线来建立点对点连接发送数据，使其称为各种主机，网桥，路由器之间简单连接的共同解决方案。<br>②由SLIP协议发展来的，异步同步线路均可，而SLIP主要完成数据包传送，只能传输IP分组，且对于高层应用不支持，为了改进指定了PPP。<br>③三个部分组成：<br>链路控制协议LCP：用于建立，配置，测试，管理数据链路。<br>网络控制协议NCP：PPP允许多种网络层协议，不同网络层协议对应一个不同NCP配置，为网络层协议建立和配置逻辑连接。<br>一个把IP数据包封装到串行链路的方法：IP数据报就是在PPP帧中的信息部分，长度收到MTU限制。<br>④PPP帧格式如图：PPP面向字节的，所以帧长度都是整数个字节。  <img src="/2022/050135078/20.jpg" class>  ⑤PPP提供差错监测但没有纠错，只保证无差错接收，不可靠的传输协议，不使用序号和确认机制。仅支持点对点链路通信。只支持全双工链路。不同网络协议仍然可以使用一个PPP通信（帧上有协议字段）<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3>①高级数据链路控制协议，是ISO面向比特指定的数据链路层协议，它不依赖任何一种字符集编码，数据包可以透明传输，全双工通信，采用CRC检验，对于信息帧进行顺序编号防止漏发重发。适用于链路的两种配置：非平衡配置（由一个主站控制整个链路）和平衡配置（若干平等站相互传输）。<br>②站：HDLC有三种站类型：主站，从站，复合站。主站负责控制链路，发出的帧为命令帧。从站受控于主站，发出的帧为响应帧。复合站综合二者，发出帧可以是命令也可以是响应帧。<br>③数据操作方式：<br>正常响应方式：非平衡方式，主站传输，从站接收，但从站只有得到主站许可才能进行响应。<br>异步平衡方式：平衡方式，每个复合站都可以对其他站进行传输数据。<br>异步响应方式：非平衡，从站即使未接收主站许可仍然可以进行响应。<br>④HDLC帧：如图：  <img src="/2022/050135078/16.jpg" class> ⑤PPP和HDLC帧的区别：<br>PPP面向字节，HDLC面向比特。<br>PPP比HDLC多一个2字节的协议字段，当字段为0x0021时信息字段为IP数据报。<br>PPP不使用序号和确认机制，不可靠，由高层协议负责。而HDLC使用了，可靠。  <h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥概念及其基本原理"><a href="#网桥概念及其基本原理" class="headerlink" title="网桥概念及其基本原理"></a>网桥概念及其基本原理</h3></li><li>两个或者多个以太网通过网桥连接称为一个覆盖更大的以太网，原来一个以太网称为一个网段，网桥工作在MAC子层，可以使得以太网个网段称为隔离开的碰撞域。”隔离开的互不影响“。  （网桥处理帧所以是数据链路层，中继器放大器处理信号所以是物理层）  </li><li>一个网段内部发送帧直接发送，而不同网段才通过网桥，需要验证MAC地址是否是内部。每个网段数据率为10Mb&#x2F;s，三个网段的最大吞吐量就是30Mb&#x2F;s，换成放大器就是10Mb&#x2F;s。  </li><li>基本特点：<br>①具备寻址和路径选择的能力，确定帧传输方向。<br>②从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧。<br>③网桥连接不同网络之间存储并且转发帧，可以使用不同协议，进行协议转换。<br>④网桥对于帧不做修改&#x2F;少量修改，单纯转发。<br>⑤网桥应该有足够大缓冲空间，因为在短时间内帧到达速率可能高于转发速率。  </li><li>优点：<br>①过滤信息量。<br>②扩大物理范围。<br>③可以使用不同物理层。<br>④可以互联不同局域网。<br>⑤提高可靠性。<br>⑥性能改善。  </li><li>缺点：<br>①增大了时延。<br>②MAC子层没有流量控制功能。<br>③不同MAC子层的网段连接的时候需要进行帧格式转化。<br>④网桥适合用户不多，通信量不大的居于发，否则有可能网络拥塞。</li><li>网桥必须有路径选择功能，选择正确路径，根据路径算法不同分为透明网桥和源路由网桥。<br>①透明网桥：接收每一个帧，若是源LAN和目的LAN一样则丢弃该帧，不一样则转发该帧，若目的LAN位置则扩散该帧（扩散给输入网段外的所有网段）。刚连接进以太网转发表为空，逐渐建立转发表。使用一个生成树算法得到若干路径，但不一定是最佳路由。<br>②源路由网桥：路由选择由发送数据帧的源站负责，网桥只负责接收和转发。而源站通过广播方式向目的站发送一个发现帧，途中每个网桥都转发此帧，最后发现该帧可以从多个途径到达目的站，目的站一一发送应答帧，每个应答帧原路返回，途径网桥把自己标记在应答帧中，然后源站选一个最佳路由。  <h3 id="局域网交换机概念及其基本原理"><a href="#局域网交换机概念及其基本原理" class="headerlink" title="局域网交换机概念及其基本原理"></a>局域网交换机概念及其基本原理</h3></li><li>桥接器主要限制在任意时刻只能执行一个帧的转发操作，则出现了交换机。本质上就是多端口网桥，分隔隔离初多个冲突域，各个网段都有更高带宽。  </li><li>原理：监测源和目的地MAC，然后系统内部动态查找表比较，若不在则加入查找表，并发送给相应端口。</li><li>特点：<br>①每个端口都与单台主机连接，工作方式为全双工。<br>②可以同时连接多对端口，每对主机都像独占信道一样无碰撞交换数据。<br>③以太网即插即用（和透明网桥一样），内部帧转发表也是通过自学习逐渐建立起来的。<br>④交换速率高，独占传输媒体的带宽（传统10Mb&#x2F;s以太网，有N个用户，有N个端口的交换机的总容量为N*10Mb&#x2F;s）。</li><li>两种交换模式：<br>①直通式 ；只检查目的地址，立马传出去，这种方式速度快但缺乏智能和安全，无法支持不同速率的端口的交换。<br>②存储转发式：先收到帧缓存到告诉缓存器中，检查是否正确，无误则通过查找表转换成为输出端口转发，有错则丢弃。优点是可靠性高，支持不同速率端口之间的转换，缺点就是延迟大。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>链路与数据链路：<br>链路：是物理线路，无结点，路径的组成部分。<br>数据链路：除了物理线路还有一些通信协议控制数据传输。</li><li>局域网，广域网，因特网总结：<br>广域网视为大局域网，就是交换机连接多个局域网组成广域网，但仍是一个网络。而因特网则是多个网络之间的互联，由广域网和局域网通过路由器相连。</li><li>冲突域和广播域：<br>一块网卡发送信息只要可能与另一个冲突，则可能冲突的网卡构成冲突域，而一块网卡发送广播，所有能接到的网卡就是广播域。一般来说，一个网段就是冲突域，一个局域网就是广播域。  <img src="/2022/050135078/17.jpg" class> <img src="/2022/050135078/18.jpg" class> <img src="/2022/050135078/19.jpg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络物理层</title>
      <link href="/2022/050114293.html"/>
      <url>/2022/050114293.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络物理层"><a href="#计算机网络物理层" class="headerlink" title="计算机网络物理层"></a>计算机网络物理层</h1><img src="/2022/050114293/7.jpg" class><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据，信号与码元：</li></ul><p>1.数据指的是传送信息的实体，连续变化的数据为模拟数据，离散的数据为数字数据，且可以并行&#x2F;串行传输数据。<br>2.信号是数据的电气&#x2F;电磁表现形式，数据传输过程中表现形式。<br>3.码元是用一个固定时长的信号波形表示一个k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，时长成为码元宽度。</p><ul><li>信源，信道，信宿：</li></ul><p>1.一个数据通信系统由这三部分组成。<br>2.信源：产生发送数据的源头，<br>3.信宿：接收数据的终点。<br>4.信道：和电路不等同，信道是信号的传输媒介，可以看作线路的逻辑媒介，一般一个通信线路都有一个发送信道和一个接收信道。信道根据传输信号不同分为模拟信道和数字信道，按传输介质不同分为无线和有线信道。<br>5.信道上传输的信号有基带信号和宽带信号之分。<br>基带信号是用1和0不同电压表示，送到数字信道上传输——基带传输。<br>宽带信号是把基带调制形成频分复用模拟信号，送到模拟信道上传输——宽带传输。<br>6.三种通信交互方式：单向通信（一条信道），半双工通信（两条信道，不能同时发送和接收），全双工通信（两条信道，能同时发送和接收）。  </p><img src="/2022/050114293/1.jpg" class>  <ul><li>速率，波特和带宽：</li></ul><p>1.速率：数据传输率，单位时间传输数据量，可以用·码元传输速率表示（波特率，单位时间内数字通信系统所传输的码元个数，单位是波特，进制不定），也可用信息传输速率表示（信息速率，比特率，单位时间内数字通信系统所传输的码元个数，二进制）。<br>2.带宽：通信线路所能传输数据的能力，“最大速率”，单位为b&#x2F;s。</p><h3 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h3><ul><li>奈奎斯特定理：</li></ul><p>1.具体信道能够通过的频率范围有限，信号中许多高频分量往往不能通过信道，否则传输中会衰弱，导致接收端收到的信号波形失去码元之间的清晰界限，这种现象成为码间串扰。<br>2.奈奎斯特定理规定——理想低通信道中，为了避免码间串扰，极限码元传输速率为2W波特，其中为理想低通信道带宽，若用V表示每个码元离散点评的数量（即多少种不同码元，16个码元就有4个二进制位表示，则数据传输速率是码元的4倍），则极限数据率&#x3D;2W*log2(V)。<br>结论：<br>①任何信道码元传输速率有上限，超过上限就会出现严重的码间串扰，接收端不能完全正确识别码元。<br>②信道频带越宽，就可以用更高的速率进行码元的有效传输。<br>③奈奎斯特定理给出了码元传输速率限制，但并未对于信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。<br>④所以要使得每个码元带更多的比特量，多元制的调制方法。</p><ul><li>香农定理：</li></ul><p>1.香农定理给出了带宽受限且有着高斯白噪声干扰的信道的极限数据传输速率，当使用该速率传输时可以不产生误差，则极限数据率&#x3D;W*log2(1+S&#x2F;N),W为信道带宽，S为信道传输信号平均功率，N为信道内高斯噪声功率，S&#x2F;N为信噪比。<br>结论：<br>①信噪比越大，极限传输速率越高，信噪比确定时信息传输速率上限一定。<br>②只要信息传输速率低于上限，就一定有方法实现无差错传输。<br>③香农定理给出的是传输速率上限，实际信道比它低不少。</p><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><ul><li>数据无论是数字还是模拟都需要变成信号才能进行传输，则数据变换为模拟信号的过程称为调制，变为数字信号的过程称为编码。  </li><li>数字数据通过数字发送器转换成数字信号，也可通过调制器转换成模拟信号。  </li><li>模拟数据通过POM编码器转换成数字信号，也可通过放大器调制器转换成模拟信号。  </li><li>所以产生了四种编码方式：</li></ul><p>1.数字数据编码为数字信号：<br>用于基带传输，即不改变信号频率之间传输数字信号，只要把1和0区分开即可，有多种编码方式：①归零编码RZ，②非归零编码NRZ，③反向非归零编码NRZI，④曼彻斯特编码，⑤差分曼彻斯特编码，⑥4B&#x2F;5B编码。  </p><img src="/2022/050114293/2.jpg" class>   <p>2.数字数据调制为模拟信号：<br>数字数据调制技术在发送端把数字信号转换为模拟信号，在接收端将模拟信号还原为数字信号，对应调制解调器的调制和解调过程，基本有如下几种：①幅移键控ASK，②频移键控FSK，③相移键控PSK，④正交振幅调制QAM。<br>3.模拟数据编码为数字信号：<br>经典例子就是音频信号的脉码调制PCM，包括采样，量化，编码三个步骤。<br>4.模拟数据调制为模拟信号：<br>为了实现传输有效性，可能需要较高频率，这种调制方式可以用频分复用FDM。  </p><h3 id="电路交换，报文交换，分组交换"><a href="#电路交换，报文交换，分组交换" class="headerlink" title="电路交换，报文交换，分组交换"></a>电路交换，报文交换，分组交换</h3><ul><li>电路交换：<br>①定义：两节点之间必须建立一条专用的物理通信路径，路径在整个数据传输期间被这两个结点独占，直到通信结束才被释放，因此有三个阶段：连接建立，数据传输，连接释放。以直通的方式发送接收数据，不存在存储转发消耗时间。<br>②优点：<br>通信时延小（线路两节点专享）<br>有序传输<br>没有冲突（各自有不同信道）<br>适用范围广（数字模拟信号均可传输）<br>实时性强（连接建立立即可传输）<br>控制简单<br>③缺点：<br>建立连接时间长<br>线路独占<br>灵活性差<br>难以规格化  </li><li>报文交换：<br>①定义：数据交换单位是报文，带有目标地址，源地址等信息，报文交换在交换节点采用的是存储转发的传输方式。<br>②优点：<br>无须建立连接<br>动态分配线路（发送方把报文交给交换设备，先存储整个报文再选择空闲线路发送报文），提高线路可靠性<br>提高线路利用率<br>提供多目标服务（一个报文多个目的地址）。<br>③缺点：有转发时延（报文先存储再转发）<br>对于报文大小没有限制导致网络节点应该有较大的缓存空间。  </li><li>分组交换：<br>①定义：也是存储转发，但解决了大报文的问题，限制了数据块上限，把大数据块划分成为小数据块加上必要的控制信息（两个地址+编号信息等）构成了分组Packet，中间结点接受分组存储并且排队，根据分组选择下一个结点，直到到达目的结点。<br>②优点：<br>无建立时延<br>线路利用率高<br>简化了存储管理（比报文交换，因为数据块固定所以缓冲区固定，简化了缓冲区的管理）<br>加速传输（分组是逐个传输的，一个分组存储和前一个分组转发是并行的，减少了传输时间）<br>减少出错概率和重发数据量（分组更短，出错概率小，所以重发数据量减少，提高可靠性减少了时延）<br>③缺点：<br>存在传输时延<br>需要传输额外信息量（每个块都有源地址和目的地址，分组编号等，从而构成分组，信息量提高了）<br>当分组交换使用数据报网络的时候可能失序，丢失，重复等，所以分组到达目的地址的时候需要排序等工作，但使用虚电路服务的时候还要建立连接三个过程。</li><li>三个数据交换方式比较：<br>①数据量大且传送时间远远大于建立连接时间的时候使用电路交换。<br>②端到端通路由多段链路组成时，采用分组交换。<br>③报文交换和分组交换的信道利用率高于电路交换，其中分组交换比报文交换时延小，尤其适合计算机之间突发通信。  <img src="/2022/050114293/3.jpg" class>  <h3 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h3><img src="/2022/050114293/6.jpg" class>   分组交换进一步分为面向连接的虚电路方式和无连接的数据方式，都由网络层提供。</li><li>数据报：<br>①网络层加上控制信息形成数据报分组，中间结点存储分组之后找到最佳路由，尽快转发分组，分组可以不同路径，也可以不同顺序，只需要找当前状态下分组最合适的路由转发即可。<br>②特点：<br>发送分组之前不需要建立连接。<br>网络尽最大努力交付，不保证可靠性，有可能丢失，乱序。<br>分组要包含发送端和接收端的完整地址，便于独立运输。<br>分组在存储转发过程中需要排队处理，网络拥塞的时候排队的时延大大增加，还可能丢失分组。<br>网络中具有冗余的路径，当某结点&#x2F;链路发生故障的时候相应更新转发表，从另一条路径转发，对于故障适应性强。<br>存储转发时延一般较小，提高了网络吞吐量。<br>收发双方不独占某条链路，资源利用率高。  <img src="/2022/050114293/4.jpg" class>  </li><li>虚电路：<br>①虚电路尝试把电路交换和数据报方式结合起来，分组发送之前先建立连接，一旦连接建立，路径就是固定的，总过程还是三个阶段。每次建立虚电路时，选择一个未用过的虚电路号分配，在传送数据的时候，分组不仅要有分组号，校验等控制信息，还要有虚电路号，且虚电路网络中每个结点都有一个虚电路表，包括接收链路，发送链路上的虚电路号，前一个结点和后一个结点的标识。<br>②特点：<br>通信链路建立拆除需要时间开销，短时间浪费，长时间效率高。<br>虚电路路由选择体现在建立链路的时候，建立完成就完成了路由选择，只有一条路径。<br>虚电路可靠，分组正确有序到达，且有流量控制。<br>虚电路路径中某个结点&#x2F;链路故障时所有经过该结点&#x2F;链路的虚电路都会被破坏。<br>分组首部不包括目的地址，包含的是虚电路标识符。<br>虚电路中的“虚”体现在，这条物理链路不是独占的，而是逻辑上一条独占的链路，两个端系统之间有不同的进程可能也存在不同的虚电路。 <img src="/2022/050114293/5.jpg" class>  <h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2>传输介质也叫传输媒体，是数据传输系统中发送设备和接收设备之间的物理通路，分为导向和非导向传输介质。<h3 id="双绞线，同轴电缆，光纤，无线传输介质"><a href="#双绞线，同轴电缆，光纤，无线传输介质" class="headerlink" title="双绞线，同轴电缆，光纤，无线传输介质"></a>双绞线，同轴电缆，光纤，无线传输介质</h3></li><li>双绞线：TP，两根相互校合的铜导线，还有屏蔽双绞线STP，非屏蔽双绞线UTP。价格便宜，局域网和传统电话中常见，带宽取决于铜线粗细和传输距离</li><li>同轴电缆：由内导体，绝缘层，网状编制屏蔽层和塑料外层构成，有50欧的基带同轴电缆——局域网，75欧的宽带同轴电缆——电视。</li><li>光纤：光导纤维传递光脉冲来通信，容量大，传输损耗小，远距离传输经济，抗雷电电磁性能好，无串音干扰，体积小重量轻。  </li><li>无线传输介质：有无线电波（穿透力强，距离长，无需方向对准），微波，红外线，激光<h3 id="物理层接口特征"><a href="#物理层接口特征" class="headerlink" title="物理层接口特征"></a>物理层接口特征</h3></li><li>物理层考虑如何把连接计算机的媒体上传输比特流，而硬件设备和传输介质种类繁多且通信方式也有差异，物理层尽可能屏蔽差异。  </li><li>物理层主要任务是确定与传输媒体的接口有关的特性：<br>①机械特性：指定接口所用接线器形状，尺寸，引脚数量和排列，固定和锁定装置等。<br>②电器特性：指定在接口电缆各条线上出现的电压范围。<br>③功能特性：指定某条线上出现的某一个电平的电压表示何种意义。<br>④过程特性：又称规程特性，指定对于不同功能的各个可能事件的出现顺序。  </li><li>常用的物理层接口标准有：EIA RS-232-C，ADSL，SONET&#x2F;SDH等<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器repeater"><a href="#中继器repeater" class="headerlink" title="中继器repeater"></a>中继器repeater</h3></li><li>主要功能是把信号整形并放大再转发出去，消除信号经过电缆之后产生的失真和衰弱，使得信号波形和强度达到标准，进而扩大网络传输距离。</li><li>原理是信号再生，有两个端口，一个输入一个输出。而放大器原理是信号放大。</li><li>简单廉价，在物理层工作，中继器两端是同一个局域网，不能连接两个不同速率的局域网。</li><li>理论上中继器无限使用，但现实中不可能，“5-4-3原则”：4个中继器连接5个通信介质中只有3段可以连接计算机。<h3 id="集线器hub"><a href="#集线器hub" class="headerlink" title="集线器hub"></a>集线器hub</h3></li><li>实质是多端口中继器，在网络中只有信号放大和转发作用，目的为了扩大网络的传输范围，而不是信号定向传送，即信号传输的方向固定，是一个标准的共享式设备。  </li><li>集线器不能分割冲突域，所有端口属于一个冲突域，比如10Mb&#x2F;s带宽的集线器连接8台计算机，每台计算机带宽为10&#x2F;8&#x3D;1.25Mb&#x2F;s。<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>传输媒体不是物理层：传输媒体在物理层下面，传输媒体传输的是信号但不知道信号意味着啥，物理层识别所传送的比特流。</li><li>基带传输：计算机内部&#x2F;相邻设备之间近距离传输，不经过调制在信道上直接传输称为基带传输，常用于局域网。</li><li>频带传输：数字信号对于特定频率的载波进行调制，变成适合传送的信号再传输，这叫做频带传输。远距离&#x2F;无线传输时使用。</li><li>宽带传输：借助频带传输（频分复用），把链路容量分解为&gt;&#x3D;2个信道，每个信道携带不同信号，就叫宽带传输。所有信道互不干扰发送信号，链路容量大大增加。</li><li>同步异步的理解：同步：通信双方必须线建立同步，即时钟调整同一个频率，双方不停的发送接收比特流，两种同步方法：全网同步和准同步。而异步可以理解为非同步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/2022/043050802.html"/>
      <url>/2022/043050802.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><img src="/2022/043050802/9.jpg" class> <h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><ul><li>计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><h3 id="共分三类："><a href="#共分三类：" class="headerlink" title="共分三类："></a>共分三类：</h3></li><li>组成部分：硬件，软件，协议。</li></ul><p>1.硬件：主机（端系统），通信链路（双绞线，光纤），交换设备（路由器，交换机），通信处理机（网卡）<br>2.软件：实现资源共享的软件和方便用户使用的工具软件（邮件收发，聊天程序等）<br>3.协议：计网核心，“交通规则”规定网络传输数据时所遵循的规范  </p><ul><li>工作方式：边缘部分和核心部分</li></ul><p>1.边缘部分：主机，用来通信和资源共享<br>2.核心部分：网络和连接网络的路由器，为边缘提供连通和交换</p><ul><li>功能组成：通信子网和资源子网</li></ul><p>1.通信子网：传输介质，通信设备，网络协议。<br>2.资源子网：资源共享的设备及其软件</p><h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ul><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="共分六类："><a href="#共分六类：" class="headerlink" title="共分六类："></a>共分六类：</h3></li><li>分布范围：<br>广域网WAN，城域网MAN，局域网LAN，个人区域网PAN</li><li>传输技术：<br>广播式网络，点对点网络（区别于是否分组存储转发和路由选择机制）</li><li>拓扑结构：<br>总线形，星形，环形，网状（节点与通信链路的几何关系），也可以互联成为更复杂网络结构</li><li>使用者：<br>公用网，专用网</li><li>交换技术：</li></ul><p>1.电路交换网络：点对点，建立连接，传输数据，断开连接，传统电话网络。优点：数据直接传送，时延小。缺点：线路利用率低，无差错控制。<br>2.报文交换网络：加源地址和目标地址，封装成为报文段传送。也叫存储转发网络，优点：充分利用线路，一对多多对一，差错控制。缺点：资源开销大，缓冲时延，缓冲区难管理。<br>3.分组交换网络：把数据封装成固定长度数据块，块红加上目的地址和源地址等辅助信息成为分组，以存储-转发传输。优点：报文网络优点+缓冲容易管理，包时延小，现在主流网络的选择。</p><ul><li>传输介质：</li></ul><p>1.有线：双绞线网络，同轴电缆网络等。<br>2.无线：蓝牙，微波，无线电等。  </p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ul><li>带宽：bandwidth，单位Hz，表示网络通信线路传输数据能力，“最高数据传输速率”。</li><li>时延：delay，端到端传送总时间，总时延&#x3D;发送时延+传播时延+处理时延+排队时延。</li><li>时延带宽积：传播时延x信道带宽。</li><li>往返时延：round-trip-time”RTT”,从发送端开始到接收到接收端的确认历经总时延。</li><li>吞吐量：throughput，单位时间内通过某个网络数据量。</li><li>速率：speed，计算机网络上主机在数据信道上传送数据的速率，最高速率为带宽，单位为比特&#x2F;秒，b&#x2F;s。  </li><li>信道利用率： 有数据通过的时间&#x2F;有无数据通过的时间。<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3></li><li>计算机网络各层及其协议的集合就是计算机网络的体系结构。</li><li>每层活动元素成为实体，每层传送的数据单位不同，但都有两部分：数据服务单元SDU和协议控制单元PCI，共同组成协议数据单元PDU。</li><li>从上到下包装,从下到上拆解，n-SDU+n-PCI&#x3D;n-n-PDU&#x3D;(n-1)-SDU。</li><li>每层使用下层的服务，服务上层：最底层只提供服务，最高层只面向用户服务，中间层既享受服务也服务上层。</li><li>每层只能调用相邻层接口服务。</li><li>两台主机通信的时候对等层有一条直接信道。<h3 id="计算机网络协议，接口，服务"><a href="#计算机网络协议，接口，服务" class="headerlink" title="计算机网络协议，接口，服务"></a>计算机网络协议，接口，服务</h3></li><li>协议：为网络数据交换建立的规则，标准，约定。控制两个&#x2F;多个对等实体进行通信的规则的集合，是水平的，不对等实体之间没有协议。包括语法，语义，同步。</li><li>接口：同一个结点内相邻层之间交换信息的连接点，系统内部的规定，n+1层通过访问n层的SAP（服务访问点）来获取服务，每个SAP有自己的地址。</li><li>服务：下层为紧邻的上层提供的功能调用，是垂直的。上下层提供服务的时候有四类原语：请求request，指示indication，响应response，证实confirmation。<br>计算机提供的服务有三种：</li></ul><p>1.面向连接服务和无连接服务：面向连接必须先建立连接分配资源，结束再释放连接和资源，三个阶段，如TCP，无连接服务只需要直接发送数据，把带目的地的包传送在线路上，不可靠的服务，Best-Effort-Delivery，如IP和UDP<br>2.可靠服务和不可靠服务：可靠指的是有纠错，检错，应答机制，保证正确可靠传输数据，而不可靠是尽量正确可靠，尽力而为的服务。<br>3.有应答服务和无应答服务：是否有接受方接收数据之后向发送方发送应答，文件传输服务就是有应答，WWW就是无应答</p><h3 id="ISO-x2F-OSI与TCP-x2F-IP模型"><a href="#ISO-x2F-OSI与TCP-x2F-IP模型" class="headerlink" title="ISO&#x2F;OSI与TCP&#x2F;IP模型"></a>ISO&#x2F;OSI与TCP&#x2F;IP模型</h3><ul><li>OSI模型：七层，从下到上分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>低三层为通信子网（为了连接网络的通信设备），传输层承上启下，上三层为资源子网（相当于计算机，完成数据处理）。</li><li>TCP&#x2F;IP模型：四层，从下到上分别为：网络接口层，网际层，传输层，应用层。  </li><li>两者共同点：都采取分层结构。都基于独立协议栈的概念。都可以解决异构网络的互连（不同厂家计算机互联）</li><li>两者不同点：<br>OSI产生服务，协议，接口概念，与面向对象思想吻合。OSI先产生的模型而没有对应协议，TCP&#x2F;TP先产生了协议再产生的模型。<br>TCP&#x2F;IP设计之初就考虑了异构网络的问题，并用IP分层，OSI后来才在网络层中产生子层完成类似IP的功能。<br>OSI支持无连接和面向连接服务，但在传输层只有面向连接服务，而TCP&#x2F;IP认为可靠性是端到端的问题，网际层仅有无连接，传输层支持两种模式。</li><li>我们折中，综合两个模型来划分五层：物理层，数据链路层，网络层，传输层，应用层。发送方用户给出自然语言通过应用层转化为数据，从上到下层层包装数据，接收方从下到上层层逆向拆解数据把数据提交给用户。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown介绍及使用教程</title>
      <link href="/2022/04296929.html"/>
      <url>/2022/04296929.html</url>
      
        <content type="html"><![CDATA[<h2 id="举个例子解释"><a href="#举个例子解释" class="headerlink" title="举个例子解释"></a>举个例子解释</h2><p> 大部分作家都是用 Word 或 Pages 写作，过去的文档也大都以微软的 .doc, .docx 格式或是苹果的 Pages 格式储存。还有人为了保证文稿发给谁都能正常打开，会用 .txt 格式。但是.doc 或 Pages 格式有如下问题：</p><p>1.不一定谁都能打开。用 Windows 的人打不开苹果的 .pages 文件，用旧版 Word 的人不一定能打开你用新版 Word 写的稿子。</p><p>2.对方看到的稿子的样子和你自己看到的可能差别很大。</p><p>3.大部分人电脑上的Office都是盗版的，使用时很容易出问题。</p><p>4.用.txt 写的稿子没有格式，这就给编辑你文章的人带来困扰了。</p><h2 id="这就是-Markdown-登场的时候了"><a href="#这就是-Markdown-登场的时候了" class="headerlink" title="这就是 Markdown 登场的时候了"></a>这就是 Markdown 登场的时候了</h2><p>Markdown 的优点如下： </p><ul><li><p>纯文本，所以兼容性极强，可以用所有文本编辑器打开。<br>兼顾了「什么人都能打开」和「样式」。Markdown 就是纯文本，就是 .txt，所以什么人都能打开。而如上所述，你可以用它来标记文本的样式，而且语法非常简单。<br>由于是纯文本，Markdown 文稿也不会因为未来软件升级而产生不同版本之间的兼容问题，即，不会出现「我这篇稿子是用旧版 Word 写的，你用新版 Word 看可能格式会有点问题」的情况。</p></li><li><p>让你专注于文字而不是排版。</p></li><li><p>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</p></li><li><p>Markdown 转 HTML 非常方便。HTML 是整个万维网（web）的标记语言，但更重要的是，它也是目前主流电子书格式所用的标记语言。无论是 EPUB, mobi，还是 Kindle 用的专有格式 .azw，都只是把一堆 HTML 文件打包而已。如果你写的是书，用 Markdown 标注格式之后，可以很方便地转为以上格式（当然这个转换工作不需要由你来做）；如果你写的是单篇的文章（例如新闻报道或专栏），未来也不排除结集出书的可能。若采用 Markdown，对于日后的文件转换工作也大有裨益。如何开始用 Markdown？继续用你习惯的写作软件即可。记事本、Word、Pages 都没问题，但请记得存成纯文本格式。就这么简单。</p></li><li><p>Markdown 的标记语法有极好的可读性。</p></li></ul><p>插入链接: </p><ul><li><a href="https://www.jianshu.com/p/7771794c88a1?msclkid=1fb103a8c7b611eca8bd8cd73728089a#%E8%BD%AC%E6%8D%A2%E4%B8%BA-HTML-%E6%96%87%E6%A1%A3">Markdown介绍及使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/265077468?msclkid=7f270e55c7bd11ec9e490cd5ce2b3b96">hexo博客如何插入图片</a><br>插入图片：  </li><li><img src="https://th.bing.com/th/id/OIP.AjQfAi88wTpfm3XCNHUYogAAAA?pid=ImgDet&rs=1">  </li><li><img src="/2022/04296929/1.jpg" class></li><li><img src="/2022/04296929/2.jpeg" class></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2022/042843699.html"/>
      <url>/2022/042843699.html</url>
      
        <content type="html"><![CDATA[<p>临近保研和课程实训，需要大量复习的专业课和学习新技术，就在此记录我的近期学习计划。</p><h2 id="计算机科学与技术："><a href="#计算机科学与技术：" class="headerlink" title="计算机科学与技术："></a>计算机科学与技术：</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h3><h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h3><h3 id="3-计算机网络"><a href="#3-计算机网络" class="headerlink" title="3.计算机网络"></a>3.计算机网络</h3><h3 id="4-计算机组成原理"><a href="#4-计算机组成原理" class="headerlink" title="4.计算机组成原理"></a>4.计算机组成原理</h3><h3 id="5-计算机科学基本理论"><a href="#5-计算机科学基本理论" class="headerlink" title="5.计算机科学基本理论"></a>5.计算机科学基本理论</h3><h3 id="6-数据库系统"><a href="#6-数据库系统" class="headerlink" title="6.数据库系统"></a>6.数据库系统</h3><h2 id="软件工程："><a href="#软件工程：" class="headerlink" title="软件工程："></a>软件工程：</h2><h3 id="1-软件工程理论"><a href="#1-软件工程理论" class="headerlink" title="1.软件工程理论"></a>1.软件工程理论</h3><h3 id="2-软件测试与质量保证"><a href="#2-软件测试与质量保证" class="headerlink" title="2.软件测试与质量保证"></a>2.软件测试与质量保证</h3><h3 id="3-软件需求分析与系统设计"><a href="#3-软件需求分析与系统设计" class="headerlink" title="3.软件需求分析与系统设计"></a>3.软件需求分析与系统设计</h3><h3 id="4-软件项目管理与过程改进"><a href="#4-软件项目管理与过程改进" class="headerlink" title="4.软件项目管理与过程改进"></a>4.软件项目管理与过程改进</h3><h3 id="5-面向对象基本理论"><a href="#5-面向对象基本理论" class="headerlink" title="5.面向对象基本理论"></a>5.面向对象基本理论</h3><h3 id="6-程序设计基本理论"><a href="#6-程序设计基本理论" class="headerlink" title="6.程序设计基本理论"></a>6.程序设计基本理论</h3><h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><h3 id="1-高等数学"><a href="#1-高等数学" class="headerlink" title="1.高等数学"></a>1.高等数学</h3><h3 id="2-离散数学"><a href="#2-离散数学" class="headerlink" title="2.离散数学"></a>2.离散数学</h3><h3 id="3-概率论"><a href="#3-概率论" class="headerlink" title="3.概率论"></a>3.概率论</h3><h3 id="4-线性代数"><a href="#4-线性代数" class="headerlink" title="4.线性代数"></a>4.线性代数</h3><h2 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h2><h3 id="1-springboot"><a href="#1-springboot" class="headerlink" title="1.springboot"></a>1.springboot</h3><h3 id="2-vue"><a href="#2-vue" class="headerlink" title="2.vue"></a>2.vue</h3><h3 id="3-springcloud"><a href="#3-springcloud" class="headerlink" title="3.springcloud"></a>3.springcloud</h3><h3 id="4-redis"><a href="#4-redis" class="headerlink" title="4.redis"></a>4.redis</h3><h3 id="5-部署服务器"><a href="#5-部署服务器" class="headerlink" title="5.部署服务器"></a>5.部署服务器</h3><h2 id="（未完待续）"><a href="#（未完待续）" class="headerlink" title="（未完待续）"></a>（未完待续）</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
