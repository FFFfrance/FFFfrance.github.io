<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lombok</title>
      <link href="/2022/052426635.html"/>
      <url>/2022/052426635.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Lombok项目是一个<a href="https://baike.baidu.com/item/Java/85979">Java</a>库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@<a href="https://baike.baidu.com/item/Data/7096603">Data</a>)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在开发工具中安装lombok插件</li><li>在项目中引入lombok.jar包</li><li>使用lombok注解（生成特定的代码）</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>作用在类上，是以下注解的集合：@ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor</p><pre><code>@Data@AllArgsConstructorpublic class Student {        private Integer id;        private String name;        private Integer age;        private String schoolName ;}</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>@NoArgsConstructor：生成无参数构造方法</li><li>@AllArgsConstructor：生成全参数的构造方法</li><li>@RequiredArgsConstructor：生成包含final和@NonNull注解成员变量的构造方法</li></ol><pre><code>//@NoArgsConstructor@AllArgsConstructor//生成包含final和@NonNull注解成员变量的构造方法@RequiredArgsConstructorpublic class Student {    @NonNull    private Integer id;        private String name;        private Integer age;        private final String schoolName ;}</code></pre><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><ul><li>这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：</li></ul><pre><code>//成员方法参数加上@NonNull注解public String getName(@NonNull Person p){    return p.getName();}</code></pre><p>实际效果相当于：</p><pre><code>public String getName(@NonNull Person p){    if(p==null){        throw new NullPointerException("person");    }    return p.getName();}</code></pre><ul><li><p>用在成员变量上面，可以在生成Setter方法和构造方法的时候，检查对应形参是否为空</p><pre><code>@Datapublic class User {    @NonNull    private Integer id;    private String name;    private Integer age;}</code></pre></li></ul><h3 id="Getter-x2F-Setter"><a href="#Getter-x2F-Setter" class="headerlink" title="@Getter/@Setter"></a>@Getter/@Setter</h3><ul><li><p>作用在类上，生成所有成员变量的getter/setter方法</p></li><li><p>作用在成员变量上，生成该成员变量的getter/setter方法</p></li><li><p>可以设定访问权限</p></li></ul><pre><code>@Setter@Getter(value = AccessLevel.PROTECTED)public class Student {    private Integer id;        private String name;        private Integer age;}</code></pre><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>作用在类上，覆盖默认的toString()方法，可以通过 of 属性限定显示某些字段，通过 exclude 属性排除某些字段</p><pre><code>@ToString(exclude = {"age"},of = {"id","name"})public class Student {    private Integer id;        private String name;        private Integer age;}</code></pre><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>作用在类上，覆盖默认的equals和hashCode方法，可以通过 of 属性限定比较某些字段，通过 exclude 属性排除某些字段</p><pre><code>@EqualsAndHashCode(of = {"id"})public class Student {    private Integer id;        private String name;        private Integer age;}</code></pre><h2 id="Lombok实现原理"><a href="#Lombok实现原理" class="headerlink" title="Lombok实现原理"></a>Lombok实现原理</h2><p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”（插件化注解处理API）规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p><p>Lombok就是一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><hr><ol><li><p>javac对源代码进行分析，生成一棵抽象语法树(AST)</p></li><li><p>javac编译过程中调用实现了JSR 269的Lombok程序</p></li><li><p>此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树    (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</p></li><li><p>javac使用修改后的抽象语法树(AST)生成字节码文件</p></li></ol><h2 id="Eclipse安装Lombok插件"><a href="#Eclipse安装Lombok插件" class="headerlink" title="Eclipse安装Lombok插件"></a>Eclipse安装Lombok插件</h2><p>1、下载lombok.jar，lombok.jar官方下载地址：<a href="https://projectlombok.org/download">https://projectlombok.org/download</a></p><p>2、双击下载好的lombak.jar，安装步骤如下：</p><p>2-1.关闭弹出的警告窗口，点击 Specify location..</p> <img src="/2022/0524undefined/1.jpg" class=""><p>2-2.选择eclipse的安装目录（确保该路径中不能有中文）</p> <img src="/2022/0524undefined/2.jpg" class=""><p>2-3.点击Install / Update</p> <img src="/2022/0524undefined/3.jpg" class=""><p>2-4.点击Quit Installer，完成安装</p> <img src="/2022/0524undefined/4.jpg" class=""><p>3、安装完成之后，请确认eclipse安装路径下是否多了一个lombok.jar包，并且其<br>   配置文件eclipse.ini中是否 添加了如下内容:-javaagent:D:\build-env\eclipse\lombok.jar</p> <img src="/2022/0524undefined/5.jpg" class=""> <img src="/2022/0524undefined/6.jpg" class=""><p>4、重启eclipse或myeclipse</p><p>5、测试，建立如下类：</p><p>import lombok.Data;  </p><p>@Data<br>public class DataObject {<br>   private String id;<br>   private String name;<br>   private String userId;<br>   private String password;<br>}<br>备注：如过安装成功但是@Data等注解无效，可能是由于你的eclipse版本是新版本，你的lombok.jar版本太旧。那么请下载最新的lombok.jar再进行安装。</p><p>6、lombok注解介绍请参看：<a href="http://blog.csdn.net/sunsfan/article/details/53542374">http://blog.csdn.net/sunsfan/article/details/53542374</a></p>]]></content>
      
      
      <categories>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2022/052313919.html"/>
      <url>/2022/052313919.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>软件的半成品</p><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>是一个持久层框架，使用sql语句将实体类映射到数据表，是一个半自动的ORM实现</p><p>O：对象</p><p>R：关系型数据库</p><p>M：映射（自动映射）</p><p>Hibernate：全自动的ORM实现</p><p>SSH：Struts2、Spring，Hibernate</p><p>SSM：SpringMVC、Spring、MyBatis</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>最早是apache的一个开源项目iBatis，2010年更名为mybatis</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>外部化sql语句：把sql语句与java代码分离</p><p>封装化sql语句：把sql语句封装到单独的文件总，方便管理</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>创建一个maven项目</p></li><li><p>配置 pom.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;                    &lt;/plugins&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li><li><p>在resources目录下，添加SqlMapConfig.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置一个环境，一个环境对应着一个数据库，default为某一个环境的id --&gt;    &lt;environments default="mysql"&gt;        &lt;environment id="mysql"&gt;            &lt;!-- 事务管理器，jdbc/managed(由外部容器管理，自己什么也不做) --&gt;            &lt;transactionManager type="jdbc"&gt;&lt;/transactionManager&gt;            &lt;!-- 数据源，unpooled、pooled、jndi --&gt;            &lt;dataSource type="pooled"&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"/&gt;                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="root"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name="com.neu.mapper"&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li><li><p>Mapper映射文件</p><ul><li><p>编写实体类</p></li><li><p>创建一个包：com.neu.mapper</p></li><li><p>在Mapper包下，创建接口：DeptMapper，在该接口中添加增删改查的方法</p></li><li><p>使用mybatis mapper向导，生成接口的配置映射文件：配置文件的名与接口名相同</p></li><li><p>在生成的映射文件中（DeptMapper.xml）,namespace的名称为对应的接口的完全限定名（包名+接口名）</p></li><li><p>statement的id与接口中的方法名相同</p></li><li><p>如果statement为select类型，必须添加一个 resultType 或 resultMap 属性，resultType的值必须为方法返回值中实体类型名</p></li><li><p>注册 mapper（SqlMapConfig.xml）</p><pre><code>&lt;mappers&gt;        &lt;!-- &lt;mapper resource="com/neu/mapper/DeptMapper.xml" /&gt; --&gt;        &lt;!-- &lt;mapper class="com.neu.mapper.DeptMapper"/&gt; --&gt;        &lt;package name="com.neu.mapper"&gt;&lt;/package&gt;&lt;/mappers&gt;</code></pre></li></ul></li><li><p>改进后的测试代码</p><pre><code>package com.neu.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.neu.mapper.DeptMapper;import com.neu.po.Dept;public class DeptMapperTest {    private DeptMapper deptMapper;    private SqlSession sqlSession;        @Before    public void setup() throws IOException {        //读取SqlMapConfig.xml文件        InputStream resource = Resources.getResourceAsStream("SqlMapConfig.xml");        //创建SqlSessionFactory        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource);        //得到Sqlsession对象（相当于数据库连接）        sqlSession = sqlSessionFactory.openSession();        //得到DeptMapper接口的实现类        deptMapper = sqlSession.getMapper(DeptMapper.class);    }        @After    public void after() {        //关闭sqlSession，把连接放回到连接池        sqlSession.close();    }        @Test    public void testInsert() throws IOException {        int n = deptMapper.insert(new Dept(66,"hr","sy"));                System.out.println(n);        //提交事务        sqlSession.commit();    }        @Test    public void testUpdate() throws IOException {        int n = deptMapper.update(new Dept(66,"hr","nj"));                System.out.println(n);        //提交事务        sqlSession.commit();    }        @Test    public void testDelete() throws IOException {        int n = deptMapper.delete(66);                System.out.println(n);        //提交事务        sqlSession.commit();    }        @Test    public void testGetById() throws IOException {        Dept dept = deptMapper.getById(10);                System.out.println(dept);    }        @Test    public void testGetAll() throws IOException {        List&lt;Dept&gt; list = deptMapper.getAll();                System.out.println(list);    }}</code></pre></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>实现 Emp 的增删改查方法</p><h2 id="使用log4j生成日志"><a href="#使用log4j生成日志" class="headerlink" title="使用log4j生成日志"></a>使用log4j生成日志</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>&lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>拷贝log4j.properties配置文件到resources下</p><pre><code># Global logging configuration#\u751F\u4EA7\u73AF\u5883\u914D\u7F6Einfo   ERRORlog4j.rootLogger=DEBUG,stdout# MyBatis logging configuration...log4j.logger.org.mybatis.example.BlogMapper=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><h2 id="多参数的处理"><a href="#多参数的处理" class="headerlink" title="多参数的处理"></a>多参数的处理</h2><ol><li><p>使用参数名：arg0、arg1…</p><pre><code>&lt;select id="search" resultType="com.neu.po.Dept"&gt;        select * from dept where dname = #{arg0} and loc = #{arg1}&lt;/select&gt;</code></pre></li><li><p>使用参数名：param1、param2</p><pre><code>&lt;select id="search" resultType="com.neu.po.Dept"&gt;        select * from dept where dname = #{param1} and loc = #{param2}&lt;/select&gt;</code></pre></li><li><p>使用@Param注解（推荐）</p><pre><code>接口：List&lt;Dept&gt; search(@Param("dname") String dname,@Param("loc") String loc);mapper:select * from dept where dname = #{dname} and loc = #{loc}</code></pre></li><li><p>使用实体类封装多个参数</p><pre><code>接口：List&lt;Dept&gt; search2(Dept dept);mapper:select * from dept where dname = #{dname} and loc = #{loc}测试代码：List&lt;Dept&gt; list = deptMapper.search2(new Dept(null,"hr","sy"));</code></pre></li><li><p>使用map集合，封装多个参数（很灵活）</p><pre><code>接口：List&lt;Dept&gt; search3(Map&lt;String, String&gt; map);mapper：select * from dept where dname = #{dname} and loc = #{loc}测试代码：Map map = new HashMap&lt;&gt;();map.put("dname", "hr");map.put("loc", "sy");        List&lt;Dept&gt; list = deptMapper.search3(map);</code></pre></li></ol><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><ol><li><p>#{}:使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用</p></li><li><p>${}:使用拼接字符串的方式生成sql语句，参数为列名的时候，可以使用</p><pre><code>接口：//根据参数列名来排序List&lt;Dept&gt; order(String columnName);mapper:select * from dept order by ${columnName}</code></pre></li><li><p>模糊查询</p><ul><li><p>使用#{}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like #{dname}测试代码：List&lt;Dept&gt; list = deptMapper.search4("%h%");</code></pre></li><li><p>使用${}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like '%${dname}%'测试代码：List&lt;Dept&gt; list = deptMapper.search4("h");</code></pre></li></ul></li></ol><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><ol><li><p><code>&lt;if test="表达式"&gt;sql片段&lt;/if&gt;</code></p><p>当表达式为true的时候，输出sql片段，否则不输出</p><pre><code>List&lt;Dept&gt; find(Dept dept);mapper:&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         where 1 = 1        &lt;if test="deptno != null"&gt;            and deptno = #{deptno}        &lt;/if&gt;        &lt;if test="dname != null"&gt;            and dname = #{dname}        &lt;/if&gt;        &lt;if test="loc != null"&gt;            and loc = #{loc}        &lt;/if&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;trim prefix="前缀" prefixOverrides="被覆盖的前缀" suffixOverrides="被覆盖的后缀"&gt;&lt;/trim&gt;</code></p><p>prefix:如果trim标签中内容不为空串，则添加该前缀，如果内容为空串，则不添加</p><p>prefixOverrides：如果trim标签内容最前面的部分是该属性的内容，则覆盖掉</p><p>suffixOverrides：如果trim标签内容最后面的部分是该属性的内容，则覆盖掉</p><pre><code>&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         &lt;trim prefix="where" prefixOverrides="and"&gt;            &lt;if test="deptno != null"&gt;                and deptno = #{deptno}            &lt;/if&gt;            &lt;if test="dname != null"&gt;                and dname = #{dname}            &lt;/if&gt;            &lt;if test="loc != null"&gt;                and loc = #{loc}            &lt;/if&gt;        &lt;/trim&gt;&lt;/select&gt;&lt;update id="update2"&gt;        update dept         &lt;trim prefix="set" suffixOverrides=","&gt;            &lt;if test="dname != null" &gt;                dname = #{dname},            &lt;/if&gt;            &lt;if test="loc != null" &gt;                loc = #{loc}            &lt;/if&gt;        &lt;/trim&gt;        where deptno = #{deptno}    &lt;/update&gt;</code></pre></li><li><p><code>&lt;where&gt;&lt;/where&gt;</code>，相当于：<code>&lt;trim prefix="where" prefixOverrides="and"&gt;</code></p><pre><code>&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         &lt;where&gt;            &lt;if test="deptno != null"&gt;                and deptno = #{deptno}            &lt;/if&gt;            &lt;if test="dname != null"&gt;                and dname = #{dname}            &lt;/if&gt;            &lt;if test="loc != null"&gt;                and loc = #{loc}            &lt;/if&gt;        &lt;/where&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;set&gt;&lt;/set&gt;</code>相当于：<code>&lt;trim prefix="set" suffixOverrides=","&gt;</code></p><pre><code>&lt;update id="update2"&gt;        update dept         &lt;set&gt;            &lt;if test="dname != null" &gt;                dname = #{dname},            &lt;/if&gt;            &lt;if test="loc != null" &gt;                loc = #{loc}            &lt;/if&gt;        &lt;/set&gt;        where deptno = #{deptno}&lt;/update&gt;</code></pre></li><li><p><code>&lt;foreach&gt;&lt;/foreach&gt;</code>:用来处理集合和数组</p><p>collection：list|conllection|array</p><p>item：引用集合或数组中的当前遍历元素</p><p>separator:分隔符</p><pre><code>接口：int batchInsert(List&lt;Dept&gt; list);mapper:&lt;insert id="batchInsert"&gt;        insert into dept values        &lt;foreach collection="list" item="dept" separator=","&gt;            (#{dept.deptno},#{dept.dname},#{dept.loc})        &lt;/foreach&gt;&lt;/insert&gt;</code></pre><p>open:要添加的开始字符串</p><p>close：要添加的结束字符串</p><pre><code>接口：int batchDelete（int[] ids）;mapper:&lt;delete id="batchDelete"&gt;        delete from dept where deptno in        &lt;foreach collection="array" item="deptno" separator="," open="(" close=")"&gt;            #{deptno}        &lt;/foreach&gt;&lt;/delete&gt;</code></pre><p>练习：编写Emp的动态sql</p></li></ol><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ol><li><p>定义：用来定义可以重复使用的sql代码段，可以包含在其他sql语句中</p></li><li><p>使用：</p><ul><li><p>定义sql片段</p><pre><code>&lt;sql id="selectAll"&gt;    select * from dept&lt;/sql&gt;</code></pre></li><li><p>引用sql片段</p><pre><code>&lt;include refid="selectAll"&gt;&lt;/include&gt;</code></pre></li></ul></li></ol><h2 id="得到插入的主键值"><a href="#得到插入的主键值" class="headerlink" title="得到插入的主键值"></a>得到插入的主键值</h2><p><code>&lt;selectKey&gt;</code>:</p><ul><li><p>order:决定了查询语句执行的先后</p><ul><li>after：先执行插入语句，后执行查询主键的sql语句（mysql）</li><li>before：先执行查询（生成）主键值的语句，再执行插入语句（oracle）</li></ul></li><li><p>keyProperty：键属性名，查询得到的主键值放到形参的哪个属性中</p></li><li><p>resultType：查询的主键值的类型</p></li></ul><p>使用：</p><pre><code>&lt;insert id="insert"&gt;        &lt;selectKey order="AFTER" keyProperty="deptno" resultType="int"&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into dept values(null,#{dname},#{loc})&lt;/insert&gt;</code></pre><h2 id="查询返回简单数据类型"><a href="#查询返回简单数据类型" class="headerlink" title="查询返回简单数据类型"></a>查询返回简单数据类型</h2><p>简单数据类型：基本数据类型（8种）、对应的包装类、String</p><pre><code>接口：//根据部门编号得到部门名称String getDname(int deptno);mapper:&lt;select id="getDname" resultType="string"&gt;        select dname from dept where deptno = #{deptno}&lt;/select&gt;</code></pre><pre><code>//得到部门总数int count();&lt;select id="count" resultType="int"&gt;    select count(*) from dept&lt;/select&gt;</code></pre><p>返回boolean类型：如果查询的记录数&gt;0,返回：true，等于0，返回：false</p><pre><code>//判断名称为参数执行的部门是否存在boolean exist(String dname);&lt;select id="exist" resultType="boolean"&gt;    select count(*) from dept where dname = #{dname}&lt;/select&gt;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code>//pageNum:第几页，pageSize：每页最多有多少行List&lt;Dept&gt; getPaged(@Param("pageNum") int pageNum,@Param("pageSize") int pageSize);&lt;select id="getPaged" resultType="com.neu.po.Dept"&gt;    select * from dept     limit ${(pageNum - 1) * pageSize},#{pageSize}&lt;/select&gt;</code></pre><h2 id="列名与属性名不一致"><a href="#列名与属性名不一致" class="headerlink" title="列名与属性名不一致"></a>列名与属性名不一致</h2><ol><li><p>在sql语句中，为列起别名，别名与属性名一致</p><pre><code>select deptno,dname dname2,loc from dept</code></pre></li><li><p>使用<code>&lt;resultMap&gt;</code>来进行映射</p><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;!-- &lt;id column="deptno" property="deptno"/&gt; --&gt;                &lt;result column="dname" property="dname2"/&gt;        &lt;!-- &lt;result column="loc" property="loc"/&gt; --&gt;&lt;/resultMap&gt;&lt;select id="getById" resultMap="basicMap"&gt;        &lt;include refid="selectAll"&gt;&lt;/include&gt; where deptno = #{no}&lt;/select&gt;</code></pre><p><code>&lt;id&gt;</code>:用来映射标识列（数据库中的主键）</p><p><code>&lt;result&gt;</code>：用来映射普通的结果（非主键）</p><p>column：列名</p><p>property：属性名</p></li></ol><h2 id="实体关联"><a href="#实体关联" class="headerlink" title="实体关联"></a>实体关联</h2><p><code>&lt;association&gt;</code>:关联（实体），表示一对一的关系（emp=》dept）</p><pre><code>//Emp实体类...Dept dept;</code></pre><pre><code>mapper:&lt;mapper namespace="com.neu.mapper.EmpMapper"&gt;    &lt;resultMap type="com.neu.po.Emp" id="basicMap"&gt;        &lt;id column="empno" property="empno" &gt;&lt;/id&gt;        &lt;result column="ename" property="ename"/&gt;        &lt;result column="job" property="job"/&gt;        &lt;result column="hiredate" property="hiredate"/&gt;        &lt;result column="sal" property="sal"/&gt;        &lt;result column="mgr" property="mgr"/&gt;        &lt;result column="comm" property="comm"/&gt;                &lt;association property="dept" javaType="com.neu.po.Dept"&gt;            &lt;id column="deptno" property="deptno"/&gt;            &lt;result column="dname" property="dname2"/&gt;            &lt;result column="loc" property="loc"/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        SELECT e.*,dname,loc         FROM dept d JOIN emp e         ON d.deptno = e.deptno        where empno = #{empno}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;id column="deptno" property="deptno" /&gt;        &lt;result column="dname" property="dname1"/&gt;        &lt;result column="loc" property="loc"/&gt;                &lt;collection property="emps" ofType="com.neu.po.Emp"&gt;            &lt;id column="empno" property="empno"/&gt;            &lt;id column="ename" property="ename"/&gt;            &lt;id column="job" property="job"/&gt;            &lt;id column="hiredate" property="hiredate"/&gt;            &lt;id column="sal" property="sal"/&gt;            &lt;id column="comm" property="comm"/&gt;            &lt;id column="mgr" property="mgr"/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        select d.dname,d.loc,e.* from dept d left join emp e         on d.deptno = e.deptno          WHERE e.deptno = #{deptno}    &lt;/select&gt;</code></pre><p>实体关联的第二种实现方法：再执行一次查询，根据已有的列查询出需要的对象</p><pre><code>&lt;mapper namespace="com.neu.mapper.EmpMapper"&gt;    &lt;resultMap type="com.neu.po.Emp" id="basicMap"&gt;        &lt;!-- column的值为emp表中的列名 --&gt;        &lt;association property="dept" column="deptno" select="com.neu.mapper.DeptMapper.getById"&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        SELECT * FROM emp where empno = #{empno}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="关联集合"><a href="#关联集合" class="headerlink" title="关联集合"></a>关联集合</h2><p><code>&lt;collection&gt;</code>:关联集合，表示一对多的关系（dept=》List<emp>）</emp></p><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;id column="deptno" property="deptno"/&gt;                &lt;result column="dname" property="dname2"/&gt;        &lt;!-- &lt;result column="loc" property="loc"/&gt; --&gt;        &lt;!-- column列的值为：Dept表中的deptno --&gt;        &lt;collection property="emps" column="deptno" select="com.neu.mapper.EmpMapper.getByDeptno"&gt;&lt;/collection&gt;&lt;/resultMap&gt;</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><pre><code>CREATE TABLE role(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL) CHARSET=utf8;INSERT INTO role VALUES(1,'管理员');INSERT INTO role VALUES(2,'普通用户');CREATE TABLE myuser(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL,    roleId INT NOT NULL) CHARSET=utf8;INSERT INTO myuser VALUES(1,'tom',1);INSERT INTO myuser VALUES(2,'scott',2);INSERT INTO myuser VALUES(3,'marry',2);</code></pre><p>功能：</p><ol><li>查询所有用户的信息（包括用户的角色信息）</li><li>根据角色名称查询该角色的信息及该角色下的所有用户信息</li></ol><h2 id="使用注解替代Mapper文件"><a href="#使用注解替代Mapper文件" class="headerlink" title="使用注解替代Mapper文件"></a>使用注解替代Mapper文件</h2><ol><li><p>使用注解</p><pre><code>@Update("update dept set dname = #{dname2} ,loc = #{loc} where deptno = #{deptno}")int update(Dept dept);</code></pre></li><li><p>长sql语句的写法</p><pre><code>@Update("update dept set dname = #{dname2} ,loc = #{loc} "+        "where deptno = #{deptno}")int update(Dept dept);@Update({"update dept set dname = #{dname2} ,loc = #{loc} ",          "where deptno = #{deptno}"})int update(Dept dept);</code></pre></li><li><p>ResultMap（mybatis 3.5.4）</p><pre><code>@Select("select * from dept where deptno = #{deptno}")@Results(id = "basicMap",value= {            @Result(column = "deptno",property = "deptno",id = true),            @Result(column = "dname",property = "dname2",id = false),            @Result(column = "loc",property = "loc",id = false),            @Result(column = "deptno",property = "emps",many=@Many(select = "com.neu.mapper.EmpMapper.getByDeptno"))                })Dept getById(int deptno);</code></pre></li></ol><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ol><li><p>定义：在数据与对象进行mapping操作时，只有在真正使用该对象的时候，才进行mapping操作，以减少数据库开销，从而提高系统性能</p></li><li><p>默认情况下，mybatis没有开启延迟加载功能，如果要开启，需要配置SqlMapConfig.xml文件</p><pre><code>&lt;settings&gt;        &lt;!-- 开启延迟加载 --&gt;        &lt;setting name="lazyLoadingEnabled" value="true"/&gt;        &lt;!-- 取消积极加载 --&gt;        &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;</code></pre></li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li><p>定义：是一种“以空间换时间”的设计理念，利用内存或硬盘空间来提高数据检索速度的有效手段之一。</p></li><li><p>一级缓存：默认开启，把数据缓存到当前会话中（SqlSession）</p><pre><code>@Testpublic void testGetById() throws IOException {    Dept dept = deptMapper.getById(10);    System.out.println(dept.getDname2());    dept = deptMapper.getById(10);    System.out.println(dept.getDname2());}</code></pre></li><li><p>二级缓存：默认没有开启，需要手工开启，修改SqlMapConfig.xml文件，把数据缓存到SqlSessionFactory中</p><pre><code>&lt;!-- 开启二级缓存 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt;</code></pre><p>在需要缓存的mapper文件中：</p><pre><code>&lt;cache&gt;&lt;/cache&gt;</code></pre><p>注意：缓存对象要实现可序列化接口（Serializable）</p></li></ol><h2 id="MBG"><a href="#MBG" class="headerlink" title="MBG"></a>MBG</h2><ol><li><p>定义：是一个MyBatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;  &lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;    &lt;jdbcConnection connectionURL="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf8" driverClass="com.mysql.jdbc.Driver" password="root" userId="root" /&gt;    &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="mybatisdemo2" /&gt;    &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="mybatisdemo2"&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="mybatisdemo2" type="XMLMAPPER" /&gt;           &lt;table schema="root" tableName="dept"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li></ul></li></ol><p>排序：</p><pre><code>example.setOrderByClause("ename desc");</code></pre><h2 id="Example练习"><a href="#Example练习" class="headerlink" title="Example练习"></a>Example练习</h2><ol><li>查询员工姓名等于“smith”并且sal大于等于3000的员工信息</li><li>查询员工编号为：7783和7876的员工信息</li><li>查询奖金（comm）不是null的所有员工信息</li><li>更新员工编号为7783的薪水，薪水增加200元</li><li>查询工资小于2000元或部门编号为10的所有员工信息</li><li>根据部门名称查询该部门所有员工（组合DeptExample和EmpExample查询）</li></ol><h2 id="Idea-中使用-Free-mybatis-plugin"><a href="#Idea-中使用-Free-mybatis-plugin" class="headerlink" title="Idea 中使用 Free mybatis plugin"></a>Idea 中使用 Free mybatis plugin</h2><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><ol><li><p>在idea中连接数据库</p><ul><li>添加数据源，选mysql</li></ul> <img src="/2022/052313919/1.jpg" class=""><ul><li><p>配置数据库连接参数</p><img src="/2022/052313919/2.jpg" class=""></li><li><p>在Advanced 中 配置 serverTimezone：Asia/Shanghai</p><img src="/2022/052313919/3.jpg" class=""></li><li><p>测试连接</p><img src="/2022/052313919/4.jpg" class=""></li><li><p>查看数据表</p><img src="/2022/052313919/5.jpg" class=""></li></ul></li></ol><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><ol><li><p>选择表</p><img src="/2022/052313919/6.jpg" class=""></li><li><p>输入参数</p><img src="/2022/052313919/7.jpg" class=""></li></ol><h2 id="Idea环境中pom-xml"><a href="#Idea环境中pom-xml" class="headerlink" title="Idea环境中pom.xml"></a>Idea环境中pom.xml</h2><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo3&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;!--&lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;--&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--&lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;--&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="Idea中代码生成"><a href="#Idea中代码生成" class="headerlink" title="Idea中代码生成"></a>Idea中代码生成</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>创建 maven 项目，导入依赖和插件</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;mbgdemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;--&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--mybatis-generator插件--&gt;            &lt;plugin&gt;                &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>在 src/main/resources/ 创建文件：generatorConfig.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;  &lt;classPathEntry location="D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar"/&gt;  &lt;context id="context1" targetRuntime="Mybatis3"&gt;    &lt;jdbcConnection         connectionURL="jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"         driverClass="com.mysql.cj.jdbc.Driver"         password="root"         userId="root" &gt;        &lt;property name="nullCatalogMeansCurrent" value="true"/&gt;    &lt;/jdbcConnection&gt;    &lt;!-- 实体类 --&gt;    &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="src/main/java" /&gt;    &lt;!-- 生成Mapper.xml --&gt;    &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="src/main/resources"&gt;&lt;/sqlMapGenerator&gt;    &lt;!-- java的Mapper接口 --&gt;    &lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="src/main/java" type="XMLMAPPER" /&gt;            &lt;table schema="root" tableName="role"&gt;        &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;          &lt;/table&gt;      &lt;!--      &lt;table schema="root" tableName="user"&gt;          &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;          &lt;columnOverride column="useType" property="role" javaType="Role" /&gt;      &lt;/table&gt;      --&gt;        &lt;!--&lt;table schema="root" tableName="Department" domainObjectName="Department"&gt;        &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;                  &lt;columnOverride column="DeptCode" property="deptCode"&gt;&lt;/columnOverride&gt;        &lt;columnOverride column="DeptName" property="deptName"&gt;&lt;/columnOverride&gt;        &lt;columnOverride column="DeptCategoryID" property="deptCategory" javaType="ConstantItem"&gt;&lt;/columnOverride&gt;        &lt;columnOverride column="DeptType" property="deptType" javaType="ConstantItem"&gt;&lt;/columnOverride&gt;        &lt;columnOverride column="DelMark" property="delMark"&gt;&lt;/columnOverride&gt;    &lt;/table&gt;--&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>生成代码</p><img src="/2022/052313919/8.jpg" class=""></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>使用 <code>MyBatisCodeHelpPro</code> 插件，生成 xml配置文件</p><img src="/2022/052313919/9.jpg" class=""></li><li><p>修改 xml 配置文件，内容同方法一一样</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration    PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"    "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;    &lt;classPathEntry location="D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar"/&gt;    &lt;context id="Mybatis3Context" targetRuntime="MyBatis3"&gt;        &lt;property name="javaFileEncoding" value="UTF-8"/&gt;        &lt;jdbcConnection                connectionURL="jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"                driverClass="com.mysql.cj.jdbc.Driver"                password="root"                userId="root" &gt;            &lt;property name="nullCatalogMeansCurrent" value="true"/&gt;        &lt;/jdbcConnection&gt;        &lt;javaTypeResolver&gt;            &lt;property name="forceBigDecimals" value="false"/&gt;        &lt;/javaTypeResolver&gt;        &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="src/main/java"&gt;            &lt;property name="enableSubPackages" value="true"/&gt;            &lt;property name="trimStrings" value="true"/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="src/main/resources"&gt;            &lt;property name="enableSubPackages" value="true"/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.neu.mapper" targetProject="src/main/java"&gt;            &lt;property name="enableSubPackages" value="true"/&gt;        &lt;/javaClientGenerator&gt;        &lt;table schema="root" tableName="role"&gt;            &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>修改 pom.xml文件，添加 maven 插件</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;mgb2&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--mybatis-generator插件--&gt;            &lt;plugin&gt;                &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/MybatisGenerator.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>生成代码（同方法一）</p></li></ol><h1 id="Idea中生成Mapper"><a href="#Idea中生成Mapper" class="headerlink" title="Idea中生成Mapper"></a>Idea中生成Mapper</h1><ol><li><p>在 mapper 接口上 alt + enter</p><img src="/2022/052313919/10.jpg" class=""></li><li><p>选择：Generate mapper of xml</p></li><li><p>选择mapper 位置</p><img src="/2022/052313919/11.jpg" class=""></li></ol><h1 id="MyBatis中TypeHandler"><a href="#MyBatis中TypeHandler" class="headerlink" title="MyBatis中TypeHandler"></a>MyBatis中TypeHandler</h1><p>在Mybatis中可以定义一个TypeHandler类型，通过它可以实现Java类型跟数据库类型的相互转换。</p><p>需求：把java实体类中的String[],转换为数据库中的varchar类型（例如保存用户的多个爱好）　</p><ol><li><p>数据库</p><pre><code>CREATE TABLE myuser(    id INT PRIMARY KEY AUTO_INCREMENT,    username VARCHAR(30) NOT NULL,    PASSWORD VARCHAR(30) NOT NULL,    interests VARCHAR(100) )</code></pre></li><li><p>实体类</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class MyUser {    private int id;      private String username;      private String password;      private String[] interests;}</code></pre></li><li><p>类型转换器</p><pre><code>package com.neu.util;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Date;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import org.apache.ibatis.type.MappedJdbcTypes;import org.apache.ibatis.type.MappedTypes;@MappedJdbcTypes(JdbcType.VARCHAR)@MappedTypes(String[].class)public class StringArrayTypeHandler extends BaseTypeHandler&lt;String[]&gt; {    private String[] getStringArray(String columnValue) {       if (columnValue == null)           return null;       return columnValue.split(",");    }         @Override    public String[] getNullableResult(ResultSet rs, String columnName)           throws SQLException {       return getStringArray(rs.getString(columnName));    }     @Override    public String[] getNullableResult(ResultSet rs, int columnIndex)           throws SQLException {       return this.getStringArray(rs.getString(columnIndex));    }     @Override    public String[] getNullableResult(CallableStatement cs, int columnIndex)           throws SQLException {       return this.getStringArray(cs.getString(columnIndex));    }     @Override    public void setNonNullParameter(PreparedStatement ps, int i,           String[] parameter, JdbcType jdbcType) throws SQLException {       //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了       StringBuffer result = new StringBuffer();       for (String value : parameter)           result.append(value).append(",");       result.deleteCharAt(result.length()-1);       ps.setString(i, result.toString());    }       }</code></pre><p>1.@MappedJdbcTypes定义是JdbcType类型，必须要是枚举类org.apache.ibatis.type.JdbcType所枚举的数据类型<br>2.@MappedTypes定义的是JavaType的数据类型，描述哪些Java类型可被拦截。<br>3.在我们启用了自定义的这个TypeHandler之后，数据的读写都会被这个类所过滤<br>4.在setNonNullParameter方法中，重新定义要写往数据库的数据。<br>5.在另外三个方法中我们将从数据库读出的数据类型进行转换。</p></li><li><p>注册 TypeHandler（SqlMapConfig.xml）</p><pre><code>&lt;typeHandlers&gt;   &lt;package name="com.neu.util"/&gt;&lt;/typeHandlers&gt;或&lt;typeHandlers&gt;   &lt;typeHandler handler="com.neu.util.StringArrayTypeHandler"/&gt;&lt;/typeHandlers&gt;</code></pre></li><li><p>接口</p><pre><code>public interface MyUserMapper {    MyUser getById(int id);        int insert(MyUser user);        int update(MyUser user);}</code></pre></li><li><p>mapper（可以不配置 typeHandler 属性，由mybatis自动选择）</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.neu.mapper.MyUserMapper"&gt;    &lt;resultMap type="com.neu.po.MyUser" id="basicMap"&gt;        &lt;result column="interests" property="interests" typeHandler="com.neu.util.StringArrayTypeHandler" /&gt;    &lt;/resultMap&gt;    &lt;!-- 可以使用 resultMap 进行手工映射 --&gt;    &lt;select id="getById" resultType="com.neu.po.MyUser"&gt;        select * from myuser where id = #{id}    &lt;/select&gt;        &lt;insert id="insert"&gt;        insert into myuser values(            #{id},            #{username,javaType=String,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.StringTypeHandler},            #{password},#{interests,typeHandler=com.neu.util.StringArrayTypeHandler}        )    &lt;/insert&gt;        &lt;update id="update"&gt;        update myuser set username = #{username},password= #{password},interests=#{interests}        where id = #{id}    &lt;/update&gt;&lt;/mapper&gt;</code></pre></li><li><p>测试代码</p><pre><code>public class MyUserMapperTest {    private SqlSession session;    private MyUserMapper myuserMapper;        @Before    public void setup() throws IOException {        //ctrl+2 L        //读取配置文件        InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        //创建SqlSessionFactory        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //创建连接，相当于Connection        session = sessionFactory.openSession();        //返回DeptMapper接口的实现类        myuserMapper = session.getMapper(MyUserMapper.class);    }        @After    public void after() {        //关闭会话        session.close();    }    @Test    public void testInsert() {        int n = myuserMapper.insert(new MyUser(33,"tom","111",new String[]{"游泳","爬山"}));                System.out.println(n);                session.commit();    }        @Test    public void testGetById() {        MyUser user = myuserMapper.getById(10);        System.out.println(user);    }        @Test    public void testUpdate() {        int n = myuserMapper.update(new MyUser(33,"marry","222",new String[]{"游泳","爬山","钓鱼"}));                System.out.println(n);                session.commit();    }}</code></pre></li></ol><p>mybatis中 在  <code>TypeHandlerRegistry</code> 注册内置拦截器</p><pre><code>public TypeHandlerRegistry(Configuration configuration) {    this.unknownTypeHandler = new UnknownTypeHandler(configuration);    register(Boolean.class, new BooleanTypeHandler());    register(boolean.class, new BooleanTypeHandler());    register(JdbcType.BOOLEAN, new BooleanTypeHandler());    register(JdbcType.BIT, new BooleanTypeHandler());    register(Byte.class, new ByteTypeHandler());    register(byte.class, new ByteTypeHandler());    register(JdbcType.TINYINT, new ByteTypeHandler());    register(Short.class, new ShortTypeHandler());    register(short.class, new ShortTypeHandler());    register(JdbcType.SMALLINT, new ShortTypeHandler());    register(Integer.class, new IntegerTypeHandler());    register(int.class, new IntegerTypeHandler());    register(JdbcType.INTEGER, new IntegerTypeHandler());    register(Long.class, new LongTypeHandler());    register(long.class, new LongTypeHandler());    register(Float.class, new FloatTypeHandler());    register(float.class, new FloatTypeHandler());    register(JdbcType.FLOAT, new FloatTypeHandler());    register(Double.class, new DoubleTypeHandler());    register(double.class, new DoubleTypeHandler());    register(JdbcType.DOUBLE, new DoubleTypeHandler());    register(Reader.class, new ClobReaderTypeHandler());    register(String.class, new StringTypeHandler());    register(String.class, JdbcType.CHAR, new StringTypeHandler());    register(String.class, JdbcType.CLOB, new ClobTypeHandler());    register(String.class, JdbcType.VARCHAR, new StringTypeHandler());    register(String.class, JdbcType.LONGVARCHAR, new StringTypeHandler());    register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCHAR, new NStringTypeHandler());    register(String.class, JdbcType.NCLOB, new NClobTypeHandler());    register(JdbcType.CHAR, new StringTypeHandler());    register(JdbcType.VARCHAR, new StringTypeHandler());    register(JdbcType.CLOB, new ClobTypeHandler());    register(JdbcType.LONGVARCHAR, new StringTypeHandler());    register(JdbcType.NVARCHAR, new NStringTypeHandler());    register(JdbcType.NCHAR, new NStringTypeHandler());    register(JdbcType.NCLOB, new NClobTypeHandler());    register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler());    register(JdbcType.ARRAY, new ArrayTypeHandler());    register(BigInteger.class, new BigIntegerTypeHandler());    register(JdbcType.BIGINT, new LongTypeHandler());    register(BigDecimal.class, new BigDecimalTypeHandler());    register(JdbcType.REAL, new BigDecimalTypeHandler());    register(JdbcType.DECIMAL, new BigDecimalTypeHandler());    register(JdbcType.NUMERIC, new BigDecimalTypeHandler());    register(InputStream.class, new BlobInputStreamTypeHandler());    register(Byte[].class, new ByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler());    register(Byte[].class, JdbcType.LONGVARBINARY, new BlobByteObjectArrayTypeHandler());    register(byte[].class, new ByteArrayTypeHandler());    register(byte[].class, JdbcType.BLOB, new BlobTypeHandler());    register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.LONGVARBINARY, new BlobTypeHandler());    register(JdbcType.BLOB, new BlobTypeHandler());    register(Object.class, unknownTypeHandler);    register(Object.class, JdbcType.OTHER, unknownTypeHandler);    register(JdbcType.OTHER, unknownTypeHandler);    register(Date.class, new DateTypeHandler());    register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());    register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());    register(JdbcType.TIMESTAMP, new DateTypeHandler());    register(JdbcType.DATE, new DateOnlyTypeHandler());    register(JdbcType.TIME, new TimeOnlyTypeHandler());    register(java.sql.Date.class, new SqlDateTypeHandler());    register(java.sql.Time.class, new SqlTimeTypeHandler());    register(java.sql.Timestamp.class, new SqlTimestampTypeHandler());    register(String.class, JdbcType.SQLXML, new SqlxmlTypeHandler());    register(Instant.class, new InstantTypeHandler());    register(LocalDateTime.class, new LocalDateTimeTypeHandler());    register(LocalDate.class, new LocalDateTypeHandler());    register(LocalTime.class, new LocalTimeTypeHandler());    register(OffsetDateTime.class, new OffsetDateTimeTypeHandler());    register(OffsetTime.class, new OffsetTimeTypeHandler());    register(ZonedDateTime.class, new ZonedDateTimeTypeHandler());    register(Month.class, new MonthTypeHandler());    register(Year.class, new YearTypeHandler());    register(YearMonth.class, new YearMonthTypeHandler());    register(JapaneseDate.class, new JapaneseDateTypeHandler());    // issue #273    register(Character.class, new CharacterTypeHandler());    register(char.class, new CharacterTypeHandler());  }</code></pre><p>mybatis 类型别名 注册：TypeAliasRegistry</p><pre><code>说明：https://blog.csdn.net/lgl782519197/article/details/109066243</code></pre><pre><code>public TypeAliasRegistry() {    registerAlias("string", String.class);    registerAlias("byte", Byte.class);    registerAlias("long", Long.class);    registerAlias("short", Short.class);    registerAlias("int", Integer.class);    registerAlias("integer", Integer.class);    registerAlias("double", Double.class);    registerAlias("float", Float.class);    registerAlias("boolean", Boolean.class);    registerAlias("byte[]", Byte[].class);    registerAlias("long[]", Long[].class);    registerAlias("short[]", Short[].class);    registerAlias("int[]", Integer[].class);    registerAlias("integer[]", Integer[].class);    registerAlias("double[]", Double[].class);    registerAlias("float[]", Float[].class);    registerAlias("boolean[]", Boolean[].class);    registerAlias("_byte", byte.class);    registerAlias("_long", long.class);    registerAlias("_short", short.class);    registerAlias("_int", int.class);    registerAlias("_integer", int.class);    registerAlias("_double", double.class);    registerAlias("_float", float.class);    registerAlias("_boolean", boolean.class);    registerAlias("_byte[]", byte[].class);    registerAlias("_long[]", long[].class);    registerAlias("_short[]", short[].class);    registerAlias("_int[]", int[].class);    registerAlias("_integer[]", int[].class);    registerAlias("_double[]", double[].class);    registerAlias("_float[]", float[].class);    registerAlias("_boolean[]", boolean[].class);    registerAlias("date", Date.class);    registerAlias("decimal", BigDecimal.class);    registerAlias("bigdecimal", BigDecimal.class);    registerAlias("biginteger", BigInteger.class);    registerAlias("object", Object.class);    registerAlias("date[]", Date[].class);    registerAlias("decimal[]", BigDecimal[].class);    registerAlias("bigdecimal[]", BigDecimal[].class);    registerAlias("biginteger[]", BigInteger[].class);    registerAlias("object[]", Object[].class);    registerAlias("map", Map.class);    registerAlias("hashmap", HashMap.class);    registerAlias("list", List.class);    registerAlias("arraylist", ArrayList.class);    registerAlias("collection", Collection.class);    registerAlias("iterator", Iterator.class);    registerAlias("ResultSet", ResultSet.class);  }</code></pre><h1 id="使用注解替代mapper文件"><a href="#使用注解替代mapper文件" class="headerlink" title="使用注解替代mapper文件"></a>使用注解替代mapper文件</h1><ol><li><p>使用注解</p><pre><code>@Select("select * from dept")List&lt;Dept&gt; getAll();@Insert("insert into dept values(#{deptno},#{dname},#{loc})")int insert(Dept dept);</code></pre></li><li><p>长 SQL 语句的写法</p><pre><code>@Select("select * from dept "+        "where deptno = #{deptno}")Dept getById(int deptno);@Select({"select * from dept ",         "where deptno = #{deptno}"})Dept getById(int deptno);</code></pre></li><li><p>ResultMap</p><ul><li><p>直接在接口方法上添加@Results注解</p><pre><code>//mybatis的版本号：3.5.4，支持@Results中的id属性@Select({"select * from dept ",            "where deptno = #{deptno}"})    @Results(id="basicMap", value= {            @Result(column = "deptno",property = "deptno",id = true),            @Result(column = "dname",property = "dname"),            @Result(column = "loc",property = "loc"),            @Result(property = "emps",column = "deptno",many = @Many(select = "com.neu.mapper.EmpMapper.getByDeptno"))    })    Dept getById(int deptno);        @Select("select * from emp where empno = #{empno}")    @Results(value= {            @Result(                    property = "dept",                    column = "deptno",                    one = @One(select = "com.neu.mapper.DeptMapper.getById"            ))    })    Emp getById(int empno);</code></pre></li><li><p>使用@ResultMap注解，引用@Results</p><pre><code>//basicMap可以是@Results的id或对应mapper.xml文件中&lt;resultMap&gt;的id属性@Select("select * from dept")@ResultMap("basicMap")List&lt;Dept&gt; getAll();</code></pre></li></ul><ol start="4"><li><p>得到自增主键值</p><pre><code>@Insert("insert into dept values(null,#{dname},#{loc})")    @SelectKey(        statement = "select last_insert_id()",        resultType = Integer.class,        keyProperty = "deptno",        before = false    )    int insert(Dept dept);</code></pre></li></ol></li></ol><h1 id="查询补充"><a href="#查询补充" class="headerlink" title="查询补充"></a>查询补充</h1><pre><code>//接口List&lt;Map&lt;String,Object&gt;&gt; report();//mapper&lt;select id="report" resultType="map"&gt;        select ename,job,hiredate,dname,loc        from emp e join dept d        on e.deptno = d.deptno&lt;/select&gt;</code></pre><h1 id="MBG-Mybatis-Generator"><a href="#MBG-Mybatis-Generator" class="headerlink" title="MBG(Mybatis Generator)"></a>MBG(Mybatis Generator)</h1><ol><li><p>定义：是一个Mybatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p></li><li><p>修改模板：</p><ul><li><p>改为使用“简单模板”</p><pre><code>&lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;</code></pre></li><li><p>使用默认模板</p><pre><code>&lt;context id="context1" &gt;</code></pre></li></ul></li><li><p>修改配置</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;  &lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;    &lt;jdbcConnection connectionURL="jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;amp;characterEncoding=utf8" driverClass="com.mysql.jdbc.Driver" password="root" userId="root" /&gt;    &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="mybatismbg" /&gt;    &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="mybatismbg"&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="mybatismbg" type="XMLMAPPER" /&gt;        &lt;table schema="root" tableName="dept"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;    &lt;table schema="root" tableName="emp"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>生成代码（配置文件右键）</p></li><li><p>如果有实体关联，修改xml配置文件</p><ul><li><p>修改生成xml配置文件</p><pre><code>//generatorConfig.xml&lt;table schema="root" tableName="emp"&gt;    &lt;columnOverride column="deptno" property="dept" javaType="com.neu.po.Dept" /&gt;&lt;/table&gt;</code></pre></li><li><p>修改生成的mapper文件</p><pre><code>&lt;!-- &lt;result column="deptno" jdbcType="INTEGER" property="dept" /&gt; --&gt;    &lt;association property="dept" column="deptno" select="com.neu.mapper.DeptMapper.selectByPrimaryKey"&gt;&lt;/association&gt;</code></pre><p>修改 dept =》 dept.deptno(注意：别修改列名)</p></li></ul></li></ul><ol start="3"><li><p>使用Mybatis3模板</p><ul><li><p>生成的接口中有11个方法</p><ul><li>方法名中包含 primaryKey：根据主键进行相应的操作</li><li>方法名中包含example：根据Example生成where语句来操作</li><li>方法名中包含Selective：对部分列进行有选择操作（动态sql）</li></ul></li><li><p>Example的作用：生成where语句</p><pre><code>@Test    public void testGetByExample() throws IOException {        EmpExample example = new EmpExample();//example.or().andEnameEqualTo("SMITH").andSalGreaterThan(new BigDecimal(700));//example.or().andEnameLike("%S%");//example.or().andSalBetween(new BigDecimal(1500), new BigDecimal(2000));//List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//list.add(7369);//list.add(7499);////example.or().andEmpnoIn(list);                Dept dept = new Dept();        dept.setDeptno(10);                example.or().andDeptEqualTo(dept);                List&lt;Emp&gt; list2 = empMapper.selectByExample(example);        System.out.println(list2);    }    //修改EmpExamplepublic Criteria andDeptEqualTo(Dept value) {   addCriterion("deptno =", value.getDeptno(), "dept");   return (Criteria) this;}</code></pre></li></ul><p>练习：</p><ol><li>生成Role和MyUser实体类、接口、mapper文件</li><li>根据角色Id查询该角色的所有用户信息</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/052338008.html"/>
      <url>/2022/052338008.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>Apache Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p></li><li><p>项目管理工具：编译、测试、运行、打包（jar、war）、部署</p></li><li><p>依赖管理</p></li><li><p>下载</p><p>地址：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><img src="/2022/052338008/1.jpg" class="">   </li><li><p>安装、配置</p><ul><li><p>直接解压即可</p></li><li><p>配置环境变量：</p><ul><li>M2_HOME=&gt;maven解压目录</li><li>修改 path=》添加 %M2_HOME%\bin</li></ul></li><li><p>测试：mvn -v</p></li></ul></li><li><p>maven仓库</p><ul><li>本地仓库：本地的一个文件夹</li><li>中央仓库：世界唯一，由maven社区维护（网站）</li><li>远程仓库：是位于web服务器上的一个私有仓库，由自己公司创建和维护</li><li>镜像仓库：是中央仓库的镜像（副本），目的是加快依赖jar包的下载速度</li></ul></li><li><p>修改maven配置</p><ul><li><p>修改：maven安装目录下的 conf/settings.xml</p><ul><li><p>修改本地仓库位置：</p><pre><code>&lt;localRepository&gt;D:\mavenrepository&lt;/localRepository&gt;</code></pre></li><li><p>配置阿里云镜像</p></li></ul><pre><code>&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;nexus-aliyun&lt;/id&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;name&gt;Nexus aliyun&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre></li></ul></li><li><p>在 Idea 中配置</p><ul><li><p>进入 settings</p><img src="/2022/052338008/2.jpg" class="">   </li><li><p>配置maven</p><img src="/2022/052338008/3.jpg" class=""></li></ul></li><li><p>Eclipse配置配置</p><ul><li><p>配置maven位置：</p><img src="/2022/052338008/4.jpg" class="">   </li><li><p>配置maven的配置文件：</p><p>首选项=》maven=》User settings =》选择settings.xml文件</p><img src="/2022/052338008/5.jpg" class=""></li></ul></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>maven的目录结构</p><p>src：源程序目录</p><p>​main：源程序</p><p>​java：程序</p><p>​resources：资源文件(配置文件)</p><p>​webapp:web项目（不是web项目没有）</p><p>​test：测试代码</p><p>target：项目生成的结果</p></li><li><p>创建maven项目</p><ul><li><p>maven project 向导</p></li><li><p>配置三个坐标（定位唯一的jar包）</p><ul><li>groupId：组织或公司的域名</li><li>artifactId：组件名（项目名）</li><li>version：版本号</li></ul></li><li><p>打包方式</p><ul><li>jar（默认打包方式，控制台项目或window项目）</li><li>war（web项目）</li><li>pom（maven的管理项目）</li></ul></li><li><p>配置 pom.xml</p><pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.neu&lt;/groupId&gt;  &lt;artifactId&gt;test3&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;path&gt;/&lt;/path&gt;                    端口号                    &lt;port&gt;8089&lt;/port&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;webResources&gt;                        &lt;resource&gt;                            &lt;excludes&gt;                                &lt;exclude&gt;**/WEB-INF/web.xml&lt;/exclude&gt;                            &lt;/excludes&gt;                            &lt;directory&gt;src/main/webapp&lt;/directory&gt;                        &lt;/resource&gt;                    &lt;/webResources&gt;                   &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li></ul><ol start="3"><li><p>端口号冲突，解决方法</p><ul><li><p>把原来使用该端口的程序关闭</p><ul><li>在eclipse中关闭</li><li>在任务管理器中关闭 java 进程 或 javaw进程</li></ul></li><li><p>修改当前tomcat服务的端口号，改成与之前冲突不一样即可</p><pre><code>&lt;port&gt;8089&lt;/port&gt;</code></pre></li></ul></li><li><p>web项目</p><ul><li><p>打包方式</p><pre><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></pre></li><li><p>idea中运行</p><ul><li>maven面板中，选中项目</li><li>在 plugins 中选择 tomcat7 =》tomcat7：run=》右键=》Run Maven Build</li></ul></li><li><p>eclipse中运行</p><p>maven build</p><pre><code>tomcat7:run</code></pre></li><li><p>配置 tomcat插件</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;path&gt;/&lt;/path&gt;        &lt;!-- 端口号 --&gt;        &lt;port&gt;8089&lt;/port&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre></li></ul><ol start="5"><li><p>从maven仓库中搜索并添加jar包</p><ul><li>进入maven中央仓库网站（<a href="https://mvnrepository.com/%EF%BC%89">https://mvnrepository.com/）</a></li><li>在搜索栏中输入关键字</li><li>在列表中查找需要的版本</li><li>拷贝“maven”中内容到pom.xml的 <dependencies>中</dependencies></li></ul></li><li><p>使用 JSTL</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;    &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt;    &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>测试：</p><pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    你好！    &lt;c:forEach begin="1" end="10" var="pageNum"&gt;        ${pageNum}    &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol></li></ol></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>clean：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。 </p></li><li><p>validate：验证工程是否正确，所有需要的资源是否可用。 </p></li><li><p>compile：编译项目的源代码。</p></li><li><p>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 </p></li><li><p>Package：把已编译的代码打包成可发布的格式，比如jar。</p></li><li><p>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</p></li><li><p>verify：运行所有检查，验证包是否有效且达到质量标准。</p></li><li><p>install：把包安装在本地的repository中，可以被其他工程作为依赖来使用。</p></li><li><p>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 </p></li><li><p>site：为项目生成文档站点。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统输入/输出管理</title>
      <link href="/2022/052237860.html"/>
      <url>/2022/052237860.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入-输出管理管理"><a href="#输入-输出管理管理" class="headerlink" title="输入-输出管理管理"></a>输入-输出管理管理</h1>  <h2 id="IO管理概述"><a href="#IO管理概述" class="headerlink" title="IO管理概述"></a>IO管理概述</h2><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备按照使用特性分为以下类型：<br>人机交互类外部设备：打印机，显示器，键鼠等。数据交换速度慢，通常以字节为单位数据交换。<br>存储设备：磁盘，光盘等。用于数据交换，速度快，通常以多字节组成的块为单位数据交换。<br>网络通信设备：网络接口等。速度介于前两者之间，用于远程设备通信。<br>除了以上分类方式，还可以按照以下方法分类：</p><ul><li>按传输速率分类：<br>①低速设备：键鼠等。<br>②中速：打印机等。<br>③告诉：磁带机，光盘机，磁盘机等。  </li><li>按信息交换的单位分类：<br>①块设备：属于有结构设备，如磁盘，基本特征就是传输速率高，可寻址即随机读写。<br>②字符设备：用于IO的设备，传输基本单位是字符，无结构类型，如打印机等，基本特征是传输速率低，不可寻址，IO采用中断驱动方式。  <h3 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h3>外围设备和内存之间IO控制方式有4种。  </li><li>程序直接控制方式：</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统文件管理</title>
      <link href="/2022/052139833.html"/>
      <url>/2022/052139833.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><img src="/2022/052139833/1.jpg" class="">   <h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h3><ul><li>文件的定义：<br>以计算机硬盘为载体的存储在计算机上的信息集合。系统运行时，计算机以进程为基本单位斤西瓜资源的调度和分配，而在用户进行的输入输出中，则以文件为基本单位。当用户把文件用于用户程序的输入输出时，希望还可以访问，修改，保存文件等，实现对于文件的维护管理，需要OS中的文件系统。<br>文件由存储空间中的数据，分类和索引信息，访问权限信息组成。用户通过文件系统建立文件，提供程序的输入输出，对资源进行管理，首先了解文件结构，通过自底向上的方式来定义：<br>①数据项：文件系统中最低级的数据组织形式，分为基本数据项（描述一个对象某个值，是数据中可命名的最小逻辑数据单元，即原子数据）和组合数据项（由多个基本数据项组成）。<br>②记录：一组相关数据项集合，描述一个对象在某方面的属性（考生信息一系列域）。<br>③文件：指由创建者所定义的一组相关信息集合，逻辑上分为有结构文件（文件由一组相似记录组成，又叫记录式文件）和无结构文件（视为一个字符流，又称流式文件）。</li><li>文件的属性：<br>系统不同属性也不同，但通常包括：<br>①名称：文件名称唯一，以易读取形式保存。<br>②标识符：标识文件系统内文件的唯一标签，通常为数字，对人不可读。<br>③类型：被支持不同类型的文件系统所使用。<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小，也可包括文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息。<br>⑦时间，日期和用户标识：文件创建，上次修改，上次访问的相关信息，用于保护跟踪文件使用。<br>所有文件的信息都保存在目录结构中，目录结构保存在外存中，文件信息需要时才调入内存，通常，目录条目包括文件名称以及唯一标识符，二标识符定位其他属性信息。  </li><li>文件的基本操作：<br>OS提供系统调用，对文件进行创建，写，读，重定位，删除，截断等操作。（基本操作组合可以执行其他文件操作）<br>①创建文件：①文件系统为文件找到空间。②目录中为文件创建新条目，记录文件名称和标识符等其他信息。<br>②写文件：执行系统调用，指明文件名称和要写内容，系统维护一个写位置的指针，写操作时更新写指针。<br>③读文件：执行系统调用，指明文件内容和要读文件快的内存位置，系统维护一个读位置的指针，读操作时更新读指针，读写使用同一个指针。<br>④文件重定位：按照某条件搜索目录，把当前文件位置设置为给定值，并且不会读写文件。<br>⑤删除文件：从目录找出删除文件的目录项，实质称为空项目，回收文件存储空间。<br>⑥截断文件：允许文件所有属性不变，并删除文件内容，即长度设置为0并释放其空间。  </li><li>文件打开和关闭：<br>许多系统要求首次使用文件时，系统调用open将指明文件的属性从外存复制到内存，打开文件表的一个条目，把表目编号返回给用户，OS维护一个包含所有打开文件信息的表（打开文件表），需要文件操作时可以通过该表的一个索引指定文件，省略搜索环境，不再使用可以关闭它，OS打开文件表删除这个条目。open会根据文件名搜索牡蛎，并把目录条目复制到打开文件表，open返回一个指向打开文件表中的一个条目的指针，通过这个指针进行所有IO操作，之后对于文件任何操作不需要文件名字，只需要open调用返回的指针。<br>通常OS还用一个文件打开计数器Open Count，记录多少进程打开了该文件，打开计数器为0标识不再使用，系统回收系统资源。若文件被修改过，文件写回外存，并把打开文件表相应条目删除，最后释放文件的文件控制块FCB。<br>每个打开文件都有相关关联信息：<br>①文件指针：文件当前位置的指针，打开文件某个进程是唯一的。<br>②文件打开计数：上文解释过。<br>③文件磁盘位置：绝大数文件操作要求改变文件，该信息保存在内存中，以免每个操作都从磁盘中获取。<br>④访问权限：每个进程打开文件都要有访问模式（创建，只读，读写等），该信息保存在进程打开文件表中，以便OS可以允许/拒绝IO请求。   <h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3></li><li>逻辑结构就是用户观点看到的文件组织形式。物理结构则是实现观点出发看到的文件在外存上的存储组织形式。逻辑结构上，文件划分无结构文件和有结构文件两种：</li><li>无结构文件（流式文件）：<br>最简单的文件组织形式，把数据按照顺序组织成记录并积蓄保存，它是有序相关信息项的集合，以字节为单位。记录访问只能穷举搜索，适用于对基本信息单位操作不多的文件（如源程序文件，目标代码文件等）  </li><li>有结构文件（记录式文件）：<br>按照记录的组织形式可以分为：<br>①顺序文件：记录顺序排列，通常是定长的，可以顺序/链式存储，访问时顺序搜索文件。有两种结构：第一种是串结构：存入时间先后排列。第二种是顺序结构：按照关键字顺序排列。对于记录批量操作时，顺序文件操作效率最高，此外也只有顺序文件才能存在磁带上，但对于单条记录操作就比较困难。<br>②索引文件：对于定长记录文件和可变长记录文件，查找第i条记录地址不一样。变长记录文件只能顺序查找，系统开销大，为此可以建立一张索引表加速检索。  <img src="/2022/052139833/2.jpg" class="">   ③索引顺序文件：顺序和索引两种组织形式结合，把顺序文件所有记录分为若干组，建立一张索引表，表为每组第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。同一组的关键字可以无序，但组索引必须有序，先找到组再顺序查找。  <img src="/2022/052139833/3.jpg" class="">   提高了查找效率，但配置索引表增加了存储空间。<br>④直接文件/散列文件（Hash File）：给定记录的键值/通过散列函数转换的键值直接决定记录的物理地址，没有顺序的特性，有很高的存取速度但有冲突。  <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3></li><li>包含文件信息，这些信息由OS管理。用户角度：目录需要在文件名和文件之间有映射，目录存取效率直接影响系统性能，所以要提高用户检索速度，共享系统中，目录还需要提供用于控制访问文件的信息，重名也是合理的要求，通过树形结构来解决和实现。  </li><li>文件控制块和索引结点：<br>为了实现目录管理，OS引入了文件控制块的数据结构。<br>①文件控制块FCB，用来存放控制文件所需要各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项，创建新文件则分配一个FCB并存放在文件目录中，成为目录项。主要包括：基本信息（名字，物理位置，逻辑结构等），存取控制信息（文件存取权限等），使用信息（创建修改时间等）。<br>②索引结点：检索目录文件过程中，只用到了文件名，仅当找到一个目录项时，才需要从该目录读取其物理地址，也就是其他描述信息没用到，所以有的OS采用文件名和描述分开方法，描述信息单独形成一个称为索引结点的数据结构，在文件目录中每个目录项仅由文件名和指向该文件的所对应i结点的指针构成。存放在磁盘上的索引结点称为磁盘索引结点，UNIX每个文件都由一个唯一的磁盘索引结点，主要包括：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度（以字节为单位），文件链接计数（指向该文件的指针计数），文件存取时间。<br>文件被打开时，磁盘索引结点复制到内存的索引结点以便于使用，在内存索引节点又增加了内容：索引结点编号（标识内存索引结点），状态（结点是否上锁或修改），访问计数，逻辑设备号，链接指针。  </li><li>目录结构：<br>考虑目录层次的操作:搜索，创建文件，删除文件，显示目录，修改目录。考虑以下几种目录结构：<br>①单级目录结构：<br>整个文件系统只有一个目录表，每个文件占一个目录项。  <img src="/2022/052139833/4.jpg" class="">   访问文件，先按照文件名找到对应FCB，创建文件必须检索所有目录项以确保没有重名，删除文件回收存储空间再清楚目录项。单级目录实现了“按名存取”，但速度慢，无重名，不便于用户共享。<br>②两级目录结构：<br>把文件目录分为主文件目录MFD和用户文件目录UFD。  <img src="/2022/052139833/5.jpg" class="">   主文件目录记录用户名和相应文件目录所在存储位置，而用户文件目录记录相应用户文件目录的FCB信息，当用户相对其文件访问时只需要搜索该用户对应的UFD，解决了重名问题，保证安全，但缺乏灵活性，不能对文件分类。<br>③多级目录结构（树形目录结构）：<br>用户访问某个文件，用文件路径名标识文件，用“/”分隔开，从根目录出发的路径为绝对路径。而从当前目录出发到所找文件通路的路径为相对路径。  <img src="/2022/052139833/6.jpg" class="">   很方便对于文件分配，层次清晰，但查找时需要逐次访问中间结点，增加磁盘访问次数，影响速度。<br>④无环图目录结构：<br>树形结构不利于文件共享，所以在树形结构基础上增加指向同一结点的有向边，使得整个目录成为一个有向无环图，为了实现文件共享。  <img src="/2022/052139833/7.jpg" class="">   <h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3>使多个用户共享同一个文件，系统只需要保留一个副本。常用两种方法：  </li><li>基于索引结点的共享方式（硬链接）：<br>在树形结构目录中，当两个或多个用户要共享一个子目录/文件时，必须把共享文件或子目录链接到这些用户目录中，才能方便找到该文件。<br>文件的其他信息都放在索引结点中，而目录中只有文件名和指向相应索引节点的指针，索引节点还有count来计数链接到本索引结点的用户目录项数。  <img src="/2022/052139833/8.jpg" class="">   </li><li>利用符号链实现文件共享（软链接）：<br>系统创建一个LINK类型的新文件，写入共享用户B的目录中，实现B的目录与文件F的链接，新文件中只包含被链接文件的路径名，这种方法称为符号链接。新文件中的路径名视为符号链，根据路径名读取文件，从而实现对文件的共享。<br>在利用符号链方式实现文件共享时，只有文件拥有者才拥有指向其索引节点的指针，而共享该文件的其他用户只有该文件的路径名。但仍然有一点问题，删除该文件且再次创建一样文件，软链接仍然有效。有个优点就是网络共享只需要提供该文件所在及其的网络地址及该及其中的文件路径。  <h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读，写，执行的许可问题，为此必须在文件系统中建立相应的文件保护机制。文件保护通过口令保护，加密保护，访问控制等方式实现，其中口令和加密为了防止用户文件被他人存取或窃取，而访问控制用于控制用户对于文件访问方式。  </li><li>访问类型：<br>读，写，执行（文件装入内存并执行），添加，删除，列表清单（列出文件名和属性），还有其他高级操作（通过掉哟个底层系统调用来实现）。</li><li>访问控制：<br>最常用方法就是根据用户身份进行控制，为每个文件增加一个访问控制列表ACL，以规定每个用户名及其所允许的访问类型，精简的访问列表有：拥有者（创建文件用户），组（一组内需要共享文件且具有类似访问的用户），其他（系统内的所有其他用户）。用三个域列出访问表三类用户访问权限。<br>口令和密码时另外两种访问控制：<br>①口令指用户建立一个文件时提供一个口令，系统为其建立FCB时附上口令，且告诉共享文件的其他用户，用户请求访问时必须提供相应口令，缺点是口令存在系统内部不安全。<br>②密码则是对文件加密，访问需要密钥，保密性强但编码和译码需要花费时间。<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3>现代OS有很多种文件系统类型，因此文件系统层次结构也不尽相同。  <img src="/2022/052139833/9.jpg" class="">   </li><li>用户调用接口：<br>文件系统为用户提供与文件及目录有关的调用。此层由若干程序模块组成，每个模块对应一条系统调用，用户发出一条调用，控制即转入相应的模块。  </li><li>文件目录系统：<br>管理文件目录，任务有管理活跃文件目录表，管理读写状态信息表，打开文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块。  </li><li>存取控制验证模块：<br>实现文件保护主要由该级软件完成，把用户访问和FCB中访问控制权限进行比较，确认合法性。  </li><li>逻辑文件系统和文件信息缓冲区：<br>根据文件逻辑把用户读写的记录转换成文件逻辑结构内相应块号。  </li><li>物理文件系统：<br>把逻辑记录所在的相对块号转换成实际物理地址。  </li><li>辅助分配模块：<br>管理辅存空间。  </li><li>设备管理程序模块：<br>分配设备，分配设备读写缓冲区，磁盘调度，启动设备，处理设备中断等。  <img src="/2022/052139833/10.jpg" class="">   <h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3>常用基本方法是线性列表和哈希表两种，目录实现的目的就是为了查找，因此对应线性查找和哈希查找。查询通过磁盘反复搜索完成的，开销大，复制进内存降低磁盘操作次数，提高系统速度。    </li><li>线性列表：<br>使用存储文件名和数据块指针的线性表。  </li><li>哈希表：<br>根据文件名得到值，返回一个指向线性列表中元素的指针。  <h3 id="文件实现——文件分配方式"><a href="#文件实现——文件分配方式" class="headerlink" title="文件实现——文件分配方式"></a>文件实现——文件分配方式</h3>文件分配对应文件的物理结构，如何为文件分配磁盘块，常见分配有连续分配，链接分配，索引分配。文件分配方式——对于磁盘非空闲块的管理。</li><li>连续分配：<br>要求每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序，这种排序使得作业访问磁盘需要的寻道数和时间最小。一个文件目录条目包括开始的块的地址和长度。连续分配支持顺序访问和直接访问，优点就是实现简单，存取速度快，缺点就是文件长度不宜动态增加，反复增删产生外部碎片。  <img src="/2022/052139833/11.jpg" class="">   </li><li>链接分配：<br>离散分配的方式，消除外部碎片，增删改查方便，分为隐式链接和显式链接两种形式：<br>①隐式链接：<br>每个文件对应一个磁盘块链表，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的，目录包括文件的第一块指针和最后一块指针。创建新文件时，目录中增加一个新条目，每个目录项都有指向文件首块的指针，该指针初始化为NULL以表示空文件，写文件会同空闲空间管理系统找到空闲块，把该块链接到文件尾部，读文件则通过块间指针顺序读块。缺点就是无法直接访问，只能顺序访问，且软件/硬件错误导致指针丢失也会使得数据丢失。  <img src="/2022/052139833/12.jpg" class="">   ②显式链接指把用于连接文件各物理块的指针，从物理块末尾提取出来放在链接表中，仅一张称为文件分配表FAT，每个表项存放对应块的下一块指针，即下一个块号，第一个块号存在目录中，后续通过FAT查找得到。用-1表示文件最后一块，-2表示这个磁盘块是空闲的。因此FAT不仅记录了文件各块先后关系，还标记了空闲磁盘块。FAT在系统启动的时候就被读入内存，因此查找FAT是在内存中进行的，不仅显著提高了检索速度，而且减少了访问磁盘次数。  <img src="/2022/052139833/13.jpg" class="">   </li><li>索引分配：<br>链接分配不能解决直接访问，而索引分配解决了这个问题，它把每个文件所有盘块号都集中放在一起形成索引块。每个文件都由其索引块，这是一个磁盘块地址的数组，目录条目包括索引块的地址，第i块就是第i个条目的指针来查找和读入所需的块。创建文件时，所有索引块的指针都设置为空，首次写入第i块时需要从空闲空间中取得一个块，然后把其地址写入索引块的第i个条目。    <img src="/2022/052139833/14.jpg" class="">   索引块大小很重要，每个文件必须有一个索引块，尽可能小，但太小无法支持大文件，采用以下机制解决问题：<br>①链接方案：多个索引块链接起来处理大文件。<br>②多层索引：第一层索引指向第二次，以此类推。<br>③混合索引：多种索引分配方式结合的分配方式</li><li>三种文件分配方式比较：  <img src="/2022/052139833/15.jpg" class="">   <h3 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h3></li><li>文件存储器空间的划分与初始化：<br>一般来说，一个文件存储在一个文件卷中，文件卷可以是物理盘一部分，也可以是整个物理盘。一个文件卷中，文件数据信息的空间和存放文件控制信息FCB的空间时分离的。  <img src="/2022/052139833/16.jpg" class="">   </li><li>文件存储器空间管理：<br>文件存储设备分成大小相同的物理块，并以块为单位交换信息，因此文件存储设备的管理实质上是对空闲块的组织和管理，包括空闲块的组织，分配，回收等问题。  </li><li>空闲表法：<br>连续分配方式，为每个文件分配一块连续的内存空间，系统为外存的所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，包括表项序号，该空闲区第一个盘块好，块数等信息，再递增排列。空闲盘区的分配和内存动态分配类似，同样采用首次适应算法/循环首次适应算法等。系统对用户释放的存储空间进行回收时，也采取类似用于内存回收的方法，考虑回收区是否和空闲表中插入点的前区和后区相邻接，对相邻接者予以合并。    <img src="/2022/052139833/17.jpg" class="">   </li><li>空闲链表法：<br>所有空闲盘区拉成一条空闲链，根据构成链所有基本元素不同，分为两种形式：空闲盘块链和空闲盘区链。<br>①空闲盘块链：把磁盘上所有空闲空间以盘块为单位拉成一条链，当用户因为创建文件而请求分配存储空间时，从链首开始一次摘下合适数目空闲盘块分配给用户，删除则把回收盘块放在链末尾。<br>②空闲盘区链：把磁盘上所有空闲空间以盘区为单位拉成一条链，盘区含有指向下一个盘区指针和盘区大小信息，分配和内存动态分配一样，采用首次适应算法，回收时也是把回收区和相邻接的空闲盘区合并。  </li><li>位示图法：<br>利用二进制的一位表示磁盘中的一个盘块的使用情况，0表示空闲，1表示已分配。分配和回收只需要修改二位数组的1/0即可。  <img src="/2022/052139833/18.jpg" class="">   </li><li>成组链接法：<br>UNIX使用，结合空闲表和空闲链表，克服表太大的缺点。思想:顺序的n个空扇区地址保存在第一个空扇区中，其后一个空闲扇区则保存另一个顺序空闲扇区的地址，之后一个空闲扇区内则保存另一个顺序空闲扇区的地址，如此继续，直到所有空闲扇区链接完成。  <img src="/2022/052139833/19.jpg" class="">   <h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><img src="/2022/052139833/20.jpg" class="">   <h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3>一次磁盘读写操作时间由寻道时间，旋转延迟时间，传输时间决定。  </li><li>寻道时间，活动头磁盘读信息之前，把磁头移动到指定磁道所需要的时间，这个时间除了跨越n条道的时间外，还包括启动磁臂的时间。  </li><li>旋转延迟时间，磁头定位到某磁道的扇区需要时间，设磁盘旋转速度为r，则t=1/2r。  </li><li>传输时间，从磁盘读出或向磁盘写入数据经历的时间，取决于每次读写字节数b和磁盘旋转速度t=b/rN。<br>其中寻道时间和磁盘调度算法相关，而其他都与磁盘旋转速度有关。以下几种磁盘调度算法：  </li><li>先来先服务FCFS：<br>按照先后顺序进行访问磁盘调度。  </li><li>最短寻找时间优先算法SSTF：<br>与当前磁道最近的磁道优先调度，但会产生“饥饿现象”。  </li><li>扫描算法SCAN：<br>在当前移动方向上寻找与当前磁头最近的对象，就是SSTF基础上规定了磁头运动方向。  </li><li>循环扫描算法C-SCAN：<br>扫描算法基础上规定磁头单项移动来提供服务，返回直接快速移动到起始端而不服务请求。</li><li>LOOK算法：<br>扫描算法就是磁头严格一个方向从一端到另一端，而改进之后磁头移动只需要到达最远端而不需要到达磁盘端点，这就是LOOK算法。（默认SCAN为LOOK算法）</li><li>C-LOOK算法：<br>对应C-SCAN类似，到达最远端点之后直接移动到起始端点而不提供服务请求。（默认C-SCAN为C-LOOK算法）</li><li>算法比较：  <img src="/2022/052139833/21.jpg" class="">   <h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3></li><li>磁盘初始化：<br>磁盘存储数据之前，必须分成扇区以便磁盘控制器能进行读和写的操作，这个过程称为低级格式化。低级格式化为磁盘的每个扇区采用特别的数据结构，每个扇区的数据结构通常由头，数据区域，尾部组成。为了使得磁盘存储文件，OS还需要把自己的数据结构记录在磁盘上，第一步把磁盘分为由一个或多个柱面组成的分区（C盘，D盘等），第二部对物理分区进行逻辑格式化（创建文件系统），OS把初始文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配空间及一个初始为空的目录。  </li><li>引导块：计算机启动时运行初始化程序，初始化各类资源等，接着就启动OS。引导的这个自举程序的磁盘围殴启动磁盘/系统磁盘。    </li><li>坏块：硬件故障，OS处理不了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理</title>
      <link href="/2022/05198490.html"/>
      <url>/2022/05198490.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="/2022/05198490/1.jpg" class="">   <h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><ul><li>尽管内存不断增大，但仍然不可能把所有用户进程和系统所需要的全部程序与数据放入主存，因此OS必须对内存空间进行合理划分和有效动态分配。定义：OS对内存的划分和动态分配。  </li><li>功能有：<br>①内存空间的分配和回收：OS完成主存空间分配和管理，使人工不负责分配。<br>②地址转换：把程序逻辑地址转换为物理地址。<br>③内存空间的扩充：利用虚拟存储技术/自动覆盖技术，逻辑上扩充内存。<br>④存储保护：保证各作业在各自内存空间内运行，互不干扰。  </li><li>在具体内存管理之前，首先要了解进程运行基本原理和要求：<br>①程序装入和链接：<br>创建进程首先要将程序和数据装入内存，把用户源程序变成内存中执行程序：<br>Ⅰ编译：编译程序把用户源代码编译成若干目标模块。<br>Ⅱ链接：链接程序把编译好的一组目标模块以及所需要的库函数链接在一起，形成一个完整装入模块。<br>Ⅲ装入：装入程序将装入模块装入内存中。   <img src="/2022/05198490/2.jpg" class="">   程序链接有三种方式：<br>Ⅰ静态链接：程序运行之前，各模块及所需库函数链接成一个完整可执行程序，不再拆开。<br>Ⅱ装入时动态链接：把用户源程序编译后得到一组目标模块，装入时采用边装边链接。<br>Ⅱ运行时动态链接：对于某些目标模块的链接是在程序执行中需要该目标模块时才进行的，优点就是便于修改更新，便于实现对于目标模块的共享。<br>内存的装入也有三种方式：<br>Ⅰ绝对装入：编译时若知道程序所留内存位置，则编译程序之间产生绝对地址目标代码，装入模块中地址，且程序中逻辑地址和实际地址完全相同，因此不需要对于程序和数据的地址进行修改。绝对装入方式只适合于单道程序环境，<br>Ⅱ可重定位装入：多道程序环境下，多个目标模块的起始地址通常从0开始，程序中的其他地址都是相对于起始地址的，此时应该采用可重定位装入方式，根据内存当前情况装入适当位置，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成，又称静态重定位，特点就是一个作业装入内存时必须有所需全部内存空间，否则不能装入该作业，一旦进入内存，整个运行期间不能移动，也不能再申请内存空间。<br>Ⅲ动态运行时装入：也是动态重定位，程序在内存中若发生移动，则需要采用动态装入方式，装入内存后不立马把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行，因此钻杆如内存后所有地址为相对地址，需要要一个重定位寄存器支持。特点：可以把程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。   <img src="/2022/05198490/3.jpg" class="">   ②逻辑地址空间与物理地址空间：<br>编译后，每个目标模块都从0开始编址，称为该目标模块的相对地址（逻辑地址），当链接程序链接成一个完整可执行程序时，链接程序顺序依次按照各个模块的相对地址构成统一的0号单元开始编址的逻辑地址空间。<br>而物理地址空间指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后通过物理地址从主存中获取，当装入程序将可执行代码装入内存时必须把逻辑地址转换为物理地址，这个过程称为重定位。<br>③内存保护：<br>内存分配前，保护OS不受用户进程影响，同时保护用户进程不受其他进程影响：<br>Ⅰ在CPU中设置上，下限寄存器，存放用户作业在主存中的上下限地址，每当CPU访问地址分别和上下限对比，判断是否越界。<br>Ⅱ采用重定位寄存器和界地址实现保护：重定位寄存器含最小物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。  <img src="/2022/05198490/4.jpg" class="">   <h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3>多道程序环境下扩充内存的两种方法。</li><li>覆盖：由于程序运行时不是任何时候都需要访问程序和数据各个部分，所以把用户空间分成一个固定区和若干覆盖区，活跃部分放在固定区，其余部分按照调用关系进行分段，把即将访问的段放入覆盖区，其他段放入外存，需要调用再调入覆盖区，替换覆盖区中原有段。<br>特点就是打破了全部信息装入内存后才能运行的限制，但同时运行代码大于主存的时候仍然不能运行，此外内存更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。    </li><li>交换：把处于等待状态的程序从内存转到辅存，把内存空间腾出来，称为换出。把准备竞争CPU运行的程序从辅存移动到内存，这一过程又称为换入。（中级调度就是交换技术）<br>特点就是主要在不同进程之间进行，而覆盖是同一个进程中。  <h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3></li><li>指为一个用户程序分配一个连续的内存空间，包括单一连续分配和固定分区分配和动态分区分配。  </li><li>单一连续分配：系统分为系统区和用户区，系统区仅仅让OS使用，通常在低地址部分。这种方式无须内存保护，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。优点就是简单，无外部碎片，可以用覆盖技术。缺点是只用于单道程序系统。  </li><li>固定分区分配：最简单的多道程序存储管理方式，把用户内存空间划分为若干固定大小区域，每个分区只装入一道作业，当有空闲分区时便可以再从后备作业队列选择适当大小作业装入分区，而划分分区还有两种方法：①分区大小相等②分区大小不等（多个小分区，适量中分区，少量大分区）<br>为了便于内存分配，通常按分区大小排队，建立分区说明表（包括每个分区起始地址，大小，状态是否分配）  <img src="/2022/05198490/5.jpg" class="">   问题：程序可能大到任何分区装不下。且主存利用率低，当程序小于固定分区大小的时候也浪费了分区空间（称为内部碎片）。</li><li>动态分区分配：进程装入内存时根据内存大小动态建立分区，使得分区大小合适进程。分区的大小和数目都是可变的。开始分配时是好的，但随着分配进行会产生若干小的内存块，这些小的内存块称为外部碎片，为了克服外部碎片通过“紧凑”技术来解决（OS对于进程的移动和整理）<br>首次进程装入主存，OS确定分配哪个内存块给进程使用，分配策略算法：<br>①首次适应算法（First Fit）：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到第一个大小满足要求的第一个空闲分区。<br>②最佳适应算法（Best Fit）：空闲分区按照容量递增形成分区链，找到第一个满足要求的空闲分区。<br>③最坏适应算法（Worst Fit）：空闲分区按照容量递减形成分区链，找到第一个满足要求的空闲分区。<br>④邻近适应算法（Next Fit）：由首次适应算法演变而来，分配内存时从上次查找结束的位置开始继续查找。  <img src="/2022/05198490/6.jpg" class="">   <h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3></li><li>允许一个程序分散装入不相邻的内存区，也根据分区大小是否固定，分为分页存储管理方式和分段存储管理方式。</li><li>分页存储模式又根据运行作业时是否把作业所有页面都撞入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式，只介绍基本分页存储管理方式。<br>①基本分页存储管理方式：<br>固定分区产生内部碎片，动态分区产生外部碎片，内存利用率都比较低。为了避免碎片产生，引入分页思想：把主存空间划分为大小相等且固定的块，作为主存的基本单位，进程也以块为单位进行划分，进程在执行以块为基本单位逐个申请主存中的块空间。<br>类似于固定分区，但本质不同：块大小比分区小很多，而且进程也按照块进行划分，所以即使有内部碎片也是很小的（页内碎片）。</li></ul><p>–几个基本概念：<br>Ⅰ页面和页面大小：进程中的块称为“页”，内存中的块称为“页帧Page Frame”。外存也以同样的单位进行划分，直接称为块Block，进程执行需要申请主存空间，即要为每个页面分配主存中可用页帧，产生了页和页帧的一一对应。为了方便地址转换，页面大小应该是2的整数幂，大小适中。页面太小会使得进程页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面转入转出的效率。页面过大又会使页内碎片增多，降低内存利用率，所以大小应该适中，要在空间效率和时间效率间抉择。<br>Ⅱ地址结构：页号P和页内偏移量W。地址长度为32位，0-11为页内地址，每页大小为4KB，12-31位为页号，地址空间最多允许2的20次方页。<br>Ⅲ页表：为了便于内存中查找进程每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般放在内存中。页表由页表项组成的，第一部分是页号，第二部分与地址结构的第二部分共同组成物理地址。配置页表之后，进程执行时，通过查找该表，找到每页在内存中的物理块号。  </p><img src="/2022/05198490/9.jpg" class="">   <p>–基本地址变换结构：<br>地址变换机构的任务是将逻辑地址转换为内存中的物理地址，地址变换是借助页表实现的。  </p><img src="/2022/05198490/7.jpg" class="">   <p>每次访问存储操作都需要从逻辑地址到物理地址，转换地址过程必须足够快，否则访问速度会降低。每个进程引入页表，用户存储映射机制，页表不能太大否则内存利用率降低。<br>–具有快表的地址变换结构：<br>若页表全部放在内存中，存取一个数据/指令至少访问两次内存，第一次是访问页表获取物理地址，第二次是存取数据/指令，显然比通常执行指令慢了一半。<br>为此增设了一个并行查找能力的告诉缓冲存储器——快表，又称TLB，用来存放当前访问的若干页表项，加速地址变化的过程，而主存中的页表常称为慢表。  </p><img src="/2022/05198490/8.jpg" class="">   <p>–两级页表：<br>逻辑结构是一级页号+二级页号+页内偏移。为了压缩页表，进一步延申页表映射的思想。<br>②基本分段存储管理方式：<br>分页管理目的为了提高内存利用率，通过硬件实现。而分段提出考虑了用户和程序员，满足方便编程，信息保护和共享，动态增长，等多方面需要。<br>Ⅰ分段：按照用户进程中的自然段划分逻辑空间。每段从0开始编址，并且分配一段连续的地址空间，其逻辑地址由段号S和段内偏移量W两部分组成。段号16为，偏移量16位，一个作业最多2的16次方=65536段，最大段长为64KB。（页系统的S和W对于用户透明，而端系统则是由用户提供的）  </p><img src="/2022/05198490/10.jpg" class="">   <p>Ⅱ段表：每个进程都有一个逻辑空间与内存空间映射的段表。  </p><img src="/2022/05198490/11.jpg" class="">   <p>配置表之后，执行中的进程可以通过查找段表，找到每段所对应的内存区。  </p><img src="/2022/05198490/12.jpg" class="">   <p>Ⅲ地址变换机构：实现进程从逻辑地址到物理地址的变换功能，再系统设置了段表寄存器，用于存放段表起始位置F和段表长度M。   </p><img src="/2022/05198490/13.jpg" class="">   <p>Ⅳ段的共享和保护：通过两个作业的段表中响应表项指向被共享的段的同一个物理副本来实现的，不能修改的数据和代码可以共享。<br>③段页式管理方式：<br>作业地址空间首先分成若干逻辑段，每段都有自己段号，段分成若干大小固定的页，内存仍然分成和页面大小相同的块。   </p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><ul><li>传统存储方式特征：①一次性：作业一次性装入内存，才可以运行，但如果作业大无法装入，且大量作业同时运行无法满足只能少部分作业先运行，多道程序度降低。②驻留性：作业装入之后不换出 ，可能长期等待状态。  </li><li>局部性原理：高速缓存依赖的就是局部性原理，有两方面：①时间局部性：程序中指令和数据可能大量循环执行。②空间局部性：程序访问某个存储单元，不久之后附近的存储单元也将被访问，即程序一段时间内访问的地址可能是集中在一定范围内。<br>时间局部性通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存层次结构实现。空间局部性通常使用较大的高速缓存，并把预处理机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器机构，利用局部性原理实现高速缓存。  </li><li>虚拟存储器的定义和特征：<br>基于局部性原理，程序装入时，把程序的一部分装入内存，其余部分留在外存，就可以启动程序运行。在程序执行过程中，当所访问信息不在内存时，由OS将所需的部分调入内存继续执行程序，OS把不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这时系统好像为用户提供了一个比实际内存大得多的存储器称为虚拟存储器。<br>只是由于系统提供了部分装入，请求调出和置换功能之后，给用户感觉像存在一个比实际内存大得多的存储器。大小由计算机地址结构决定，并不是内存+外存，特征有：①多次性：作业无须一次性全部装入内存，允许多次调入内存运行。②对换性：作业无须一直等待在内存中， 允许换进换出。③虚拟性：逻辑上扩充内存容量。  </li><li>虚拟内存技术实现：<br>允许一个作业多次调入内存，所以采用连续分配方式时使得相当一部分内存处于空闲，所以需要建立在离散分配的内存管理方式的基础上。有三种方式：请求分页存储管理，请求分段存储管理，请求段页式存储管理。<br>但无论哪种方式都需要硬件支持：一定容量内存和外存，页表机制，中断机构，地址变换机构。<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3></li><li>建立在基本分页系统基础上，为了支持虚拟存储区功能而增加了“请求调页”和“页面置换”功能，也是最常用的方法。请求分页管理方式中：只要求让当前需要的一部分页面装入内存便可开始运行作业，当访问页面内存中不存在时，再通过调页功能将其调入，同时还可以通过页置换功能把暂时不用的页面换出到外存，腾出内存空间。  </li><li>页表机制：  <img src="/2022/05198490/14.jpg" class="">  比基本分页管理中页表项多个4个字段：<br>①状态位P：用于指示该页是已经调入内存。<br>②访问字段A：记录本页一段时间内被访问次数（页置换时使用）。<br>③修改位M：标识该页调入内存中是否被修改过。<br>④外存地址：该页外存上的地址，通常是物理块号。  </li><li>缺页中断机构：<br>访问页面不在内存中，便产生缺页中断，请求操作系统把所缺少的页调入内存，此时应该把缺页的进程阻塞，若内存有空闲块，则分配一个块，把调入的页传入该块，并修改页表中相应页表项，无空闲块则要淘汰某页（淘汰的页如果修改过则要写回外存）。<br>缺页中断作为中断，同样经历中断的几个步骤，但有两个明显区别：①在指令执行期间而非之后产生和处理中断信号，属于内部中断。②一条指令执行期间，可能产生多次缺页中断。  </li><li>地址变换机构：<br>是在分页系统地址变换机构的基础上，为实现虚拟内存，增加了某些功能而形成的。地址变换时，先检索快表。  <img src="/2022/05198490/15.jpg" class="">   <h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3></li><li>进程运行访问页面不在内存中而需要把它调入，但内存已无空闲空间，就需要从内存中调出一页程序或数据送入磁盘的对换区。选择调出的页面算法就是页置换算法，好的页置换算法应该有较低的页面置换频率。   </li><li>最佳置换算法OPT：<br>选择淘汰的页面是以后永不使用的页面，或是在最长时间内不再访问的页面，以保证最低的缺页率（但未知进程下不知道哪个是最长不被访问的，所以无法实现），但可以用作评价其他置换算法。  <img src="/2022/05198490/16.jpg" class="">   </li><li>先进先出页面置换算法FIFO：<br>优先淘汰先进入内存的页面，即留在内存最长时间的页面，但算法跟实际运行规律不符。而且FIFO算法还会产生所分配的物理块增大而页故障数不减反增的异常现象（Belady异常），而LRU和OPT算法不会出现Belady异常。  <img src="/2022/05198490/17.jpg" class="">   </li><li>最近最久未使用置换算法LRU：<br>选择最长时间为访问过的页面淘汰，过去时间未访问过的页面将来也不会访问。OPT是向后看，而LRU是向前看。LRU性能较好。   <img src="/2022/05198490/18.jpg" class="">   </li><li>时钟置换算法CLOCK：<br>LRU实现困难，开销大，且性能接近OPT。因此试图使用较小的开销但性能接近LRU的算法，都是CLOCK的变体。简单CLOCK算法给每帧关联一个附加位，称为使用位。当该页首次装入主存，使用位为1，随后再次被访问到时也为1。用于替换的候选帧集合视为一个循环缓冲区，并有一个指针与之关联，当某页被替换时该指针被设置指向缓冲区的下一帧，当需要替换一页时，OS把该位重新置为0。若开始过程时，缓冲区所有帧为0，则选择遇到第一个帧替换，若全为1，则指针在缓冲区完整循环一周，把所有使用位置为0，并停留在最初的位置，替换该帧的页，又称为最近未用算法(NRU)。<br>通过增加使用位数目，可以使得CLOCK算法更高效，再增加一个修改位，得到改进型CLOCK置换算法，则出现四种情况：<br>①最近未被访问，也未被修改（u=0，m=0）<br>②最近被访问，但也未被修改（u=1，m=0）<br>③最近未被访问，但被修改（u=0，m=1）<br>④最近被访问，也被修改（u=1，m=1）<br>算法步骤如下：<br>①指针从当前位置开始，扫描帧缓冲区，对使用位不作任何修改，选择遇到的第一个帧（u=0，m=0）用于替换。<br>②若①失败，则重新扫描，查找（u=0，m=1）的帧，选择第一个这样的帧替换，对于每个跳过的帧，使用位都设置为0.<br>③若②失败，则指针回到最初位置，且集合中所有帧使用位为0，重复①，若有必要重复②。  <h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3></li><li>驻留集大小：<br>对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程所有页读入主存，因此OS决定读取多少页，即决定给特定的进程分配几个页框，就是这个进程的驻留集，考虑以下几点：<br>①分配给一个进程存储量越小，任何时候驻留在主存中的进程数越多，提高处理机时间利用率。<br>②一个进程主存中页数过少，则尽管有局部性原理，但页错误率仍然较高。<br>③页数过多，则局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显影响。<br>基于这些因素，OS常采用三种策略：<br>①固定分配局部置换：物理块数量固定，数目不好确定，太少频繁缺页中断，太多资源利用率下降。<br>②可变分配全局置换：易实现，进程分配一定物理块，OS内也有空间物理块，发生缺页就去拿一个物理块给进程，并调页进其中，更加灵活。但盲目加物理块导致多道程序并发能力下降。<br>③可变分配局部置换：从该进程在内存的页面中选出一页换出，频繁换页则分配物理块，若缺页率低则减少物理块。不仅动态增加，还能减少，保证系统均衡。  </li><li>调入页面时机：<br>两种策略：<br>①预调页策略：根据局部性定理，一次调入若干页可能比逐次搞笑，但调入很多未访问则是低效。所以预测为基础的预调页策略，预计不久之后被访问的页面预先调入内存。<br>②请求调页策略：进程运行中需要请求调页。缺点就是一次只能调一页。<br>实际上预调页就是运行前调入，请求调页就是运行期间调入，一般两种策略同时使用。  </li><li>从何处调入页面：<br>请求分页系统中的外存分为两部分：用于存放文件的文件去和用于存放兑换页面的对换区。对换区常用连续分配方式，文件区用离散分配方式，因此对换区IO速度比文件区更快，有三种情况：<br>①系统拥有足够对换区空间：可以全部从对换区调入页面，提高调页速度，所以进程运行前把所有的所需文件从文件区复制到对换区。<br>②系统缺少足够对换区空间：凡是不会被修改的文件都直接从文件区调入，修改的部分需要调入对换区，再从对换区调入内存。<br>③UNIX方式：与进程有关文件都放在文件区，因此未运行过的页面都在文件区调入，曾经运行过的放在对换区，因此下次调入时应从对换区调入。  <h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3>页面置换时一种最糟糕情形是刚刚换出页面马上换入主存，频繁的页面调入行为就是抖动/颠簸，若一个进程在换页时间多于执行时间，则这个进程就在颠簸。主要原因就是，某个进程频繁访问的页面数目高于可用的物理页帧数。  <h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3>指某段时间间隔内，进程要访问的页面集合，可用最近访问过的页面确定工作集。一般说，工作集W可由时间t和工作窗口大小来确定。   <img src="/2022/05198490/19.jpg" class="">   <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/05198490/20.jpg" class=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程管理</title>
      <link href="/2022/051437005.html"/>
      <url>/2022/051437005.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><img src="/2022/051437005/1.jpg" class="">  <h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><ul><li>进程的概念：多道程序环境下，允许多个程序并发执行，此时他们失去封闭性，并且具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</li><li>为了使参与并发执行的程序能独立运行，必须为之配备一个专门的数据结构称为进程控制块PCB，描述进程的基本情况和运行状态，进而控制和管理进程，由程序段，相关数据段和PCB三部分组成了进程映像。所谓创建进程，实质上是创建进程映像中的PCB，而撤销进程实际上也是撤销PCB，即PCB是进程存在的唯一标志。</li><li>定义：进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个单位。就是“时间片”分配的独立单位。</li><li>特征：进程是由多道程序的并发执行引出的，它和程序完全不同：<br>①动态性：进程是程序的一次执行，有着创建，活动，暂停，终止等过程，有生命周期，动态性是其最基本特征。<br>②并发性：指多个进程同时存在内存中，可以同时运行。<br>③独立性：指进程实体是一个能够独立运行，获得资源和接收调度的基本单位，必须有PCB。<br>④异步性：由于进程相互制约，进程具有执行的间断性，即按照各自独立不可预知的速度前进，异步性导致结果不可再现性，为此必须配置相应的进程同步性。<br>⑤结构性：每个进程都配置一个PCB进行描述，结构上看进程实体由程序段，数据段，PCB组成。  <h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3></li><li>进程动态性，环境动态性，通常5种状态：<br>①运行态：正在运行单处理机环境下，只有一个进程处于运行状态。<br>②就绪态：进程已经获得了除处理机外所有资源，一旦得到处理机可以立即执行，通常有多个就绪进程为就绪队列。<br>③阻塞态/等待态：进程等待某个事件，即使处理机空闲也无法执行。<br>④创建态：正在被创建：首先申请PCB，向PCB填写一些控制和管理进程的信息，然后由系统为该进程分配运行时必要资源，最后把该进程转成就绪态。<br>⑤结束态：进程正在消失，可能是进程正常结束或其他原因中断退出运行。先置为结束态再释放资源和回收等工作。</li><li>五种状态转换：<br>①就绪态-&gt;运行态：就绪态进程被调度指挥，获得处理机资源进入运行态。<br>②运行态-&gt;就绪态：时间片用完了，让出处理机转为就绪态，还有可能是更高优先级的进程就绪的时候抢占处理机。<br>③运行态-&gt;阻塞态：进程请求某资源的使用和分配或等待某事件发生时，从运行态变为阻塞态。<br>④阻塞态-&gt;就绪态：进程等待的事件到来，只等处理机了。  <img src="/2022/051437005/2.jpg" class="">  <h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3></li><li>主要功能就是对系统中所有进程有效管理，具有创建，撤销，状态转换等功能。一般进程控制的程序段称为原语，特点就是原子性，不可分割的基本单位。  </li><li>进程创建：<br>允许一个进程创建另一个，父子进程。子进程继承父进程的资源，撤销时归还给父进程，撤销父进程时撤销所有子进程。过程：<br>①为新进程分配一个唯一进程标识号，申请空白PCB。PCB申请失败则创建失败。<br>②为进程分配资源，必要的内存，若资源不足，进程进入阻塞态等待内存资源。<br>③初始化PCB，包括初始化标志信息，初始化处理机状态信息，控制信息，进程优先级等。<br>④若进程就绪队列能够接纳新进程，就插入就绪队列等待被调度运行。  </li><li>进程终止：<br>引起终止的事件有：①正常结束。②异常结束（非法指令，运行超时，IO故障）。③外界干扰（外界请求终止，人工干预/父进程撤销等），过程：<br>①根据进程标识符，检索PCB，读出进程状态。<br>②若处于执行状态，立即终止，把资源分配给其他进程。<br>③若有子孙进程，全部终止。<br>④把所有资源，归还给父进程或OS。<br>⑤把PCB删除。  </li><li>进程阻塞和唤醒：<br>阻塞（主动）就是运行态中等待某事件发生，调用原语Block，过程：<br>①找到进程标识号和PCB。<br>②若执行态则保护现场，转为阻塞态。<br>③把该PCB插入相应事件的等待队列，把处理机分配给其他进程。<br>等待事件发生，调用原语Awake，过程：<br>①找到进程标识号和PCB。<br>②从等待队列移除，变为就绪态。<br>③把该PCB插入就绪队列，等待调度程序调度。  </li><li>进程切换：<br>处理机从一个进程运行转到另一个进程运行，过程：<br>①保存处理机上下文，包括程序计数器和其他寄存器。<br>②更新PCB信息。<br>③把进程的PCB移入相应队列，如就绪队列，等待队列等。<br>④选择另一个进程执行，更新其PCB。<br>⑤更新内存管理的数据结构。<br>⑥恢复处理机上下文。<h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3></li><li>PCB：进程存在唯一标志，通过PCB管理控制进程。  <img src="/2022/051437005/3.jpg" class="">  ①进程描述信息：进程标识符（标识各个进程，唯一），用户标识符（标识进程归属用户）<br>②进程控制和管理信息：进程当前状态（状态信息，作为分配调度的依据），进程优先级。<br>③资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的IO设备信息。<br>④处理机相关信息：主要处理处理机中各寄存器值，当进程切换时，处理机状态信息必须保存在PCB中，重新执行可以从断点继续执行。  </li><li>程序段：能够被进程调度程序调度到CPU执行的程序代码段，多个程序可能有同一个代码段。  </li><li>数据段：可以是进程对应程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。  <h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3>高级通信方法有三类：共享存储，消息传递，管道通信。  <h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3></li><li>线程的基本概念：<br>引入进程目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。而引入线程的目的是减小程序在并发执行时所付出的时空开销，提高OS的并发性能。线程最直接的理解就是轻量级“进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID，程序计数器，寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调用和分派的基本单位，线程自己不具有系统资源，只拥有一点运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程中的全部资源，一个线程可以创建/撤销另一个线程，也可以并发执行，也有三种状态：就绪，阻塞和运行。引入线程之后，进程只作为CPU之外系统资源分配单元，而线程是处理机分配单元，由于一个进程内部多个线程，则线程切换开销小。    </li><li>比较：<br>①调度：线程是独立调度的基本单位，进程是拥有资源的基本单位。<br>②拥有资源：进程是拥有资源的基本单位，而线程没有，但可以访问隶属进程的资源，提出线程就是为了切换线程时开销小，否则没有意义。<br>③并发性：进程线程均可以并发执行，使得操作系统更好的并发性，提高系统吞吐量。<br>④系统开销：由于进程增删，系统都要分配回收资源，开销远大于线程增删。进程切换的时候，涉及当前执行进程的CPU环境保存和新调度进程CPU环境读取，线程切换只需要保存和设置少量寄存器内容，开销很小。且线程同步与通信很容易实现。<br>⑤地址空间和其他资源：进程的地址空间相互独立，而同一个进程内线程共享。<br>⑥通信方面：进程之间通过线程同步和互斥手段辅助，而线程之间读写进入程序数据段来通信。  </li><li>线程的属性：<br>多线程OS把线程作为独立运行的基本单位，此时进程不是基本可执行实体，但仍然具有执行状态，所谓的“执行”状态，就是其中线程在执行，线程主要属性如下：<br>①线程是一个情形实体，不拥有系统资源，但每个线程有唯一标识符和线程控制块（记录线程执行的寄存器和栈等现场状态）<br>②不同线程可以窒息感相同程序，即同一个程序不同用户调用也是不同线程。<br>③同一个进程中各个线程资源共享。<br>④线程是处理机的独立调度基本单位，多个线程可以并发执行。<br>⑤线程创建之后开启生命周期，直至终结。  </li><li>线程的实现方式：<br>两类实现方式用户级线程（ULT），内核级线程（KLT）。<br>①用户级线程：有关线程管理的工作都应用程序完成，内核意识不到线程存在，应用程序可以通过使用线程库设计成多线程程序，通常应用程序从单线程程序开始，在该线程中运行，运行任何时刻都可以调用线程库中创建新线程。<br>②内核级线程：线程管理所有工作都由内核完成，应用程序通过调用接口。内核为进程及其内部的每个线程维护上下文信息，调用也在内核基于线程构架基础上完成。<br>③组合方式：线程创建，调度，同步在用户空间，映射到一些内核级线程上。  <img src="/2022/051437005/4.jpg" class="">  </li><li>多线程模型：<br>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的联机方式。<br>①多对一模型：多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见。<br>②一对一模型：每个用户级线程映射到一个内核级线程。<br>③多对多模型：把n个用户级线程映射到m个内核级线程。m小于等于n。  <h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3></li><li>基本概念：从就绪队列中按照一定算法选择一个进程并把处理机分配给它运行，以实现进程并发地执行。  </li><li>调度的层次：一个作业从提交到开始，往往经历三级调度：<br>①作业调度：又称高级调度，其主要任务是按一定的原则从外存上处于后备的作业中挑选作业给他们分配资源，建立相应的进程，使得他们获得竞争处理机的机会，就是内存与辅存之间的调度。执行频率低，几分钟一次。<br>②中级调度：又称内存调度，其作用是提高内存利用率和系统吞吐量，为此应将那些暂时不能运行的进程调至外存等待，此时进程状态为挂起态，当他们已经具备运行条件且内存又稍有空闲的时候，由中级调度决定把外存上那些就绪进程调入内存，修改其状态为就绪态，在就绪队列上等待。<br>④进程调度：又称低级调度，主要任务就是按照某些策略从就绪队列中选取一个进程分配处理机，频率很高，几十毫秒一次。  <img src="/2022/051437005/5.jpg" class="">   </li><li>三种调度联系：<br>作业调度从外存的后备队列选择一批作业进入内存，为他们建立进程，送入就绪队列，进程调度从就绪队列选出一个进程运行，把CPU分配给它。而中级调度是为了提高内存利用率，系统将那些暂时不运行的进程挂起来，当内存宽松的时候，通过中级调度选择具备运行条件的进程唤醒。（进程调度不可或缺，最基本的）  <h3 id="调度的时机，切换和过程"><a href="#调度的时机，切换和过程" class="headerlink" title="调度的时机，切换和过程"></a>调度的时机，切换和过程</h3></li><li>进程调度和切换程序是OS内核程序，现代OS中不可以进行进程调度和切换的情况有：<br>①处理中断过程中。<br>②进程在OS内核程序临界区中，临界区独占式访问共享数据，并行程序无法进入。<br>③其他需要完全屏蔽中断的原子操作过程中。  </li><li>应发生调度和切换的情况有：<br>①发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换，非剥夺调度。<br>②中断处理结束或trap处理结束，返回被中断进程的用户态程序执行现场签，可以马上进行进程调度和切换，剥夺调度。  <h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3>指当某个进程正在处理机上执行，若有更重要的进程需要处理，则优先权更高的进程进入就绪队列，此时应该如何分配处理机，通常两种方式：<br>①非抢占方式：正在执行任务执行完再给更重要的任务配分。即一旦把CPU分配给一个进程，就会保持CPU直到终结或等待态。优点就是实现简单，开销小，适用于大多数批处理系统，单不用于分时系统和大多数实时系统。<br>②抢占方式：立即暂停正在执行进程，把处理机给更重要的进程。对于提高系统吞吐量和响应效率都有益处，但必须有原则地进行抢占。  <h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3>调度算法考虑的评价准则，主要考虑以下几种：<br>①CPU利用率：使CPU尽可能忙。<br>②系统吞吐量：单位时间内CPU完成作业数量，长作业需要长时间处理，降低系统吞吐量，而短作业提高吞吐量，所以不同调度方式对于吞吐量影响大。<br>③周转时间：指从作业提交到完成经历时间，是作业等待，在就绪队列排队和处理机上运行及IO花费时间总和。<br>④等待时间：指进程处于等待处理机时间之和，单纯考虑等待时间即可评判算法好坏。<br>⑤响应时间：指从用户提交请求到系统首次响应所用的时间。<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3></li><li>先来先服务调度算法FCFS：<br>最简单的算法，最先进入队列的作业调入内存分配资源，创建进程并放入就绪队列。  <img src="/2022/051437005/6.jpg" class="">   属于非抢占算法，所有作业公平，但长作业会使得后边的短作业等待时间过长，所以不能作为分时系统和实时系统的策略，但常跟其他策略结合。算法简单，效率低，有利于CPU繁忙型作业，不利于IO繁忙型作业。  </li><li>短作业优先调度算法SJF：<br>从后备队列中选择若干运行时间短的作业把处理机分配给它，使之立即执行，直到完成/发生某事件而阻塞时才释放处理机。  <img src="/2022/051437005/7.jpg" class="">  该算法对于长作业不利，长作业出现可能长期都不被调度的“饥饿”现象。而且完全不考虑作业紧迫程度。作业时长是估计的并不准确，有可能长作业缩短很多，并不一定做到最短优先。  </li><li>优先级调度算法：<br>优先级就是作业紧迫程度。从后备队列中选择优先级最高的若干作业调入内存，分配资源创建进程放入就绪队列，每次只分配给当前优先级最高的作业处理机。根据是否能抢占，又分为两种：非剥夺式优先级调度算法和剥夺式优先级调度算法，且进程优先级是否可以改变又把进程优先级分为两种：静态优先级（不改变，但确定优先级需要根据进程类型，对资源要求等）和动态优先级（改变，确定根据进程占有CPU时间长短，就绪过程等待CPU长短等）。<br>一般来说，进程优先级设置参照原则：<br>①系统进程&gt;用户进程。②交互式进程&gt;非交互式进程。③IO型进程&gt;计算型进程。  </li><li>高响应比优先调度算法：<br>对于FCFC和SJF的平衡，考虑每个作业的等待时间和估计的运行时间。每次进行作业调度时先计算后备队列中每个作业响应比，找出最高的投入运行。响应比Rp=（等待时间+要求服务时间）/要求服务时间。<br>则作业等待时间相同的时候短作业有利，要求服务时间相同时先来先服务有利，对于长作业等待时间增大响应比就可以增大到很大，克服了“饥饿”现象。  </li><li>时间片轮转调度算法：<br>主要适用分时系统，系统把所有就绪进程按到达时间排列FCFS，但仅仅有一个时间片，使用完时间片就让下一个进程使用。时间片大小对于系统性能影响很大，时间片很大所有进程都能在一个时间片内完成，则就是FCFS算法，时间片很小则处理机在进程之间频繁切换，使得开销增大，真正用于运行用户进程的时间减少，因此时间片大小应该选择适当。  </li><li>多级反馈队列调度算法：<br>融合了时间片轮转法和优先级调度算法，通过动态调整优先级和时间片大小。  <img src="/2022/051437005/8.jpg" class="">   思想：<br>①设计多个就绪队列，每个队列不同优先级，优先级逐次降低。<br>②赋予各个队列进程执行时间片大小各不相同，优先级越高的队列时间片越小，时间片成1倍线性增长.<br>③一个新进程进入内存之后，首先把它放入第1级队列末尾，按照FCFS原则排队等待，若时间片内完成则撤离系统否则进入第2级队列末尾，同样进行下去。<br>④仅当第1级队列为空时，才调度第2级队列进行，若处理机正在第i级队列处理进程，1-i-1的队列加入优先级高的队列就会抢占当前处理机。<br>优点：<br>①终端型作业用户：短作业优先。<br>②短批处理作业用户：周转时间短。<br>③长批处理作业用户：经过前几个队列得到部分执行，不会出现“饥饿”现象。<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3></li><li>多道程序环境下，进程是并发的，不同进程之间存在制约关系，为了协调进程之间的制约关系，所以出现了同步。（2+3*1，一定要让加法发生在乘法之后）  </li><li>临界资源：<br>多个进程可以共享系统资源，但许多资源只能有一个进程独占，我们把一次仅允许一个进程使用的资源称为临界资源。（许多物理设备和变量数据）对于临界资源的访问必须互斥地进行，每个进程中访问临界资源的那段代码称为临界区，把访问临界资源分为四个部分：<br>①进入区：进入临界区使用临界资源，检查是否可以进，能进则设置正在访问标志，阻止其他进程访问临界区。<br>②临界区：访问临界资源的代码，又称临界段。<br>③退出区：把正在访问临界区的标志删除。<br>④剩余区：代码其余部分。   <img src="/2022/051437005/9.jpg" class="">   </li><li>同步：<br>同步亦称直接制约关系，指的是为了完成某种任务而建立起的若干进程，需要在某些位置上协调他们的工作次序而等待，传递信息所产生的制约关系。  </li><li>互斥：<br>互斥是间接制约关系，当一个进程进入临界区另一个就需要等待。  <h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3></li><li>软件检查法：在进入区设置并检查一些标志来表明是否有进程在临界区，若有则循环检查进行等待，进程离开临界区后则在退出区修改标志。<br>①单标志法：设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。即turn=0，允许P0进入临界区，每次只有一个进程进入临界区，而且两个进程必须交替进入，否则另一个进程也无法进入临界区，因为标志一直不变了。  <img src="/2022/051437005/10.jpg" class="">   ②双标志先检测法：每个进程访问临界区之前，先查看临界资源是否被访问，正在访问则等待，否则可以进入临界区，设置flag[i]，false标识Pi未进入临界区，true标识进入临界区。  <img src="/2022/051437005/11.jpg" class="">   ③双标志后检测法：先检测可能同时进入，所以先把自己设置为true，再检测对方的状态，对方为true则等待，否则进入临界区。  <img src="/2022/051437005/12.jpg" class="">   ④Peterson算法：防止两个进程为了进入临界区无期限等待，设置turn，每个进程先设置自己标志再设置turn，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时想进入临界区时只有一个能进入。设置自己flag为true，把turn设置为其他进程，然后检测是否其他进程为true，是则等待，否则进入临界区。利用flag解决临界资源的互斥访问，利用turn解决“饥饿”现象。   <img src="/2022/051437005/13.jpg" class="">      </li><li>硬件实现方法：通过硬件支持实现临界问题的方法称为低级方法/元方法。<br>①中断屏蔽方法：当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入就禁止一切中断发生，或称之为屏蔽中断，关中断（CPU只在中断的时候进行进程切换）<img src="/2022/051437005/14.jpg" class="">   ②硬件指令方法：<img src="/2022/051437005/15.jpg" class="">   ③硬件方法优点：任意数目进程都可以，简单，支持进程多个临界区。<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3></li><li>用来解决互斥问题的，只能被两个标准原语wait（S）和signal（S）访问，也就是P操作和V操作。原语是指完成某种功能且不被分割，不被中断执行的操作序列，通常硬件实现，<br>①整形信号量：wait——当s&lt;=0则陷入循环，否则自减，signal——自增。<br>②记录型信号量：wait——当s.value&lt;=0则资源分配完毕，自我阻塞，否则自减，分配资源。而signal——自增，释放一个资源，资源数增加1。<br>③利用信号量实现同步，互斥，前驱关系：设置一个进程公用的信号量S，并且根据需求进行初始化，V加P减，举例如下：  <img src="/2022/051437005/16.jpg" class="">   <h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3></li><li>大量分散的同步操作麻烦且容易死锁，所以产生进程同步工具——管程，保证了进程互斥，无须人工实现，降低死锁发生可能性，同时提供了条件变量，程序员灵活实现同步。  </li><li>定义：系统中硬软件资源均可用数据结构描述其资源特性，对该结构实施的操作定义为一组过程。进程对共享资源的申请，释放等操作都通过这组过程实现，还可以根据资源情况或接收阻塞进程访问，确保每次仅有一个进程使用共享资源，这就可以统一管理共享资源访问，实现进程互斥，这个资源管理程序，就是管程。定义了一个数据结构和能为并发进程所执行的一组操作，能够同步进程和改变管程中的数据。  </li><li>组成：名称，局部与管程内部的共享数据结构说明，操作的一组过程，初始化语句。  </li><li>管程很像一个类CLASS，能够把共享资源封装起来，且每次允许一个进程进入管程，从而实现互斥。  <h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3>重在理解，信号量和缓冲区的运用。</li><li>生产者-消费者问题  </li><li>读者-写者问题 </li><li>哲学家就餐问题  </li><li>吸烟者问题<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3></li><li>定义：多个进程并发执行带来死锁这个问题，多个进程因竞争资源而造成的相互等待的僵局。</li><li>产生原因：<br>①系统资源的竞争：<br>通常是系统中不可剥夺资源，数量不足需求，比如打印机。（不剥夺资源竞争不会死锁）<br>②进程推进顺序非法：<br>进程运行中请求和释放资源顺序不当，也会死锁（两个进程各自占着对面需要的资源），信号量也会产生死锁。（两个进程等待对方发来的消息）<br>③死锁产生必要条件：<br>产生死锁必须同时满足4个条件：<br>Ⅰ：互斥条件：只有一个进程能够拥有该资源。<br>Ⅱ：不剥夺条件：资源未使用完不可被剥夺。<br>Ⅲ：请求并保持条件：进程至少已经保持了一个资源，并且提出了请求资源（该资源已被占有），此时请求失败，但还不放弃自己已经得到的资源。<br>Ⅳ：循环等待条件：存在一种进程资源的循环等待链，相当于一个环（12345，1的请求资源被2占有。。。5的资源被1占有）  <img src="/2022/051437005/17.jpg" class="">   <h3 id="死锁处理策略："><a href="#死锁处理策略：" class="headerlink" title="死锁处理策略："></a>死锁处理策略：</h3></li><li>死锁预防：设置某些限制条件，破坏4个必要条件，防止发生死锁。  </li><li>避免死锁：动态分配资源中，使用某种方法防止进入不安全状态，进而避免死锁。  </li><li>死锁检测和解除：允许死锁，及时检测并且接触即可。  <img src="/2022/051437005/18.jpg" class="">   <h3 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h3></li><li>破坏互斥条件：不可行（肯定有资源是互斥的）  </li><li>破坏不剥夺条件：一个保持资源的进程得不到需要的资源就把拥有的全部资源释放。  </li><li>破坏请求并保持条件：设备申请就申请所有需要的资源，也就是说没有资源才可以申请。  </li><li>破坏循环等待条件：给系统中资源编号，每个进程必须按照递增顺序请求资源，即申请大于自己编号的资源。  <h3 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h3></li><li>系统安全状态：系统能够按照某种进程的推进顺序为每个进程分配所需资源，直到满足每个进程对于资源的最大需求，使每个进程都顺序完成，此时进程序列为安全序列，若系统中没有一个安全序列，则系统是不安全状态。并非不安全状态就是死锁状态，只是有可能是死锁状态，但只要是安全状态，系统就可以避免死锁状态。</li><li>银行家算法：最著名的死锁避免算法：三个矩阵一个向量（可用资源向量Available，最大需求矩阵Max，分配矩阵Allocation，需求矩阵Need，其中Need=Max-Allocation），先分配资源，检查是否处于安全状态（安全性算法，求一个安全序列），安全则确定分配，不安全则取消分配。一定掌握！！！  <h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3></li><li>资源分配图：圆圈代表进程，框代表资源，其中从进程到资源的有向边称为请求边，反向则是分配边。  </li><li>死锁定理：<br>简化资源分配图就可以检测系统状态S是否为死锁，不可完全简化就是死锁的。  <img src="/2022/051437005/19.jpg" class="">    </li><li>死锁解除：<br>①资源剥夺法：挂起死锁进程，抢占其资源，把资源分配给其他死锁进程。<br>②撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源，撤销原则按照优先级和撤销进程代价高低进行。<br>③进程回退法：让一个/多个进程回退到足够避免死锁的地步，要求系统保持历史状态，设置还原点。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/051437005/20.jpg" class="">   </li><li>进程同步和互斥：<br>并发进程执行会产生相互制约的关系：一种是进程之间竞争使用临界资源，但只有一个能用，这是互斥，是竞争关系。而进程之间协同完成任务，某点上进程需要等待另一个进程发来的消息，以便协同一致，是一种协作关系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统计算机系统概述</title>
      <link href="/2022/051418462.html"/>
      <url>/2022/051418462.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><img src="/2022/051418462/5.jpg" class="">  <h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><ul><li>软件是计算机系统的灵魂，而软件核心是操作系统。  </li><li>计算机系统从上到下分四个部分：硬件，操作系统，应用程序，用户。</li><li>操作系统管理各种计算机硬件，并且为应用程序提供基础，充当计算机硬件与用户之间的中介。</li><li>硬件比如：CPU，内存，IO设备等提供基本计算资源。应用程序如：字处理程序，编译器，浏览器等规定按照何种方式来使用这些计算资源解决用户的计算问题。操作系统就负责控制和协调各个用户的应用程序对硬件的分配和使用。  </li><li>综上，OS就是控制和管理整个计算机系统硬件与软件资源，合理组织和调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的集合，也是计算机系统中最基本的系统软件。  <h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3></li><li>OS是一种系统软件，但与其他系统软件和应用软件有很大不同，它有自己的特殊性即基本特征：并发，共享，虚拟，异步。  </li><li>并发Concurrence：<br>两个或多个事件在同一个时间间隔内发生，OS具有处理和调度多个程序同时执行的能力，同时引入进程的目的就是让程序可以并发执行。<br>注意同一时间间隔（并发）和同一时刻（并行）的区别：单个时刻单处理机环境下实际只能有一个程序执行，因此微观上这些程序仍然是分时交替执行的，OS的并发性也是通过分时实现的。   </li><li>共享sharing：<br>即资源共享，系统中资源可以供内存中多个并发执行的进程共同使用，分两种方式：<br>①互斥共享方式：<br>系统中某些资源某段时间内只允许一个进程访问资源。把这种资源成为临界资源/独占资源。计算机系统大多物理设备及某些软件中的栈，变量，表格都是临界资源，只允许一个正在使用的进程。<br>②同时访问方式：<br>宏观上是“同时”，微观上进程可能是交替地对资源进行访问即“分时共享”的，可供多个进程“同时”访问的资源是磁盘设备。<br>（并发和共享是OS最基本特征，相互依赖）</li><li>虚拟virtual：<br>把物理上的实体变成若干逻辑上的对应物，技术成为虚拟技术，OS利用多种虚拟技术实现虚拟处理器，虚拟内存，虚拟外部设备等。<br>虚拟处理器技术通过多道程序设计技术，采用让多道程序并发执行的方法，分时使用一个处理器，一个物理CPU虚拟成为多个逻辑的CPU，成为虚拟处理器。（同理虚拟内存，虚拟外部设备）<br>虚拟技术归纳为时分复用，技术，空分复用技术。  </li><li>异步asynchronism：<br>多道程序允许多个程序并发执行，但资源有限，进程执行并不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性。  <h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3></li><li>OS应该具有以下功能：处理机管理，存储器管理，设备管理， 文件管理，且必须向用户提供接口。  </li><li>操作系统作为计算机系统资源的管理者：<br>①处理机管理：<br>处理机分配和运行都以进程为基本单位，也就是对进程的管理：主要包括进程控制，进程同步，进程通信，进程通信，死锁处理，处理机调度等。<br>②存储器管理：<br>给多道程序运行提供环境，方便用户使用及提高内存利用率，包括内存分配和回收，地址映射，内存保护和共享，内存扩充等功能。<br>③文件管理：<br>信息都以文件形式存储，负责管理文件部分为文件系统，包括文件存储空间管理，目录管理，文件读写管理和保护。<br>④设备管理：<br>设备管理主要任务是完成用户的I/O请求，方便用户使用各种设备，提高设备利用率，包括缓冲管理，设备分配，设备处理，虚拟设备等。  </li><li>操作系统作为用户与计算机硬件系统之间的接口：<br>两类接口：<br>①命令接口：用户利用命令组织控制作业的执行。两种控制作业的方式为联机控制方式和脱机控制方式，所以把接口分为联机命令接口和脱机命令接口。<br>联机命令接口：又叫交互式命令接口，适用分时/实时系统的接口。（多次输入命令逐次处理）<br>脱机命令接口：又叫批处理命令接口，适用于批处理系统的接口。（一次输入逐次处理）<br>②程序接口：编程人员使用他们请求操作系统服务。由一组系统调用组成，用户通过程序中使用这些系统调用来请求OS服务，比如GUI。  </li><li>操作系统作为扩充机器：<br>没有任何软件支持计算机成为裸机，为物理基础，而实际应该使用OS把裸机改造成功能更强，使用更方便的机器，因此覆盖了软件的机器称为扩充机器/虚拟机。  <h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3></li><li>计算机计算过程需要人工干预，缺点：①用户独占全机，资源利用率低。②CPU等待手工操作，CPU利用率低。  <h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3></li><li>为了解决人际矛盾及CPU和IO设备矛盾，出现了批处理系统，分为单道批处理系统和多道批处理系统。  </li><li>单道批处理系统：<br>①自动性：作业自动逐行运行，无须人工干预。<br>②顺序性：作业完成顺序就是进入内存顺序，先进入先完成。<br>③单道性：内存中只有一道程序运行，结束才让其他程序进入。<br>④但高速CPU仍然等待低速I/O完成状态。  </li><li>多道批处理系统：<br>允许多个程序同时进入内存，允许他们在CPU交替运行，共享系统资源。一道程序因为I/O请求等待，CPU就可以处理其他程序，使得资源利用率提高。<br>①多道：计算机内存中同时存多道程序。<br>②宏观上并行：同时进入内存的程序都处于运行中，但实际是先后运行。<br>③微观上串行：内存中多道程序轮流占用CPU，交替执行。<br>④优点是资源利用率高，系统吞吐量大，资源保持忙碌状态。<br>⑤缺点是用户响应时间长，没有人机交互。<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3>分时技术：把处理器运行时间分为时间片，轮流分配给作业使用，作业只利用自己的时间片完成计算，没有完成的也停止，也支持多道程序，但是包括人机交互的。<br>①同时性：允许多个终端用户同时使用计算机。<br>②交互性：用户通过终端采用人机对话方式控制程序<br>③独立性：多个用户彼此独立操作互不干扰。<br>④及时性：短时间内响应用户请求，一个计算机服务多个终端，所以响应及时。<br>⑤尽管解决了人机交互问题，但短时间反映问题还需要处理，所以出现实时操作系统。  <h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3></li><li>某个时间限制内完成某些紧急任务而不需要时间片排队，分两种情况：<br>①硬实时系统：某个动作必须绝对在规定时刻发生，则称为硬实时系统。（飞行器控制系统）<br>②软实时系统：能够接收偶尔违反实践规定且不会引起永久性损害。（飞机订票系统）  <h3 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h3></li><li>网络操作系统是把计算机网络各台计算机有机结合起来，提供一对一，经济有效的使用各台计算机方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。  </li><li>分布式计算机系统组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息，每台计算机地位平等，资源所有用户共享，任意计算机都可以构成一个子系统，任何工作都可以分布在几台计算机上，由他们并行工作，协同完成。系统称为分布式计算机系统，特点就是分布性和并行性。  <h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3>目前最广泛的操作系统，如Windows，Linux等<img src="/2022/051418462/1.jpg" class="">   <h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3></li><li>计算机系统中，CPU通常执行两种不同性质的程序：一种是OS内核程序，一种是用户自编程序（应用程序）。对于OS来说前者是后者的管理者，因此需要特权指令比如：IO指令，置中断指令等指令。实现上把CPU划分为用户态（只能执行非特权指令）和核心态（可以执行特权指令），应用程序运行在用户态，而OS内核程序运行在核心态。  </li><li>内核是计算机底层软件，是计算机功能延申，不同系统对于内核定义不同，但大多包括4方面内容：<br>①时钟管理：<br>时钟是最关键的设备，第一功能是计时，向用户提供标准系统时间。通过时钟中断的管理实现进程切换（时间片轮转等），因此系统依赖时钟。<br>②中断机制：<br>引入中断目的是提高多道程序运行环境中的CPU的利用率，逐步发展形成多种类型，成为OS各项操作的基础。例如：键鼠信息输入，进程调度，设备驱动等。现代OS就是靠中断驱动的软件。<br>③原语：<br>OS底层一些可以被调用的小程序，各自完成一定操作，特点：①处于OS最底层，最接近硬件的部分。②程序具有原子性。③运行时间短，而且调用频繁。<br>具有这些特点的程序就是原语，定义原语的直接方法就是关闭中断，让所有动作不可分割完成之后再中断，系统中的设备驱动，CPU切换，进程通信等过程就是原语，成为内核组成部分。<br>④系统控制的数据结构和处理：<br>系统中登记状态信息的数据结构很多，如作业控制块，进程控制块PCB，设备控制块，各类链表，消息队列，缓冲区，空闲区登记表，内存分配表等，常见操作有：进程管理，存储器管理，设备管理。<h3 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h3></li><li>中断和异常的定义：<br>中断Interruption，也称外中断，来自CPU执行指令以外的事情发生（IO设备中断表示输入输出完毕发生下一个请求；时钟中断表示固定时间片到期），通常是指与当前指令无关的事件。<br>异常Exception，也称内中断，例外，陷入trap。指源自CPU指令内部的事情引起的事件（算术溢出，地址越界，非法操作等），对异常处理一般要依赖当前程序运行现场，且异常不能被屏蔽，一旦出现必须处理。  <img src="/2022/051418462/2.jpg" class="">   </li><li>中断处理过程：  <img src="/2022/051418462/3.jpg" class="">   <h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3></li><li>指用户在程序调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统内各种共享资源都有OS掌管，在用户程序中，凡是跟资源有关操作都需要系统调用的方式向OS提出服务请求，请OS代为完成，通常这种指令有很多条，分为几大类：设备管理，文件管理，进程控制，进程通信，内存管理。</li><li>系统调用相关功能涉及系统资源管理，进程管理等操作，需要特权指令，所以系统调用处理需要由操作系统欸和程序负责完成运行在核心态。用户程序可以执行trap命令发起系统调用，请求OS服务，相当于把CPU使用权交给OS内核程序。用户程序不能直接执行对系统影响很大的操作，必须通过系统调用的方式请求OS执行，以便保证系统稳定性和安全性，防止用户程序随意更改/访问重要的系统资源，影响其他进程执行。  </li><li>OS运行环境理解为：用户通过OS上层程序，而这个程序依赖OS底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序，也可能是程序运行出现异常情况，被动需要管理程序服务，通过异常处理来进入核心态，管理程序运行结束时，用户程序需要继续运行，此时通过响应的保存的程序现场退出中断处理程序/异常处理程序，返回断点处继续执行。  <img src="/2022/051418462/4.jpg" class="">  <h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3></li><li>大内核：把OS主要模块作为一个紧密相连的整体运行在核心态，从而为应用提供高性能的系统服务，因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以性能有优势。</li><li>微内核：随着功能需求不断增多，大内核难以维护，所以出现微内核。它把内核中最基本的功能保留在内核，而那些不需要在核心态执行的功能移到用户态执行，从而减低了内核设计的复杂性，那些移出内核的OS的代码根据分层的原则被划分成若干服务程序，它们执行相互独立，交互则都借助于微内核进行通信。有效分离了内核与服务，服务与服务，接口更清晰，维护代价降低，各部分都可以独立优化和演进，保证了OS可靠性。但问题就是因为频繁在核心态和用户态之间切换，OS执行开销相当大。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2022/050732155.html"/>
      <url>/2022/050732155.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络应用层"><a href="#计算机网络应用层" class="headerlink" title="计算机网络应用层"></a>计算机网络应用层</h1><img src="/2022/050732155/1.jpg" class="">  <h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-x2F-服务器类型"><a href="#客户-x2F-服务器类型" class="headerlink" title="客户/服务器类型"></a>客户/服务器类型</h3><ul><li>C/S模型中，一个总是打开的主机为服务器，服务于其他称为客户机的主机请求，工作流程如下：<br>①服务器处接收请求状态。<br>②客户机发出服务请求，并等待结果。<br>③服务器收到请求之后，分析请求，进行必要的处理，得到结果并发送给客户机。  </li><li>客户程序必须知道服务器程序的地址，服务器程序不用知道客户程序的地址。主要特征就是客户是服务请求方，服务器是服务提供方，典型应用包括：Web，文件传输协议FTP，远程登陆TELNET，电子邮件E-mail。  </li><li>主要特点还有：<br>①网络中计算机地位不平等。<br>②客户机之间不能直接通信。<br>③可扩展性不佳。  <h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3></li><li>思想是整个网络中传输内容不在中心服务器上，而是每个结点都有下载，上传的功能，任意一对计算机称为对等方Peer，可以直接通信，典型应用包括：PPLive，Bittorrent和电驴等。  </li><li>相比C/S，主要优点是：<br>①减轻服务器计算压力，消除了对某个服务器完全依赖，任务分配在各个结点上，大大提高系统效率和资源利用率。<br>②多个客户机共享文档。<br>③可扩展性号，传统服务器有响应和带宽，因此只能接收一定数量请求。<br>④网络健壮性强，一个结点失效不会影响其他结点。  </li><li>也有缺点：获取服务的时候也要给其他结点服务，占用较多内存，影响整机速度。    <img src="/2022/050732155/2.jpg" class="">  <h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2></li><li>因特网使用的命名系统，用来把便于人们记忆具有特定含义的主机名转化为便于机器处理的IP地址，使用C/S，运行在UDP之上，使用53号端口。分为三部分：层次域名空间，域名服务器，解析器。    <h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3></li><li>采用层次树状命名方法，任何一个连接到因特网的主机或路由器都有一个唯一层次标识，即域名。域是名字空间中可以被管理的部分。域还可以划分子域，还能继续划分，形成了顶级域，二级域，三级域等。每个域名都有由标号序列组成，各个标号都由.隔开。  <img src="/2022/050732155/3.jpg" class="">  </li><li>注意点：<br>①标号中英文不区分大小写。<br>②标号中除了-之外不能使用其他符号。<br>③每个标号不超过63字符，多标号不超过255字符。<br>④级别最低域名在最左边，最高在最右边。  </li><li>顶级域名TLD有三类：<br>①国家顶级域名：“.cn”表示中国。<br>②通用顶级域名：“。com”表示公司。<br>③基础结构域名：这种顶级域名只有一个arpa，用于反向域名解析，又称反向域名。    </li><li>国家下的二级域名由该国家自行确定，展示树状结构：  <img src="/2022/050732155/4.jpg" class="">  </li><li>每个域名可以由不同组织进行管理组织也可以再分成一定数目的子域去管理。  <h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3></li><li>因特网的域名系统被设计成一个联机分布式服务器，用C/S模型，域名到IP地址解析是用由运行在域名服务器上的程序完成的，一个服务器负责管辖称为区，每个区都有响应权限域名服务器，用来保存该区所有主机的域名到IP地址的映射。每个域名服务器不但能够映射IP地址，还能连接其他域名服务器，当自己不能够映射出IP地址的时候找其他域名服务器。DNS使用大量域名服务器，以层次方式组织，所有映射分布在所有的DNS上，主要有4种类型域名服务器：<br>①根域名服务器：<br>最高层次域名服务器，所有根域名服务器都知道所有的顶级域名服务器的IP地址，共有13个，通常它不把域名直接转换成IP地址，而是告诉本地域名服务器下一步应该找哪个顶级域名服务器。<br>②顶级域名服务器：<br>负责管理在该顶级域名服务器注册的所有二级域名，收到DNS查询请求的时候给出相应应答（有可能是结果，也有可能是下一步找哪个域名服务器的IP地址）<br>③授权域名服务器（权限域名服务器）：<br>每台主机必须在授权域名服务器处登记，为了更可靠工作，一台主机最好有至少两个。<br>④本地域名服务器：<br>每个ISP/大学/院系甚至都有一个本地域名服务器，当一个主机发送DNS请求的时候，这个查询请求报文发送给该主机的本地域名服务器。  <img src="/2022/050732155/5.jpg" class="">   <h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3></li><li>把域名解析成IP地址为正向解析，或者反向解析。客户机需要域名解析的时候，通过本机DNS构造一个DNS请求报文以UDP数据报形式发往本地域名服务器。  </li><li>域名解析有两种方式：递归查询和迭代与递归结合查询。  <img src="/2022/050732155/6.jpg" class="">    <img src="/2022/050732155/7.jpg" class="">    <h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3></li><li>FTP是因特网是商用最广泛的文件传输协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，适合在异构网络任意计算机之间传送文件。  </li><li>提供以下功能：<br>①提供不同种类主机系统之间的文件传输能力。<br>②以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力。<br>③以匿名FTP的方式提供公用文件共享的能力。  </li><li>使用TCP，C/S模型，一个FTP服务器进程可同时为多个客户进程提供服务，FTP服务器进程由两大部分组成：一个主进程负责接收新请求，若干从属进程，负责处理单个请求。  </li><li>工作步骤：<br>①打开熟知端口21，使得客户进程能够连接上。<br>②等待客户进程发来连接请求。<br>③启动丛书进程处理客户进程发来的请求，主进程和从属进程并发执行，从属进程对客户进程的请求处理完毕后终止。<br>④回到等待状态，继续接收其他客户进程的请求。</li><li>FTP服务器必须在整个会话期间保留用户的状态信息，特别是必须把指定用户和控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。  <h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3></li><li>FTP工作使用两个并行TCP，一个控制连接（端口21），一个数据连接（端口20），使用两个不同端口使得协议更加简单和容易实现。  </li><li>控制连接：<br>21端口，等待客户连接，建立在这个端口上称为控制连接，用来传输控制信息（连接请求，传送请求等），不用来传送文件，一直保持打开状态。  </li><li>数据连接：<br>20端口，服务器端的控制进程在接收到FTP客户发来的文件传输请求之后，创建“数据传送进程”和“数据连接”，数据连接来连接C和S的数传送进程，而进程实际完成文件的传送，结束关闭“数据传送连接”并结束运行。<br>数据连接两种模式：主动PORT，被动PASV。<br>①PORT工作原理：客户端连接到21，登陆成功读取数据时，客户端随机开一个端口，并发送命令告知服务器，服务器收到PORT命令和端口号，通过20端口和客户端开放的端口号连接，发送数据。<br>②PASV不同点是：客户端读取数据，发送PASV到服务器，服务器随机开一个端口告知客户端，客户端再连接到服务器开放的端口进行书传书。<br>但两种模式，选择权都在客户端，主动模式就是服务器连接到客户端端口，被动模式就是客户端连接到服务器端口。  <h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3></li><li>一个电子邮件系统最主要三个组成构件：用户代理，邮件服务器，电子邮箱使用的协议（如SMTP，POP3或IMAP）等。  </li><li>用户代理：用户与电子邮件系统的接口，用户代理给用户提供一个友好接口发送接收邮件，通常情况下就是一个运行在PC上的程序，比如Foxmail等。  </li><li>邮件服务器：功能就是收发邮件，同时向发信人报告邮件传送情况，采用C/S模型工作，但它必须都能充当C和S。  </li><li>邮件发送协议和读取协议：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP。邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3。且SMTP用的是PUSH的方式，即用户代理向邮件服务器发送邮件以及邮件服务器之间转发邮件时，SMTP客户把邮件”推“向服务器，而POP3则是”拉“（PULL），读取邮件，用户代理向服务器发出请求，拉取用户邮箱中的邮件。  <img src="/2022/050732155/8.jpg" class="">   <h3 id="电子邮箱格式与MIME"><a href="#电子邮箱格式与MIME" class="headerlink" title="电子邮箱格式与MIME"></a>电子邮箱格式与MIME</h3></li><li>电子邮箱格式：<br>分为信封和内容两大部分，内容又分为首部和主题两部分。RFC 822规定了邮件的首部格式，而邮件的主题部分则让用户自由撰写。用户写好首部之后，邮件系统自动地把信封所需的信息提取出来写在信封上，用户不需要亲自填写信封上的信息。<br>邮件内容首部包含一些首部行，每个首部行由一个关键字后跟冒号再根值组成，有些关键字必须的，有些则是可选的，最重要的是To：，Subject：。<br>To是必须关键字，后面填入一个/多个收件人电子邮件，规定格式为：收件人邮件名@邮件所在主机域名。Subject是可选关键字，是邮件主题，反映了邮件主要内容。From也是必须，但它通常被邮件系统自动填入，从上到下Form，To，Subject，组成了首部。  </li><li>多用途网际邮件扩充MIME：<br>SMTP只能传送一定长度的ASCII码，许多非英语国家文字无法传送，且无法传送可执行文件及其他二进制对象，一次提出了MIME。MIME并非取代SMTP或改动它，而是增加了邮件主题的结构，定义了传送非ASCII码的编码规则。  <h3 id="SMTP和POP3"><a href="#SMTP和POP3" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3></li><li>SMTP:<br>简单邮件传输协议SMTP，可靠有效的电子邮件传输协议，控制两个相互通信的SMTP进程交换信息，由于SMTP使用C/S模型，因此负责发送邮件的SMTP进程就是SMTP客户，负责接收的SMTP进程就是SMTP服务器，用TCP连接，端口号为25。有三个阶段：<br>①连接建立：<br>发件人邮件发送到发送方邮件服务器邮件缓存中，SMTP每个一段时间骚猫一次，有邮件则用25端口与接收方邮件的SMTP服务器建立TCP连接，之后接收方服务器发出220 Service ready，然后SMTP客户向SMTP服务器发出HELO指令，附上发送方的主机名。<br>②邮件传送：<br>连接建立之后，开始传送邮件，邮件从MAIL命令开始，若SMTP服务器已经准备好接收邮件，则回答250 OK，接着SMTP客户端发送一个或多个RCPT命令，格式为RCPT TO&lt;收件人地址&gt;，每发送一个RCPT命令，都应有相关信息从STMP服务器返回，如250 OK或者550 No such user here。（RCPT命令作用是先弄清服务器是否已经做好接收邮件准备，再发送邮件，不至于白发送错误地址）。<br>获取OK回答之后，客户端使用DATA命令，表示要开始传输邮件的内容，正常SMTP服务器回复信息是354 Start mail input;end with CRLF.CRLF。此时SMTP客户端就可以开始传送邮件内容。<br>③连接释放：<br>SMTP客户应发送QUIT命令，服务器返回221，表示SMTP同意释放连接。  </li><li>POP3和IMAP：<br>POP3：邮局协议POP是一个简单但功能有限的邮件读取协议，采用PULL的方式，用户读取邮件则向服务器发出请求，拉取用户邮箱中的邮件。也是用C/S模型，使用TCP，端口110。有两种运行方式：”下载并保留“和”下载并删除“。<br>IMAP：它比POP复杂很多，为用户提供了创建文件夹，不同文件夹移动邮件等命令，为此IMAP服务器维护了会话用户的状态信息。IMAP另一个特性就是允许用户代理只读部分内容。  <h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="WWW的概念与组成结构"><a href="#WWW的概念与组成结构" class="headerlink" title="WWW的概念与组成结构"></a>WWW的概念与组成结构</h3></li><li>万维网是一个分布式，联机式的信息存储空间，万物有一个全域同一资源定位符URL标识，资源通过超文本传输协议HTTP传送给使用者，后者通过单机链接获取资源。万维网的内核部分由三个标准组成：<br>①统一资源定位符URL：标识万维网上各种文档，且每个都有URL。<br>②超文本传输协议HTTP：使用TCP链接，万维网客户程序和服务器程序之间交互必须遵循的规则。<br>③超文本标记语言HTML：一种文档结构标记语言，使用一些约定的标记对页面信息，格式进行描述。  </li><li>URL格式：协议：//主机：端口/路径。  </li><li>万维网以C/S方式工作，浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则是运行服务器程序，称为万维网服务器，工作流程是：<br>①Web用户使用浏览器指定URL与Web服务器建立连接，并发送浏览请求。<br>②Web服务器把URL转换为文件路径，并返回给Web浏览器。<br>③通信完成，关闭连接。<br>万维网是无数个网站和网页集合，构成了因特网最主要的部分。   <h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2></li><li>HTTP定义浏览器怎么向万维网服务器请求万维网文档，以及服务器怎么把文档传给浏览器，是面向事务的应用层协议。  </li><li>HTTP操作过程：<br>浏览器访问WWW服务器，首先完成对WWW域名解析获得IP地址，通过TCP向服务器发送连接。大致工作过程：每个万维网站点有一个服务器进程，不断监听TCP端口80，监听到连接请求就建立连接，然后，浏览器通过向服务器发送请求获取某个Web页面的HTTP请求，服务器返回Web页面必须信息，通过HTTP响应返回给浏览器，浏览器再进行信息解释，然后把Web页面显示给用户，最后TCP连接释放。  <img src="/2022/050732155/9.jpg" class="">    </li><li>HTTP特点：<br>①使用TCP保证可靠传输。<br>②HTTP无状态，服务器不记住HTTP状态，但可以通过Cookie加数据库的方式来跟踪用户活动。<br>③HTTP既可以使用非持久连接，也可以使用持久连接。<br>对于非持久连接，每个网页对象都需要单独TCP连接，万维网服务器负担重。<br>对于持久连接，万维网服务器发送响应之后仍然保持这链接，同一个客户和该服务器可以继续在这条连接上 传送后续HTTP请求和响应报文。  <img src="/2022/050732155/10.jpg" class="">     </li><li>HTTP报文结构：<br>①面向文本的，每个字段都是ASCII码串，每个字段长度不固定，有两类:请求报文（客户向服务器发）和响应报文（服务器到客户的回答）。<br>②HTTP两个报文都是三部分组成：开始行，首部行，实体主体<img src="/2022/050732155/11.jpg" class="">  </li><li>常见应用层协议小结：  <img src="/2022/050732155/12.jpg" class="">  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>互联网，因特网，万维网：<br>互联网：泛指多个计算机网络按照一定通信协议相互连接而成的一个大型计算机网络。<br>因特网：世界最大全球性互联网络，最大的互联网。<br>万维网：无数网站和网页集合，构成因特网最主要部分。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络传输层</title>
      <link href="/2022/05076519.html"/>
      <url>/2022/05076519.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络传输层"><a href="#计算机网络传输层" class="headerlink" title="计算机网络传输层"></a>计算机网络传输层</h1><img src="/2022/05076519/1.jpg" class="">  <h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><ul><li>传输层向应用层提供通信服务，属于面向通信的最高层，也是用户功能的最低层。它为运行在不同主机的进程之间提供了逻辑通信，而网络层则是不同主机之间的网络通信，即使网络层协议不可靠，传输层同样能为应用程序提供给可靠的服务。   </li><li>网络边缘部分的两台主机使用网络核心部分的功能进行端到端通信，只有主机的协议栈才有传输层和应用层，而路由器转发分组用了下三层的功能，如图：   <img src="/2022/05076519/2.jpg" class="">  </li><li>功能：<br>①传输层提供应用进程之间的逻辑通信，而网络层提供主机之间的逻辑通信。（应用进程之间的通信实际是“端到端的逻辑通信”，实际上逻辑通信就是好像沿着水平方向传输数据，但物理上并没有一条物理连接。）<br>②复用和分用：复用指的是发送方不同应用进程都可以使用同一个传输层协议传输数据。分用指的是接收方的传输层剥去报文的首部之后能够把这些数据正确交付到目的应用进程。（网络层也有复用分用，复用是把发送方不同协议数据都可以封装成IP数据报发送出去，分用是把接收方的网络层剥去首部后把数据交付给相应协议。）<br>③传输层还要对收到的报文进行差错检测（首部和数据部分），而网络层只监测IP数据报的首部，不检查数据部分。<br>④提供两种不同协议UDP和TCP，而网络层无法同时实现两种协议。（要么面向连接虚电路，要么无连接数据报。）  <h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3></li><li>端口的作用：<br>①端口可以让应用层的各个应用进程将其数据通过该端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的相应进程。端口就是传输层服务访问点（TSAP），它在传输层作用类似于IP地址在网络层/MAC地址在数据链路层，只不过IP/MAC标记的是主机，而端口标识的是主机中的应用进程。<br>②硬件端口是不同硬件设备进行交互的端口，软件端口是应用层各种协议进程与传输实体进行层间交互的一种地址。   </li><li>端口号：<br>应用进程之间通过端口号进行标识，长度为16比特，能够标识2的16次方个进程，只有本地意义，即端口号只标记本计算机应用层的各种进程，分两类：<br>①服务器端使用的端口号，又分为两类：一类是熟知端口号，0——1023，派发给最重要的应用程序，另一类是等级端口号，1024——49151，提供给其他应用程序使用。<br>一些熟知端口号：FTP——21，TELNET——23，SMTP——25，DNS——53，TFTP——69，HTTP——80，SNMP——161。<br>②客户端使用的端口号，49152——65535。由于这类端口号仅在客户进程运行时才动态选择，又称为短暂端口号，通信结束后更用过的客户端端口号不复存在，该端口就可以重新使用。  </li><li>套接字：<br>IP标识不同主机，端口号标识不同进程，则端口号拼接到IP地址即套接字。<br>socket=（IP地址：端口号）  <h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3></li><li>TCP是面向连接的服务，在传送数据之前必须建立连接，数据传送结束后释放连接，不提供组播/广播，不可避免的增加许多开销（确认，流量控制，计时器，连接管理），适用于可靠性更重要的场合，如：文件传输协议FTP，超文本传输协议HTTP，远程登录TELNET等。  </li><li>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查。IP知道投放哪个主机但不知道哪个进程。UDP比较简单，因此执行速度快，实时性好，如：小文本传送协议TFTP，DNS，SNMP，实时传输协议RTP等。</li><li>IP数据报和UDP数据报区别：IP数据报在网络层要经过路由存储转发，而UDP数据报在传输层端到端的逻辑信道中传输，封装成IP数据报在网络层传输时对外不可见。  </li><li>TCP和网络层虚电路区别：TCP报文在传输层抽象的逻辑信道中传输，对路由器不可见，虚电路经过交换节点必须保存虚电路状态信息，则网络层使用虚电路则无法提供无连接服务，而传输层采用TCP不影响网络层提供无连接服务。  <h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3></li><li>UDP概述：<br>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查，应用程序几乎直接与IP打交道。<br>优点：<br>①无须连接，没有建立连接时延。<br>②无连接状态，不跟踪确认等参数，因此使用UDP的时候可以支持更多的活动客户机。<br>③分组首部开销小，TCP有20B的首部开销，UDP只有8B的开销。<br>④应用层更好控制要发送的数据和发送时间。<br>⑤支持1-1，1-N，N-1，N-N的服务。<br>常用于一次性传输较少的网络应用，如DNS，SNMP等，如果用TCP则开销大（数据少性价比低）。UDP常用于多媒体应用等，因为可靠性不是最重要的，实时性才是。<br>UDP不保证可靠传输，不意味着应用对于数据要求是不可靠的，维护可靠性工作交给应用层来做。<br>UDP是面向报文的，发送方UDP对应用层交下来的报文，在添加首部之后就向下交付给IP层，一次发送一个报文，不合并不拆分，保留报文边界。一次交付一个完整报文，因此报文不可分割，是UDP数据报的最小单位。因此应用程序必须选择大小合适的报文，太长则会分片，太短则首部相对太长，两者都会降低IP层的效率。  </li><li>UDP首部格式：<br>首部有8B，四个字段组成，每个长为2B：<br>①源端口：源端口号，需要对方回信的时候，不需要可以为0。<br>②目的端口：目的端口号，在终点交付报文时必须用到。<br>③长度：UDP数据报长度，最小数8（仅有首部，没有数据）。<br>④校验和：监测UDP数据报传输中是否出错，出错丢弃，当不想校验时可使字段为0。  <img src="/2022/05076519/3.jpg" class="">    当传输层从IP获得UDP数据报的时候，就根据首部中目的端口号传送给相应端口进行分用。如果UDP发现收到端口号不正确，则丢弃该报文且由ICMP发送“端口不可达”给发送方。  <h3 id="UDP校验："><a href="#UDP校验：" class="headerlink" title="UDP校验："></a>UDP校验：</h3>计算校验和时，需要在UDP首部加上12B伪首部，得到一个临时UDP数据报，单纯为了计算校验和。检查首部和数据部分。<img src="/2022/05076519/4.jpg" class="">     计算过程：<br>发送方把全0放入校验和字段并添加伪首部，把UDP数据报视为许多16位字符串连接起来，若UDP数据报数据部分不是偶数个字节，需要填充一个全0字节（但不发送），按照二进制反码运算16位字的和，把此和的二进制反码写入校验和字段并发送。<br>接收方收到UDP数据报加上伪首部后，按二进制反码求16位字的和，无差错则全是1，否则有差错丢弃数据报。  <img src="/2022/05076519/5.jpg" class="">   注意：<br>校验时，若UDP数据报数据部分长度不是偶数，则填充一个偶数字节。<br>这种检错能力不强，但优点是简单，处理速度快。  <h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h3></li><li>TCP在不可靠IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠，有序，无丢失，不重复，特点如下：<br>①TCP是面向连接的。<br>②每条TCP只有两个端点，只能是点对点的。<br>③TCP传输的可靠，有序，无丢失，不重复。<br>④TCP提供全双工通信，两端都有发送和接收缓存，临时存放双向通信的数据。<br>其中发送缓存存放的是：①发送应用程序传送给发送发TCP准备发送的数据。②TCP以发送但尚未收到确认的数据。<br>接收缓存存放的是：①按序到达但未被接收应用程序读取的数据。②不按序到达的数据。<br>⑤TCP是面向字节流的，虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅视为玉莲船的无结构的字节流。  </li><li>TCP和UDP在发送报文时采用的方式完全不同，UDP报文的长度由发送应用程序决定，而TCP报文长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。如果应用程序传送到TCP缓存数据块太长了，TCP就把它划分短一些再传送，太短也可以积累到组成够多字节再组成报文段发送出去。  <h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3></li><li>TCP传送的数据单元是报文段，既可以来运送数据，又可以建立连接，释放连接和应答。一个TCP报文段分为首部，数据两部分，整个TCP报文段作为IP数据报的数据部分。首部前20B都是固定的，最短20B。  <img src="/2022/05076519/6.jpg" class="">  </li><li>各个字段意义：<br>源端口和目的端口：各占2B，端口是运输层和应用层的服务接口，运输层的复用和分用都需要通过端口实现。<br>序号：占4B，一共2的32次方个序号，TCP面向字节流，所以每个字节都需要按顺序编号，指的是本报文段所发送的数据的第一个字节的序号。<br>确认号：占4B，期望收到对方下一个报文段的第一个数据字节的序号，若确认号为N，咋表明N-1的所有数据都已经正确收到。<br>数据偏移：占4位，指出TCP报文段数据起始位置距离TCP报文段的起始处有多远。单位是32位，因此字段为15的时候，TCP首部最大长度是60B.<br>保留：占6位，保留位今后使用，先置为0.<br>紧急位URG：为1时标识紧急指针字段有效，告诉系统此报文段由紧急数据，应尽快传送，但需要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。<br>确认位ACK：仅当ACK=1时确认号字段才有效，当为0的时候，确认号无效。TCP规定，连接建立之后所有报文段都是ACK=1。<br>推送位PSH：接收方TCP收到PSH=1的报文段，尽快把它交付给应用程序，不等到缓存充满再交付。<br>复位位RST：RST=1时表明TCP连接中出现严重差错，必须释放连接，然后再重新连接。<br>同步位SYN：SYN=1时表明这是一个连接请求，当SYN=1且ACK=0的时候表明这是一个请求连接报文，对方同意连接则响应报文中SYN=1，ACK=1。<br>终止位FIN：释放一个连接，当FIN=1，表明此报文段的发送方的数据以及发送完毕，并要求释放连接。<br>窗口：占2B，指出现允许对方发送的数据量，接收方的数据缓存有限，因此用窗口值作为接收方让发送方设置其发送窗口的依据。（设为1000，说明接收缓存空概念还有1000字节数据）<br>校验和：占2B，校验和检验数据部分和首部，和UDP一样，加入12B的伪首部。<br>紧急指针：占2B，紧急指针仅在URG=1时有意义，指出在本报文段中紧急数据共多少字节。<br>选项：长度可变，TCP最初只规定了一个选项，即最大报文长度MSS。（数据部分最大长度）<br>填充：为了使得整个首部长度是4B的整数倍。  <h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3></li><li>三个阶段：连接建立，数据传送，连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。  </li><li>TCP连接建立过程，解决三个问题：<br>①使得每一方都能够确知对方存在。<br>②允许双方协商一些参数。<br>③能够对运输实体资源进行分配。<br>TCP连接两端的端口为套接字socket或插口，每条TCP被唯一的两个套接字确定，采用C/S方式，主动发起连接建立的应用进程称为客户Client，而被动等待连接建立的应用进程称为服务器Server。  </li><li>TCP连接建立：“三次握手”  <img src="/2022/05076519/7.jpg" class="">  连接建立之前，服务器进程属于LISTEN状态等待客户连接请求。<br>①客户机的TCP首先向服务器的TCP发送连接请求报文段，这个特殊报文段的首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不可以携带数据，但要消耗掉一个序号。这时，TCP客户端进程进入SYN-SENT状态。<br>②服务器的TCP收到连接请求报文段后，如果同意连接，则向客户机发挥确认，并为该TCP连接分配缓存和变量。在确认报文段中，把SYN和ACK都置为1，确认号是ack=x+1，同时也为字节选择的一个初始序号seq=y。注意，确认报文段不能携带数据，但也消耗一个序号。这时，TCP服务器进程进入SYN-RCVD状态。<br>③当客户机收到确认报文的时候，还要向服务器给出确认，并且为该TCP分配缓存和变量，确认报文段的ACK为1，确认号ack=y+1，序号为seq=x+1。该报文段可以携带数据，若不携带数据则不消耗序号。这时TCP客户进程进入了ESTABLISHED状态。<br>之上三步就连理了TCP连接，接下来就可以传送应用层数据了，全双工通信。值得注意的是：服务器端分配资源是在第二次握手的时候分配的，客户端的资源是在第三次握手时分配的。  </li><li>TCP连接的释放：“四次挥手”  <img src="/2022/05076519/8.jpg" class="">   ①客户机打算关闭连接，向TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文端的终止位FIN=1，序号seq=u，它等于前面已经传送过的数据的最后一个字节的序号+1，FIN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FIN-WAIT-1状态，但TCP全双工，即一条TCP连接上有两条数据通路，发送FIN的一端不可以发送数据，即关闭了一条数据通路，但对面还可以发送数据。<br>②服务器收到连接释放报文段后即发出确认，确认号ack=u+1，序号seq=v，等于前面已经传送过的数据的最后一个字节的序号+1，然后服务器进入CLOSE-WAIT状态，此时从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态，但服务器若发送数据，客户机仍要接受，即从服务器到客户机这个方向的连接并未关闭。<br>③若服务器已没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1的连接释放报文段，设该报文段的序号为w，还须重复上次已经发送的确认号ack=u+1。这时服务器进入LAST-ACK状态。<br>④客户机收到连接释放报文段之后，必须发出确认，把确认报文段中的确认位ACK置为1，确认号ack=w+1，序号seq=u+1.此时TCP连接还未释放，必须经过时间等待计时器设置的时间为2MSL（最长报文段寿命）后，客户机才进入CLOSED状态。  </li><li>总结：  <img src="/2022/05076519/9.jpg" class="">    <h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3>保证接收方进程从缓存区读取的字节流和发送方发出的字节流完全一致。使用了校验，序号，确认，重传的机制来达到这个目的（校验和UDP一样，不赘述）。  </li><li>序号：<br>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。每个字节都有编号，但序号字段指的是本报文所发送的数据的第一个字节的序号。  </li><li>确认：<br>TCP首部的确认号是期望收到对方下个报文段的数据的第一个字节的序号，TCP默认使用累计确认，即只确认数据流中至第一个丢失字节为止的字节。（即使已经收到了6-7字节，但3字节丢失，确认号仍然是3）  </li><li>重传：<br>有两种事件导致TCP对报文段进行重传：超时和冗余ACK。<br>①超时：<br>TCP每发送一个报文段，就会设置一次计时器，重传时间到期仍未收到确认就重传。<br>由于路由选择变化大，时延方差很大，所以为了计算重传时间，TCP使用自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（RTT），保留RTT加权平均往返时间RTTs，随着样本变化而变化，显然超时计时器设置的超时重传时间RTO应该略大于RTTs，但也不能太多，否则丢失时不能很快重传，导致数据传输时延过大。<br>②冗余ACK：<br>超时重传存在问题就是超时周期太长。但发送方可以在超时事件发生前通过注意所谓的荣誉ACK来较好地监测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方已经受到过该报文段的确认。TCP规定每当比期望序号大的失序报文段到达的时候，就发送i给冗余ACK，指明下一个期待字节的序号。当收到同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失，这属于快速重传技术。  <h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3></li><li>TCP流量控制来消除发送方使接收方缓冲区溢出的可能性，因此可以说流量控制是一个速度匹配服务。提供一种基于滑动窗口协议的流量控制机制，在通信过程中，接收方根据字节接收缓存的大小，动态调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，限制发送方向网络注入报文速率，同时发送方根据对齐当前网络拥塞程度估计而确定窗口值，称为拥塞窗口cwnd，其大小与网络带宽和时延密切相关。   <img src="/2022/05076519/10.jpg" class="">     </li><li>传输层和数据链路层的流量控制区别：<br>传输层定义端到端之间的流量控制，数据链路层定义两个中间相邻结点之间的流量控制，且数据链路层滑动窗口协议的窗口大小不能动态变化，而传输层的可以动态变化。  <h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3></li><li>拥塞控制是防止过多的数据注入网络，保证网络中的路由器/链路不至于过载。</li><li>拥塞控制与流量控制区别：拥塞控制让网络能够承受现有的网络负荷，是一个全局性过程，涉及所有的主机，路由器，以及与降低网络传输性能有关的所有因素，相反，流量控制则是点对点通信量控制，是端到端的维妮塔，只要抑制发送方速率以便于接收方来得及接收。  </li><li>因特网定义了拥塞控制的4种算法：慢开始，拥塞避免，快重传，快恢复。  </li><li>发送方确定发送报文段速率的时候，既要根据接收方接收能力，又要全局考虑不要使网络发生拥塞，因此TCP协议要求发送方维护以下两个窗口：<br>①接收窗口rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量，由接收方根据其放在TCP报文的首部窗口字段通知发送方。<br>②拥塞窗口cwnd，发送方根据自己估算的拥塞程度而设置的窗口值，反映当前容量，只要网络未出现拥塞，就可以把拥塞窗口再增大一些，以便把更多的分组发送出去，但只要网咯出现拥塞，拥塞窗口就减小一些。<br>③发送窗口上限=两者中小的那个。  </li><li>慢开始：<br>当TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd=1，即一个最大报文段长度MSS，每收到一个对新报文段的确认cwnd就加一。这个慢开始的“慢”并不是cwnd增加速度慢，而是开始先发送第一个报文段，然后开始逐渐增大cwnd，这对防止网络出现拥塞是一个非常有力的措施。使用慢开始算法后，每经历一个RTT，cwnd都会加倍，即指数型增长，这样，慢开始增到一个规定的慢开始门限ssthresh，然后改用拥塞避免算法。  </li><li>拥塞避免算法：<br>思路就是让拥塞窗口cwnd缓慢增大，具体做法是，没经历一个RTT，要把发送方的拥塞窗口+1，而不是加倍，线性缓慢增长，根据cwnd大小执行不同算法，可归纳如下：<br>①cwnd小于ssthresh，使用慢开始算法。<br>②cwnd大于ssthresh，停止使用慢开始算法改用拥塞避免算法。<br>③cwnd等于ssthresh，两者均可以使用，通常使用拥塞避免算法。 </li><li>网络拥塞处理：<br>无论慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到通知），就要把慢开始门限ssthresh设置为拥塞发送方的cwnd值的一半，然后把cwnd重新设置为1，执行慢开始算法，目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。  <img src="/2022/05076519/11.jpg" class="">     拥塞控制不能完全避免，是使网络不容易出现拥塞。  </li><li>快重传：<br>快重传使用冗余ACK监测丢包发生，而且冗余ACK也用于网络拥塞，当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待报文段重传计时器。  </li><li>快恢复：<br>原理：当发送方连续收到三个重复的ACK报文时，执行“乘法减小”算法，把慢开始门限ssthresh设置为此时发送方cwnd的一半。这是为了预防网络发生拥塞，但放生发认为现在网络没有发生拥塞，否则不会有几个报文段连续到达接收方，也不会连续收到重复确认，因此与慢开始不同的是，它把cwnd值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法（“加法增大”），跳过了从cwnd=1开始过程，所以称为“快恢复”。  <img src="/2022/05076519/12.jpg" class="">    </li><li>总结：TCP建立连接和网络超时时，采用慢开始和拥塞避免，当发送发接收到冗余ACK时，采用快重传和快恢复。快重传和快恢复是对慢开始和拥塞避免的一种改进。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>MSS设置太小，：网络利用率很低，如果TCP报文段只有1B数据，40B首部，则效率小于1/41，到了链路层还要进行开销，利用率进一步降低。<br>MSS设置太大：IP层传输进行分片，终端还要重组，传输有差错还要进行重传，都会增大开销。<br>所以，MSS应该尽量大些，只要到IP层不需要分片就行，最佳MSS很难确定，一般默认536B。  </li><li>最后一次挥手等待2MSL时间：<br>①保证A发送的最后一个确认报文段能够到达B，如果A不等待2MSL，若A返回最后确认报文段丢失，B就不能进入正常关闭状态，而A已经关闭无法重传。<br>②防止出现“已失效的连接请求报文段”，A发送最后一个确认报文段后，经过2MSL保证本连接持续时间内所有报文段从网络中消失。  </li><li>TCP和GBN区别：TCP正确收到但失序的报文不会丢弃而是缓存起来，并且发送冗余ACK指明期望收到的下一个报文段。而GBN就丢弃了。  </li><li>超时时间之后cwnd变为1，是因为拥塞程度更严重。<br>收到3个冗余ACK时cwnd减半，因为拥塞程度不是很严重，能收到冗余ACK。  </li><li>为什么不用“两次握手”建立连接？<br>为了防止两次握手情况下，已经失效的连接请求突然传送到服务器而产生错误。如果客户A向服务器B发出TCP连接请求，第一个连接请求报文长时间滞留，A超时认为丢失则重传，B收到之后建立连接，数据传输完毕断开连接，此时这个丢失的连接请求到达服务器B，而B认为A又发来连接请求，若使用“三次握手”，则B向A返回确认报文段，由于是一个失效的请求，因此A不予理睬，建立连接失败。  </li><li>TCP每次建立连接选择初始序号一定和前面的一些连接所用的序号不同。  </li><li>若网络不发生错误，无差错，TCP是不是多余？<br>不多余！！！<br>①数据到达目的结点会失序。<br>②由于路由计算错误，IP数据报在互联网中转圈，TTL=0，被丢弃。<br>③某个路由器通信量大处理不及时，有的数据报被丢弃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2022/050628245.html"/>
      <url>/2022/050628245.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>有一个排列P1P2P3PiPjPn，若Pi&gt;Pj，则称Pi和Pj为逆序，一个排列中所有逆序的全体叫做逆序数。  </p>  ]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网络层</title>
      <link href="/2022/05033405.html"/>
      <url>/2022/05033405.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络网络层"><a href="#计算机网络网络层" class="headerlink" title="计算机网络网络层"></a>计算机网络网络层</h1><img src="/2022/05033405/1.jpg" class=""><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p>网络层设计思路就是，向上提供简单灵活，无连接，尽最大努力交付的数据报服务。如果主机中进程之间的通信需要可靠的，可以由更高层的传输层负责。  </p><h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><ul><li>把全球网络互联需要解决不同的问题，网络层任务之一就是互联它们。所谓互联就是把两个及以上计算机网络通过一定方法，用一种/多种通信设备互相连接成为更大的网络系统，中间设备又称为中间系统/中继系统。  </li><li>中继系统分为四种：①物理层中继系统：中继器，集线器。②数据链路层中继系统：网桥，交换机。③网络层中继系统：路由器。④网络层以上的中继系统：网关。</li><li>但物理层的中继系统只是扩大网络，不算是互联，因此网络互联指的是路由器进行网络互连和路由选择。</li><li>由于参加互联的网络都使用相同的网际协议（Internet Protocol,IP）,因此把互联后的计算机网络视为全部连接到一个虚拟的IP网络，看不见网络异构的细节。  <h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3></li><li>路由器珠岙两个功能：路由选择，分组转发。</li><li>路由选择：根据特定路由选择协议构造出路由表，同时经常和相邻路由器交换信息不断更新维护路由表。得到整个网络拓扑变化情况，动态改变所选择路由。  </li><li>分组转发：转发表查询，转发，已经相关队列管理和任务调度等。由转发表把用户IP数据报从合适端口转发出去。</li><li>路由表根据路由选择算法计算出的，而转发表是从路由表得出的，转发表的结构应当使得查找最优化，路由表则需要对网络拓扑变化的计算最优化，往往笼统都是用路由表一词。<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3></li><li>通信子网中过量分组引起网络性能下降称为拥塞。一旦分组到达路由器速率到达带宽附近则时延就急剧增加，且大量分组被丢弃。</li><li>判断是否进入拥塞方法：看网络吞吐量与负载的关系。如果随着网络负载增加，吞吐量明显小于正常，则轻度拥塞，吞吐量减小则可能已经拥塞，吞吐量讲到零则进入死锁状态。</li><li>作用就是：确保子网能够承载所达到的流量，全局性的过程，涉及各方面的行为：主机，路由器及路由器内部的转发处理等过程。单一增加资源并不能解决拥塞控制。</li><li>拥塞控制与流量控制区别：流量是两端点对点通信量的控制，只需要限制发送速率。而拥塞控制必须保证通信子网能够传送待传送的数据，是全局性的，涉及所有主机，路由器以及导致网络传输能力下降的所有因素。</li><li>方法有两种：<br>①开环控制：设计网络前把因素考虑周到，力求网络工作不产生拥塞，这是静态预防的方法，一旦系统启动就不修改。手段包括：何时确定可接收新流量，何时丢弃分组，丢弃哪些分组，确定调度策略等，总之不考虑当前网络状态。静态的方法。<br>②闭环控制：设计网络前不考虑因素，采用监测系统及时监测哪里发生拥塞，把拥塞信息传送到合适地方，调整整个系统运行，动态的方法。<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h3></li><li>路由器转发分组通过路由表转发，而表则从算法得到的，路由算法分两类：<br>①静态路由算法（非自适应路由算法）：需要网络管理员手工配置的路由信息，网络拓扑结构或链路状态发生变化的时候，需要手工配置，不能及时更新网络状态，适用于简单小型网络。<br>②动态路由算法（自适应路由算法）：路由器相邻之间彼此交换信息，按照一定比例游湖出来，则这些路由信息在一定时间间隙不断更新，随时获得最优寻路效果。</li><li>静态路由简单开销小，拓扑变化不大的网络效果好。动态路由算法负责增加网络负担，反应太快引起震荡，太慢引起路由不一致。动态有两种方法：距离-向量路由算法，链路状态路由算法。<h3 id="距离-向量路由算法（DV）"><a href="#距离-向量路由算法（DV）" class="headerlink" title="距离-向量路由算法（DV）"></a>距离-向量路由算法（DV）</h3></li><li>所有结点都定期把它的路由选择表传送给所有与之直接相连的结点，路由选择表包括每条路径目的地和代价。所有结点都监听从其他结点传来的路由选择更新信息：<br>①当被通告一条新的路由，该路由在本结点路由表中不存在，此时本地系统加入这条新路由。<br>②当发来的路由信息中有一个到达某个目的地路由更短距离（更小代价）则替代原路由。  </li><li>实质是：迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短通路。但更新信息与子网结点个数成正比。  </li><li>最常见的距离-向量路由算法是RIP算法，采用”跳数“作为距离度量。  <h3 id="链路状态路由算法（LS）"><a href="#链路状态路由算法（LS）" class="headerlink" title="链路状态路由算法（LS）"></a>链路状态路由算法（LS）</h3></li><li>要求每个参与结点都具有完全的网络拓扑信息，执行两步骤：①主动测试所有临界点状态，②定期把链路状态传播给所有其他结点。一个结点检查链路状态，并把状态信息传给全网所有结点（不是相邻结点），每个结点都通过这种方式接收状态信息，通过这些状态信息来更新自己网络拓扑和状态图，一旦链路发生变化，则利用Dijkstra算法重新计算路由，计算单源最短路径。最常用的链路状态路由算法是OSPF算法。</li><li>三个特征：<br>①向本自治系统的所有路由器发送信息，使用泛洪法Flooding，即路由器通过所有端口向相邻路由器发送信息，而接收到之后又重复该过程（但不发给刚才发给自己的那个路由器）。<br>②发送的信息是与路由器相邻的所有路由器的链路状态，所谓”链路状态“就是本路由器与哪些路由器相邻以及链路的”度量“。对于OSPF算法，”度量“则是费用，距离，时延，带宽等。<br>③当链路状态发生改变才发送信息。  </li><li>优点：每个路由都独立计算自己的信息。链路信息不改变进行传播，易于查找故障。当一个结点接到所有其他节点的信息则可以计算自己的信息。<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3></li><li>当网络规模扩大时，路由表成比例扩大，不仅消耗路由器缓冲区空间，而且需要CPU更多时间来扫描路由表，更多带宽交换路由状态信息，因此必须按照层次方式进行。  </li><li>因特网把互联网划分许多小自治系统，每个系统都自主决定系统内采用何种路由选择协议，则两系统间通信就需要协议来屏蔽差异。</li><li>路由选择协议划分两大类：<br>①自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体有RIP和OSPF。<br>②自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也成为域间路由选择，具体有BGP。  </li><li>使用层次路由的时候，OSPF把自治系统再划分若干区域，每个路由器只需要自导自己区域如何路由即可。<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h3></li><li>IPv4即现在普遍使用的IP，IP定义数据传送的基本单元——IP分组以及确切的数据格式，也包括规则，指明分组如何处理，错误如何控制。特别是IP还包含了非可靠投递的思想，以及于此关联的分组路由选择的思想。</li><li>IPv4分组的格式：如图：  <img src="/2022/05033405/11.jpg" class="">  重要字段含义：<br>版本：IP的版本号，通常为4。<br>首部长度：占4位，最大进制15。<br>总长度：占16位，指的是首部和数据之和的长度，单位为字节，因此数据包最大长度为2的16次方-1=65535B，以太网MTU=1500B，因此IP数据报封装成帧的时候一定小于MTU。<br>标识：占16位。它是一个计数器，每产生一个数据报就加1，并且赋值给标识字段，但它并不是序号，因为IP不可靠服务，当一个数据报长度超过网络MTU时，必须分片，此时每个数据报片都需要复制一次标识号，以便能重新组装成原数据报。<br>标志：占3位，标志字段最低位为MF，MF=1表示后面还有分片，MF=0表示是最后一个分片，标志字段中间为DF，当DF为0的时候才允许分片。<br>片偏移：占13位，它指出较长的分组在分片之后，某片在原分组中的相对位置，片偏移以8个字节位偏移单位，每个分片的长度一定是8B的整数倍。<br>生存时间TTL：占8位数据报在网络中可以通过的路由器数量最大值，标识分组在网络中寿命，以确保不会永远在网络中循环。路由器在转发分组前，先把TTL减一，TTL=0丢弃分组。<br>协议：占8位，指出此分组携带的数据使用什么协议，即分组的数据部分应该交给那个传输层协议，如TCP，UDP等，其中值为6表示TCP，17表示UCP。<br>首部校验和：占16位，IP数据报首部校验和只校验分组的首部，不校验数据部分。<br>源地址字段：占4B，发送方IP地址。<br>目的字段：占4B，接收方IP地址。  </li><li>IP数据报分片：<br>①一个数据链路层数据报能承受的最大数据量为MTU，因为IP数据报被封装在链路层数据报中，因此MTU限制着IP数据报的长度。而且在IP数据报目的/源地可能不同的数据链路层协议，有不同的MTU。这时把IP数据报中数据分装在多个小的IP数据报中，称为片。<br>②片在目的地网络层被重新组装，目的主机使用IP首部标识，标志，片偏移字段来重组片，创建一个IP数据报的时候，源主机为该数据报加一个标识号，每个片的表示号一样，目的主机通过标识号来确定哪些片属于原始数据报。而IP首部中的标志位有3比特，但只有后2比特有意义，分别是MF和DF，DF为0时IP数据报才允许分片，MF=0代表后边还有片，MF=1代表是最后一片。目的主机重组的时候通过片偏移来确定数据报的各个片的位置。<br>③计算过程：  <img src="/2022/05033405/2.jpg" class="">   </li><li>网络层转发分组流程：<br>①从数据报首部提取目的主机IP地址D，得出目的网络地址N。<br>②若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这成为路由器的直接交付，否则是间接交付执行③。<br>③若路由器有目的地址为D的特定主机路由，则把数据报交给路由表中指定的下一跳路由器，否则执行④<br>④若路由表中有到达网络N的路由，则把数据报传给路由表中指定的下一跳路由器，否则执行⑤<br>⑤若路由表有一个默认路由，则把数据报传送给默认路由器，否则执行⑥<br>⑥报告转发分组出错。  <h3 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h3></li><li>IPv4地址：<br>①连接到互联网的每台主句都分配了一个32比特的全球唯一标识符，即IP地址，传统IP地址是分类的地址，分为ABCDE五类。由网络号+主机号组成，网络和标志主机所连接到的网络，一个网络号在整个互联网必须是唯一的，主机号标志该主机，主机号在该网络号范围内必须是唯一的，所以整个IP地址就是唯一的。<br>②五类IP地址：  <img src="/2022/05033405/3.jpg" class="">  ③各类IP地址有的不能用：<br>主机号全0表示网络本身，如202.98.174.0<br>主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255</li></ul><p>127.0.0.0保留为环回自检地址，表示任意主机本身，目的地址为该地址的IP数据报用不会出现网络上。<br>32位全为0，0.0.0.0表示本网络上的本主机。<br>32位全为1，255.255.255.255表示整个TCP/TP网络的广播地址，但由于路由器隔离广播域，则认为它为本网络的广播地址。<br>④常用ABC网络IP地址使用范围：  </p><img src="/2022/05033405/4.jpg" class="">   <p>⑤重要特点：<br>IP是分等级的地址结构，好处是：IP地址管理机构分配IP地址时只分配网络号，而主机号由网络自行分配。路由器根据网络号转发分组，不考虑主机号，减小路由器所占存储空间。<br>IP地址标志一条主机和一条链路的接口，当主机同时连接两个网络的时候必须有两个IP地址，则一个路由器必然至少有两个IP地址。<br>IP地址所有分配到网络号的网络都是平等的。  </p><ul><li>网络地址转换：<br>①Network Address Translation，NAT，通过把专用网络地址转换为公用网络地址，对外隐藏内部管理的IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网连通，由于本机IP地址可以重用，大大节省了IP地址消耗，同时隐藏内部网络结构，降低风险。<br>②为了网络安全，画出了部分IP地址为私有，私有IP地址只用于LAN，不用于WANianj，并且允许私有IP地址被LAN重复使用。在因特网中，路由器对于私有地址一律不予转发，称私有地址为专用互联网/本地互联网，<br>③使用NAT需要在专用互联网连接到因特网的路由器上安装NAT软件，NAT路由器至少有i一个有效的外部全球地址，NAT路由器使用NAT转换表把本地地址转换为全球地址或反向，这两个地址在转发表中是映射关系，可以多个私有IP地址映射到同一个全球地址。  <h3 id="子网划分与子网掩码，CIDR："><a href="#子网划分与子网掩码，CIDR：" class="headerlink" title="子网划分与子网掩码，CIDR："></a>子网划分与子网掩码，CIDR：</h3>①子网划分：<br>使得两级IP地址变为三级IP地址。子网划分属于内部事情，对外仍然表现为没有划分子网的网络，从主机号借用若干比特作为子网号，当然主机号也相应减少了相同的比特，三级IP地址=网络号+子网号+主机号。同样的路由器转发分组的时候现根据子网号找子网，再转发给目的主机。<br>注意：子网划分是把主机号再进行划分，不改变网络号。<br>②子网掩码：<br>对ABC类网络进行子网划分，必须使用子网掩码表示对于源网络中主机号的借位。它是一个32比特的二进制串，由一串1和跟随的0组成，1对应IP地址中网络号及其子网号，而0对应主机号，计算机只需要把它的IP地址和其对应的子网掩码逐位“与”就可以得到子网IP地址。未进行划分子网的有默认子网掩码：A类255.0.0.0，B类255.255.0.0，C类255.255.255.0。<br>子网掩码属于重要属性，所以路由器必须在相互交换路由信息的时候必须把自己所在的网络的子网掩码告诉对方，路由器每个条目，除了给出目的网络地址和下一跳地址外，还要给出目的网络的子网掩码。<br>③无分类域间路由选择（CIDR）：<br>无分类域间路由选择是在变长子网掩码基础上提出的一种消除传统ABC类网络划分，并且可以在软件支持下实现超网构造的一种IP地址划分方法。<br>特点：<br>CIDR使用网络前缀+主机号，即变成了无分类的IP地址。使用斜线技法——IP地址/网络前缀所占比特数。把网络前缀相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，称为路由聚合，使得原来多个传统网络分类地址的路由变成现在一个，减少路由器之间的路由选择信息的交换，提高网络性能。<br>优点在于网络前缀长度的灵活性，且使用最长前缀匹配。  <h3 id="ARP，DHCP，ICMP："><a href="#ARP，DHCP，ICMP：" class="headerlink" title="ARP，DHCP，ICMP："></a>ARP，DHCP，ICMP：</h3>①IP地址和硬件地址：<br>IP地址是网络层使用的分层地址。硬件地址则是数据链路层使用的平面式的地址（MAC地址），IP地址放在IP数据报的首部，而MAC地址放在MAC数据帧首部，通过数据封装把IP数据报分组封装成MAC帧之后，数据链路层看不见数据报分组中的IP地址。<br>由于路由器隔离，IP只能通过IP地址寻址，依靠路由表跳转到目标网络，改为在目标LAN中通过数据链路层的MAC地址以广播方式寻址。（路由器只根据目的地IP地址的网络号进行路由选择）<br>在局域网数据链路层只能看见MAC帧，通过路由器转发IP分组的时候，此IP分组在每个网络中都被路由器解封装和重新封装，因此MAC地址不断改变，所以MAC地址无法夸网络通信。<br>②地址解析协议ARP：<br>无论网络层使用什么协议，在实际网络的链路上传送数据帧的时候，最终必须使用硬件地址，所以需要从IP转化为MAC，这就是地址解析协议ARP，每台主机都有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表，使用ARP来动态维护此表。<br>工作在网络层：原理如下：主机A想向B发送数据报，先在其ARP告诉缓存中查看有无主机B的IP地址，有则查其MAC地址，再写入MAC帧，通过局域网发送到此MAC地址。没有则使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并且广播ARP请求分组，使得同一个局域网里所有主机收到ARP请求。主机B收到ARP请求之后向主机A发出响应ARP分组，分组包含B的IP和MAC映射关系，A收到之后写入缓存，然后按照查询的MAC发送分组。（用于解决同一个局域网上的IP与MAC映射关系，不在同一个局域网就要通过ARP找到一个位于本局域网的路由器MAC地址，由这个路由器进行分组转发给下一个网络）<br>③动态主机配置协议（DHCP）：<br>常用给主机动态分配IP地址，提供了即插即用的机制，允许一台计算机加入新网络和获取IP地址而不用手工参与，是应用层协议，基于UDP。<br>工作原理：使用C/S方式，需要IP地址的主机向DHCP服务器广播发送发现报文成为其客户，本地网络上所有主机都能收到此广播报文，但只有DHCP服务器能回复，DHCP服务器在其数据库查找是否有该计算机配置，有则返回信息，无则从服务器IP地址取一个地址分配给该计算机，称为提供报文。<br>DHCP服务器可能多个，客户端只需要挑选一个接收信息即可，通常是最先到达的。且分配的IP地址为临时的，称为租用期，数值应该由DHCP服务器自己决定，DHCP客户也可以进行要求。通过广播方式进行交互，因为客户端不知道服务器IP地址，而客户端没有IP地址，从而必须广播，且为UDP，因为没有IP地址无法使用TCP建立连接。<br>④网际控制报文协议（ICMP）：<br>为了提高IP数据报交付成功的机会，网络层使用ICMP让主机/路由器报告差错和异常情况，ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。有两种：ICMP差错报告报文和ICMP询问报文。  </li><li>差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，有五类：<br>终点不可达：路由器/主机不能交付数据报时。<br>源点抑制： 路由器/主机由于拥塞丢失数据报，应该把数据报的发送速率降低。<br>时间超过：路由器收到TTL=0的数据报时，除了丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定时间内不能收到一个数据报全部数据报片的时候就把已经收到的全部丢弃，并向源点发送时间超过报文。<br>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确的时候，就丢弃数据报，并向源点发送参数问题报文。<br>改变路由：路由器把改变路由报文发送给主机，让主机知道通过更好路由发送给另外的路由器。    </li><li>询问报文：有四种，回送请求和回答报文，时间戳请求和回答报文，掩码地址请求和回答报文，路由器询问和回答报文。  </li><li>ICMP常见的应用是分组网间探测PING（用来测试两台主机之间连通性）和Traceroute（跟踪分组经过路由），其中PING用了回送请求和回答报文，Traceroute使用了ICMP时间超过报文。PING工作在应用层，直接使用网络层ICMP，而Traceroute工作在网络层。  <h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6的主要特点"><a href="#IPv6的主要特点" class="headerlink" title="IPv6的主要特点"></a>IPv6的主要特点</h3>解决IP耗尽问题有三种：①采用CIDR无类别编址，使得IP地址分配更加合理。②采用网络地址转换NAT方法节省全球IP地址。③采用更大地址空间新版本IPv6。<br>IPv6特点：<br>①有更大地址空间，32位变成128位，字节数16B是4B的平方。<br>②扩展的地址层次。<br>③灵活的首部格式。<br>④改进的选项。<br>⑤允许协议继续扩充。<br>⑥即插即用（自动配置）。<br>⑦支持资源预分配。<br>⑧不允许分片。<br>⑨首部长度为8B的整数倍，而IPv4是4B的整数倍。<br>⑩增大了安全性，身份验证和保密功能是IPv6的整数倍。  <h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3>IPv6的数据报目的地址是：单播（传统点对点），多播（一对多，分组给一组计算机的每个），任播（IPv6增加的类型，数据报只交付给一组计算机的一台最近的计算机）。<br>使用了分级概念，三个等级：公共拓扑，单个场点，单个网络接口。  <h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3>AS，单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同度量来确定分组在该AS的路由，同时使用一种AS之间的路由选择协议来确定分组在AS之间的路由。一个自治系统的所有网络都由一个单位管线，且所有路由器都联通。  <h3 id="域间路由和域内路由"><a href="#域间路由和域内路由" class="headerlink" title="域间路由和域内路由"></a>域间路由和域内路由</h3>自治系统内部路由选择称为域内路由选择，外部称为域间路由选择。<br>①内部网关协议（Interior Gateway Protocol，IGP）：有RIP和OSPF。<br>②外部网关协议（External Gateway Protocol，EGP）：<br>若源站和目的站处于不同AS，则传送数据报的时候就需要使用一种协议把路由信息传递给另一个系统，这样的协议就是EGP，使用最多的就是BGP-4。  <img src="/2022/05033405/5.jpg" class="">    <h3 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h3>基于距离向量的路由选择协议（DV），最大优点就是简单。<br>①RIP规定：<br>网络中每个路由器都需要维护从它自身到其他每个目的网络的距离记录。<br>距离也称为跳数，每经过一个路由+1。<br>RIP认为好的路由就是跳数小，允许最多15跳，大于15则不可达，所以只使用小型互联网。<br>RIP默认两个使用RIP路由器之间每30s一次广播路由更新信息，以便建立更新维护路由表。<br>②RIP特点：<br>只和自己相邻路由器交换信息。<br>路由器交换信息是当前路由器所知道的全部信息，即自己的路由表。<br>按照固定时间间隔交换路由信息，如每隔30s。<br>③距离向量算法：<br>路由表有三个关键数据：目的网络N，距离d，下一跳路由器地址X。则每个RIP报文执行：  </li><li>地址X相邻路由器发来报文，修改此报文所有项目，把下一跳改为X，距离+1。  </li><li>对于修改后的RIP报文中每个项目要：当前路由表中没有目的网络N，则添加。有目的网络N且下一跳路由器是X则替换。有目的网络N且下一跳路由器不是X且新距离短则替换，距离长则不做改变。  </li><li>若180s没有收到更新路由表，把相邻路由器记作不可达路由器，距离设置为16。   </li><li>返回。<br>④优缺点：<br>优点就是实现简单，开销小，收敛过程快。<br>缺点就是RIP限制网络规模，能够使用最大距离为15。路由器之间交换的是完整路由表，网络规模越大开销越大。网络出现故障的时候出现慢收敛现象。<br>RIP是应用层协议，使用UDP传送数据，路径一定是路由器最少的路径，但不一定是时间最短的路径。  <h3 id="开放最短路径优先协议（OSPF）"><a href="#开放最短路径优先协议（OSPF）" class="headerlink" title="开放最短路径优先协议（OSPF）"></a>开放最短路径优先协议（OSPF）</h3>①OSPF的特点：</li><li>与RIP区别：<br>OSPF使用洪泛法向所有路由器发送信息。而RIP向相邻路由器发送信息。<br>OSPF发送信息是与本路由器相邻所有路由器的链路状态。而RIP是整个路由表。<br>OSPF当链路发生变化的时候才更新路由器。而RIP是定期更新。<br>OSPF是网络层协议，使用IP数据报传送。而RIP是应用层协议，使用UDP传送。  </li><li>OSPF还有自己的特点：<br>OSPF对于不同链路根据IP分组不同服务类型而设置不同代价，因此计算出不同路由，很灵活。<br>如果对同一个目的网络有多条代价相同的路径，则可以把通信量分配给这几条路径，称为多路径之间的负载平衡。<br>所有在OSPF路由器之间的交换分组都有鉴别功能，保证了仅在可信赖路由器之间交换链路状态信息。<br>支持可变长子网划分和无分类编址CIDR。<br>每个链路状态都有自己32位序号，序号越大，状态越新。<br>②OSPF基本原理：<br>各路由器之间频繁交换链路状态，因此都可以建立一个链路状态数据库，就是全网拓扑图，在全网范围内是一致的，然后用Dijkstra计算单源最短路径，构造自己路由表，更新之后继续计算构造新路由表即可。<br>为了使得OSPF能够用于更大的网络，需要把AS再次划分称为更小范围的区域，减小了通信量。<br>③OSPF的五种分组类型：<br>问候分组：用来发现和维持邻站的可达性。<br>数据库描述分组：向邻站给出自己链路状态数据库中信息。<br>链路状态请求分组：向对方请求发送某些链路状态项目的详细信息。<br>链路状态更新分组：用洪泛法对全网更新状态。<br>链路状态确认分组：对链路更新分组的确认。<br>通常10s，两个相邻路由器交换一次问候分组，知道哪些可达。路由器开始工作的时候，OSPF让每个路由器使用数据库描述分组和相邻交换本数据库中的信息，然后路由器使用链路状态请求分组，向对方请求发送自己缺少的某些链路状态项目的详细信息。经过一系列的分组交换，建立全网同步的链路状态数据库。<img src="/2022/05033405/6.jpg" class="">  <h3 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h3></li><li>常用于互联网网关之间，只求能找到一条到达目的网络且较好的路由，并非最佳路由，使用的是路径向量DV，BGP是应用层协议，基于TCP。  </li><li>工作原理如下：每个自治系统管理员选择一个路由器（可以多个）作为发言人，发言人之间交换路由信息（建立TCP连接），当所有的发言人都相互交换信息之后就可以找到各个自治系统的较好路由。  </li><li>特点：<br>AS数量级就是BGP的节点数量级，比AS中的网络数量小很多。<br>发言人数量很少，使得AS间的路由选择不复杂。<br>BGP支持CIDR。  </li><li>BGP一共使用4种报文：<br>①打开报文（Open），用来与相邻的另一个BGP发言人建立关系。<br>②更新报文（Update），用来发送某一路由的信息，以及列出要撤销的多条路由。<br>③保活报文（Keepalive），用来确认打开报文并周期性地证实邻站关系。<br>④通知报文（Notification），用来发送检测到的差错。<h3 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h3><img src="/2022/05033405/7.jpg" class="">  <h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP组播的概念"><a href="#IP组播的概念" class="headerlink" title="IP组播的概念"></a>IP组播的概念</h3></li><li>让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被他们正确接收。组播一定仅应用于UDP，TCP一对一不适用。让源主机把单个分组发送给一个组播地址，该组播地址标识一组地址，而一个主机可以属于多个组。  </li><li>主机使用IGMP协议加入组播组，它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组愿望。  </li><li>主机组播仅仅发送一份数据，路径分叉的时候才复制，因此大大减轻网络负载和发送者负担，组播需要路由器支持才能实现，能够运行组播协议的路由器称为组播路由器。  </li><li>组播和单播区别：  <img src="/2022/05033405/12.jpg" class="">  <h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3></li><li>使用D类地址，前四位1110，因此D类范围为224.0.0.0———239.255.255.255，每个IP地址标志一个组播组。  </li><li>组播数据报和IP数据报区别是：前者使用D类IP地址作为目的地址，并且首部协议字段为2，使用IGMP，需要注意的是：<br>①组播数据报是不可靠的，尽最大努力交付的。<br>②组播地址只能用于目的地址，不能用于源地址。<br>③对于组播数据报不产生ICMP差错报文，因此PING命令不响应。<br>④并非所有D类地址都可以是组播地址。  </li><li>组播地址分两种：本局域网内硬件组播，因特网内组播。  <h3 id="IGMP与组播路由算法"><a href="#IGMP与组播路由算法" class="headerlink" title="IGMP与组播路由算法"></a>IGMP与组播路由算法</h3></li><li>要使路由器知道组播成员信息，需要利用因特网组管理协议IGMP，连接到局域网上的组播路由器必须和因特网上其他组播路由器协同工作，以便把组播数据报以最小代价传送给所有组成员，所以使用组播路由选择协议。  </li><li>IGMP不知道IP组播包含的成员，而是让连接在本地局域网上的组播路由器知道主机是否参加/退出了某个组播组。  </li><li>IGMP工作两个阶段：<br>①某台主机加入新组买主机应该向组播组的组播地址发送一个IGMP报文，声明自己要成为成员，本地组播路由器收到以后，把组成员关系转发给因特网上的其他组播路由器。<br>②组成员是动态的，本地组播路由器周期性探询主机，看看是否还是成员。  </li><li>组播路由实际就是找出以源主机为根结点的组播转发树。  <h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h3 id="移动IP的概念"><a href="#移动IP的概念" class="headerlink" title="移动IP的概念"></a>移动IP的概念</h3></li><li>支持移动性的因特网体系结构与协议称为移动IP，为了满足移动结点在移动中保持连接性而设计的。确切的说，移动IP技术是指移动结点以固定IP地址跨越不同网段的漫游功能，且保证网络权限不发生改变。</li><li>基于IPv4的移动IP定义三种功能实体：<br>①移动结点：具有永久IP地址的移动结点。<br>②本地代理：一个网络环境中一个结点永久的“居所”称为归属网络，在归属网络中代表结点执行移动管理功能的实体为本地代理。<br>③外部代理：外部网络中帮助结点完成移动管理功能的实体为外部代理。  <h3 id="移动IP的通信过程"><a href="#移动IP的通信过程" class="headerlink" title="移动IP的通信过程"></a>移动IP的通信过程</h3></li><li>移动结点本地地址唯一且不变，所以本地网络链路上每个本地结点需要本地代理为它维护当前位置信息，需要引入转交地址。当移动结点连接到外地网络链路上时，转交地址用来标识结点现在所处位置，以便进行路由选择。移动结点本地地址和转交地址的联合称为移动绑定/绑定，当移动结点获得一个新的转交地址，通过绑定向本地代理注册，以便让本地代理了解移动结点所处位置。  </li><li>通信过程如下：<br>①移动结点连接本地网使用传统TCP/IP通信。<br>②漫游到外地网络，需要向本地代理注册当前位置地址，这个位置地址是转交地址。<br>③本地代理接收注册之后，构建一条通向转交地址的隧道，把截获的发给移动结点的分组通过隧道传给转交地址处。<br>④转交地址接触封装，回复原始IP分组，最后送到移动结点。<br>⑤移动结点在外网通过路由器/外部代理向通信对端发送数据包。<br>⑥移动结点来到另一个外网时，需要向本地代理更新注册的转交地址，就可以继续通信。<br>⑦移动结点回到本地网时，移动结点向本地代理注销转交地址，继续以TCP/TP进行通信。  </li><li>移动IP为主机设置两个IP地址，主地址和辅地址（转交地址）。移动结点本地网用主地址，移动另外网络使用临时辅地址，主地址不变。  <h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h3></li><li>路由器是一个具有多个输入/输入端口的专用计算机，任务是连接不同网络并完成路由转发。同一个网络传递无须路由器的参与，而跨网络通信必须通过路由器进行转发。</li><li>从结构上看，路由器由路由选择和分组转发两部分构成，路由器是网络层设备，实现了网络模型的下三层，即物理层，数据链路层，网络层。  <img src="/2022/05033405/8.jpg" class="">   </li><li>路由选择部分也叫控制部分，核心构建是路由选择处理机，其任务是根据所选定的路由选择协议构造出路由表，同时经常或者定期地和相邻路由交换路由信息不断更新维护路由表。  </li><li>分组转发部分由三部分组成：交换结构，一组输入和一组输入端口。输入端口从物理层接收到的比特流中提取出数据链路层的帧，从帧中提取出网络层数据报，输出端口则执行恰好相反的操作。交换结构则是关键部件，根据转发表对分组处理，把某个输入端口进入的分组从一个合适的端口转发出去，有三种常见方法：通过存储器进行交换， 通过总线进行交换，通过互联网络进行交换。  <h3 id="路由表和路由转发"><a href="#路由表和路由转发" class="headerlink" title="路由表和路由转发"></a>路由表和路由转发</h3>标准路由表有四个项目：目的网络IP地址，子网掩码，下一跳IP地址，接口。  <img src="/2022/05033405/9.jpg" class="">  转发表是由路由表得到的，格式不同，含有目的地址和下一跳MAC地址。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>尽最大努力的交付含义：有可能有差错，有可能不按时，有可能不按序，有可能重复，有可能意外丢失数据报。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络数据链路层</title>
      <link href="/2022/050135078.html"/>
      <url>/2022/050135078.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络数据链路层"><a href="#计算机网络数据链路层" class="headerlink" title="计算机网络数据链路层"></a>计算机网络数据链路层</h1><img src="/2022/050135078/1.jpg" class=""> <h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，把其可能出错的物理连接改造为逻辑上无差错的物理链路，使之对于网络层表现为一条无差错的链路。功能如下：</p><ul><li>为网络层提供服务：<br>①对于网络层，链路层基本任务就是把原机器来自网络层数据传输到目的机器网络层，提供三种服务。<br>②无确认的无连接服务：不需要连接，不发送确认，丢失帧不负责，适用于实时性强误码率低的通信信道，如以太网。<br>③有确认的无连接服务：不需要连接，但发送确认，源机器长时间没收到确认就重传帧，适用于误码率高的通信信道，如无线通信。<br>④有确认的面向连接服务：需要建立连接，每个帧都需要确认，适用于通信要求高的场合。<br>⑤有连接一定要有确定，不存在无确认的无连接服务。</li><li>链路管理：<br>数据链路层连接的建立，维持，释放的过程称为链路管理，主要用于面向连接服务，链路两端结点进行通信，必须首先确认对方已处于就绪状态，交换信息对帧序号初始化之后才能建立连接。多个站点公用一个物理信道如何分配和管理信号也属于管理范畴。  </li><li>帧定界，帧同步，透明传输：<br>①主机之间传输信息把网络层分组封装成帧，分别添加首部尾部，都包含很多控制信息，为了确定帧的界限，即帧定界。<br>②帧同步指的是接收方能够从接收到的二进制比特流中区分帧的起止。<br>③为了提高帧传输效率，应该使得数据部分长度尽可能大于首部和尾部，但每个协议都规定数据部分长度上限——最大传送单元MTU。<br>④数据部分恰好出现与帧定界相同的比特组合会误认为结束了，则采用透明传输————不管什么样的数据部分都能在链路上传送。</li><li>流量控制：<br>①由于收发双方各自工作速率和缓存空间差异，可能出现发送能力高于接收能力，如果不调整发送速率会使得未被接收的帧被后来的帧淹没而丢失，因此，流量控制就是限制发送方的数据流量，使得其发送速率不超过接收方的接收能力。<br>②需要反馈机制使得发送方知道接收方能否跟得上自己，需要知道何时才能发送下一帧，何时暂停发送。<br>③流量控制并不是链路层特有的功能，许多高层协议也有该功能，控制对象不同。链路层控制的是两结点之间的数据链路上的流量，运输层是端之间的流量。  </li><li>差错控制：<br>①由于噪声等因素，帧会出错，则用以使得发送方确定接收方是否正确收到其发送的数据的方法为差错控制，错误可以分为位错和帧错。<br>②位错使用循环冗余校验（CRC）的方法，通过自动重传请求（Automatic Repeat reQuest，ARQ）方式进行重传出错的帧。具体做法是：发送方的帧中包含一定CRC冗余码一并发送，接收方根据检错码对帧进行验证，错误就丢弃，发送方超时而重传，这种方法叫ARQ，只需要回复少量的控制信息就可以确定帧是否正确接收。<br>③帧错误包括丢失，重复，失序等，在链路层引入定时器和编号机制，超时或者编号缺少则重传，保证每帧都能传到目的结点。<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2>数据链路层为啥组帧——出错时只重发出错的帧而不是全部数据，提高效率。为了能够监测错误，必须依照一定规则把网络层的分组组帧。组帧解决帧定界，帧同步，透明传输等问题，有四个方法组帧：</li><li>字符计数法：帧头部有一个计数字段，缺点：如果头部出错就失去了帧边界，无法判断结束和下一个帧开始，直接失去同步，造成灾难性后果。</li><li>字符填充的首尾定界法：特殊字符定界开始和结束，数据中如果出现结束符，则在前边加上一个标识符比秒结束，接收方遇见标识符删去即可得到原来数据。 <img src="/2022/050135078/2.jpg" class=""> </li><li>零比特填充的首尾标志法：还能进行透明传输，如图：  <img src="/2022/050135078/3.jpg" class=""> </li><li>违规编码法：物理层进行比特编码的时候常用违规编码法，借用违规的编码序列来标志开始和结尾，不需要任何填充技术，便实现透明传输，只适用于冗余编码的特殊编码环境。  </li><li>目前常用比特填充和违规编码法。<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2>实际通信传输中可能产生比特差错，通常利用编码技术进行差错控制，主要有两类：自动重传请求ARQ和前向纠错FEC。在ARQ中接收端检测出错的时候通知重发直到正确，FEC中可以确定比特串错误位置进行纠正，因此可以分为检错编码和纠错编码。</li><li>检错编码：检错编码都是采用荣誉编码技术，核心思想就是在有效数据发送前按照某种关系附加一定冗余位，构成一个符合某规则的码之后再发送，当发送数据发送变化的时候，相应冗余位也变化，常见的有奇偶校验码和循环冗余码。<br>①奇偶校验码：由n-1位信息元和1位校验元组成，如果是奇校验码则n个码字中1的个数为奇数，偶校验码则为偶数。只能校验是否出错，不知道出错情况。<br>②循环冗余码：CRC，熟练掌握计算过程！！！给定一个m位的帧/报文，发送器生成一个r位的序列称为帧检验序列FCS，形成的帧由m+r位组成，事先双方商定一个G（x）作为检验，可以被整除无余数即可认为无差错。（其实CRC有纠错功能，但链路层没用到）</li><li>纠错编码：最常见的就是海明威码，熟练掌握计算过程！！！原理是有效信息位中加入几个校验位形成海明码，并且把海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错之后会引起有关的几个校验位的值发生变化，不但能发现错位还能找到其位置，为自动纠错提供依据。<h2 id="流量控制与可靠性传输机制"><a href="#流量控制与可靠性传输机制" class="headerlink" title="流量控制与可靠性传输机制"></a>流量控制与可靠性传输机制</h2></li><li>流量控制，可靠传输与滑动窗口机制：<br>①流量控制对帧的发送速率，以便接收方有足够的缓冲空间来接收每个帧。基本方法由接收方控制发送方发送速率，常见方法有两种：停止-等待协议和滑动窗口协议。<br>②停止-等待协议：基本原理就是发送方每发送一帧都要等待接收方应答才发送下一帧，接收方同理，不反馈则会一直等待，因此效率很低。<br>③滑动窗口协议： 在任意时刻，发送方都维持一组连续的允许发送的帧的序号，为发送窗口，同理接收方的接收窗口。而发送窗口大小指的是接收方未发送确认信息前还能发送多少个数据帧。同时接收窗口只有收到数据帧序号落入接收窗口内才能把帧收下，窗口外直接丢弃。同时发送方每收到一个确认帧就前移一个位置，当发送窗口没有可以发送的帧的时候就停止直到收到确认，接收方也是收到数据帧之后前移并发回确认帧。<br>滑动窗口特性：<br>只有接收窗口前移，发送窗口才能前移。<br>接收窗口大小为1的时候可以保证帧的有序接收。<br>窗口大小在传输过程中是固定的。<br>④可靠传输机制：经常使用确认和超时重传两种机制完成，ARQ就是处理差错的方法之一，常见ARQ有：停止等待ARQ，后退N帧ARQ，选择性重传ARQ。在数据链路层中，流量控制和可靠性传输交织在一起。  <img src="/2022/050135078/4.jpg" class="">  <img src="/2022/050135078/5.jpg" class="">  </li><li>单帧滑动窗口和停止等待协议：<br>①停止等待是发送和接收窗口均为1的滑动窗口，单帧。<br>②除了数据帧丢失之外，还存在两种差错：帧遭到破坏和数据帧正确确认帧错误。<br>③帧遭到破坏被检测出来之后丢弃，发送方有计时器，长时间未接到确认就重复发送直到成功。<br>④信道利用率太低，所以产生了后退N帧协议和选择重传协议。<img src="/2022/050135078/6.jpg" class="">  </li><li>多帧滑动窗口和后退N帧协议（GBN）：<br>①发送方无须收到上一个帧确认才发送下一个帧，而是可以连续发送，当接收方检测到失序的帧时要求发送方发送最后一个正确接收的帧和之后的所有未被确定的帧，也就是————接收方只能按照顺序接收帧。<br>②为了节省开销，接收窗口并不是接到一个帧就确认一个，而是几个帧再确认，说明最后一个帧之前的所有帧都收到了。<br>③接收窗口=1，保证按顺序接收帧，提高信道利用率，但重传有时候把自己传输正确的帧也重传了，这种做法又使得传输效率降低，所以信道质量差的时候效率不一定比停止等待协议高。</li><li>多帧滑动窗口和选择重传协议（SR）：<br>①为了提高信道利用率，设法只重传出错的数据帧/计时器超时的数据帧，但必须加大接收窗口大小，以便先收下发送序号不连续但仍在接收窗口中的那些帧，等到所缺的帧收到之后再一并送交主机。<br>②每个发送缓冲区对应一个计时器，超时就会把缓冲区内重传。接收和发送窗口大小均&gt;1，一般来说大小相同，使用累计确认的方法。<br>③SR确实避免了重传正确的帧，但需要在接收方缓冲区存储正确的帧，缓冲区的数目大小等于窗口的大小。</li><li>从滑动窗口概念来看，停止等待协议的发送窗口大小=1，接收窗口大小=1。后退N帧协议的发送窗口大小&gt;1，接收窗口大小=1。选择重传协议的发送窗口大小&gt;1，接收窗口大小&gt;1。 <h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2>介质访问控制为了使用介质每个结点隔离来自同一信道其他结点传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制层子层（Medium Access Control，MAC）。若干结点如果使用同一个信道可能会相互干扰。常见方法有：信道划分介质访问控制（静态划分方法），随机访问介质访问控制（动态划分方法），轮询访问介质访问控制（动态划分方法）。</li><li>信道划分介质访问：<br>①将使用介质的每个设备与其他设备通信隔离开，把时域和频域资源合理分配给网络上设备。<br>②多路复用：当介质带宽超过传输单个信号所需要的带宽时，人们通过在一条介质上传输多个传输信号的方法提高信道利用率。采用多路复用技术可以把多个输入通道信息整合到一个复用通道里，接收端把收到的信息分离出来并传送到对应的输出通道。<img src="/2022/050135078/7.jpg" class="">   ③信道划分的实质是分时，分频，分码等方法把原来的一条广播信道逻辑上分为若干条互不干扰子信道，实际是把广播变成点对点信道。<br>④频分多路复用FDM：把信道总带宽划分为单个信号带宽相同的子信道，每个子信道传输一种信号。每个子信道带宽可以不相同，但总和必须小于总带宽，为了防止相互干扰加入“保护频带”，优点就是充分利用带宽，系统效率搞，技术简单实现容易。<br>⑤时分多路复用TDM：时分多路复用把物理信道按照时间分为若干时间片，轮流分配给多个信号使用，每个时间片由复用的一个信号占用，其中STDM是动态分配信道时间（一个用户可以占用全部时间片，效率加倍）。  <img src="/2022/050135078/8.jpg" class=""> ⑥波分多路复用WDM：即光的频分多路复用，波长（频率）不同，互不干扰。<br>⑦码分多路复用CDM：不同编码区分各路原始信号，举个例子：<br>实际上也叫码分多址CDMA，把比特时间划分为m个端的时间槽，称为码片，通常m为64/128。举例m为8，每个站点被指派了一个唯一的m位的码片序列，发送1时站点发送它的码片序列，0时也方该码片序列的反码，当两个站点同时发送的时候，各路数据在信道中线性相加。为了分理出各路信号，要求各个站点码片序列相互正交。优点：频谱利用率高，抗干扰能力强，保密性强等。<img src="/2022/050135078/9.jpg" class=""> </li><li>随机访问介质访问：<br>不采用集中控制方式解决发送信息次序，所有用户都能偶根据自己意愿随机发送信息，占用信道全部速率。总线型网络中，两个或以上用户发送信息的时候产生冲突，为了解决冲突，每个用户需要按照规则反复重传他的帧，直到无碰撞的通过。常用的协议有：ALOHA，CSMA，CSMA/CD，CSMA/CA，核心思想都是胜利者获得权力发送信息，因此又称为挣用型协议。实质上随机访问介质访问把广播信道转化为了点到点信道。<br>①ALOHA协议：<br>又分为两种——纯ALOHA和时隙ALOHA。<br>纯ALOHA：基本思想时当网络中任何一个站点需要发送数据时，可以不经检测直接发送数据，如果在一段时间内未收到确认，那么该站点就认为传输过程中发生冲突，发送站点需要等待一段时间再发送数据，直至发送成功。重传策略则是各站等待随机时间进行重传。但吞吐量低，改进得到时隙ALOHA。<br>时隙ALOHA：把所有站点时间同步起来，把时间划分为登场时隙SLOT，规定只能在每个时隙开始时发送一个帧，避免随意性，减少冲突可能，提高信道利用率。重传策略和ALOHA相似。吞吐量比ALOHA大一倍。<br>②CSMA协议：<br>如果每个站点发送前都侦听一下信道，空闲再发送就大大减少冲突的可能，从而提高信道利用率，载波侦听多路访问（Carrier Sense Multiple Access，CSMA）就是这个思想，比ALOHA多了一个载波侦听装置。而CSMA又分三种：<br>1-坚持CSMA：侦听到信道空闲则发送，忙则继续侦听直到空闲，如果冲突则随机等待一个时间重复上述过程。但传播延迟使得1-坚持CSMA仍然会发生冲突。<br>非坚持CSMA：侦听到信道空闲则发送，忙则放弃侦听，随机等待一个时间重复过程。侦听到忙碌就放弃了，降低了冲突概率。<br>p-坚持CSMA：用于时分信道，侦听到信道空闲则发送，忙则继续侦听直到空闲，空闲则有p的概率发送给数据，以1-p的概率推迟到下一个时隙，下一个时隙重复该过程。<img src="/2022/050135078/10.jpg" class="">   ③CSMA/CD协议：<br>载波侦听多路访问/碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA/CD）是CSMA改进方案，适用于总线型网络/半双工网络，而碰撞监测则是边发送边侦听，判断是否其他站点也在发送数据。工作过程概括为“先听后发，边听边发，冲突停发，随机重发”————只能半双工通信，不能同时收发。<br>为了确保发送数据同时监测是否碰撞，需要发送之前就能收到自己发送出去的数据，即帧传输时延至少两倍于信号在总线上的传播时延，才能保证无碰撞，所以CSMA/CD总线中所有数据帧都需要大于一个最小帧长，小于最小帧长当作无效帧丢弃（非要发就需要填充字段到最小帧长），最小帧长=总传播时延X数据传输速率X2。<br>除此之外，CSMA/CD冲突之后采用退避算法解决碰撞问题，第k次重传，就从0-2的k次方-1之间抽随机数，随机数乘以争用期得到重传的时间。该算法求出的时间随着重传时间增大而增大，降低发生碰撞概率。  <img src="/2022/050135078/11.jpg" class=""> ④CSMA/CA协议：<br>CSMA/CD协议已经成功用于有线连接局域网。无线网中并不适用，所以802.11标准则定义了CSMA/CA，其中CA为Collision Avoidance碰撞避免，尽量避免碰撞发生。为了尽量避免，802.11规定所有站发送完之后必须等一段时间才发送下一帧，称为帧间间隔（InterFrame Space,IFS），其长短取决于帧类型，有三种：SIFS(短IFS)，PIFS（点协调IFS），DIFS（分布式协调IFS）。<br>⑤CSMA/CA与CSMA/CD区别：<br>CSMA/CD可以监测冲突但没法避免，CSMA/CA尽量避免但有可能冲突。<br>传输介质不同：CSMA/CD用于总线型以太网，CSMA/CA用于无线局域网802.11 a/b/g/n等。<br>监测方式不同：CSMA/CD通过电缆中电压变化监测，而CSMA/CA通过能量监测，载波监测，能力载波混合监测三种监测方式。<br>总结：CSMA/CD基本思想先侦后发，边发边侦，而CSMA/CA则是发送前先广播告知其他结点短时间内别发数据，以免出现碰撞。  </li><li>轮询访问介质访问控制：令牌传递协议<br>①用户不能随机发送信息，而是通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道分配，信道只有一个结点使用。 典型的就是令牌传递协议——用于令牌环局域网中。<br>②令牌传递协议中，令牌以固定次序交换，它是一组特殊比特组成的帧。环上的站希望传送帧时必须等令牌，收到令牌即可发送数据。令牌上包括目的地址，标示这哪个站点接收，令牌在环上进行传送。不需要发送数据的时候，令牌就在环形网上游荡，令牌只有一个，不会冲突。网络中物理拓扑不是一个环，逻辑上是一个环，适合负载高的广播信道，用其他的协议则会冲突概率很大，没有共享空间和时间。<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h3>①局域网（Local Area Network，LAN）指的是较小的地理范围内，把各种计算机，外部设备，数据库系统通过双绞线，同轴电缆等介质相互连接起来，组成资源和信息共享的计算机互联网络。<br>②特点：<br>一个单位所拥有，地理范围站点数目有限。<br>所有站点共享较高的总带宽。<br>较低的时延和较低的误码率。<br>各站为平等关系而非主从关系。<br>能进行广播和组播。<br>③拓扑结构，传输介质，介质访问控制方式决定了局域网技术特性。<br>拓扑结构有：星形结构，环形结构，总线型结构，星型和总线型复合结构。<br>传输介质有：双绞线，铜缆，光纤等，双绞线为主流。<br>介质访问控制方式有：CSMA/CD，令牌总线，令牌环，前两种方式用于总线型，后一种为环形局域网。<br>④三种特殊局域网：<br>以太网：目前适用范围最广局域网，逻辑拓扑总线形结构，物理拓扑是星型/拓展星型。<br>令牌环：逻辑拓扑环形结构，物理拓扑是星型。<br>FDDI：逻辑拓扑环形，物理拓扑是双环形。<br>IEEE 802标准把数据链路层拆为两个子层逻辑链路控制层LLC和媒体接入控制层MAC。其中与接入传输媒体有关内容都在MAC，它向上屏蔽物理层访问差异，提供对物理层同意统一接口，主要功能有：组帧和拆卸帧，比特传输差错检测，透明传输，而LLC向网络层提供无确认无连接，有确认无连接，有确认有连接，告诉传送四种不同连接服务。<h3 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h3>以太网采用总线型拓扑结构，所有计算机共享总线，信息以广播形式发送，以太网简化CSMA/CD进行访问控制。802.3局域网简称以太网。以太网采用两种方式简化通信：①采用无连接工作方式，不可靠服务，纠错由上层完成。②使用曼彻斯特编码，每个码元中间出现一次电压转换，利用其提取出来同步信号。<br>①以太网传输介质与网卡：<br>常用传输介质由粗缆，细缆，双绞线，光纤，各种介质适用情况见下表：  <img src="/2022/050135078/12.jpg" class=""> 计算机与局域网连接通过主机箱内插入的一块网络接口板（网络适配器Adapter或网络接口卡NIC），网卡上有处理器和存储器，工作在链路层的组件。网卡不仅实现与传输介质之间的物理连接和电信号匹配，还涉及到帧的发送和接收，帧的封装和拆封，介质访问控制，数据编码与解码，数据缓存等功能。每块网卡有一个独一无二的介质访问控制地址（MAC地址），数据链路层都是用MAC地址。<br>②以太网的MAC帧：<br>也称物理地址，长度为6字节，由12个16进制数表示。由于使用总线广播，则检查MAC帧，符合就接收否则丢弃。帧格式有两种：DIX Ethernet V2标准和IEEE 802.3标准。<br>Ⅰ：DIX Ethernet V2标准：<br>前导码：使接收端和发送端时钟同步，在帧前面插入的8个字节可以再分为两个字段，一个字段7字节为前同步码，第二个是帧开始定界符，表示后边的信息是MAC帧。<br>地址：通常使用6字节地址MAC地址。<br>类型：2字节，指出数据应该用哪个协议实体处理。<br>数据：46-1500字节，包含高层协议信息，由于CSMA//CD协议长度限制最小为64，不够需要填充。（64-18=46，首尾共18字节）<br>填充：0-64字节。<br>校验码FCS：4字节，范围从目的地址段到数据末尾，采用32位CRC码，不但检验MAC帧数据部分，还有目的地址，源地址，类型字段，但不校验前导码。 <img src="/2022/050135078/13.jpg" class="">  Ⅱ：IEEE 802.3标准：不同之处就是长度域代替了DIX帧中的类型域，指出数据域长度。<br>③高速以太网：<br>速度超过100Mb/s的以太网。有三种：<br>Ⅰ： 100BASE-T以太网：双绞线上传送100Mb/s基带信号的星形拓扑结构以太网，使用CSMA/CD协议，全双工/半双工均可，全双工不用CSMA/CD。<br>Ⅱ：吉比特以太网：1G/s下全双工/半双工工作，半双工使用CSMA/CD。<br>Ⅲ：10吉比特以太网：10G/s下使用光纤作为传输媒体，只全双工。  <h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3>无线局域网分为两类：有固定基础设施无线局域网和无固定基础设施移动自组织网络。<br>①有固定基础设施无线局域网：<br>对于有固定基础设施，IEEE指定了802.11系列协议标准。802.11使用星形拓扑，中心称为接入点（Access Point，AP），MAC层使用CSMA/CA协议，又称Wi-Fi。<br>无线局域网最小构件是基本服务集BSS（Basic Service Set，BSS），包括一个基站和若干移动站，BSS内部之间通信，外部则通过基站通信，AP就是基站，安装AP时需要给它分配一个不超过32字节的服务集标识符SSID和一个信道，一个BSS覆盖范围称为一个基本服务区BSA，一般不超过100m。<br>一个基本服务区BSA可以独立，也可以通过AP连接到一个分配系统DS，然后连接到另一个基本服务集，构成扩展的服务集ESS，通过一种叫做Portal（相当于网桥）的设备为无限用户提供有线连接的以太网接入。如图，A想要连接B则经过AP1和AP2即，A-&gt;AP1-&gt;AP2-&gt;B，注意AP1和AP2是有线传输。  <img src="/2022/050135078/14.jpg" class=""> ②无固定基础设施移动自组织网络：<br>又叫做自组网络，一些平等状态的移动站相互动心组成的临时网络，各节点地位平等，中间结点为转发结点，都有路由器的功能。<br>通常可移动设备发现附近有其他可移动设备，要求进行通信，网络中每个移动站都参与其他移动站的路由的维护和发现。  <h3 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h3>令牌环网每一站都通过电缆与环接口干线耦合器TCU连接（TCU为了传递所有经过的帧，为介入站发送接收数据提供接口，有收听状态和发送状态），数据总在一个方向上从一个TCU到另一个TCU传输。只有一个结点独占信道，不发生碰撞，令牌Token就是一个数据帧。<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>覆盖范围广的长距离网络，是因特网核心部分。因此连接广域网结点的交换机为高速链路，且容量足够大便于以后扩充。广域网不等于互联网（互联网可以连接不同类型网络，使用路由器），广域网是由结点交换机和连接交换机的链路组成。（交换机不是路由器，结点交换机和路由器均转发分组，而交换机在单个网络中转发，路由器则是多个网络构成的互联网中转发），交换机存储转发分组，一个交换机与多个相连。<br>局域网和广域网区别于联系：  <img src="/2022/050135078/15.jpg" class=""> <h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3>①Point-to-Point Protocol,是使用串行线路通信的的面向字节的协议，直接应用在两个结点的链路上，目的通过拨号/专线来建立点对点连接发送数据，使其称为各种主机，网桥，路由器之间简单连接的共同解决方案。<br>②由SLIP协议发展来的，异步同步线路均可，而SLIP主要完成数据包传送，只能传输IP分组，且对于高层应用不支持，为了改进指定了PPP。<br>③三个部分组成：<br>链路控制协议LCP：用于建立，配置，测试，管理数据链路。<br>网络控制协议NCP：PPP允许多种网络层协议，不同网络层协议对应一个不同NCP配置，为网络层协议建立和配置逻辑连接。<br>一个把IP数据包封装到串行链路的方法：IP数据报就是在PPP帧中的信息部分，长度收到MTU限制。<br>④PPP帧格式如图：PPP面向字节的，所以帧长度都是整数个字节。  <img src="/2022/050135078/20.jpg" class="">  ⑤PPP提供差错监测但没有纠错，只保证无差错接收，不可靠的传输协议，不使用序号和确认机制。仅支持点对点链路通信。只支持全双工链路。不同网络协议仍然可以使用一个PPP通信（帧上有协议字段）<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3>①高级数据链路控制协议，是ISO面向比特指定的数据链路层协议，它不依赖任何一种字符集编码，数据包可以透明传输，全双工通信，采用CRC检验，对于信息帧进行顺序编号防止漏发重发。适用于链路的两种配置：非平衡配置（由一个主站控制整个链路）和平衡配置（若干平等站相互传输）。<br>②站：HDLC有三种站类型：主站，从站，复合站。主站负责控制链路，发出的帧为命令帧。从站受控于主站，发出的帧为响应帧。复合站综合二者，发出帧可以是命令也可以是响应帧。<br>③数据操作方式：<br>正常响应方式：非平衡方式，主站传输，从站接收，但从站只有得到主站许可才能进行响应。<br>异步平衡方式：平衡方式，每个复合站都可以对其他站进行传输数据。<br>异步响应方式：非平衡，从站即使未接收主站许可仍然可以进行响应。<br>④HDLC帧：如图：  <img src="/2022/050135078/16.jpg" class=""> ⑤PPP和HDLC帧的区别：<br>PPP面向字节，HDLC面向比特。<br>PPP比HDLC多一个2字节的协议字段，当字段为0x0021时信息字段为IP数据报。<br>PPP不使用序号和确认机制，不可靠，由高层协议负责。而HDLC使用了，可靠。  <h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥概念及其基本原理"><a href="#网桥概念及其基本原理" class="headerlink" title="网桥概念及其基本原理"></a>网桥概念及其基本原理</h3></li><li>两个或者多个以太网通过网桥连接称为一个覆盖更大的以太网，原来一个以太网称为一个网段，网桥工作在MAC子层，可以使得以太网个网段称为隔离开的碰撞域。”隔离开的互不影响“。  （网桥处理帧所以是数据链路层，中继器放大器处理信号所以是物理层）  </li><li>一个网段内部发送帧直接发送，而不同网段才通过网桥，需要验证MAC地址是否是内部。每个网段数据率为10Mb/s，三个网段的最大吞吐量就是30Mb/s，换成放大器就是10Mb/s。  </li><li>基本特点：<br>①具备寻址和路径选择的能力，确定帧传输方向。<br>②从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧。<br>③网桥连接不同网络之间存储并且转发帧，可以使用不同协议，进行协议转换。<br>④网桥对于帧不做修改/少量修改，单纯转发。<br>⑤网桥应该有足够大缓冲空间，因为在短时间内帧到达速率可能高于转发速率。  </li><li>优点：<br>①过滤信息量。<br>②扩大物理范围。<br>③可以使用不同物理层。<br>④可以互联不同局域网。<br>⑤提高可靠性。<br>⑥性能改善。  </li><li>缺点：<br>①增大了时延。<br>②MAC子层没有流量控制功能。<br>③不同MAC子层的网段连接的时候需要进行帧格式转化。<br>④网桥适合用户不多，通信量不大的居于发，否则有可能网络拥塞。</li><li>网桥必须有路径选择功能，选择正确路径，根据路径算法不同分为透明网桥和源路由网桥。<br>①透明网桥：接收每一个帧，若是源LAN和目的LAN一样则丢弃该帧，不一样则转发该帧，若目的LAN位置则扩散该帧（扩散给输入网段外的所有网段）。刚连接进以太网转发表为空，逐渐建立转发表。使用一个生成树算法得到若干路径，但不一定是最佳路由。<br>②源路由网桥：路由选择由发送数据帧的源站负责，网桥只负责接收和转发。而源站通过广播方式向目的站发送一个发现帧，途中每个网桥都转发此帧，最后发现该帧可以从多个途径到达目的站，目的站一一发送应答帧，每个应答帧原路返回，途径网桥把自己标记在应答帧中，然后源站选一个最佳路由。  <h3 id="局域网交换机概念及其基本原理"><a href="#局域网交换机概念及其基本原理" class="headerlink" title="局域网交换机概念及其基本原理"></a>局域网交换机概念及其基本原理</h3></li><li>桥接器主要限制在任意时刻只能执行一个帧的转发操作，则出现了交换机。本质上就是多端口网桥，分隔隔离初多个冲突域，各个网段都有更高带宽。  </li><li>原理：监测源和目的地MAC，然后系统内部动态查找表比较，若不在则加入查找表，并发送给相应端口。</li><li>特点：<br>①每个端口都与单台主机连接，工作方式为全双工。<br>②可以同时连接多对端口，每对主机都像独占信道一样无碰撞交换数据。<br>③以太网即插即用（和透明网桥一样），内部帧转发表也是通过自学习逐渐建立起来的。<br>④交换速率高，独占传输媒体的带宽（传统10Mb/s以太网，有N个用户，有N个端口的交换机的总容量为N*10Mb/s）。</li><li>两种交换模式：<br>①直通式 ；只检查目的地址，立马传出去，这种方式速度快但缺乏智能和安全，无法支持不同速率的端口的交换。<br>②存储转发式：先收到帧缓存到告诉缓存器中，检查是否正确，无误则通过查找表转换成为输出端口转发，有错则丢弃。优点是可靠性高，支持不同速率端口之间的转换，缺点就是延迟大。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>链路与数据链路：<br>链路：是物理线路，无结点，路径的组成部分。<br>数据链路：除了物理线路还有一些通信协议控制数据传输。</li><li>局域网，广域网，因特网总结：<br>广域网视为大局域网，就是交换机连接多个局域网组成广域网，但仍是一个网络。而因特网则是多个网络之间的互联，由广域网和局域网通过路由器相连。</li><li>冲突域和广播域：<br>一块网卡发送信息只要可能与另一个冲突，则可能冲突的网卡构成冲突域，而一块网卡发送广播，所有能接到的网卡就是广播域。一般来说，一个网段就是冲突域，一个局域网就是广播域。  <img src="/2022/050135078/17.jpg" class=""> <img src="/2022/050135078/18.jpg" class=""> <img src="/2022/050135078/19.jpg" class=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络物理层</title>
      <link href="/2022/050114293.html"/>
      <url>/2022/050114293.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络物理层"><a href="#计算机网络物理层" class="headerlink" title="计算机网络物理层"></a>计算机网络物理层</h1><img src="/2022/050114293/7.jpg" class=""><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据，信号与码元：</li></ul><p>1.数据指的是传送信息的实体，连续变化的数据为模拟数据，离散的数据为数字数据，且可以并行/串行传输数据。<br>2.信号是数据的电气/电磁表现形式，数据传输过程中表现形式。<br>3.码元是用一个固定时长的信号波形表示一个k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，时长成为码元宽度。</p><ul><li>信源，信道，信宿：</li></ul><p>1.一个数据通信系统由这三部分组成。<br>2.信源：产生发送数据的源头，<br>3.信宿：接收数据的终点。<br>4.信道：和电路不等同，信道是信号的传输媒介，可以看作线路的逻辑媒介，一般一个通信线路都有一个发送信道和一个接收信道。信道根据传输信号不同分为模拟信道和数字信道，按传输介质不同分为无线和有线信道。<br>5.信道上传输的信号有基带信号和宽带信号之分。<br>基带信号是用1和0不同电压表示，送到数字信道上传输——基带传输。<br>宽带信号是把基带调制形成频分复用模拟信号，送到模拟信道上传输——宽带传输。<br>6.三种通信交互方式：单向通信（一条信道），半双工通信（两条信道，不能同时发送和接收），全双工通信（两条信道，能同时发送和接收）。  </p><img src="/2022/050114293/1.jpg" class="">  <ul><li>速率，波特和带宽：</li></ul><p>1.速率：数据传输率，单位时间传输数据量，可以用·码元传输速率表示（波特率，单位时间内数字通信系统所传输的码元个数，单位是波特，进制不定），也可用信息传输速率表示（信息速率，比特率，单位时间内数字通信系统所传输的码元个数，二进制）。<br>2.带宽：通信线路所能传输数据的能力，“最大速率”，单位为b/s。</p><h3 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h3><ul><li>奈奎斯特定理：</li></ul><p>1.具体信道能够通过的频率范围有限，信号中许多高频分量往往不能通过信道，否则传输中会衰弱，导致接收端收到的信号波形失去码元之间的清晰界限，这种现象成为码间串扰。<br>2.奈奎斯特定理规定——理想低通信道中，为了避免码间串扰，极限码元传输速率为2W波特，其中为理想低通信道带宽，若用V表示每个码元离散点评的数量（即多少种不同码元，16个码元就有4个二进制位表示，则数据传输速率是码元的4倍），则极限数据率=2W*log2(V)。<br>结论：<br>①任何信道码元传输速率有上限，超过上限就会出现严重的码间串扰，接收端不能完全正确识别码元。<br>②信道频带越宽，就可以用更高的速率进行码元的有效传输。<br>③奈奎斯特定理给出了码元传输速率限制，但并未对于信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。<br>④所以要使得每个码元带更多的比特量，多元制的调制方法。</p><ul><li>香农定理：</li></ul><p>1.香农定理给出了带宽受限且有着高斯白噪声干扰的信道的极限数据传输速率，当使用该速率传输时可以不产生误差，则极限数据率=W*log2(1+S/N),W为信道带宽，S为信道传输信号平均功率，N为信道内高斯噪声功率，S/N为信噪比。<br>结论：<br>①信噪比越大，极限传输速率越高，信噪比确定时信息传输速率上限一定。<br>②只要信息传输速率低于上限，就一定有方法实现无差错传输。<br>③香农定理给出的是传输速率上限，实际信道比它低不少。</p><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><ul><li>数据无论是数字还是模拟都需要变成信号才能进行传输，则数据变换为模拟信号的过程称为调制，变为数字信号的过程称为编码。  </li><li>数字数据通过数字发送器转换成数字信号，也可通过调制器转换成模拟信号。  </li><li>模拟数据通过POM编码器转换成数字信号，也可通过放大器调制器转换成模拟信号。  </li><li>所以产生了四种编码方式：</li></ul><p>1.数字数据编码为数字信号：<br>用于基带传输，即不改变信号频率之间传输数字信号，只要把1和0区分开即可，有多种编码方式：①归零编码RZ，②非归零编码NRZ，③反向非归零编码NRZI，④曼彻斯特编码，⑤差分曼彻斯特编码，⑥4B/5B编码。  </p><img src="/2022/050114293/2.jpg" class="">   <p>2.数字数据调制为模拟信号：<br>数字数据调制技术在发送端把数字信号转换为模拟信号，在接收端将模拟信号还原为数字信号，对应调制解调器的调制和解调过程，基本有如下几种：①幅移键控ASK，②频移键控FSK，③相移键控PSK，④正交振幅调制QAM。<br>3.模拟数据编码为数字信号：<br>经典例子就是音频信号的脉码调制PCM，包括采样，量化，编码三个步骤。<br>4.模拟数据调制为模拟信号：<br>为了实现传输有效性，可能需要较高频率，这种调制方式可以用频分复用FDM。  </p><h3 id="电路交换，报文交换，分组交换"><a href="#电路交换，报文交换，分组交换" class="headerlink" title="电路交换，报文交换，分组交换"></a>电路交换，报文交换，分组交换</h3><ul><li>电路交换：<br>①定义：两节点之间必须建立一条专用的物理通信路径，路径在整个数据传输期间被这两个结点独占，直到通信结束才被释放，因此有三个阶段：连接建立，数据传输，连接释放。以直通的方式发送接收数据，不存在存储转发消耗时间。<br>②优点：<br>通信时延小（线路两节点专享）<br>有序传输<br>没有冲突（各自有不同信道）<br>适用范围广（数字模拟信号均可传输）<br>实时性强（连接建立立即可传输）<br>控制简单<br>③缺点：<br>建立连接时间长<br>线路独占<br>灵活性差<br>难以规格化  </li><li>报文交换：<br>①定义：数据交换单位是报文，带有目标地址，源地址等信息，报文交换在交换节点采用的是存储转发的传输方式。<br>②优点：<br>无须建立连接<br>动态分配线路（发送方把报文交给交换设备，先存储整个报文再选择空闲线路发送报文），提高线路可靠性<br>提高线路利用率<br>提供多目标服务（一个报文多个目的地址）。<br>③缺点：有转发时延（报文先存储再转发）<br>对于报文大小没有限制导致网络节点应该有较大的缓存空间。  </li><li>分组交换：<br>①定义：也是存储转发，但解决了大报文的问题，限制了数据块上限，把大数据块划分成为小数据块加上必要的控制信息（两个地址+编号信息等）构成了分组Packet，中间结点接受分组存储并且排队，根据分组选择下一个结点，直到到达目的结点。<br>②优点：<br>无建立时延<br>线路利用率高<br>简化了存储管理（比报文交换，因为数据块固定所以缓冲区固定，简化了缓冲区的管理）<br>加速传输（分组是逐个传输的，一个分组存储和前一个分组转发是并行的，减少了传输时间）<br>减少出错概率和重发数据量（分组更短，出错概率小，所以重发数据量减少，提高可靠性减少了时延）<br>③缺点：<br>存在传输时延<br>需要传输额外信息量（每个块都有源地址和目的地址，分组编号等，从而构成分组，信息量提高了）<br>当分组交换使用数据报网络的时候可能失序，丢失，重复等，所以分组到达目的地址的时候需要排序等工作，但使用虚电路服务的时候还要建立连接三个过程。</li><li>三个数据交换方式比较：<br>①数据量大且传送时间远远大于建立连接时间的时候使用电路交换。<br>②端到端通路由多段链路组成时，采用分组交换。<br>③报文交换和分组交换的信道利用率高于电路交换，其中分组交换比报文交换时延小，尤其适合计算机之间突发通信。  <img src="/2022/050114293/3.jpg" class="">  <h3 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h3><img src="/2022/050114293/6.jpg" class="">   分组交换进一步分为面向连接的虚电路方式和无连接的数据方式，都由网络层提供。</li><li>数据报：<br>①网络层加上控制信息形成数据报分组，中间结点存储分组之后找到最佳路由，尽快转发分组，分组可以不同路径，也可以不同顺序，只需要找当前状态下分组最合适的路由转发即可。<br>②特点：<br>发送分组之前不需要建立连接。<br>网络尽最大努力交付，不保证可靠性，有可能丢失，乱序。<br>分组要包含发送端和接收端的完整地址，便于独立运输。<br>分组在存储转发过程中需要排队处理，网络拥塞的时候排队的时延大大增加，还可能丢失分组。<br>网络中具有冗余的路径，当某结点/链路发生故障的时候相应更新转发表，从另一条路径转发，对于故障适应性强。<br>存储转发时延一般较小，提高了网络吞吐量。<br>收发双方不独占某条链路，资源利用率高。  <img src="/2022/050114293/4.jpg" class="">  </li><li>虚电路：<br>①虚电路尝试把电路交换和数据报方式结合起来，分组发送之前先建立连接，一旦连接建立，路径就是固定的，总过程还是三个阶段。每次建立虚电路时，选择一个未用过的虚电路号分配，在传送数据的时候，分组不仅要有分组号，校验等控制信息，还要有虚电路号，且虚电路网络中每个结点都有一个虚电路表，包括接收链路，发送链路上的虚电路号，前一个结点和后一个结点的标识。<br>②特点：<br>通信链路建立拆除需要时间开销，短时间浪费，长时间效率高。<br>虚电路路由选择体现在建立链路的时候，建立完成就完成了路由选择，只有一条路径。<br>虚电路可靠，分组正确有序到达，且有流量控制。<br>虚电路路径中某个结点/链路故障时所有经过该结点/链路的虚电路都会被破坏。<br>分组首部不包括目的地址，包含的是虚电路标识符。<br>虚电路中的“虚”体现在，这条物理链路不是独占的，而是逻辑上一条独占的链路，两个端系统之间有不同的进程可能也存在不同的虚电路。 <img src="/2022/050114293/5.jpg" class="">  <h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2>传输介质也叫传输媒体，是数据传输系统中发送设备和接收设备之间的物理通路，分为导向和非导向传输介质。<h3 id="双绞线，同轴电缆，光纤，无线传输介质"><a href="#双绞线，同轴电缆，光纤，无线传输介质" class="headerlink" title="双绞线，同轴电缆，光纤，无线传输介质"></a>双绞线，同轴电缆，光纤，无线传输介质</h3></li><li>双绞线：TP，两根相互校合的铜导线，还有屏蔽双绞线STP，非屏蔽双绞线UTP。价格便宜，局域网和传统电话中常见，带宽取决于铜线粗细和传输距离</li><li>同轴电缆：由内导体，绝缘层，网状编制屏蔽层和塑料外层构成，有50欧的基带同轴电缆——局域网，75欧的宽带同轴电缆——电视。</li><li>光纤：光导纤维传递光脉冲来通信，容量大，传输损耗小，远距离传输经济，抗雷电电磁性能好，无串音干扰，体积小重量轻。  </li><li>无线传输介质：有无线电波（穿透力强，距离长，无需方向对准），微波，红外线，激光<h3 id="物理层接口特征"><a href="#物理层接口特征" class="headerlink" title="物理层接口特征"></a>物理层接口特征</h3></li><li>物理层考虑如何把连接计算机的媒体上传输比特流，而硬件设备和传输介质种类繁多且通信方式也有差异，物理层尽可能屏蔽差异。  </li><li>物理层主要任务是确定与传输媒体的接口有关的特性：<br>①机械特性：指定接口所用接线器形状，尺寸，引脚数量和排列，固定和锁定装置等。<br>②电器特性：指定在接口电缆各条线上出现的电压范围。<br>③功能特性：指定某条线上出现的某一个电平的电压表示何种意义。<br>④过程特性：又称规程特性，指定对于不同功能的各个可能事件的出现顺序。  </li><li>常用的物理层接口标准有：EIA RS-232-C，ADSL，SONET/SDH等<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器repeater"><a href="#中继器repeater" class="headerlink" title="中继器repeater"></a>中继器repeater</h3></li><li>主要功能是把信号整形并放大再转发出去，消除信号经过电缆之后产生的失真和衰弱，使得信号波形和强度达到标准，进而扩大网络传输距离。</li><li>原理是信号再生，有两个端口，一个输入一个输出。而放大器原理是信号放大。</li><li>简单廉价，在物理层工作，中继器两端是同一个局域网，不能连接两个不同速率的局域网。</li><li>理论上中继器无限使用，但现实中不可能，“5-4-3原则”：4个中继器连接5个通信介质中只有3段可以连接计算机。<h3 id="集线器hub"><a href="#集线器hub" class="headerlink" title="集线器hub"></a>集线器hub</h3></li><li>实质是多端口中继器，在网络中只有信号放大和转发作用，目的为了扩大网络的传输范围，而不是信号定向传送，即信号传输的方向固定，是一个标准的共享式设备。  </li><li>集线器不能分割冲突域，所有端口属于一个冲突域，比如10Mb/s带宽的集线器连接8台计算机，每台计算机带宽为10/8=1.25Mb/s。<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>传输媒体不是物理层：传输媒体在物理层下面，传输媒体传输的是信号但不知道信号意味着啥，物理层识别所传送的比特流。</li><li>基带传输：计算机内部/相邻设备之间近距离传输，不经过调制在信道上直接传输称为基带传输，常用于局域网。</li><li>频带传输：数字信号对于特定频率的载波进行调制，变成适合传送的信号再传输，这叫做频带传输。远距离/无线传输时使用。</li><li>宽带传输：借助频带传输（频分复用），把链路容量分解为&gt;=2个信道，每个信道携带不同信号，就叫宽带传输。所有信道互不干扰发送信号，链路容量大大增加。</li><li>同步异步的理解：同步：通信双方必须线建立同步，即时钟调整同一个频率，双方不停的发送接收比特流，两种同步方法：全网同步和准同步。而异步可以理解为非同步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/2022/043050802.html"/>
      <url>/2022/043050802.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><img src="/2022/043050802/9.jpg" class=""> <h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><ul><li>计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><h3 id="共分三类："><a href="#共分三类：" class="headerlink" title="共分三类："></a>共分三类：</h3></li><li>组成部分：硬件，软件，协议。</li></ul><p>1.硬件：主机（端系统），通信链路（双绞线，光纤），交换设备（路由器，交换机），通信处理机（网卡）<br>2.软件：实现资源共享的软件和方便用户使用的工具软件（邮件收发，聊天程序等）<br>3.协议：计网核心，“交通规则”规定网络传输数据时所遵循的规范  </p><ul><li>工作方式：边缘部分和核心部分</li></ul><p>1.边缘部分：主机，用来通信和资源共享<br>2.核心部分：网络和连接网络的路由器，为边缘提供连通和交换</p><ul><li>功能组成：通信子网和资源子网</li></ul><p>1.通信子网：传输介质，通信设备，网络协议。<br>2.资源子网：资源共享的设备及其软件</p><h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ul><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="共分六类："><a href="#共分六类：" class="headerlink" title="共分六类："></a>共分六类：</h3></li><li>分布范围：<br>广域网WAN，城域网MAN，局域网LAN，个人区域网PAN</li><li>传输技术：<br>广播式网络，点对点网络（区别于是否分组存储转发和路由选择机制）</li><li>拓扑结构：<br>总线形，星形，环形，网状（节点与通信链路的几何关系），也可以互联成为更复杂网络结构</li><li>使用者：<br>公用网，专用网</li><li>交换技术：</li></ul><p>1.电路交换网络：点对点，建立连接，传输数据，断开连接，传统电话网络。优点：数据直接传送，时延小。缺点：线路利用率低，无差错控制。<br>2.报文交换网络：加源地址和目标地址，封装成为报文段传送。也叫存储转发网络，优点：充分利用线路，一对多多对一，差错控制。缺点：资源开销大，缓冲时延，缓冲区难管理。<br>3.分组交换网络：把数据封装成固定长度数据块，块红加上目的地址和源地址等辅助信息成为分组，以存储-转发传输。优点：报文网络优点+缓冲容易管理，包时延小，现在主流网络的选择。</p><ul><li>传输介质：</li></ul><p>1.有线：双绞线网络，同轴电缆网络等。<br>2.无线：蓝牙，微波，无线电等。  </p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><ul><li>带宽：bandwidth，单位Hz，表示网络通信线路传输数据能力，“最高数据传输速率”。</li><li>时延：delay，端到端传送总时间，总时延=发送时延+传播时延+处理时延+排队时延。</li><li>时延带宽积：传播时延x信道带宽。</li><li>往返时延：round-trip-time”RTT”,从发送端开始到接收到接收端的确认历经总时延。</li><li>吞吐量：throughput，单位时间内通过某个网络数据量。</li><li>速率：speed，计算机网络上主机在数据信道上传送数据的速率，最高速率为带宽，单位为比特/秒，b/s。  </li><li>信道利用率： 有数据通过的时间/有无数据通过的时间。<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3></li><li>计算机网络各层及其协议的集合就是计算机网络的体系结构。</li><li>每层活动元素成为实体，每层传送的数据单位不同，但都有两部分：数据服务单元SDU和协议控制单元PCI，共同组成协议数据单元PDU。</li><li>从上到下包装,从下到上拆解，n-SDU+n-PCI=n-n-PDU=(n-1)-SDU。</li><li>每层使用下层的服务，服务上层：最底层只提供服务，最高层只面向用户服务，中间层既享受服务也服务上层。</li><li>每层只能调用相邻层接口服务。</li><li>两台主机通信的时候对等层有一条直接信道。<h3 id="计算机网络协议，接口，服务"><a href="#计算机网络协议，接口，服务" class="headerlink" title="计算机网络协议，接口，服务"></a>计算机网络协议，接口，服务</h3></li><li>协议：为网络数据交换建立的规则，标准，约定。控制两个/多个对等实体进行通信的规则的集合，是水平的，不对等实体之间没有协议。包括语法，语义，同步。</li><li>接口：同一个结点内相邻层之间交换信息的连接点，系统内部的规定，n+1层通过访问n层的SAP（服务访问点）来获取服务，每个SAP有自己的地址。</li><li>服务：下层为紧邻的上层提供的功能调用，是垂直的。上下层提供服务的时候有四类原语：请求request，指示indication，响应response，证实confirmation。<br>计算机提供的服务有三种：</li></ul><p>1.面向连接服务和无连接服务：面向连接必须先建立连接分配资源，结束再释放连接和资源，三个阶段，如TCP，无连接服务只需要直接发送数据，把带目的地的包传送在线路上，不可靠的服务，Best-Effort-Delivery，如IP和UDP<br>2.可靠服务和不可靠服务：可靠指的是有纠错，检错，应答机制，保证正确可靠传输数据，而不可靠是尽量正确可靠，尽力而为的服务。<br>3.有应答服务和无应答服务：是否有接受方接收数据之后向发送方发送应答，文件传输服务就是有应答，WWW就是无应答</p><h3 id="ISO-x2F-OSI与TCP-x2F-IP模型"><a href="#ISO-x2F-OSI与TCP-x2F-IP模型" class="headerlink" title="ISO/OSI与TCP/IP模型"></a>ISO/OSI与TCP/IP模型</h3><ul><li>OSI模型：七层，从下到上分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>低三层为通信子网（为了连接网络的通信设备），传输层承上启下，上三层为资源子网（相当于计算机，完成数据处理）。</li><li>TCP/IP模型：四层，从下到上分别为：网络接口层，网际层，传输层，应用层。  </li><li>两者共同点：都采取分层结构。都基于独立协议栈的概念。都可以解决异构网络的互连（不同厂家计算机互联）</li><li>两者不同点：<br>OSI产生服务，协议，接口概念，与面向对象思想吻合。OSI先产生的模型而没有对应协议，TCP/TP先产生了协议再产生的模型。<br>TCP/IP设计之初就考虑了异构网络的问题，并用IP分层，OSI后来才在网络层中产生子层完成类似IP的功能。<br>OSI支持无连接和面向连接服务，但在传输层只有面向连接服务，而TCP/IP认为可靠性是端到端的问题，网际层仅有无连接，传输层支持两种模式。</li><li>我们折中，综合两个模型来划分五层：物理层，数据链路层，网络层，传输层，应用层。发送方用户给出自然语言通过应用层转化为数据，从上到下层层包装数据，接收方从下到上层层逆向拆解数据把数据提交给用户。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown介绍及使用教程</title>
      <link href="/2022/04296929.html"/>
      <url>/2022/04296929.html</url>
      
        <content type="html"><![CDATA[<h2 id="举个例子解释"><a href="#举个例子解释" class="headerlink" title="举个例子解释"></a>举个例子解释</h2><p> 大部分作家都是用 Word 或 Pages 写作，过去的文档也大都以微软的 .doc, .docx 格式或是苹果的 Pages 格式储存。还有人为了保证文稿发给谁都能正常打开，会用 .txt 格式。但是.doc 或 Pages 格式有如下问题：</p><p>1.不一定谁都能打开。用 Windows 的人打不开苹果的 .pages 文件，用旧版 Word 的人不一定能打开你用新版 Word 写的稿子。</p><p>2.对方看到的稿子的样子和你自己看到的可能差别很大。</p><p>3.大部分人电脑上的Office都是盗版的，使用时很容易出问题。</p><p>4.用.txt 写的稿子没有格式，这就给编辑你文章的人带来困扰了。</p><h2 id="这就是-Markdown-登场的时候了"><a href="#这就是-Markdown-登场的时候了" class="headerlink" title="这就是 Markdown 登场的时候了"></a>这就是 Markdown 登场的时候了</h2><p>Markdown 的优点如下： </p><ul><li><p>纯文本，所以兼容性极强，可以用所有文本编辑器打开。<br>兼顾了「什么人都能打开」和「样式」。Markdown 就是纯文本，就是 .txt，所以什么人都能打开。而如上所述，你可以用它来标记文本的样式，而且语法非常简单。<br>由于是纯文本，Markdown 文稿也不会因为未来软件升级而产生不同版本之间的兼容问题，即，不会出现「我这篇稿子是用旧版 Word 写的，你用新版 Word 看可能格式会有点问题」的情况。</p></li><li><p>让你专注于文字而不是排版。</p></li><li><p>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</p></li><li><p>Markdown 转 HTML 非常方便。HTML 是整个万维网（web）的标记语言，但更重要的是，它也是目前主流电子书格式所用的标记语言。无论是 EPUB, mobi，还是 Kindle 用的专有格式 .azw，都只是把一堆 HTML 文件打包而已。如果你写的是书，用 Markdown 标注格式之后，可以很方便地转为以上格式（当然这个转换工作不需要由你来做）；如果你写的是单篇的文章（例如新闻报道或专栏），未来也不排除结集出书的可能。若采用 Markdown，对于日后的文件转换工作也大有裨益。如何开始用 Markdown？继续用你习惯的写作软件即可。记事本、Word、Pages 都没问题，但请记得存成纯文本格式。就这么简单。</p></li><li><p>Markdown 的标记语法有极好的可读性。</p></li></ul><p>插入链接: </p><ul><li><a href="https://www.jianshu.com/p/7771794c88a1?msclkid=1fb103a8c7b611eca8bd8cd73728089a#%E8%BD%AC%E6%8D%A2%E4%B8%BA-HTML-%E6%96%87%E6%A1%A3">Markdown介绍及使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/265077468?msclkid=7f270e55c7bd11ec9e490cd5ce2b3b96">hexo博客如何插入图片</a><br>插入图片：  </li><li><img src="https://th.bing.com/th/id/OIP.AjQfAi88wTpfm3XCNHUYogAAAA?pid=ImgDet&amp;rs=1">  </li><li><img src="/2022/04296929/1.jpg" class=""></li><li><img src="/2022/04296929/2.jpeg" class=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2022/042843699.html"/>
      <url>/2022/042843699.html</url>
      
        <content type="html"><![CDATA[<p>临近保研和课程实训，需要大量复习的专业课和学习新技术，就在此记录我的近期学习计划。</p><h2 id="计算机科学与技术："><a href="#计算机科学与技术：" class="headerlink" title="计算机科学与技术："></a>计算机科学与技术：</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h3><h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h3><h3 id="3-计算机网络"><a href="#3-计算机网络" class="headerlink" title="3.计算机网络"></a>3.计算机网络</h3><h3 id="4-计算机组成原理"><a href="#4-计算机组成原理" class="headerlink" title="4.计算机组成原理"></a>4.计算机组成原理</h3><h3 id="5-计算机科学基本理论"><a href="#5-计算机科学基本理论" class="headerlink" title="5.计算机科学基本理论"></a>5.计算机科学基本理论</h3><h3 id="6-数据库系统"><a href="#6-数据库系统" class="headerlink" title="6.数据库系统"></a>6.数据库系统</h3><h2 id="软件工程："><a href="#软件工程：" class="headerlink" title="软件工程："></a>软件工程：</h2><h3 id="1-软件工程理论"><a href="#1-软件工程理论" class="headerlink" title="1.软件工程理论"></a>1.软件工程理论</h3><h3 id="2-软件测试与质量保证"><a href="#2-软件测试与质量保证" class="headerlink" title="2.软件测试与质量保证"></a>2.软件测试与质量保证</h3><h3 id="3-软件需求分析与系统设计"><a href="#3-软件需求分析与系统设计" class="headerlink" title="3.软件需求分析与系统设计"></a>3.软件需求分析与系统设计</h3><h3 id="4-软件项目管理与过程改进"><a href="#4-软件项目管理与过程改进" class="headerlink" title="4.软件项目管理与过程改进"></a>4.软件项目管理与过程改进</h3><h3 id="5-面向对象基本理论"><a href="#5-面向对象基本理论" class="headerlink" title="5.面向对象基本理论"></a>5.面向对象基本理论</h3><h3 id="6-程序设计基本理论"><a href="#6-程序设计基本理论" class="headerlink" title="6.程序设计基本理论"></a>6.程序设计基本理论</h3><h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><h3 id="1-高等数学"><a href="#1-高等数学" class="headerlink" title="1.高等数学"></a>1.高等数学</h3><h3 id="2-离散数学"><a href="#2-离散数学" class="headerlink" title="2.离散数学"></a>2.离散数学</h3><h3 id="3-概率论"><a href="#3-概率论" class="headerlink" title="3.概率论"></a>3.概率论</h3><h3 id="4-线性代数"><a href="#4-线性代数" class="headerlink" title="4.线性代数"></a>4.线性代数</h3><h2 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h2><h3 id="1-springboot"><a href="#1-springboot" class="headerlink" title="1.springboot"></a>1.springboot</h3><h3 id="2-vue"><a href="#2-vue" class="headerlink" title="2.vue"></a>2.vue</h3><h3 id="3-springcloud"><a href="#3-springcloud" class="headerlink" title="3.springcloud"></a>3.springcloud</h3><h3 id="4-redis"><a href="#4-redis" class="headerlink" title="4.redis"></a>4.redis</h3><h3 id="5-部署服务器"><a href="#5-部署服务器" class="headerlink" title="5.部署服务器"></a>5.部署服务器</h3><h2 id="（未完待续）"><a href="#（未完待续）" class="headerlink" title="（未完待续）"></a>（未完待续）</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
