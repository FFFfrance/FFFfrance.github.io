<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机组成原理输入输出系统</title>
      <link href="/2022/061152378.html"/>
      <url>/2022/061152378.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理输入输出系统"><a href="#计算机组成原理输入输出系统" class="headerlink" title="计算机组成原理输入输出系统"></a>计算机组成原理输入输出系统</h1><img src="/2022/061152378/IO%E7%B3%BB%E7%BB%9F.jpg" class="">   <h2 id="IO系统基本概念"><a href="#IO系统基本概念" class="headerlink" title="IO系统基本概念"></a>IO系统基本概念</h2><ul><li>IO系统演变过程：  <img src="/2022/061152378/1.jpg" class="">  </li><li>IO系统基本组成：  <img src="/2022/061152378/2.jpg" class="">  </li><li>IO方式间接：  <img src="/2022/061152378/3.jpg" class="">  <img src="/2022/061152378/4.jpg" class="">  <h2 id="输入输出设备"><a href="#输入输出设备" class="headerlink" title="输入输出设备"></a>输入输出设备</h2></li><li>外部设备：  <img src="/2022/061152378/5.jpg" class="">  ①输入设备：<br>鼠标，键盘。<br>②输出设备：<br>显示器：  <img src="/2022/061152378/6.jpg" class="">  <img src="/2022/061152378/7.jpg" class="">  其中CRT显示器根据显示内容不同又分为字符显示器，图形显示器，图像显示器。<br>打印机：  <img src="/2022/061152378/8.jpg" class="">  <img src="/2022/061152378/9.jpg" class="">  ③外存储器：  <img src="/2022/061152378/10.jpg" class="">  磁盘存储器：  <img src="/2022/061152378/11.jpg" class="">  <img src="/2022/061152378/12.jpg" class="">  <img src="/2022/061152378/13.jpg" class="">  磁盘阵列：  <img src="/2022/061152378/14.jpg" class="">  光盘存储器：<img src="/2022/061152378/15.jpg" class="">  固态硬盘：<img src="/2022/061152378/16.jpg" class="">  <h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2></li><li>定义：  <img src="/2022/061152378/17.jpg" class="">  </li><li>功能：  <img src="/2022/061152378/18.jpg" class="">  </li><li>基本结构：  <img src="/2022/061152378/19.jpg" class="">  <img src="/2022/061152378/20.jpg" class="">   </li><li>接口和端口：  <img src="/2022/061152378/21.jpg" class="">   IO端口和编址：  <img src="/2022/061152378/22.jpg" class="">   </li><li>接口类型：  <img src="/2022/061152378/23.jpg" class="">   <h2 id="IO方式"><a href="#IO方式" class="headerlink" title="IO方式"></a>IO方式</h2><img src="/2022/061152378/24.jpg" class="">   </li><li>程序查询方式：<br>①流程：  <img src="/2022/061152378/25.jpg" class="">   ②接口结构：  <img src="/2022/061152378/26.jpg" class="">   </li><li>中断方式：<br>①中断系统：  <img src="/2022/061152378/27.jpg" class="">   根据中断进行分类：   <img src="/2022/061152378/28.jpg" class="">   也可以把内中断分为：  <img src="/2022/061152378/29.jpg" class="">   为了分辨是哪个类型的中断，设置中断请求标记：  <img src="/2022/061152378/30.jpg" class="">   中断判优：  <img src="/2022/061152378/31.jpg" class="">   <img src="/2022/061152378/32.jpg" class="">   ②中断处理过程：  <img src="/2022/061152378/33.jpg" class="">   <img src="/2022/061152378/34.jpg" class="">   <img src="/2022/061152378/36.jpg" class="">   单重中断与多重中断：   <img src="/2022/061152378/35.jpg" class="">   中断屏蔽技术：  <img src="/2022/061152378/37.jpg" class="">   </li><li>DMA方式：  <img src="/2022/061152378/38.jpg" class="">   DMA控制器：  <img src="/2022/061152378/39.jpg" class="">   DMA传送过程：  <img src="/2022/061152378/43.jpg" class="">   DMA传送方式：  <img src="/2022/061152378/40.jpg" class="">   特点：  <img src="/2022/061152378/41.jpg" class="">   <img src="/2022/061152378/42.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理总线</title>
      <link href="/2022/060954841.html"/>
      <url>/2022/060954841.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理总线"><a href="#计算机组成原理总线" class="headerlink" title="计算机组成原理总线"></a>计算机组成原理总线</h1><h2 id="总线的概念及分类"><a href="#总线的概念及分类" class="headerlink" title="总线的概念及分类"></a>总线的概念及分类</h2><img src="/2022/060954841/10.jpg" class="">   <ul><li>总线：<br>①定义：  <img src="/2022/060954841/1.jpg" class="">   ②特性（机械，电器，功能，时间）：  <img src="/2022/060954841/2.jpg" class="">   ③分类：  <img src="/2022/060954841/3.jpg" class="">  其中：<br>按照数据格式传输：  <img src="/2022/060954841/4.jpg" class="">    按照功能分类：  <img src="/2022/060954841/5.jpg" class="">   <img src="/2022/060954841/6.jpg" class="">   按照时序控制方式：  </li><li>系统总线经典结构：<br>①单总线：  <img src="/2022/060954841/7.jpg" class="">   ②双总线：  <img src="/2022/060954841/8.jpg" class="">   ③三总线：  <h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2></li><li><img src="/2022/060954841/11.jpg" class="">   ①总线的传输周期（总线周期）：<br>一次总线操作时间（申请，寻址，传输，结束四个阶段），通常包括若干个总线时钟周期。  <img src="/2022/060954841/12.jpg" class="">   ②总线时钟周期：<br>即及其的时钟周期，计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要收此时钟的控制。<br>③总线的工作频率：<br>总线上各种操作的频率，为总线周期的倒数。<br>④总线的时钟频率：<br>即机器的时钟频率，为周期的倒数，也就是一秒内有多少个时钟周期。<br>⑤总线宽度：<br>总线位宽，总线上同时传输的数据位数，也就是数据总线根数。<br>⑥总线宽度：<br>总线的数据传输率，即单位时间内可传输的数据的位数，单位是B/s。指的是总线本身达到的最高传输速率。<br>⑦总线复用：<br>一种信号线在不同时间传输不同的信息。可以用较少的线传输更多的信息，从而节省了空间和成本。<br>⑧信号线数：<br>地址总线，数据总线，控制总线。三种线的总和。<br>⑨总结：  <img src="/2022/060954841/14.jpg" class="">   </li><li>串行总线和并行总线：  <img src="/2022/060954841/13.jpg" class="">   <h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><img src="/2022/060954841/15.jpg" class="">   </li><li>集中仲裁：  <img src="/2022/060954841/16.jpg" class="">   <img src="/2022/060954841/17.jpg" class="">   <img src="/2022/060954841/18.jpg" class="">   总结：  <img src="/2022/060954841/19.jpg" class="">   </li><li>分布仲裁:  <img src="/2022/060954841/20.jpg" class="">   <h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2></li><li>总线传输的四个阶段：  <img src="/2022/060954841/21.jpg" class="">   </li><li>总线定时：<br>①同步定时方式：  <img src="/2022/060954841/22.jpg" class="">   ②异步定时方式：  <img src="/2022/060954841/23.jpg" class="">   <img src="/2022/060954841/24.jpg" class="">   ③半同步通信：略<br>④分离式通信：略</li><li>波特率：<br>单位时间内传送的二进制数据的位数，单位用bps，记作波特。  </li><li>比特率：<br>单位时间内传送的二进制有效数据的位数，单位用bps，即bit/s。<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2></li><li>概念：  <img src="/2022/060954841/25.jpg" class="">   </li><li>常见标准：  <img src="/2022/060954841/26.jpg" class="">   ISA，EISA，PCI，AGP，PCI-E，USB，RS-232C，SATA，SCSI，PCMCI</li><li>桥接器：用于连接不同总线，具有数据缓冲， 转换和控制功能。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理中央处理器</title>
      <link href="/2022/060947947.html"/>
      <url>/2022/060947947.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理中央处理器"><a href="#计算机组成原理中央处理器" class="headerlink" title="计算机组成原理中央处理器"></a>计算机组成原理中央处理器</h1><img src="/2022/060947947/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8.jpg" class=""> <h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><img src="/2022/060947947/5.jpg" class="">   <ul><li><img src="/2022/060947947/1.jpg" class="">   分为运算器和控制器：  <img src="/2022/060947947/2.jpg" class="">   </li><li>运算器基本结构：  <img src="/2022/060947947/3.jpg" class="">   </li><li>控制器的基本结构：<img src="/2022/060947947/4.jpg" class="">   </li><li>总体划分为ALU，寄存器，CU，中断系统四部分电路。  <h2 id="CPU中指令执行过程"><a href="#CPU中指令执行过程" class="headerlink" title="CPU中指令执行过程"></a>CPU中指令执行过程</h2><img src="/2022/060947947/13.jpg" class="">   </li><li>指令周期：CPU从主存中取出并执行一条指令所需的全部时间。常常用若干机器周期（又叫CPU周期）来表示。而机器周期又包含若干时钟周期（CPU操作最基本单位）。  <img src="/2022/060947947/6.jpg" class="">   不同指令内机器周期可以不同：  <img src="/2022/060947947/8.jpg" class="">   指令周期流程：  <img src="/2022/060947947/7.jpg" class="">   ①取指周期：  <img src="/2022/060947947/9.jpg" class="">   ②间址周期：  <img src="/2022/060947947/12.jpg" class="">   ③执行周期：<br>任务就是根据IR中的指令字的操作码和操作数通过ALU操作产生结果，不同指令的执行周期操作不同，因此没有统一的数据流向。<br>④中断周期：  <img src="/2022/060947947/11.jpg" class="">   </li><li>指令执行方案：  <img src="/2022/060947947/10.jpg" class="">   <h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2></li><li>数据通路：数据在功能部件之间的传送路径。  </li><li>CPU内部单总线方式：   <img src="/2022/060947947/14.jpg" class="">   内部总线指的是同一部件如CPU内部连接各寄存器及运算部件之间的总线。而系统总线是一台计算机各部件，如CPU，内存，通道和各类IO接口间的相互连接的总线。  <img src="/2022/060947947/15.jpg" class="">   </li><li>专用数据通路方式：<br>类似于总线，但直接利用通路进行传送而不是输入到总线再输出。  <h2 id="控制器：硬布线和微程序（略）"><a href="#控制器：硬布线和微程序（略）" class="headerlink" title="控制器：硬布线和微程序（略）"></a>控制器：硬布线和微程序（略）</h2><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2></li><li>指令阶段：  <img src="/2022/060947947/16.jpg" class="">   </li><li>指令执行方式：  <img src="/2022/060947947/17.jpg" class="">   </li><li>流水线的性能指标：<br>①吞吐率TP：  <img src="/2022/060947947/18.jpg" class="">   ②加速比S：  <img src="/2022/060947947/19.jpg" class="">   ③效率E：  <img src="/2022/060947947/20.jpg" class="">   <h2 id="影响流水线因素和分类"><a href="#影响流水线因素和分类" class="headerlink" title="影响流水线因素和分类"></a>影响流水线因素和分类</h2>方便流水线设计，把每个阶段耗时取成一样，以最长耗时为标准。  </li><li>影响因素：<br>①结构相关（资源冲突）：  <img src="/2022/060947947/21.jpg" class="">   ②数据相关（数据冲突）：<img src="/2022/060947947/22.jpg" class="">   ③控制相关（控制冲突）：  <img src="/2022/060947947/23.jpg" class="">   </li><li>分类：  <img src="/2022/060947947/24.jpg" class="">   <img src="/2022/060947947/25.jpg" class="">   </li><li>流水线的多发技术：<br>①超标量技术：  <img src="/2022/060947947/26.jpg" class="">   ②超流水技术：  <img src="/2022/060947947/27.jpg" class="">   ③超长指令字：  <img src="/2022/060947947/28.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理指令系统</title>
      <link href="/2022/060920601.html"/>
      <url>/2022/060920601.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理指令系统"><a href="#计算机组成原理指令系统" class="headerlink" title="计算机组成原理指令系统"></a>计算机组成原理指令系统</h1><img src="/2022/060920601/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F.jpg" class="">   <h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><img src="/2022/060920601/8.jpg" class="">   <ul><li>定义：指示计算机执行某种操作的命令，是计算机运行的最小功能单位，一台计算机所有指令集合构成该机的指令系统（指令集）。  </li><li>格式：  <img src="/2022/060920601/2.jpg" class="">   从四地址指令把指令和数据分开放，引入PC，使得减去下条指令的地址，变为三地址指令：  <img src="/2022/060920601/3.jpg" class="">   定长指令字结构：  <img src="/2022/060920601/4.jpg" class="">   扩展操作码：   <img src="/2022/060920601/5.jpg" class="">   不允许短操作码是长操作码前缀，且使用频率高的指令分配较短的操作码（哈夫曼编码的思想）  <img src="/2022/060920601/6.jpg" class="">   </li><li>操作类型：  <img src="/2022/060920601/7.jpg" class="">   <h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><img src="/2022/060920601/11.jpg" class="">   </li><li>数据存取：（存储器定位到某个存储单元）  <img src="/2022/060920601/9.jpg" class="">   尽量把边界对齐减少存取次数：起始地址是字长的整数倍。    <img src="/2022/060920601/10.jpg" class="">   </li><li>指令寻址：<br>分别定位指令（下一个指令的地址）和数据（本指令的操作数地址）<br>指令寻址：<br>顺序寻址（PC自增），跳跃寻址（由转移指令指出）  <h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><img src="/2022/060920601/25.jpg" class="">   </li><li>操作数类型：  <img src="/2022/060920601/12.jpg" class="">   </li><li>数据寻址：<br>根据寻址特征，把形式地址转换为操作数的真实地址，称为有效地址。  <img src="/2022/060920601/13.jpg" class="">   ①立即寻址:  <img src="/2022/060920601/14.jpg" class="">   ②直接寻址：  <img src="/2022/060920601/15.jpg" class="">   ③间接寻址：  <img src="/2022/060920601/16.jpg" class="">   ④寄存器寻址：  <img src="/2022/060920601/17.jpg" class="">   ⑤寄存器间接寻址：  <img src="/2022/060920601/18.jpg" class="">   ⑥隐含寻址：  <img src="/2022/060920601/19.jpg" class="">   ⑦基址寻址（偏移寻址）：   <img src="/2022/060920601/20.jpg" class="">   EA=BR+D（相对地址，直接寻址需要改变）  <img src="/2022/060920601/21.jpg" class="">   ⑧变址寻址：  <img src="/2022/060920601/22.jpg" class="">   ⑨相对寻址：  <img src="/2022/060920601/23.jpg" class="">   </li><li>总结：  <img src="/2022/060920601/24.jpg" class="">   </li><li>堆栈寻址和隐含寻址：<br>隐含是隐含了一个操作数，而堆栈则是隐藏了所有操作数。使用寄存器实现就是硬堆栈，存储器实现就是软堆栈。   <img src="/2022/060920601/26.jpg" class="">   <h2 id="CISE和RISE"><a href="#CISE和RISE" class="headerlink" title="CISE和RISE"></a>CISE和RISE</h2><img src="/2022/060920601/27.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理存储系统</title>
      <link href="/2022/06079185.html"/>
      <url>/2022/06079185.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理存储系统"><a href="#计算机组成原理存储系统" class="headerlink" title="计算机组成原理存储系统"></a>计算机组成原理存储系统</h1><img src="/2022/06079185/6.jpg" class="">   <h2 id="主存模型和寻址"><a href="#主存模型和寻址" class="headerlink" title="主存模型和寻址"></a>主存模型和寻址</h2><img src="/2022/06079185/5.jpg" class="">   <ul><li>一个能够完成二进制位读写的单元为存储元，存储体由多个存储元构成。  <img src="/2022/06079185/1.jpg" class="">    其中时序控制逻辑如图：  <img src="/2022/06079185/2.jpg" class="">    封装称为存储器芯片。其中有若干接口线：地址线，数据线，片选线，读写控制线。总容量=存储单元个数X存储字长。  <img src="/2022/06079185/3.jpg" class="">   </li><li>寻址：如何定位到一个存储单元（一行）<br>按照字节寻址，每单元1B。按照字寻址，每个单元4B。还有半字2B和双字8B。根据单元个数求出地址线根数，分出若干组，求出每组的组号作为字地址。<br>而此时如何存放一个字？字长为4B，可以根据大端和小端方式来存放字。    <img src="/2022/06079185/4.jpg" class="">   <h2 id="半导体存储器RAM"><a href="#半导体存储器RAM" class="headerlink" title="半导体存储器RAM"></a>半导体存储器RAM</h2><img src="/2022/06079185/8.jpg" class="">   </li><li>半导体存储器芯片的基本结构：  <img src="/2022/06079185/9.jpg" class="">   </li><li>SRAM和DRAM比较：  <img src="/2022/06079185/7.jpg" class="">   </li><li>DRAM的刷新：<br>①刷新周期2ms。<br>②每次刷新一行存储单元，并且根据行列等长地址定位（减少选通线的数量）。<br>③根据硬件，读出一行之后重新写入，占用一个读/写周期。<br>④整个刷新周期每行刷新一次即可。  <h2 id="半导体存储器ROM"><a href="#半导体存储器ROM" class="headerlink" title="半导体存储器ROM"></a>半导体存储器ROM</h2><img src="/2022/06079185/11.jpg" class="">   RAM是易失性存储器，断电丢失数据，所以不能作为主存，所以出现了ROM（存储开机之后需要初始的固定信息）。  <img src="/2022/06079185/10.jpg" class="">   <h2 id="存储系统基本概念"><a href="#存储系统基本概念" class="headerlink" title="存储系统基本概念"></a>存储系统基本概念</h2><img src="/2022/06079185/16.jpg" class="">   </li><li>分类：<br>使用不同材料：①磁表面存储器：磁盘（直接存取）磁带（顺序存储）。②磁芯存储器。③半导体存储器（随机存储ROM，RAM）。④光存储器。  <img src="/2022/06079185/13.jpg" class="">   </li><li>性能指标：  <img src="/2022/06079185/14.jpg" class="">   </li><li>存储器层次化结构：  <img src="/2022/06079185/15.jpg" class="">   <h2 id="主存和CPU的连接"><a href="#主存和CPU的连接" class="headerlink" title="主存和CPU的连接"></a>主存和CPU的连接</h2><img src="/2022/06079185/21.jpg" class="">     </li><li>CPU和存储器之间地址线和数据线分别连接，可以通过位扩展和字扩展。<br>位扩展：  <img src="/2022/06079185/17.jpg" class="">   字扩展：<br>①线选法：n条线控制n个选片信号  <img src="/2022/06079185/18.jpg" class="">   ②译码器片选法：n条线控制2的n次方个选片信号  <img src="/2022/06079185/19.jpg" class="">   字位同时扩展：  <img src="/2022/06079185/20.jpg" class="">   <h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2>两者都是为了提高存储器的工作速度。<br>存取周期：存取时间+恢复时间（利用恢复时间存取其他数据）  <img src="/2022/06079185/36.jpg" class="">   </li><li>双端口RAM：  <img src="/2022/06079185/37.jpg" class="">   </li><li>多模块存储器：  <img src="/2022/06079185/38.jpg" class="">   </li></ul><h2 id="高速缓冲存储器局部性原理"><a href="#高速缓冲存储器局部性原理" class="headerlink" title="高速缓冲存储器局部性原理"></a>高速缓冲存储器局部性原理</h2><img src="/2022/06079185/24.jpg" class="">   <p>把主存数据调入Cache之后，使CPU和Cache交互处理数据。<br><img src="/2022/06079185/22.jpg" class=""><br><img src="/2022/06079185/23.jpg" class="">   </p><h2 id="Cache和主存之间的地址映射"><a href="#Cache和主存之间的地址映射" class="headerlink" title="Cache和主存之间的地址映射"></a>Cache和主存之间的地址映射</h2><img src="/2022/06079185/25.jpg" class="">  <img src="/2022/06079185/27.jpg" class="">    <img src="/2022/06079185/26.jpg" class="">   <h2 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h2><img src="/2022/06079185/30.jpg" class="">   <img src="/2022/06079185/28.jpg" class="">   <img src="/2022/06079185/29.jpg" class="">  <h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><img src="/2022/06079185/31.jpg" class="">    <p>根据划分单位不同，分为三种不同虚拟存储器：  </p><ul><li>页式虚拟存储器：  <img src="/2022/06079185/32.jpg" class="">   </li><li>段式虚拟存储器：  <img src="/2022/06079185/33.jpg" class="">   </li><li>段页式虚拟存储器：  <img src="/2022/06079185/34.jpg" class="">   快表TLB：<br>页表，段表放在主存中，收到虚拟地址之后要先访问主存，查询页表和段表进行转换，放在内存中的表称为慢表。为了提高变换速度，用高速缓冲存储器存放常用的页表项，形成了快表TLB。  <img src="/2022/06079185/35.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理数据的表示和运算</title>
      <link href="/2022/060652765.html"/>
      <url>/2022/060652765.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理数据的表示和运算"><a href="#计算机组成原理数据的表示和运算" class="headerlink" title="计算机组成原理数据的表示和运算"></a>计算机组成原理数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><img src="/2022/060652765/2.jpg" class="">   <ul><li>符号反映权重：罗马数字Ⅴ=5。  </li><li>十进制：数字符号反映权重，且符号位置也反映权重（位权）。  </li><li>进位计数制（逢N进1）：基数（每个数码位所用到的不同符号的个数，r进制的基数为r）。   </li><li>进制之间相互转化：<br>各进制转化为十进制。<br>十进制转化为各进制。（整数部分用短除法：不停除r求余数，先得到的余数是低位。小数部分用乘积取整法：不停乘r取整数，先得到的整数是高位）<br>二进制变为八进制和十六进制。（分别是3或4位变为1位）<br>十六，八进制转化为二进制。（1位变为4或3位）</li><li>真值：符合人类习惯的数字。<br>机器数：数字实际存到机器里的形式（正负号需要添加符号位0/1）  <h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><img src="/2022/060652765/1.jpg" class="">   </li><li>8421码：四个位表示一个十进制数字。进行加法运算时若结果位于10-15内，后四位就继续加6（0110），进一位.若结果大于15时，后四位也加6（0110）。————有权码</li><li>余3码：8421码+（0011）————无权码  </li><li>2421码：改变权值的定义，5以后的数字首位必为1。  <h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><img src="/2022/060652765/3.jpg" class="">   </li><li>ASCII码：8位，128个字符（7位即可高位补0），32-126是可打印字符，其余字符是控制和通信字符。  </li><li>汉字的表示和编码：GB2312-80汉字+各种符号共7445个，定义了区位码（94X94个位置）映射到汉字。为了防止信息交互和ASCII码冲突，+20H得到国标码，进一步得到汉字内码。汉字输入输出通过国标码和汉字内码实现二进制和汉字之间转换。  </li><li>字符串：按字节编址，连续存储，最后一位/0。带汉字的时候两个地址存一个汉字。  <h2 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h2><img src="/2022/060652765/5.jpg" class="">  位错误导致01反转。<img src="/2022/060652765/4.jpg" class="">  </li><li>添加一个奇偶校验位。<br>奇校验码：码中1的个数为奇数。<br>偶校验码：码中1的个数为偶数。但多个位错误有可能检测不出来。    </li><li>求偶校验位：所有位数异或得到。<br>而进行偶校验时候，则把所有位异或看是否为0，为0则正确否则为错误。  <h2 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h2><img src="/2022/060652765/8.jpg" class="">  奇偶校验码没法查看哪些错误，只能反馈对/错。而海明码则把信息位分组进行偶校验，设置多个校验位，找出出错位置。   </li><li>信息n位，校验k位，则2的k次方大于等于n+k+1。<br>其中校验位的值根据信息位的位置求得，各个分组异或得到。  <img src="/2022/060652765/9.jpg" class="">   <img src="/2022/060652765/6.jpg" class="">   <img src="/2022/060652765/7.jpg" class="">   <h2 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h2><img src="/2022/060652765/12.jpg" class="">   </li><li>数据发送和接收方约定一个“除数”，K信息位+R校验位作为”被除数“,添加校验位之后保证余数为0，接收方检查余数是否为0。非0则重传/单比特纠错。当2的R次方大于等于K+R+1的时候，CRC码可以纠正一位错误（否则位置大于信息位能表示的位个数）  <img src="/2022/060652765/10.jpg" class="">   <img src="/2022/060652765/11.jpg" class="">   <h2 id="定点数的表示"><a href="#定点数的表示" class="headerlink" title="定点数的表示"></a>定点数的表示</h2><img src="/2022/060652765/18.jpg" class="">   定点数：小数点固定，比如99.99。<br>浮点数：小数点不固定，比如9.999*10（科学计数法）  </li><li>无符号数：整个机器字长全部二进制位均为数值位，没有符号位，通常是整数。表示范围0-2的n次方-1。  </li><li>有符号数：分别保存整数和小数<br>原码：  <img src="/2022/060652765/13.jpg" class="">   <img src="/2022/060652765/14.jpg" class="">   反码：<br>若符号为0，则反码和原码相同，否则数值位全部取反。  <img src="/2022/060652765/15.jpg" class="">   补码：  <img src="/2022/060652765/16.jpg" class="">  移码： <img src="/2022/060652765/17.jpg" class="">   方便计算机比较，从前到后位数哪个不是1哪个就小。<h2 id="各种码的作用"><a href="#各种码的作用" class="headerlink" title="各种码的作用"></a>各种码的作用</h2>补码让减法变为加法，节约硬件成本，ALU无须集成减法器。<br>移码实现两个整数的比较大小，用硬件非常方便。<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2>通过移位运算实现乘法和除法。  </li><li>原码的算数移位：<br>符号位不变，数值位移动。<br>右移：高位补0，低位舍弃。舍弃的位=0则相当于除2，若舍弃的位不等0，则丢失精度。<br>左移：低位补0，高位舍弃。舍弃的位=0则相当于乘2，若舍弃的位不等0，则出现严重误差。 </li><li>反码的算数移位：<br>正数的反码和原码一样，所以左右移位也一样。<br>负数的反码数值位和原码数值位相反，则：<br>右移：高位补1，低位舍弃。<br>左移：低位补1，高位舍弃。  </li><li>补码的算数移位：  <img src="/2022/060652765/19.jpg" class="">   <h2 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h2>单纯补充0  <h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2>左右端被移出的数字放到相反的一端。<br>但加法溢出的一位则有一个保留进位。（进位位）  <h2 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h2><img src="/2022/060652765/21.jpg" class="">    </li><li>原码的加减：<br>四种加法运算：++，+-，-+，—。<br>四种减法运算：转化为加法。  </li><li>补码的加减：  <img src="/2022/060652765/20.jpg" class="">   <h2 id="乘法和除法"><a href="#乘法和除法" class="headerlink" title="乘法和除法"></a>乘法和除法</h2>原码和补码的乘法除法（暂不复习）<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><img src="/2022/060652765/22.jpg" class="">   <h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2>定点数表示数字范围有限，但我们不能无限制增加长度。<br>十进制科学计数法：  <img src="/2022/060652765/23.jpg" class="">   阶码E反映浮点数的表示范围及小数点的实际位置。<br>尾数的数值部分的位数n反映浮点数的精度。  <img src="/2022/060652765/24.jpg" class="">  <h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><img src="/2022/060652765/25.jpg" class="">   浮点数标准 <h2 id="算数逻辑单元ALU"><a href="#算数逻辑单元ALU" class="headerlink" title="算数逻辑单元ALU"></a>算数逻辑单元ALU</h2><img src="/2022/060652765/30.jpg" class="">   </li><li>ALU功能：算术运算（加减乘除），逻辑运算（与或非异或），辅助功能（移位，求补）。<br>基本结构：输入，输出，控制。  <img src="/2022/060652765/26.jpg" class="">   </li><li>最基本的逻辑运算：与或非。优先级：与&gt;或。有分配律，结合律等定义简化电路。<br>复合逻辑：与非，或非，异或，同或（异或的取反）  </li><li>一位全加器FA：  <img src="/2022/060652765/27.jpg" class="">   </li><li>串行加法器：  <img src="/2022/060652765/28.jpg" class="">  </li><li>串行进位的并行加法器：  <img src="/2022/060652765/29.jpg" class="">    一般来说是四个FA组成一个4位的计算装置，依赖于低位的进位才可以进行计算，如何更快的产生进位？<br>利用多个四位的计算装置再次串联  <img src="/2022/060652765/31.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理计算机系统概述</title>
      <link href="/2022/06059000.html"/>
      <url>/2022/06059000.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机发展历程"><a href="#计算机发展历程" class="headerlink" title="计算机发展历程"></a>计算机发展历程</h2><ul><li><img src="/2022/06059000/2.jpg" class="">  </li><li>计算机系统=软件+硬件。<br>软件分为系统软件（OS，DBMS等）和应用软件。   </li><li>计算机发展历史：<br>硬件发展：  <img src="/2022/06059000/1.jpg" class="">   机器字长：计算机一次整数运算能够处理的二进制位数。<br>摩尔定律：集成电路可容纳的晶体管数目，每隔18个月便会增加一倍，整体性能也将提升一倍。<br>软件发展：<br>机器语言和汇编语言，高级编程语言（FORTRAN，PASCAL），操作系统从DOS到Windows。  <h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2></li><li><img src="/2022/06059000/7.jpg" class="">   </li><li><img src="/2022/06059000/3.jpg" class="">  </li><li><img src="/2022/06059000/4.jpg" class="">   特点：①计算机由五大部件组成（IO，存储器，运算器，控制器）。②指令和数据以同等地位位于存储器。③指令和数据二进制表示。④指令由操作码和地址码组成。⑤存储程序（提前存储）。⑥以运算器为中心（数据传送也通过运算器）。  </li><li><img src="/2022/06059000/5.jpg" class="">   </li><li><img src="/2022/06059000/6.jpg" class="">   <h2 id="认识硬件部件"><a href="#认识硬件部件" class="headerlink" title="认识硬件部件"></a>认识硬件部件</h2><img src="/2022/06059000/12.jpg" class="">   </li><li>主存储器基本组成：  <img src="/2022/06059000/8.jpg" class="">   </li><li>运算器的基本组成：  <img src="/2022/06059000/9.jpg" class="">   </li><li>控制器的基本组成：  <img src="/2022/06059000/10.jpg" class="">   </li><li>计算机总体运行步骤：  <img src="/2022/06059000/11.jpg" class="">    <h2 id="多级层次结构"><a href="#多级层次结构" class="headerlink" title="多级层次结构"></a>多级层次结构</h2><img src="/2022/06059000/15.jpg" class="">   </li><li>下层是上层的基础，上层是下层的扩展：  <img src="/2022/06059000/13.jpg" class="">   </li><li>编译程序和解释程序：  <img src="/2022/06059000/14.jpg" class="">    <h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><img src="/2022/06059000/19.jpg" class="">  </li><li>存储器的性能指标：  <img src="/2022/06059000/16.jpg" class="">  </li><li>CPU的性能指标：  <img src="/2022/06059000/17.jpg" class="">   </li><li>系统整体性能指标：  <img src="/2022/06059000/18.jpg" class="">  使用基准程序来测量计算机处理速度（跑分软件）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js</title>
      <link href="/2022/060232144.html"/>
      <url>/2022/060232144.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>Vue是一个专注于构建web用户界面的 JavaScript 库</li><li>作者：尤雨溪，中国人，早前就职于 Google</li><li>思想：MVVM（Model-View-ViewModel）</li><li>一个渐进式的框架</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-基础案例"><a href="#1-基础案例" class="headerlink" title="1.基础案例"></a>1.基础案例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8" /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            {{msg}}        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: "#app",                data:{                    msg:'hello'                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>el：是一个必不可少的属性，用来指定一个页面中已存在的Dom元素来挂载vue实例，其值可以是一个dom元素，也可以是css选择器</p><p>data:存放数据的对象</p><p>{}（两个）：文本插值，类似于：innerText，会把数据原封不动的显示出来，其中的值可以是JavaScript的表达式</p><p><strong>Vue3</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;VueDemo&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        {{msg}}    &lt;/div&gt;    &lt;script&gt;        const config = {            data(){                return {                    msg:"hello"                }            }        }        //Vue.createApp(config):基于config配置对象，创建一个Vue应用实例        //mount("#app"):把Vue实例挂载到id为app的div上        const root = Vue.createApp(config).mount("#app");    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="2-v-html"><a href="#2-v-html" class="headerlink" title="2.v-html"></a>2.v-html</h3><p>v-html：会对数据中的html内容进行解析，显示解析后的结果，类似于Dom的 innerHTML</p><p>v-text: 不会对数据中的html内容进行解析，类似于dom中的 innerText</p><pre><code>        &lt;div id="app"&gt;            {{msg}}&lt;br&gt;            &lt;p v-text="msg"&gt;&lt;/p&gt;            &lt;p v-html="msg"&gt;&lt;/p&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: "#app",                data:{                    msg:'&lt;span style="color:red;"&gt;hello&lt;/span&gt;'                }            });        &lt;/script&gt;</code></pre><h3 id="3-v-bind"><a href="#3-v-bind" class="headerlink" title="3.v-bind"></a>3.v-bind</h3><p>动态绑定一个或多个属性（简写形式： 冒号）</p><pre><code>        &lt;div id="app"&gt;            &lt;p :align="align" v-html="msg"&gt;&lt;/p&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: "#app",                data:{                    msg:'&lt;span style="color:red;"&gt;hello&lt;/span&gt;',                    align:'right'                }            });        &lt;/script&gt;</code></pre><h3 id="4-v-model"><a href="#4-v-model" class="headerlink" title="4.v-model"></a>4.v-model</h3><p>绑定表单数据，双向绑定</p><pre><code>        &lt;div id="app"&gt;                        &lt;input type="text" v-model="msg"&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: "#app",                data:{                    msg:'&lt;span style="color:red;"&gt;hello&lt;/span&gt;',                                    }            });        &lt;/script&gt;</code></pre><h3 id="5-v-on"><a href="#5-v-on" class="headerlink" title="5.v-on"></a>5.v-on</h3><p>绑定事件处理程序（简写：@）</p><pre><code>        &lt;div id="app"&gt;            &lt;input type="text" :value="msg"&gt;            &lt;input type="button" value="按钮" @click="del"&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el: "#app",                data:{                    msg:'&lt;span style="color:red;"&gt;hello&lt;/span&gt;',                },                methods:{                                            del(){                        console.log(100);                    }                }            });        &lt;/script&gt;</code></pre><h3 id="6-v-show"><a href="#6-v-show" class="headerlink" title="6.v-show"></a>6.v-show</h3><p>是否显示元素</p><p>当 v-show的值为：0、空字符串、undefined、null、false、NaN时候隐藏，其他显示</p><pre><code>&lt;p v-show="isShow"&gt;可能隐藏的内容&lt;/p&gt;data:{                        isShow:null}</code></pre><h3 id="7-v-if、v-else-if、v-else"><a href="#7-v-if、v-else-if、v-else" class="headerlink" title="7.v-if、v-else-if、v-else"></a>7.v-if、v-else-if、v-else</h3><pre><code>&lt;p v-if="isShow"&gt;可能隐藏的内容&lt;/p&gt;&lt;p v-else-if="elseIf"&gt;else if 部分&lt;/p&gt;&lt;p v-else&gt;else 部分&lt;/p&gt;data:{                        isShow:0,    elseIf:0}</code></pre><p>v-if和v-show区别</p><p>v-if：如果为false，删除dom元素，为true：创建dom元素</p><p>v-show：用来显示和隐藏元素</p><h3 id="8-v-for"><a href="#8-v-for" class="headerlink" title="8.v-for"></a>8.v-for</h3><p>循环指令</p><pre><code>&lt;p v-for="(name,index) in arr" &gt;{{index}}-{{name}}&lt;/p&gt;data:{                      arr:["tom","marry","scott"]}</code></pre><p>html模板</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="省市级联案例"><a href="#省市级联案例" class="headerlink" title="省市级联案例"></a>省市级联案例</h2><img src="/2022/060232144/1.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            省份：            &lt;select @change="getCity" v-model="province"&gt;                &lt;option&gt;请选择&lt;/option&gt;                &lt;option v-for="(item,index) in map.keys()"&gt;{{item}}&lt;/option&gt;            &lt;/select&gt;            城市：            &lt;select&gt;                &lt;option&gt;请选择&lt;/option&gt;                &lt;option v-for="(item,index) in cities"&gt;{{item}}&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    map: new Map([                        ["辽宁",["沈阳","大连"]],                        ["吉林",["长春","四平"]],                        ["黑龙江",["哈尔滨","齐齐哈尔"]]                    ]),                    province:'请选择',                    cities:[]                },                methods:{                    getCity(){                                                this.cities = this.map.get(this.province);                    }                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="移动列表选中项案例"><a href="#移动列表选中项案例" class="headerlink" title="移动列表选中项案例"></a>移动列表选中项案例</h2><img src="/2022/060232144/2.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;select size="10" multiple="multiple" v-model="leftSelected"&gt;                &lt;option v-for="n in leftList" &gt;{{n}}&lt;/option&gt;            &lt;/select&gt;            &lt;input type="button" value="=&gt;" @click="toRight"&gt;            &lt;input type="button" value="&lt;=" @click="toLeft"&gt;            &lt;select size="10" multiple="multiple"&gt;                &lt;option v-for="n in rightList" :value="n"&gt;{{n}}&lt;/option&gt;            &lt;/select&gt;        &lt;/div&gt;        &lt;script&gt;            var app = new Vue({                el:"#app",                data:{                    leftList:[1,2,3,4,5,6,7,8],                    rightList:[10,20],                    leftSelected:[2,3]                },                methods:{                    toRight(){                        for(n of this.leftSelected){                            this.rightList.push(n);                        }                        var temp = this.leftList.filter(n=&gt;!this.leftSelected.includes(n));                        this.leftList = temp;                    },                    toLeft(){                    }                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3实现"><a href="#vue3实现" class="headerlink" title="vue3实现"></a>vue3实现</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;vuedemo&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;    &lt;style&gt;        select{            width:40px;            height: 200px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        &lt;select multiple size="15" v-model="leftSel"&gt;            &lt;option v-for="n in left"&gt;{{n}}&lt;/option&gt;        &lt;/select&gt;        &lt;input type="button" value="=&gt;" @click="toRight"&gt;        &lt;input type="button" value="&lt;=" @click="toLeft"&gt;        &lt;select multiple size="15" v-model="rightSel"&gt;            &lt;option v-for="n in right"&gt;{{n}}&lt;/option&gt;        &lt;/select&gt;    &lt;/div&gt;    &lt;script&gt;    //vue的配置对象    let config = {        data(){            return {                left:['1','2','3','4','5','6','7','8','9'],                right:[],                leftSel:[],                rightSel:[]            }        },        methods:{            toRight(){                for(let i = 0;i &lt; this.leftSel.length;i++){                    this.right.push(this.leftSel[i])                    let index = this.left.indexOf(this.leftSel[i]);                    this.left.splice(index,1)                }                this.leftSel.length = 0            },            toLeft(){                for(let i = 0;i &lt; this.rightSel.length;i++){                    this.left.push(this.rightSel[i])                    let index = this.right.indexOf(this.rightSel[i]);                    this.right.splice(index,1)                }                this.rightSel.length = 0            }        }    }    //createApp方法返回一个应用程序对象    const app = Vue.createApp(config);    const p = app.mount("#app")    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;</code></pre><h2 id="vue绑定复选框"><a href="#vue绑定复选框" class="headerlink" title="vue绑定复选框"></a>vue绑定复选框</h2><pre><code>&lt;input type="checkbox" v-model="all" value="1"&gt;如果all为数组，选中复选框，value值在数组中，没有选中，value值不在数组中data:{    all:[]}如果all不是数组，选中复选框，all的值为true，不选中，为false,标签中的value值被覆盖data:{    all:true}</code></pre><h2 id="vue绑定下拉列表框"><a href="#vue绑定下拉列表框" class="headerlink" title="vue绑定下拉列表框"></a>vue绑定下拉列表框</h2><pre><code>&lt;select v-model="s" multiple&gt;    &lt;option&gt;1&lt;/option&gt;    &lt;option&gt;2&lt;/option&gt;    &lt;option&gt;3&lt;/option&gt;&lt;/select&gt;如果有multiple属性，需要绑定一个数组,数组中的元素被选中data:{    s:[]}如果没有multiple属性，需要绑定单个值，value等于该值的被选中，没有value属性的，value属性等于innerTextdata:{    s:'2'}</code></pre><h2 id="vue绑定单选按钮"><a href="#vue绑定单选按钮" class="headerlink" title="vue绑定单选按钮"></a>vue绑定单选按钮</h2><pre><code>&lt;input type="radio" value="1" v-model="r"&gt;&lt;input type="radio" value="2" v-model="r"&gt;单选按钮需要绑定到单个值，不能绑定到数组，当v-model的值与value值相等的时候，单选按钮被选中data:{    r:'1'}</code></pre><h2 id="Vue动态添加属性"><a href="#Vue动态添加属性" class="headerlink" title="Vue动态添加属性"></a>Vue动态添加属性</h2><p>默认情况下，vue不跟踪动态添加的属性</p><pre><code>        &lt;div id="app"&gt;            {{stu.name}}            &lt;input type="button" value="动态添加属性" @click="addAttr"&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    stu:{}                },                methods:{                    addAttr(){                        // this.stu.name ="tom";//不行                        // this.$set(this.stu,"name","tom")//可以                        Vue.set(this.stu,"name","tom");                    }                }            });        &lt;/script&gt;</code></pre><h2 id="综合案例：员工管理"><a href="#综合案例：员工管理" class="headerlink" title="综合案例：员工管理"></a>综合案例：员工管理</h2><img src="/2022/060232144/3.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            编号:&lt;input type="text" v-model="dept.deptno"&gt;&lt;br&gt;            名称:&lt;input type="text" v-model="dept.dname"&gt;&lt;br&gt;            地址:&lt;input type="text" v-model="dept.loc"&gt;&lt;br&gt;            &lt;input type="button" value="添加" @click="add"&gt;&lt;br&gt;            &lt;table border="1" width="500"&gt;                &lt;tbody &gt;                    &lt;tr v-for="dept,index in depts"&gt;                        &lt;td&gt;{{dept.deptno}}&lt;/td&gt;                        &lt;td v-if="dept.edit"&gt;                            &lt;input type="text"  v-model="tempDept.dname" size="4"&gt;                        &lt;/td&gt;                        &lt;td v-else&gt;{{dept.dname}}&lt;/td&gt;                        &lt;td v-if="dept.edit"&gt;                            &lt;input type="text"  v-model="tempDept.loc" size="4"&gt;                        &lt;/td&gt;                        &lt;td v-else&gt;{{dept.loc}}&lt;/td&gt;                        &lt;td&gt;                            &lt;input type="button" value="删除" @click="del(index)"&gt;                            &lt;input type="button" :value="dept.editBtnValue" @click="handleClick(dept,index)"&gt;                            &lt;input type="button" value="取消" @click="cancel(dept,index)"&gt;                        &lt;/td&gt;                    &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    depts:[],                    dept:{},                    tempDept:{},                    editBtnValue:"编辑"                },                created(){                    //模仿ajax操作，得到部门集合                    this.depts = [                        {"deptno":10,"dname":"市场部","loc":"沈阳","editBtnValue":"编辑"},                        {"deptno":20,"dname":"生产部","loc":"大连","editBtnValue":"编辑"},                        {"deptno":30,"dname":"供应部","loc":"北京","editBtnValue":"编辑"}                    ]                },                methods:{                    del(index){                        if(confirm("是否删除?")){                            this.depts.splice(index,1);                        }                    },                    add(){                        this.depts.push(this.dept);                        this.dept = {};                    },                    handleClick(dept,index){                        if(dept.editBtnValue == "编辑"){                            this.$set(dept,"edit",true)                            dept.editBtnValue = "保存";                            this.tempDept.dname = dept.dname;                            this.tempDept.loc = dept.loc;                        }else{                            dept.edit = false;                            dept.editBtnValue = "编辑";                            dept.dname = this.tempDept.dname;                            dept.loc = this.tempDept.loc;                        }                    },                    cancel(dept,index){                        dept.edit = false;                        dept.editBtnValue = "编辑";                    }                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="vue3实现-1"><a href="#vue3实现-1" class="headerlink" title="vue3实现"></a>vue3实现</h3><pre><code>&lt;template&gt;员工管理  &lt;table border="1" width="500"&gt;    &lt;tr v-for="emp,index in emps" :key="emp.empno"&gt;      &lt;template v-if="emp.edit"&gt;        &lt;td&gt;{{emp.empno}}&lt;/td&gt;        &lt;td&gt;&lt;input type="text" v-model="copyEmps[index].ename"&gt;&lt;/td&gt;        &lt;td&gt;&lt;input type="text" v-model="copyEmps[index].sal"&gt;&lt;/td&gt;        &lt;td&gt;          &lt;input type="button" value="保存" @click="update(index)"&gt;          &lt;input type="button" value="取消" @click="cancel(index)"&gt;        &lt;/td&gt;      &lt;/template&gt;      &lt;template v-else&gt;        &lt;td&gt;{{emp.empno}}&lt;/td&gt;        &lt;td&gt;{{emp.ename}}&lt;/td&gt;        &lt;td&gt;{{emp.sal}}&lt;/td&gt;        &lt;td&gt;          &lt;input type="button" value="编辑" @click="edit(index)"&gt;          &lt;input type="button" value="删除" @click="del(index)"&gt;        &lt;/td&gt;      &lt;/template&gt;    &lt;/tr&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "Emp",  data(){    return {      emps:[        {empno:1,ename:"tom",sal:3000},        {empno:2,ename:"scott",sal:2000},        {empno:3,ename:"marry",sal:3300}      ],      copyEmps:[]    }  },  created() {      //初始化的时候，复制员工数组    let s = JSON.stringify(this.emps);    this.copyEmps = JSON.parse(s);  },  methods:{    edit(index){      this.emps[index].edit = true    },    update(index){      this.emps[index].edit = false      this.emps[index] = {...this.copyEmps[index]}//克隆元素    },    cancel(index){      this.emps[index].edit = false      this.copyEmps[index] = {...this.emps[index]}    },    del(index){      if(confirm("是否删除")){        this.emps.splice(index,1)        this.copyEmps.splice(index,1)      }    }  }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>作用：处理一些复杂逻辑</p><pre><code>        &lt;div id="app"&gt;            商品单价：&lt;input type="text" v-model="price"&gt;&lt;br&gt;            商品数量：&lt;input type="text" v-model="num"&gt;&lt;br&gt;            总额：{{total}}        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    username:"marry",                    price:'',                    num:''                },                computed:{                    un(){                        return this.username.toUpperCase();                    },                    total(){                        return this.price * this.num;                    }                }            });        &lt;/script&gt;</code></pre><h2 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h2><p>可以通过watch来响应数据的变化</p><pre><code>        &lt;div id="app"&gt;            &lt;input type="text" v-model="km"&gt;千米&lt;br&gt;            &lt;input type="text" v-model="m"&gt;米&lt;br&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    km:'',                    m:''                },                watch:{                    km(newValue,oldValue){                        this.m = newValue * 1000;                    },                    m(newValue,oldValue){                        this.km = newValue/1000;                    }                }            });        &lt;/script&gt;</code></pre><p>监听对象</p><pre><code>&lt;body&gt;        &lt;div id="app"&gt;            商品单价：&lt;input type="text" v-model="good.price"&gt;&lt;br&gt;            商品数量：&lt;input type="text" v-model="good.num"&gt;&lt;br&gt;            总额：{{good.total}}        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    username:"marry",                    good:{                        price:'',                        num:'',                        total:''                    }                },                computed:{                    un(){                        return this.username.toUpperCase();                    },                    total(){                        return this.price * this.num;                    }                },                watch:{                    good:{                        //handle方法名固定                        handler(newValue,oldValue){                            newValue.total = newValue.price * newValue.num;                        },                        deep:true                    }                }            });        &lt;/script&gt;    &lt;/body&gt;</code></pre><h2 id="v-model参数特性"><a href="#v-model参数特性" class="headerlink" title="v-model参数特性"></a>v-model参数特性</h2><ol><li><p>lazy：在默认情况下，v-mode在每次 input 事件触发后，将输入框的值与数据同步，可以使用 lazy 修饰符，从而转变为使用 change 事件进行同步</p><pre><code>    &lt;body&gt;        &lt;div id="app"&gt;            &lt;input type="text" v-model.lazy="km"&gt;千米&lt;br&gt;            &lt;input type="text" v-model="m"&gt;米&lt;br&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    km:'',                    m:''                },                watch:{                    km(newValue,oldValue){                        this.m = newValue * 1000;                    },                    m(newValue,oldValue){                        this.km = newValue/1000;                    }                }            });        &lt;/script&gt;    &lt;/body&gt;</code></pre></li><li><p>number：如果想自动将用户输入值类型转换为数值类型，可以使用number修饰符</p><pre><code>&lt;input type="text" v-model.lazy.number="km"&gt;千米&lt;br&gt;</code></pre></li><li><p>trim:自动过滤用户输入的首尾空白符，使用trim去掉首尾空白符</p><pre><code>        &lt;div id="app"&gt;            &lt;input type="text" v-model.trim="msg"&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    msg:'tom'                }            });        &lt;/script&gt;</code></pre></li></ol><h2 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h2><ol><li><p>绑定 class 类样式（值是一个对象）</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;        &lt;style&gt;            .class1{                color:red;            }            .class2{                font-size: 40px;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;div :class="{class1:class1Style,class2:class2Style}"&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    class1Style:true,                    class2Style:true                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>可以把一个数组传递给class属性</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;        &lt;style&gt;            .class1{                color:red;            }            .class2{                font-size: 40px;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;div :class="[class1Style,class2Style]"&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    class1Style:'class1',                    class2Style:"class2"                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>style对象语法</p><pre><code>        &lt;div id="app"&gt;            &lt;div :style="{'color':color,'font-size':size}"&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    color:'blue',                    size:'50px'                }            });        &lt;/script&gt;</code></pre></li><li><p>style数组语法</p><pre><code>        &lt;div id="app"&gt;            &lt;div :style="[style1,style2]"&gt;                动态样式            &lt;/div&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    style1:{'color':'red'},                    style2:{'font-size':'20px'}                }            });        &lt;/script&gt;</code></pre></li></ol><h2 id="定时器使用案例"><a href="#定时器使用案例" class="headerlink" title="定时器使用案例"></a>定时器使用案例</h2><img src="/2022/060232144/4.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;div&gt;{{name}}&lt;/div&gt;            &lt;input type="button" value="开始" @click="startGame"&gt;            &lt;input type="button" value="停止" @click="stopGame"&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var app = new Vue({                el:"#app",                data:{                    name:'请选择',                    arr:["唐僧","悟空","八戒","沙僧","小白龙"],                    t:'',                    index:0                },                methods:{                    startGame(){                        this.index = parseInt(Math.random()*this.arr.length);                        this.name = this.arr[this.index];                        this.t = setTimeout(this.startGame,100);                    },                    stopGame(){                        clearTimeout(this.t);                        this.arr.splice(this.index,1);                    }                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="定时器练习"><a href="#定时器练习" class="headerlink" title="定时器练习"></a>定时器练习</h3><img src="/2022/060232144/5.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;vuedemo&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="app"&gt;        &lt;div&gt;            &lt;input type="button" v-for="num in arr" :value="num"&gt;            和：{{sum}}        &lt;/div&gt;        &lt;input type="button" value="开始" @click="startGame"&gt;        &lt;input type="button" value="结束" @click="stopGame"&gt;    &lt;/div&gt;    &lt;script&gt;    //vue的配置对象    let config = {        data(){            return {                arr:[0,0,0,0],                t:-1,                sum:0            }        },        methods:{            startGame(){                this.arr.length = 0;                this.sum = ''                /*for(let i = 0;i &lt; 4;i++){                    let n = parseInt(Math.random()*10);                    this.arr.push(n);                }*/                //生成各不相同的4个数                while(true){                    let n = parseInt(Math.random()*10);                    if(this.arr.indexOf(n) == -1){                        this.arr.push(n);                    }                    if(this.arr.length == 4) break;                }                this.t = setTimeout(this.startGame,100)            },            stopGame(){                clearTimeout(this.t)                this.sum = 0;                for(let i = 0;i &lt; 4;i++){                    this.sum += this.arr[i]                }            }        }    }    //createApp方法返回一个应用程序对象    const app = Vue.createApp(config);    const p = app.mount("#app")    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ol><li><p>定义：可以复用的Vue实例，且带有一个名字</p></li><li><p>使用</p><ul><li><p>定义组件</p><pre><code>            const mybtn = {                template:                `                &lt;button type="button" @click="add"&gt;点击 {{num}}&lt;/button&gt;                `,                //data必须是一个方法                data(){                    return{                        num:0                    }                },                methods:{                    add(){                        this.num++;                    }                }            };            const mybtn = Vue.extend({            });</code></pre></li><li><p>注册</p><ul><li><p>全局注册</p><pre><code>Vue.component("mybtn",mybtn);</code></pre></li><li><p>局部注册</p><pre><code>            var app = new Vue({                el:"#app",                data:{                },                components:{                    "mybtn":mybtn//简写：mybtn                }            });</code></pre></li></ul></li><li><p>使用</p><pre><code>&lt;div id="app"&gt;    &lt;mybtn&gt;&lt;/mybtn&gt;&lt;/div&gt;</code></pre></li></ul></li><li><p>vue组件命名</p><p>在模板中（挂载点）的标签名（组件名），使用短横线命名法（单词之间用短横线分隔），所有字符小写</p></li><li><p>template编写方法</p><ul><li><p>直接写到vue实例对象中</p></li><li><p>使用<template>标签</template></p><pre><code>        &lt;template id="btn"&gt;            &lt;button type="button" @click="add"&gt;点击 {{num}}&lt;/button&gt;        &lt;/template&gt;        &lt;script type="text/javascript"&gt;            const mybtn = {                template:"#btn",                data(){                    return{                        num:0                    }                },                methods:{                    add(){                        this.num++;                    }                }            };            //全局注册            // Vue.component("myBtn",mybtn);            var app = new Vue({                el:"#app",                data:{                },                components:{                    "myBtn":mybtn                }            });        &lt;/script&gt;</code></pre></li></ul></li></ol><h2 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h2><ol><li><p>使用 prop 属性向组件传值，在组件中定义属性接收值</p><pre><code>//父组件&lt;my-btn num="10"&gt;&lt;/my-btn&gt;//子组件        &lt;template id="btn"&gt;            &lt;button type="button" @click="add"&gt;点击 {{num}}&lt;/button&gt;        &lt;/template&gt;            const mybtn = {                template:"#btn",                data(){                    return{                        n:''                    }                },                created(){                    this.n = this.num;//初始同步                },                methods:{                    add(){                        this.n++;                    }                },                props:[                    "num"                ]            };</code></pre></li><li><p>在子组件中，可以向使用data的属性一样，来使用props中的属性</p></li><li>注意：在子组件中不要去改变属性的值</li></ol><h2 id="通过-自定义事件-子组件向父组件传值"><a href="#通过-自定义事件-子组件向父组件传值" class="headerlink" title="通过 自定义事件 子组件向父组件传值"></a>通过 自定义事件 子组件向父组件传值</h2><ol><li><p>在 子组件中 触发自定义事件（什么时候想向父组件传值，什么时候触发）</p><pre><code>this.$emit("retval",this.n);</code></pre></li><li><p>父组件中，订阅子组件触发的自定义事件</p><pre><code>&lt;my-btn :num="num" @retval="getValue($event)"&gt;&lt;/my-btn&gt;</code></pre></li><li><p>注意：自定义的事件名与组件命名规则相同</p></li></ol><h2 id="组件传值综合练习"><a href="#组件传值综合练习" class="headerlink" title="组件传值综合练习"></a>组件传值综合练习</h2><img src="/2022/060232144/6.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;div&gt;        &lt;child v-for="q in n" :endval="endval" :isstart="isstart" @myevent="getVal($event)" style="width:30px"&gt;&lt;/child&gt;        &lt;div&gt;            &lt;input type="button" value="开始" @click="isstart=true" &gt;            &lt;input type="button" value="停止" @click="isstart=false" &gt;            和:{{sum}}        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;template id="child"&gt;    &lt;input type="button" v-model="num"&gt;&lt;/template&gt;&lt;script&gt;    let child = {        template: "#child",        props: [            "endval",            "isstart"        ],        created() {            this.start();        },        data() {            return {                num: '0',//按钮上默认数字                b:false//是否已返回数            }        },        methods: {            start() {                setTimeout(this.start, 100);//循环执行，始终监听是否重新开始运行                if (this.isstart) {                    this.num = parseInt(Math.random() * this.endval) + 1;//产生随机数                    this.b = false;//重新开始                }else{                    if(!this.b){                        this.$emit("myevent",this.num);//触发自定义事件，并返回数                        this.b = true//已返回数                    }                }            }        }    }    let app = new Vue({        el: "#app",        components: {            child        },        data: {            isstart: true,//是否开始            endval: 35,//数字范围            nums:[],//存储组件返回的数            sum:0,//和            n:10,//按钮个数            i:0//已返回数字的按钮数        },        methods:{            getVal(num){                this.nums.push(num);//把新产生的数添加到数组中                this.i++;                //全部组件都返回数后计算                if(this.i == this.n){                    this.sum = 0;//重新开始计算                    for(let p of this.nums){                        this.sum += p;                    }                    this.nums = [];//重新开始计算                    this.i = 0;//重新开始计算                }            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="向子组件传值，修改后再返回"><a href="#向子组件传值，修改后再返回" class="headerlink" title="向子组件传值，修改后再返回"></a>向子组件传值，修改后再返回</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;  &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id="app"&gt;    &lt;child :com-num="num" @myevent="num=$event" &gt;&lt;/child&gt;      &lt;!--&lt;child :com-num.sync="num"&gt;&lt;/child&gt;--&gt;      &lt;div&gt;          {{num}}      &lt;/div&gt;  &lt;/div&gt;&lt;template id="child"&gt;    &lt;div&gt;        &lt;input type="text" :value="comNum"&gt;        &lt;input type="text" v-model="num"&gt;        &lt;input type="button" value="传出" @click="toVal"&gt;    &lt;/div&gt;&lt;/template&gt;  &lt;script&gt;      let child = {          template:"#child",          props:[              "comNum"          ],          data(){              return {                  num:''              }          },          methods: {              toVal(){                  // this.$emit("update:comNum",this.num)                  this.$emit("myevent",this.num)              }          }      }    var app = new Vue({      el:"#app",      data:{        num:10      },        components:{          child        }    });  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>简化写法：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;!--&lt;child :com-num="num" @myevent="num=$event" &gt;&lt;/child&gt;--&gt;    &lt;!--.sync表示异步修改，需要组件内支持，即自定义事件名为：update:组件属性名--&gt;    &lt;child :com-num.sync="num"&gt;&lt;/child&gt;    &lt;div&gt;        {{num}}    &lt;/div&gt;&lt;/div&gt;&lt;template id="child"&gt;    &lt;div&gt;        &lt;input type="text" :value="comNum"&gt;        &lt;input type="text" v-model="num"&gt;        &lt;input type="button" value="传出" @click="toVal"&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = {        template: "#child",        props: [            "comNum"        ],        data() {            return {                num: ''            }        },        methods: {            toVal() {                //update:comNum中的comNum与属性名相同，前缀固定为update                this.$emit("update:comNum", this.num)                // this.$emit("myevent",this.num)            }        }    }    var app = new Vue({        el: "#app",        data: {            num: 10        },        components: {            child        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>需求：组件间传递值比较麻烦，有的时候，仅仅需要把父组件的值显示到子组件的可视范围内</p><p>匿名插槽：<code>&lt;slot&gt;&lt;/slot&gt;</code>，只能有一个</p><pre><code>&lt;body&gt;&lt;div id="app"&gt;    &lt;child&gt;{{msg}}&lt;/child&gt;&lt;/div&gt;&lt;template id="child"&gt;    &lt;div&gt;        &lt;hr&gt;        &lt;!-- 引用父组件的值 --&gt;        &lt;slot&gt;&lt;/slot&gt;        &lt;hr&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = {        template: "#child"    }    let app = new Vue({        el: "#app",        data: {            msg: 'hello'        },        components: {            child        }    });&lt;/script&gt;</code></pre><p>具名插槽：<code>&lt;slot name="插槽名"&gt;&lt;/slot&gt;</code></p><img src="/2022/060232144/7.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;child &gt;                &lt;!--为插槽s1赋值--&gt;                &lt;template slot="s1"&gt;marry&lt;/template&gt;                &lt;template slot="s2"&gt;scott&lt;/template&gt;                &lt;!--为匿名插槽赋值--&gt;                &lt;template&gt;{{msg}}&lt;/template&gt;                &lt;!--或 {{msg}}--&gt;            &lt;/child&gt;        &lt;/div&gt;        &lt;template id="child"&gt;            &lt;div&gt;                子组件                &lt;hr&gt;                &lt;slot name="s1"&gt;&lt;/slot&gt;                &lt;hr&gt;                &lt;slot name="s2"&gt;&lt;/slot&gt;                &lt;hr&gt;                &lt;slot&gt;&lt;/slot&gt;                &lt;hr&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;script type="text/javascript"&gt;            var child = {                template:"#child"                            };            var app = new Vue({                el:"#app",                data:{                    msg:"tom"                },                components:{                    child                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>注意：插槽属于父组件，在子组件中，只能决定放置在哪个地方，不能修改</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>作用：把子组件的值通过插槽属性传递出来，由父组件决定如何显示，并且只在当前插槽中有效</p><p>slot-scope：就像一个临时变量，包含了从组件传回的所有属性。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;child&gt;        &lt;template slot-scope="scope" slot="s1"&gt;            &lt;span&gt;姓名：{{scope.name1}}&lt;/span&gt;            &lt;span&gt;年龄：{{scope.age}}&lt;/span&gt;        &lt;/template&gt;    &lt;/child&gt;&lt;/div&gt;&lt;template id="child"&gt;    &lt;div&gt;        &lt;!-- 注意插槽的属性不能为name，否则不显示 --&gt;        &lt;slot name="s1" :name1="name" :age="age"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = {        template: "#child",        data(){            return{                name:'tom',                age:20            }        }    }    let app = new Vue({        el: "#app",        data: {            msg: 'hello'        },        components: {            child        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>也可以传递对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;script src="js/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;    &lt;child&gt;        &lt;template slot-scope="scope" slot="s1"&gt;            &lt;span&gt;姓名：{{scope.stu.name}}&lt;/span&gt;            &lt;span&gt;年龄：{{scope.stu.age}}&lt;/span&gt;        &lt;/template&gt;    &lt;/child&gt;&lt;/div&gt;&lt;template id="child"&gt;    &lt;div&gt;        &lt;slot name="s1" :stu="stu"&gt;&lt;/slot&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    let child = {        template: "#child",        data(){            return{                stu:{name:"tom",age:20}//传递对象            }        }    }    let app = new Vue({        el: "#app",        data: {            msg: 'hello'        },        components: {            child        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><img src="/2022/060232144/8.jpg" class=""><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;        &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;child :data="arr"&gt;                &lt;template slot-scope="scope"&gt;                    &lt;li&gt;&lt;h3&gt;{{scope.n}}&lt;/h3&gt;&lt;h4&gt;{{scope.i}}&lt;/h4&gt;&lt;/li&gt;                &lt;/template&gt;            &lt;/child&gt;        &lt;/div&gt;        &lt;template id="t1"&gt;            &lt;div&gt;                &lt;ul&gt;                    &lt;slot v-for="(name,index) in data" :n="name" :i="index"&gt;&lt;/slot&gt;                &lt;/ul&gt;            &lt;/div&gt;        &lt;/template&gt;        &lt;script type="text/javascript"&gt;            var child = {                template:"#t1",                props:[                    "data"                ]            }            var app = new Vue({                el:"#app",                data:{                    arr:["tom","marry","scott"]                },                components:{                    child                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p><code>&lt;component :is="com"&gt;&lt;/component&gt;</code>:com属性的值是一个组件对象</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;component :is="com"&gt;&lt;/component&gt;            &lt;button type="button" @click="getCom"&gt;切换组件&lt;/button&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var com1 = {                template:`&lt;div&gt;组件1&lt;/div&gt;`            }            var com2 = {                template:`&lt;div&gt;组件2&lt;/div&gt;`            }            var app = new Vue({                el:"#app",                data:{                    com:com2                },                components:{                    com1,com2                },                methods:{                    getCom(){                        this.com = com1;                    }                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol><li><p>作用：在应用中切换组件</p></li><li><p>使用</p><ul><li><p>创建组件</p></li><li><p>导入路由文件</p><pre><code>&lt;script src="js/vue-router.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;</code></pre></li><li><p>创建路由器实例，配置路由器</p><pre><code>            var router = new VueRouter({                //路由表                routes:[                    //路由                    {                        path:'/login',                        component:login                    },                    {                        path:'/main',                        component:main                    }                ]            });</code></pre></li><li><p>注册路由器</p><pre><code>            var app = new Vue({                el:"#app",                data:{                },                router            });</code></pre></li><li><p><code>&lt;router-link to="/login"&gt;登录页&lt;/router-link&gt;</code>:功能类似于超链接，用来链接组件</p></li><li><p><code>&lt;router-view&gt;&lt;/router-view&gt;</code>：用来显示组件</p></li><li><p>使用代码切换组件</p><pre><code>this.$router.push("/main");</code></pre></li><li><p>显示第一个组件</p><pre><code>//配置路由 {     path:'/',     component:login } //通过代码             var app = new Vue({                el:"#app",                data:{                },                router,                created(){                    this.$router.push("/login");                }            });</code></pre></li><li><p>命名路由</p><pre><code>                    {                        path:'/login',                        name:"login",                        component:login                    },                    {                        path:'/main',                        name:"main",                        component:main                    }</code></pre><p>使用路由名子切换组件</p><pre><code>this.$router.push({name:'login'}).catch(()=&gt;{});</code></pre></li><li><p>嵌套路由</p><pre><code>            var router = new VueRouter({                //路由表                routes:[                    //路由                    /* {                        path:'/',                        component:login                    }, */                    {                        path:'/login',                        name:"login",                        component:login                    },                    {                        path:'/main',                        name:"main",                        component:main,                        children:[                            {                                path:'/dept',                                name:'dept',                                component:dept                            },                            {                                path:'/emp',                                name:'emp',                                component:emp                            }                        ]                    }                ]            });</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset="utf-8"&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script src="js/vue.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;        &lt;script src="js/vue-router.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;        &lt;style&gt;            #parent{                width: 800px;                height:500px;                display: flex;            }            #nav{                width:100px;                height:500px;                background-color: bisque;            }            #main{                width:600px;                height:500px;                background-color: aliceblue;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id="app"&gt;            &lt;!-- &lt;router-link to="/login"&gt;登录页&lt;/router-link&gt;            &lt;router-link to="/main"&gt;主页&lt;/router-link&gt; --&gt;            &lt;router-view&gt;&lt;/router-view&gt;        &lt;/div&gt;        &lt;script type="text/javascript"&gt;            var login = {                template:`                    &lt;div&gt;                        &lt;h1&gt;登录页&lt;/h1&gt;                        &lt;input type="button" value="登录" @click="login"&gt;                    &lt;/div&gt;                `,                methods:{                    login(){                        this.$router.push("/main");                    }                }            }            var main = {                template:`                    &lt;div&gt;                        &lt;h1&gt;主页&lt;/h1&gt;                        &lt;div id="parent"&gt;                            &lt;div id="nav"&gt;                                &lt;h4&gt;导航&lt;/h4&gt;                                &lt;router-link to="/dept"&gt;部门管理&lt;/router-link&gt;&lt;br&gt;                                &lt;router-link to="/emp"&gt;员工管理&lt;/router-link&gt;                            &lt;/div&gt;                            &lt;div id="main"&gt;                                &lt;h4&gt;主区域&lt;/h4&gt;                                &lt;router-view&gt;&lt;/router-view&gt;                            &lt;/div&gt;                        &lt;/div&gt;                    &lt;/div&gt;                `            }            var dept = {                template:`&lt;div&gt;&lt;h2&gt;部门管理&lt;/h2&gt;&lt;/div&gt;`            }            var emp = {                template:`&lt;div&gt;&lt;h2&gt;员工管理&lt;/h2&gt;&lt;/div&gt;`            }            var router = new VueRouter({                //路由表                routes:[                    //路由                    /* {                        path:'/',                        component:login                    }, */                    {                        path:'/login',                        name:"login",                        component:login                    },                    {                        path:'/main',                        name:"main",                        component:main,                        children:[                            {                                path:'/dept',                                name:'dept',                                component:dept                            },                            {                                path:'/emp',                                name:'emp',                                component:emp                            }                        ]                    }                ]            });            var app = new Vue({                el:"#app",                data:{                },                router,                created(){                    // this.$router.push("/login");                    this.$router.push({name:'login'}).catch(()=&gt;{});                }            });        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ul></li></ol><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><ol><li><p>向切换后的组件传递参数</p></li><li><p>动态路由</p><pre><code>//路由表{    path:'/dept/:deptno',    name:'dept',    component:dept}//router-link&lt;router-link to="/dept/10"&gt;部门管理&lt;/router-link&gt;//在组件中得到路由参数{{$route.params.deptno}}this.deptno = this.$route.params.deptno;</code></pre><pre><code>//路由表{    path:'/dept',    component:dept}//router-link&lt;router-link :to="{path:'/update_dept',query:{'deptno':dept.deptno}}"&gt;更新&lt;/router-link&gt;//在组件中得到路由参数{{$route.query.deptno}}this.deptno = this.$route.query.deptno;</code></pre></li><li><p>查询参数（查询参数会显示在地址栏中）</p><pre><code>//路由表{    path:'/dept',    name:'dept',    component:dept}发送数据：this.$router.push({name:'main',query:{username:'admin',age:20}});接收数据：{{$route.query.username}}this.username = this.$route.query.username;</code></pre><p>通过 name 和 params 结合传递参数（地址栏中不显示参数数据）</p><pre><code>//路由表{    path:'/dept',    name:'dept',    component:dept}发送数据：this.$router.push({name:'main',params:{username:'admin',age:20}});接收数据：{{$route.params.username}}this.username = this.$route.params.username;</code></pre></li></ol><h2 id="Vue-Cli"><a href="#Vue-Cli" class="headerlink" title="Vue-Cli"></a>Vue-Cli</h2><ol><li><p>vue.js开发的标准工具</p></li><li><p>Node.js:是一个基于 Chrome V8引擎的 JavaScript运行时环境</p></li><li><p>npm：是随着node.js一起安装的包管理工具，允许用户从npm服务器下载别人编写好的第三方包到本地</p><p>测试：npm —version</p></li><li><p>安装 cnpm</p><pre><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code></pre></li><li><p>安装 Vue-Cli</p><pre><code>cnpm install -g @vue/cli</code></pre></li><li><p>启动项目</p><pre><code>npm run serve</code></pre></li><li><p>安装路由(脚手架插件)</p><pre><code>vue add router</code></pre><p>或</p><pre><code>npm（cnpm） install vue-router</code></pre></li></ol><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><ol><li><p>安装：</p><pre><code>vue add axios</code></pre></li><li><p>定义：易用、简洁且高效的http库</p></li><li><p>作用：用户向后台服务器发送异步请求，并处理响应的结果</p></li><li><p>配置：</p><pre><code>//基础路径配置axios.defaults.baseURL="http://localhost:8089/"//允许传递证书axios.defaults.withCredentials=true</code></pre></li><li><p>get请求</p><pre><code>var url = `emp/getPaged?pageNum=${pageNum}&amp;pageSize=${pageSize}`;axios.get(url).then((resp)=&gt;{    console.log(resp);});</code></pre><pre><code>var url = `emp/getPaged`;var params = {    pageNum:pageNum,    pageSize:pageSize}axios.get(url,{params:params}).then((resp)=&gt;{    console.log(resp);});</code></pre></li><li><p>post请求</p><pre><code>var url = `emp/getPaged`;                    axios.post(url,`pageNum=${pageNum}&amp;pageSize=${pageSize}`).then((resp)=&gt;{     console.log(resp);});</code></pre><pre><code>@RequestMapping("update")public int update(@RequestBody Emp emp) {    return empService.update(emp);}update(){    var url = "emp/update";        //this.empVO.emp：为JSON对象        axios.post(url,this.empVO.emp).then((resp)=&gt;{        if(resp.data == 1){            alert("更新成功！");            this.$router.push("/emp")        }    });}</code></pre></li></ol><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ol><li><p>安装</p><pre><code>npm install --save vuex</code></pre></li><li><p>Vuex是Vue的状态管理库，用来管理状态（应用程序中的信息或数据）。它将状态存储在一个中心位置，使得任何组件都很容易与之交互</p></li><li><p>使用</p><ul><li><p>在src目录下，添加一个文件：store.js,创建Vuex的Store对象</p><pre><code>import Vue from 'vue'import Vuex from 'vuex'//安装Vuex插件Vue.use(Vuex)export default new Vuex.Store({    state:{        count:0    }})</code></pre></li><li><p>在main.js,导入 store.js</p><pre><code>import Vue from 'vue'import './plugins/axios'import App from './App.vue'import router from './router'import store from './store'Vue.config.productionTip = false//基础路径配置axios.defaults.baseURL="http://localhost:8089/"//允许传递证书axios.defaults.withCredentials=truenew Vue({  router,  store,  render: h =&gt; h(App)}).$mount('#app')</code></pre></li><li><p>在组件中访问</p><pre><code>{{$store.state.count}}</code></pre></li><li><p>在组件内，来自store的数据是只读的，不能手工修改，改变 store中数据的唯一途径就是显示的提交mutations</p><pre><code>export default new Vuex.Store({    state:{        count:10    },    mutations:{        add(state,payload){            //payload可以是一个对象            //state.count += payload.num;            state.count += payload;        }    }})//this.$store.commit("add",{num:6});this.$store.commit("add",5);</code></pre></li><li><p>使用store中的getters，来处理state数据，以便以统一的形式来显示数据</p><pre><code>export default new Vuex.Store({    state:{        count:10    },    mutations:{        add(state,payload){            state.count += payload.num;        }    },    getters:{        formatCount(state){            return `个数:${state.count}`;        }    }}){{$store.getters.formatCount}}</code></pre></li><li><p>使用 store的 actions，来执行异步状态管理</p><pre><code>export default new Vuex.Store({    state:{        count:10    },    mutations:{        add(state,payload){            state.count += payload.num;        }    },    getters:{        formatCount(state){            return `个数:${state.count}`;        }    },    actions:{        add2(context,payload){            setTimeout(function(){                context.commit("add",payload);            },1000)        }    }})this.$store.dispatch("add2",{num:7});//异步操作</code></pre></li></ul></li></ol><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><ol><li><p>在路由切换前，对路由进行检查</p></li><li><p>通过路由守卫实现修改网页title的功能</p><ul><li><p>在每个路由中添加meta属性，记录title信息</p><pre><code>export default new Router({  mode: 'history',  base: process.env.BASE_URL,  routes: [    {      path: '/',      name: 'login',      component: Login,      meta:{          title:"登录"      }    },    {      path: '/main',      name: 'main',      // route level code-splitting      // this generates a separate chunk (about.[hash].js) for this route      // which is lazy-loaded when the route is visited.      component: () =&gt; import('./views/Main.vue'),      meta:{          title:"主页"      },      children:[          {              path:"/dept",              name:'dept',              component: ()=&gt; import('./views/Dept.vue'),              meta:{                  title:"部门管理"              }          },          {              path:"/emp",              name:'emp',              component: ()=&gt; import('./views/Emp.vue'),              meta:{                  title:"员工管理"              }          },          {              path:"/empedit",              name:'empedit',              component: ()=&gt; import('./views/EmpEdit.vue'),              meta:{                  title:"编辑员工"              }          }      ]    }  ]})</code></pre></li><li><p>路由守卫</p><pre><code>router.beforeEach((to,from,next)=&gt;{    window.document.title = to.meta.title;    next();})new Vue({  router,  store,  render: h =&gt; h(App)}).$mount('#app')</code></pre><p>to：路由对象，即将要进入的目标</p><p>from:路由对象，当前导航要离开的路由</p><p>next：方法，一定要调用，决定后续如何导航处理</p><ul><li>next():继续后续的操作</li><li>next(false):中断当前导航</li><li>next(“/url”):跳转到参数指定的地址</li></ul></li></ul></li><li><p>使用路由守卫进行登录检查 </p><pre><code>login(){                this.$.commit("setUsername","admin");                this.$router.push("/main");            }</code></pre><pre><code>router.beforeEach((to,from,next)=&gt;{    window.document.title = to.meta.title;    if(to.name != "login" &amp;&amp; !store.state.username){        next("/")    }    next();})</code></pre></li></ol><h2 id="路由监听"><a href="#路由监听" class="headerlink" title="路由监听"></a>路由监听</h2><ol><li><pre><code>&lt;div id="nav"&gt;    &lt;h4&gt;导航&lt;/h4&gt;    &lt;router-link to="/dept/10"&gt;10部门管理&lt;/router-link&gt;&lt;br&gt;    &lt;router-link to="/dept/20"&gt;20部门管理&lt;/router-link&gt;&lt;br&gt;    &lt;router-link to="/emp"&gt;员工管理&lt;/router-link&gt;&lt;/div&gt;{    path:"/dept/:deptno",    name:'dept',    component: ()=&gt; import('./views/Dept.vue'),    meta:{        title:"部门管理"    }}watch:{    $route(to,from){        this.deptno = this.$route.params.deptno;    }}</code></pre></li></ol><h2 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h2><ol><li><p>安装</p><pre><code>npm i element-ui -S</code></pre></li><li><p>修改main.js</p><pre><code>import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'//在vue中安装 element-ui插件Vue.use(ElementUI)</code></pre></li><li><p>登录页前端</p><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;el-form class="login-container" :model="user" :rules="rules" ref="loginForm"&gt;            &lt;h3 class="login-title"&gt;系统登录&lt;/h3&gt;            &lt;el-form-item prop="username"&gt;                &lt;el-input type="text" v-model="user.username" placeholder="账号"&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop="password"&gt;                &lt;el-input type="password" v-model="user.password" placeholder="密码"&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item prop="checkCode"&gt;                &lt;img :src="imgUrl"&gt;&lt;a href="#" @click="getcode"&gt;看不清&lt;/a&gt;                &lt;el-input type="text" v-model="user.checkCode" placeholder="验证码"&gt;&lt;/el-input&gt;            &lt;/el-form-item&gt;            &lt;el-form-item&gt;                &lt;el-button type="primary" style="width:100%;" @click="login"&gt;登录&lt;/el-button&gt;            &lt;/el-form-item&gt;        &lt;/el-form&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        data(){            var checkCodeValidate = (rule,value,callback)=&gt;{                var url = "user/checkCode";                axios.post(url,`checkCode=${this.user.checkCode}`).then(resp=&gt;{                    if(!resp.data){                        callback(new Error("验证输入错误！"));                    }else{                        callback();                    }                });            };            return{                imgUrl:"http://localhost:8089/user/getCode",                user:{},                rules:{                    username:[                        {required:true,message:'请输入用户名',trigger:['blur','change']},                        {min:2,max:10,message:'用户名长度必须在2-10个字符之间',trigger:['blur','change']}                    ],                    password:[                        {required:true,message:'请输入密码',trigger:['blur','change']},                        {min:2,max:10,message:'密码长度必须在2-10个字符之间',trigger:['blur','change']}                    ],                    checkCode:[                        {required:true,message:'请输入验证码',trigger:['blur','change']},                        {pattern:/^\w{4}$/,message:"验证码长度必须为4位"},                        {validator:checkCodeValidate,trigger:'blur'}                    ]                }            }        },        methods:{            login(){                this.$refs["loginForm"].validate(valid=&gt;{                    if(valid){                        var url = "user/login";                        axios.get(url,{params:this.user}).then((resp)=&gt;{                            if(resp.data){                                this.$store.commit("setUsername",this.user.username);                                this.$router.push("/main");                            }else{                                this.$alert("用户名或密码错误！");                            }                        });                    }                });            },            getcode(){                this.imgUrl = this.imgUrl + "?"+Math.random();            }        }    }&lt;/script&gt;&lt;style scoped="scoped"&gt;    .login-container{        width:350px;        margin:100px auto 10px;        border:1px solid #eaeaea;        padding:35px 35px 15px 35px;        border-radius: 15px;        box-shadow:0 0 25px #cac6c6;    }    .login-title{        text-align: center;        color:#505458;        margin:0px auto 40px;    }&lt;/style&gt;</code></pre></li><li><p>登录页后端</p><pre><code>package com.neu.controller;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import javax.imageio.ImageIO;import javax.servlet.http.HttpSession;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController {    /*     * @RequestMapping("/") public String getLogin() { return "user/login"; }     */    @RequestMapping("user/login")    public boolean login(String username,String password,HttpSession session) {        if("admin".equals(username) &amp;&amp; "111".equals(password)) {            session.setAttribute("username", username);            return true;        }else {            return false;        }    }    @RequestMapping("user/getCode")    public ResponseEntity&lt;byte[]&gt; getCode(HttpSession session) throws IOException{        char[] arr = {'0','1','2','3','4','5','6','7','8','9'};        StringBuilder stb = new StringBuilder();        int n;        for(int i = 0;i &lt; 4;i++) {            n = (int)(Math.random()*arr.length);            stb.append(arr[n]);        }        session.setAttribute("code", stb.toString());        //把字符串放入到图片中，写入到输出流中        BufferedImage buffImg = new BufferedImage(90, 20, BufferedImage.TYPE_INT_RGB);        //得到画布        Graphics g = buffImg.getGraphics();        //向画布中写入字符串        g.drawString(stb.toString(), 20, 15);        ByteArrayOutputStream bos = new ByteArrayOutputStream();        ImageIO.write(buffImg, "jpeg", bos);        return new ResponseEntity&lt;byte[]&gt;(bos.toByteArray(),HttpStatus.CREATED);    }    @RequestMapping("user/checkCode")    public boolean checkCode(String checkCode,HttpSession session) {        String code = (String)session.getAttribute("code");        if(code != null &amp;&amp; code.equals(checkCode)) {            return true;        }else {            return false;        }    }}</code></pre></li></ol><h2 id="Vue-Router-4"><a href="#Vue-Router-4" class="headerlink" title="Vue-Router 4"></a>Vue-Router 4</h2><ol><li><p>安装：</p><pre><code>npm install vue-router</code></pre></li><li><p>配置</p><pre><code>// /router/index.jsimport {createRouter,createWebHistory} from 'vue-router'export default createRouter({    history:createWebHistory(),    routes:[        {            path:'/',            redirect:'/login'        },        {            path:'/login',            component:()=&gt;import('../components/login')        },        {            path:'/main',            component:()=&gt;import('../components/Main'),            children:[                {                    path:'dept',                    component:()=&gt;import('../components/Dept')                },                {                    path:'emp',                    component:()=&gt;import('../components/Emp')                },                {                    path:'user',                    component:()=&gt;import('../components/User')                }            ]        }    ]})</code></pre></li><li><p>main.js</p><pre><code>import VueRouter from './router/index'const app = createApp(App);//路由守卫VueRouter.beforeEach((to,from,next)=&gt;{    console.log(to,from,next)    let user = sessionStorage.getItem("user");    if(to.path != "/login" &amp;&amp; user == null){        next("/login")    }    next()})app.use(VueRouter)</code></pre></li><li><p>login.vue</p><img src="/2022/060232144/9.jpg" class=""><pre><code>&lt;template&gt;  &lt;input type="button" value="登录" @click="login"&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "login",  methods:{    login(){      sessionStorage.setItem("user",{})      this.$router.push("/main")    }  }}&lt;/script&gt;</code></pre></li><li><p>main.vue</p><img src="/2022/060232144/10.jpg" class=""><pre><code>&lt;template&gt;  &lt;div id="top"&gt;&lt;!--    &lt;router-link to="/login"&gt;注销&lt;/router-link&gt;--&gt;    &lt;input type="button" value="注销" @click="destroy"&gt;  &lt;/div&gt;  &lt;div id="parent"&gt;    &lt;div id="nav"&gt;      &lt;ul&gt;        &lt;li&gt;&lt;router-link to="/main/dept"&gt;部门管理&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link to="/main/emp"&gt;员工管理&lt;/router-link&gt;&lt;/li&gt;        &lt;li&gt;&lt;router-link to="/main/user"&gt;用户管理&lt;/router-link&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;div id="main"&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "Main",  created(){    this.$router.replace("/main/dept");  },  methods:{    destroy(){      sessionStorage.removeItem("user")      this.$router.replace("/login")    }  }}&lt;/script&gt;&lt;style scoped&gt;#parent{  display: flex;}#nav{  width:200px;  height: 500px;  background-color: antiquewhite;}#main{  width:100%;  height: 500px;  background-color: cornsilk;}li{  list-style: none;}&lt;/style&gt;</code></pre></li></ol><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>pom.xml</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>service</p><pre><code>@Overridepublic PageInfo&lt;Dept&gt; paged(int pageNum, int pageSize) {    PageHelper.startPage(pageNum,pageSize);    List&lt;Dept&gt; list = deptMapper.getAll();    PageInfo pageInfo = new PageInfo(list);    return pageInfo;}</code></pre><p>controller</p><pre><code>@RequestMapping("paged")@ResponseBodypublic PageInfo&lt;Dept&gt; paged(@RequestParam(defaultValue = "1") int     pageNum,@RequestParam(defaultValue = "3") int pageSize){    return deptService.paged(pageNum,pageSize);}</code></pre><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><pre><code>&lt;template&gt;  部门管理  &lt;table border="1" width="500"&gt;    &lt;tr v-for="dept in pageInfo.list" :key="dept.deptno"&gt;      &lt;td&gt;{{dept.deptno}}&lt;/td&gt;      &lt;td&gt;{{dept.dname}}&lt;/td&gt;      &lt;td&gt;{{dept.loc}}&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td colspan="3"&gt;        &lt;a href="#" v-for="num in pageInfo.navigatepageNums" :key="num" @click="paged(num,pageInfo.pageSize)"&gt;[{{num}}]&lt;/a&gt;       &lt;a href="#" @click="paged(pageInfo.navigateFirstPage,pageInfo.pageSize)" v-show="pageInfo.hasPreviousPage"&gt;第一页&lt;/a&gt;        &lt;a href="#" @click="paged(pageInfo.prePage,pageInfo.pageSize)" v-show="pageInfo.hasPreviousPage"&gt;上一页&lt;/a&gt;        &lt;a href="#" @click="paged(pageInfo.nextPage,pageInfo.pageSize)" v-show="pageInfo.hasNextPage"&gt;下一页&lt;/a&gt;        &lt;a href="#" @click="paged(pageInfo.navigateLastPage,pageInfo.pageSize)" v-show="pageInfo.hasNextPage"&gt;最后一页&lt;/a&gt;        &lt;select v-model="pageInfo.pageSize" @change="changePageSize"&gt;          &lt;option&gt;3&lt;/option&gt;          &lt;option&gt;5&lt;/option&gt;          &lt;option&gt;10&lt;/option&gt;        &lt;/select&gt;      &lt;/td&gt;    &lt;/tr&gt;  &lt;/table&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "Dept",  data(){    return {      pageInfo:{        pageNum:1,pageSize:3      }    }  },  methods:{    paged(pageNum,pageSize){      this.$http.post('dept/paged',`pageNum=${pageNum}&amp;pageSize=${pageSize}`)        .then((resp)=&gt;{          this.pageInfo = resp.data;        })    },    changePageSize(){      this.paged(1,this.pageInfo.pageSize)    }  },  created() {    this.paged(1,3)  }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h2 id="ElementUI-plus"><a href="#ElementUI-plus" class="headerlink" title="ElementUI-plus"></a>ElementUI-plus</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install element-plus --save</code></pre><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><pre><code>// main.tsimport { createApp } from 'vue'import ElementPlus from 'element-plus'import 'element-plus/dist/index.css'import App from './App.vue'const app = createApp(App)app.use(ElementPlus)app.mount('#app')</code></pre><h3 id="Container-布局容器"><a href="#Container-布局容器" class="headerlink" title="Container 布局容器"></a>Container 布局容器</h3><p>用于布局的容器组件，方便快速搭建页面的基本结构：</p><p><code>&lt;el-container&gt;</code>：外层容器。 当子元素中包含 <code>&lt;el-header&gt;</code> 或 <code>&lt;el-footer&gt;</code> 时，全部子元素会垂直上下排列， 否则会水平左右排列。</p><p><code>&lt;el-header&gt;</code>：顶栏容器。</p><p><code>&lt;el-aside&gt;</code>：侧边栏容器。</p><p><code>&lt;el-main&gt;</code>：主要区域容器。</p><p><code>&lt;el-footer&gt;</code>：底栏容器。</p><img src="/2022/060232144/11.jpg" class=""><pre><code>&lt;template&gt;  &lt;div class="common-layout"&gt;    &lt;el-container&gt;      &lt;el-header&gt;Header&lt;/el-header&gt;      &lt;el-main&gt;Main&lt;/el-main&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header, .common-layout .el-footer, .common-layout .el-main, .common-layout .el-aside {  display: flex;  justify-content: center;  align-items: center;}.common-layout .el-header, .common-layout .el-footer {  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;}.common-layout .el-main {  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;}&lt;/style&gt;</code></pre><img src="/2022/060232144/12.jpg" class=""><pre><code>&lt;template&gt;  &lt;div class="common-layout"&gt;    &lt;el-container&gt;      &lt;el-aside width="200px"&gt;Aside&lt;/el-aside&gt;      &lt;el-container&gt;        &lt;el-header&gt;Header&lt;/el-header&gt;        &lt;el-main&gt;Main&lt;/el-main&gt;        &lt;el-footer&gt;Footer&lt;/el-footer&gt;      &lt;/el-container&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header,.common-layout .el-footer,.common-layout .el-main,.common-layout .el-aside {  display: flex;  justify-content: center;  align-items: center;}.common-layout .el-header,.common-layout .el-footer {  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;}.common-layout .el-main {  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;}.common-layout .el-aside {  background-color: var(--el-color-primary-light-8);  color: var(--el-text-color-primary);  text-align: center;}&lt;/style&gt;</code></pre><img src="/2022/060232144/13.jpg" class=""><pre><code>&lt;template&gt;  &lt;div class="common-layout"&gt;    &lt;el-container&gt;      &lt;el-header&gt;Header&lt;/el-header&gt;      &lt;el-container&gt;        &lt;el-aside width="200px"&gt;Aside&lt;/el-aside&gt;        &lt;el-main&gt;Main&lt;/el-main&gt;      &lt;/el-container&gt;      &lt;el-footer&gt;Footer&lt;/el-footer&gt;    &lt;/el-container&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.common-layout .el-header,.common-layout .el-footer,.common-layout .el-main,.common-layout .el-aside {  display: flex;  justify-content: center;  align-items: center;}.common-layout .el-header,.common-layout .el-footer {  background-color: #c6e2ff;  color: var(--el-text-color-primary);  text-align: center;}.common-layout .el-main {  background-color: var(--el-color-primary-light-9);  color: var(--el-text-color-primary);  text-align: center;  height: 150px;}.common-layout .el-aside {  /*var()函数中的值可以在浏览器调试中查看*/      background-color: var(--el-color-primary-light-8);  color: var(--el-text-color-primary);  text-align: center;}&lt;/style&gt;</code></pre><h4 id="Container-属性"><a href="#Container-属性" class="headerlink" title="Container 属性"></a>Container 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">direction</td><td style="text-align:left">子元素的排列方向</td><td style="text-align:left">string</td><td style="text-align:left">horizontal / vertical</td><td style="text-align:left">子元素中有 <code>el-header</code> 或 <code>el-footer</code> 时为 vertical，否则为 horizontal</td></tr></tbody></table></div><h4 id="Container-插槽"><a href="#Container-插槽" class="headerlink" title="Container 插槽"></a>Container 插槽</h4><div class="table-container"><table><thead><tr><th style="text-align:left">插槽名</th><th style="text-align:left">说明</th><th style="text-align:left">子标签</th></tr></thead><tbody><tr><td style="text-align:left">—</td><td style="text-align:left">自定义默认内容</td><td style="text-align:left">Container / Header / Aside / Main / Footer</td></tr></tbody></table></div><h4 id="Header-属性"><a href="#Header-属性" class="headerlink" title="Header 属性"></a>Header 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">height</td><td style="text-align:left">顶栏高度</td><td style="text-align:left">string</td><td style="text-align:left">—</td><td style="text-align:left">60px</td></tr></tbody></table></div><h4 id="Header-插槽"><a href="#Header-插槽" class="headerlink" title="Header 插槽"></a>Header 插槽</h4><div class="table-container"><table><thead><tr><th style="text-align:left">插槽名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">—</td><td style="text-align:left">自定义默认内容</td></tr></tbody></table></div><h4 id="Aside-属性"><a href="#Aside-属性" class="headerlink" title="Aside 属性"></a>Aside 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">width</td><td style="text-align:left">侧边栏宽度</td><td style="text-align:left">string</td><td style="text-align:left">—</td><td style="text-align:left">300px</td></tr></tbody></table></div><h4 id="Aside-插槽"><a href="#Aside-插槽" class="headerlink" title="Aside 插槽"></a>Aside 插槽</h4><div class="table-container"><table><thead><tr><th style="text-align:left">插槽名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">—</td><td style="text-align:left">自定义默认内容</td></tr></tbody></table></div><h4 id="Main-插槽"><a href="#Main-插槽" class="headerlink" title="Main 插槽"></a>Main 插槽</h4><div class="table-container"><table><thead><tr><th style="text-align:left">插槽名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">—</td><td style="text-align:left">自定义默认内容</td></tr></tbody></table></div><h4 id="Footer-属性"><a href="#Footer-属性" class="headerlink" title="Footer 属性"></a>Footer 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">height</td><td style="text-align:left">底栏高度</td><td style="text-align:left">string</td><td style="text-align:left">—</td><td style="text-align:left">60px</td></tr></tbody></table></div><h4 id="Footer-插槽"><a href="#Footer-插槽" class="headerlink" title="Footer 插槽"></a>Footer 插槽</h4><div class="table-container"><table><thead><tr><th style="text-align:left">插槽名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">—</td><td style="text-align:left">自定义默认内容</td></tr></tbody></table></div><h4 id="CSS-var-函数"><a href="#CSS-var-函数" class="headerlink" title="CSS var() 函数"></a>CSS var() 函数</h4><p>实例</p><p>定义一个名为 “—main-bg-color” 的属性，然后使用 var() 函数调用该属性：</p><pre><code>:root {  --main-bg-color: coral;}#div1 {  background-color: var(--main-bg-color);}#div2 {  background-color: var(--main-bg-color);}</code></pre><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>通过基础的 24 分栏，迅速简便地创建布局。</p><h4 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h4><p>​       使用列创建基础网格布局。</p><p>​       通过 <code>row</code> 和 <code>col</code> 组件，并通过 col 组件的 <code>span</code> 属性我们就可以自由地组合布局。</p><p>​                <img src="/2022/060232144/14.jpg" class=""></p><pre><code>&lt;template&gt;  &lt;el-row&gt;    &lt;el-col :span="24"&gt;&lt;div class="grid-content bg-purple-dark" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span="12"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="12"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style lang="scss"&gt;.el-row {  margin-bottom: 20px;}.el-row:last-child {  margin-bottom: 0;}.el-col {  border-radius: 4px;}.grid-content {  border-radius: 4px;  min-height: 36px;}.bg-purple-dark {    background: #99a9bf;}.bg-purple {    background: rgba(192,132,252);}.bg-purple-light {    background: #e5e9f2;}&lt;/style&gt;</code></pre><h4 id="分栏间隔"><a href="#分栏间隔" class="headerlink" title="分栏间隔"></a>分栏间隔</h4><p>支持列间距。</p><img src="/2022/060232144/15.jpg" class=""><p>行提供 <code>gutter</code> 属性来指定列之间的间距，其默认值为0。</p><pre><code>&lt;template&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row {  margin-bottom: 20px;}.el-row:last-child {  margin-bottom: 0;}.el-col {  border-radius: 4px;}.grid-content {  border-radius: 4px;  min-height: 36px;}.bg-purple-dark {  background: #99a9bf;}.bg-purple {  background: rgba(192,132,252);}.bg-purple-light {  background: #e5e9f2;}&lt;/style&gt;</code></pre><h4 id="混合布局"><a href="#混合布局" class="headerlink" title="混合布局"></a>混合布局</h4><p>通过基础的 1/24 分栏任意扩展组合形成较为复杂的混合布局。</p><img src="/2022/060232144/16.jpg" class=""><pre><code>&lt;template&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="16"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="8"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="16"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="4"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row {  margin-bottom: 20px;}.el-row:last-child {  margin-bottom: 0;}.el-col {  border-radius: 4px;}.grid-content {  border-radius: 4px;  min-height: 36px;}.bg-purple {  background: rgba(192,132,252);}&lt;/style&gt;</code></pre><h4 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h4><p>您可以指定列偏移量。</p><img src="/2022/060232144/17.jpg" class=""><p>通过制定 col 组件的 <code>offset</code> 属性可以指定分栏偏移的栏数。</p><pre><code>&lt;template&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6" :offset="6"      &gt;&lt;div class="grid-content bg-purple"    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="6" :offset="6"      &gt;&lt;div class="grid-content bg-purple"    /&gt;&lt;/el-col&gt;    &lt;el-col :span="6" :offset="6"      &gt;&lt;div class="grid-content bg-purple"    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="12" :offset="6"      &gt;&lt;div class="grid-content bg-purple"    /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row {  margin-bottom: 20px;}.el-row:last-child {  margin-bottom: 0;}.el-col {  border-radius: 4px;}.grid-content {  border-radius: 4px;  min-height: 36px;}.bg-purple {  background: rgba(192,132,252);}&lt;/style&gt;</code></pre><h4 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h4><p>默认使用 flex 布局来对分栏进行灵活的对齐。</p><img src="/2022/060232144/18.jpg" class=""><p>您可以通过<code>justify</code> 属性来定义子元素的排版方式，其取值为start、center、end、space-between、space-around或space-evenly。</p><pre><code>&lt;template&gt;  &lt;el-row class="row-bg"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class="row-bg" justify="center"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class="row-bg" justify="end"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class="row-bg" justify="space-between"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class="row-bg" justify="space-around"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;  &lt;el-row class="row-bg" justify="space-evenly"&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple-light" /&gt;&lt;/el-col&gt;    &lt;el-col :span="6"&gt;&lt;div class="grid-content bg-purple" /&gt;&lt;/el-col&gt;  &lt;/el-row&gt;&lt;/template&gt;&lt;style&gt;.el-row {  margin-bottom: 20px;}.el-row:last-child {  margin-bottom: 0;}.el-col {  border-radius: 4px;}.grid-content {  border-radius: 4px;  min-height: 36px;}.bg-purple {  background: rgba(192,132,252);}.bg-purple-light {  background: #e5e9f2;}&lt;/style&gt;</code></pre><h4 id="Row-属性"><a href="#Row-属性" class="headerlink" title="Row 属性"></a>Row 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">gutter</td><td style="text-align:left">栅格间隔</td><td style="text-align:left">number</td><td style="text-align:left">—</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">justify</td><td style="text-align:left">flex 布局下的水平排列方式</td><td style="text-align:left">string</td><td style="text-align:left">start/end/center/space-around/space-between/space-evenly</td><td style="text-align:left">start</td></tr><tr><td style="text-align:left">align</td><td style="text-align:left">flex 布局下的垂直排列方式</td><td style="text-align:left">string</td><td style="text-align:left">top/middle/bottom</td><td style="text-align:left">top</td></tr><tr><td style="text-align:left">tag</td><td style="text-align:left">自定义元素标签</td><td style="text-align:left">string</td><td style="text-align:left">*</td><td style="text-align:left">div</td></tr></tbody></table></div><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="Col-属性"><a href="#Col-属性" class="headerlink" title="Col 属性"></a>Col 属性</h4><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">说明</th><th style="text-align:left">类型</th><th style="text-align:left">可选值</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">span</td><td style="text-align:left">栅格占据的列数</td><td style="text-align:left">number</td><td style="text-align:left">—</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">offset</td><td style="text-align:left">栅格左侧的间隔格数</td><td style="text-align:left">number</td><td style="text-align:left">—</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">push</td><td style="text-align:left">栅格向右移动格数</td><td style="text-align:left">number</td><td style="text-align:left">—</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">pull</td><td style="text-align:left">栅格向左移动格数</td><td style="text-align:left">number</td><td style="text-align:left">—</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">xs</td><td style="text-align:left"><code>&lt;768px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align:left">number/object (例如 {span: 4, offset: 4})</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">sm</td><td style="text-align:left"><code>≥768px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align:left">number/object (例如 {span: 4, offset: 4})</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">md</td><td style="text-align:left"><code>≥992px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align:left">number/object (例如 {span: 4, offset: 4})</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">lg</td><td style="text-align:left"><code>≥1200px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align:left">number/object (例如 {span: 4, offset: 4})</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">xl</td><td style="text-align:left"><code>≥1920px</code> 响应式栅格数或者栅格属性对象</td><td style="text-align:left">number/object (例如 {span: 4, offset: 4})</td><td style="text-align:left">—</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">tag</td><td style="text-align:left">自定义元素标签</td><td style="text-align:left">string</td><td style="text-align:left">*</td><td style="text-align:left">div</td></tr></tbody></table></div><h2 id="登录页"><a href="#登录页" class="headerlink" title="登录页"></a>登录页</h2><img src="/2022/060232144/19.jpg" class=""><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;el-form class="login-container"&gt;      &lt;h3 class="login-title"&gt;系统登录&lt;/h3&gt;      &lt;el-form-item prop="username"&gt;        &lt;el-input type="text" v-model="user.username" placeholder="账号"&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop="password"&gt;        &lt;el-input type="password" v-model="user.password" placeholder="密码"&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop="checkCode"&gt;        &lt;img&gt;&lt;a href="#" &gt;看不清&lt;/a&gt;        &lt;el-input type="text" v-model="user.checkCode" placeholder="验证码"&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type="primary" style="width:100%;" &gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: "Login",  data(){    return{      user:{}    }  }}&lt;/script&gt;&lt;style scoped="scoped"&gt;.login-container{  width:350px;  margin:100px auto 10px;  border:1px solid #eaeaea;  padding:35px 35px 15px 35px;  border-radius: 15px;  box-shadow:0 0 25px #cac6c6;}.login-title{  text-align: center;  color:#505458;  margin:0px auto 40px;}&lt;/style&gt;</code></pre><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install @element-plus/icons-vue</code></pre><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><pre><code>import * as ElementPlusIconsVue from '@element-plus/icons-vue'const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) {  app.component(key, component)}</code></pre><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><pre><code>&lt;template&gt;  &lt;p&gt;    with extra class &lt;b&gt;is-loading&lt;/b&gt;, your icon is able to rotate 360 deg in 2    seconds, you can also override this  &lt;/p&gt;  &lt;el-icon :size="20"&gt;    &lt;Edit /&gt;  &lt;/el-icon&gt;  &lt;el-icon color="#409EFC" class="no-inherit"&gt;    &lt;Share /&gt;  &lt;/el-icon&gt;  &lt;el-icon&gt;    &lt;Delete /&gt;  &lt;/el-icon&gt;  &lt;el-icon class="is-loading"&gt;    &lt;Loading /&gt;  &lt;/el-icon&gt;  &lt;el-button type="primary"&gt;    &lt;el-icon style="vertical-align: middle"&gt;      &lt;Search /&gt;    &lt;/el-icon&gt;    &lt;span style="vertical-align: middle"&gt; Search &lt;/span&gt;  &lt;/el-button&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Vue.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2022/053113229.html"/>
      <url>/2022/053113229.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>ECMAScript6.0（简称：ES6）是JavaScript语言的下一代标准，在2015年6月正式发布</li><li>目标：使得JavaScript语言可以用来编写复杂大型的应用程序，成为企业级的开发语言</li></ol><h2 id="ES6编程基础"><a href="#ES6编程基础" class="headerlink" title="ES6编程基础"></a>ES6编程基础</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><ol><li>使用let声明的变量，只在代码块中有效（代码块作用域）</li><li>let命令没有变量提升</li><li>暂时性死区：只要块级作用域存在let命令，它所声明的变量就“绑定”在这个区域，不再受外界影响</li></ol><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ol><li>const命令声明一个常量，一旦声明，值不能被改变</li><li>必须在声明的同时赋予初始值</li></ol><h3 id="函数的扩展—rest参数（剩余参数）"><a href="#函数的扩展—rest参数（剩余参数）" class="headerlink" title="函数的扩展—rest参数（剩余参数）"></a>函数的扩展—rest参数（剩余参数）</h3><ol><li><p>语法格式：</p><pre><code>function 函数名(命名参数,...剩余参数名){}</code></pre></li><li><p>剩余参数：不与任何命名参数相比配的其他参数</p></li><li><p>案例：</p><pre><code>function add(sum,...args){    for(n of args){       sum += n;    }    console.log(sum);}let sum = 10;add(sum,1,2,3,4);</code></pre></li></ol><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用解构赋值可以轻松地使用模板从对象或数组中提取数据</p><p>好处：一次可以定义多个变量，并赋值初始值</p><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ol><li><p>可以一次性的将每个属性赋予给<strong>同名</strong>变量</p><pre><code>//同名let stu = {name:"tom",age:20};let {name,age} = stu;console.log(name,age);//不同名let stu = {name:"tom",age:20};            let {name:stuName,age:stuAge} = stu;console.log(stuName,stuAge);</code></pre></li></ol><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><pre><code>var arr = ["tom","marry","scott"];var [a,b,c] = arr;console.log(a,b,c);</code></pre><h2 id="增强版的对象字面量"><a href="#增强版的对象字面量" class="headerlink" title="增强版的对象字面量"></a>增强版的对象字面量</h2><pre><code>var name ="marry";var stu = {    name,//属性的简写形式，将同名变量的值赋予给属性    age:20,    //方法的简写形式    hi(){        alert("hi")    }}console.log(stu.name);stu.hi();</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li><p>箭头函数：是ES6中函数表达式定义的一种简化写法</p></li><li><p>ES6中允许使用“箭头” (=&gt;)定义函数</p><pre><code>/* var fun1 = function(a){    return a + 1;} *///var fun1 = (a)=&gt;{return a+1;}var fun1 = a =&gt; a + 1var result = fun1(1);console.log(result);</code></pre><p>注意：</p><ul><li><p>当方法的形参个数为1的时候，形参外的括号可以省略</p></li><li><p>当方法体中只有一条 return语句的时候，方法体外的大括号可以省略，return关键字也可以省略</p></li><li><p>箭头函数在被调用的时候，不会向其传递隐式的 arguments 和 this 对象</p></li><li><p>箭头函数的函数体内的this对象，就是定义箭头函数时所在的对象，而不是调用时的对象</p><pre><code>function test(){                console.log(this);//{"name":"tom"}                let t;                /* t = function (){                    console.log(this);//window                } */                t = ()=&gt;{                    console.log(this);//{"name":"tom"}                }                t();            }            var stu = {"name":"tom"};            stu.test = test;            stu.test();</code></pre></li></ul></li></ol><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>对象扩展运算符（…）：用于取出参数对象中的所有可遍历的属性，拷贝到当前对象中</p><pre><code>var stu = {"name":"tom","age":20};var stu2 = {...stu};stu2.name = "marry";console.log(stu.name);console.log(stu2.name);</code></pre><p>数组扩展运算符:</p><pre><code>var arr = [1,2,3,4,5];var arr2 = [...arr];arr[0] = 10;console.log(arr2);</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ol><li><p>ES6模块的主要思想是必须显示地使用标识符导出模块数据，才能从外部访问模块</p></li><li><p>导入导出方式一：要求导入时使用导出时候的名称</p><pre><code>//1.jsexport var name = "tom";&lt;script type="module"&gt;import {name} from './js/1.js'console.log(name)&lt;/script&gt;//1.jsfunction test1(){    alert('test1')}//导出方法export {test1}&lt;script type="module"&gt;    import {test1} from "./js/1.js";    test1()&lt;/script&gt;</code></pre></li><li><p>默认导出导入</p><pre><code>//1.jsexport default {    name:"tom"}&lt;script type="module"&gt;import Stu from './js/1.js'console.log(Stu.name)&lt;/script&gt;</code></pre></li><li><p>全部导入</p><pre><code>//1.jsexport var name = "tom";export default {    name:"tom"}function test1(){    alert('test1')}//导出方法export {test1}&lt;script type="module"&gt;import Stu from './js/1.js'import * as app from './js/1.js'console.log(Stu.name)console.log(app.name)console.log(app.default.name)app.test1()&lt;/script&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2022/053018006.html"/>
      <url>/2022/053018006.html</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>用途：为html页面添加交互行为</li><li>执行：解释器，也称为JavaScript引擎，是浏览器的一部分</li><li>位置：通常直接嵌入到html页面</li><li>开发工具：任意网页开发工具都可以</li><li>特点：<ul><li>脚本语言：没有预先编译的过程，边解释边执行</li><li>弱类型：非强类型，定义变量的时候，不用指定变量的类型，变量的类型根据值得类型来决定</li><li>跨平台：不依赖操作系统，仅仅依赖于浏览器</li></ul></li><li>注意：<ul><li>不同浏览器中使用JavaScript编程，可能有差异</li><li>要遵循 W3C DOM标准，兼容性好</li></ul></li><li>历史<ul><li>1995网景（Netscape）</li><li>是ECMAScript标准的一种实现，是ECMA组织维护</li><li>最新版：ES6</li></ul></li></ol><h2 id="五种原始数据类型"><a href="#五种原始数据类型" class="headerlink" title="五种原始数据类型"></a>五种原始数据类型</h2><ol><li>undefined：未初始化变量的值，值只有一个：undefined</li><li>boolean：值true和false</li><li>number：表示整数和浮点数</li><li>string：字符串类型，值使用单引号或双引号括起来</li><li>null：唯一值 null</li></ol><p>可以使用 typeof 变量名，输出变量的类型：typeof null ，输出：object</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol><li>parseInt(value):把一个变量的值转换为整数<ul><li>parseInt(“3.14”) //3</li><li>parseInt(“3.14aaaaa”) //3</li><li>parseInt(3.14) //3</li><li>parseInt(“a3.14”)  //NaN</li></ul></li><li>parseFloat(value):把一个变量转换为浮点数</li><li>Number(value):把给定的值转换为数字，它转换整个值，而不是部分值<ul><li>Number(“123a”) //NaN</li></ul></li></ol><h2 id="运输符"><a href="#运输符" class="headerlink" title="运输符"></a>运输符</h2><p>与java相同</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>语法：</p><pre><code>function 函数名(参数列表){    return 值;}</code></pre><p>调用方式：</p><ol><li><p>在 <script>中直接调用</p></li><li><p>在其他函数中调用</p></li><li><p>通过事件调用</p><pre><code>&lt;button onclick=&quot;hello()&quot;&gt;调用方法&lt;/button&gt;&lt;a href=&quot;#&quot; onclick=&quot;hello()&quot;&gt;调用方法&lt;/a&gt;</code></pre></li><li><p>用超链接调用</p><pre><code>&lt;a href=&quot;javascript:hello()&quot;&gt;调用方法&lt;/a&gt;</code></pre></li></ol><h3 id="得到文本框的值"><a href="#得到文本框的值" class="headerlink" title="得到文本框的值"></a>得到文本框的值</h3><pre><code>document.getElementById(&quot;result&quot;).value</code></pre><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval(字符串表达式)：能够对表达式进行解析，并求值返回</p><h3 id="函数是对象，函数名是对象的引用"><a href="#函数是对象，函数名是对象的引用" class="headerlink" title="函数是对象，函数名是对象的引用"></a>函数是对象，函数名是对象的引用</h3><pre><code>&lt;script&gt;    function test()&#123;        console.log(&quot;hi&quot;);    &#125;    var a = test;    a();&lt;/script&gt;</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><pre><code>//等号的右边为匿名函数（定义了一个函数对象，但是没有指定该函数名）var test = function()&#123;    console.log(&quot;hi!!!&quot;);&#125;test();</code></pre><h3 id="为元素动态添加事件处理程序"><a href="#为元素动态添加事件处理程序" class="headerlink" title="为元素动态添加事件处理程序"></a>为元素动态添加事件处理程序</h3><pre><code>&lt;form&gt;    &lt;input type=&quot;button&quot; name=&quot;btn&quot; value=&quot;按钮&quot;&gt;&lt;/form&gt;&lt;script&gt;    function test()&#123;        console.log(&quot;hi!!!&quot;);        //alert(&#39;hi&#39;);    &#125;    document.forms[0].btn.onclick=test;&lt;/script&gt;</code></pre><h3 id="javascript中没有函数重载的概念"><a href="#javascript中没有函数重载的概念" class="headerlink" title="javascript中没有函数重载的概念"></a>javascript中没有函数重载的概念</h3><p>如果定义了两个同名的方法，下面的方法会把上面的同名方法覆盖</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><ol><li>js的函数可以接收任意多个参数，通过arguments对象来访问</li><li>该对象类似于数组，可以使用下标来访问，如：arguments[0]</li><li>arguments.length:实参个数</li><li>方法名.length:得到形参的个数</li></ol><h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><ol><li>定义：在单个对象中存储多个值</li><li><p>构造函数：</p><ul><li>Array():返回一个长度为0的数组对象</li><li>Array(size):返回具有size个元素的数组，元素的初始值：undefined</li><li>Array(元素列表):用元素列表初始化数组，元素可以是任意类型</li></ul></li><li><p>数组的长度不固定，赋值即可改变数组的长度</p><p>arr.length属性不是只读的，可以改变（变大或变小（相当于删除元素））</p></li><li><p>直接创建并初始化数组</p><pre><code>var arr2 = [0,true,null];</code></pre></li><li><p>遍历</p><pre><code>var arr = [1,2,3,4,5];/* for(i = 0;i &lt; arr.length;i++)&#123;    console.log(arr[i]);&#125; *//* for(i in arr)&#123;    console.log(arr[i],i);&#125; *//* for(n of arr)&#123;    console.log(n);&#125; */arr.forEach(function(item,index)&#123;    console.log(item,index);&#125;)</code></pre></li><li><p>常用方法</p><ul><li><p>sort</p><pre><code>var arr = [10,100,3,1,5];//arr.sort();//默认按照字符串排序arr.sort(function(x,y)&#123;    return x - y;&#125;);console.log(arr);</code></pre></li><li><p>splice（index，howmany，element…）:用于向数组添加、删除、替换数组元素</p><ul><li>index：必需，从何处添加、删除元素</li><li>howmany：必需，规定应该删除多少个元素，添加元素的时候，该值为0</li><li>element…:元素列表，可选，向数组添加元素的列表</li></ul><pre><code>var arr = [10,100,3,1,5];//arr.splice(1,0,&quot;tom&quot;,&quot;marry&quot;)//arr.splice(1,2);arr.splice(1,3,&quot;tom&quot;,&quot;marry&quot;);console.log(arr);</code></pre></li></ul><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><pre><code>//生成一个日期字符串var d = new Date();var year = d.getFullYear();var month = d.getMonth()+1;var date = d.getDate()var hour = d.getHours();var minute = d.getMinutes();var second = d.getSeconds();var t = year +&quot;-&quot;+month+&quot;-&quot;+date +&quot; &quot;+hour+&quot;:&quot;+minute+&quot;:&quot;+second;console.log(t);//把它显示在p中document.getElementById(&quot;time&quot;).innerText = t;</code></pre></li></ol><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><ol><li>setTimeout(“函数()”,时间间隔)：在指定的时间间隔后，调用参数1指定的函数，该方法返回一个值，表示定时器</li><li>clearTimeout(定时器引用)：关闭定时器</li></ol><h2 id="案例：选择人名"><a href="#案例：选择人名" class="headerlink" title="案例：选择人名"></a>案例：选择人名</h2><h3 id="使用二个按钮控制"><a href="#使用二个按钮控制" class="headerlink" title="使用二个按钮控制"></a>使用二个按钮控制</h3><img src="/2022/053018006/1.jpg" class=""><pre><code>    &lt;input type=&quot;button&quot; value=&quot;开始&quot; onclick=&quot;startGame()&quot;&gt;    &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stopGame()&quot;&gt;    &lt;script&gt;        var names = [&quot;唐僧&quot;,&quot;悟空&quot;,&quot;八戒&quot;,&quot;沙僧&quot;,&quot;小白龙&quot;];        var tt;        var index;        function startGame()&#123;            index = parseInt(Math.random()*names.length);            var name = names[index];            document.getElementById(&quot;div1&quot;).innerText = name;            tt = setTimeout(&quot;startGame()&quot;,10);        &#125;        function stopGame()&#123;            clearTimeout(tt);            names.splice(index,1);        &#125;    &lt;/script&gt;</code></pre><h3 id="使用一个按钮控制"><a href="#使用一个按钮控制" class="headerlink" title="使用一个按钮控制"></a>使用一个按钮控制</h3><img src="/2022/053018006/2.jpg" class=""><pre><code>        &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;        &lt;input type=&quot;button&quot; value=&quot;开始&quot; onclick=&quot;game(this)&quot;&gt;        &lt;!-- &lt;input type=&quot;button&quot; value=&quot;停止&quot; onclick=&quot;stopGame()&quot;&gt; --&gt;        &lt;script&gt;            var names = [&quot;唐僧&quot;,&quot;悟空&quot;,&quot;八戒&quot;,&quot;沙僧&quot;,&quot;小白龙&quot;];            var tt;            var index;            var isRun = false;            function game(o)&#123;                if(isRun)&#123;                    o.value = &quot;开始&quot;;                    stopGame();                    isRun = false;                &#125;else&#123;                    o.value = &quot;停止&quot;;                    startGame();                    isRun = true;                &#125;            &#125;            function startGame()&#123;                index = parseInt(Math.random()*names.length);                var name = names[index];                document.getElementById(&quot;div1&quot;).innerText = name;                tt = setTimeout(&quot;startGame()&quot;,10);                &#125;            function stopGame()&#123;                clearTimeout(tt);                names.splice(index,1);            &#125;            document.onkeydown = function()&#123;                //得到按键的键盘码                var keyCode = event.keyCode;                //console.log(keyCode);                if(keyCode == 13)&#123;                    startGame();                &#125;else if(keyCode == 32)&#123;                    stopGame();                &#125;            &#125;        &lt;/script&gt;</code></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><ol><li><p>event：事件对象，在事件发生的时候，由系统创建</p><p>属性：</p><p>keyCode：键盘码，每一个按键都不同，13：回车，32：空格，9：tab</p></li><li><p>响应按键事件</p><pre><code>document.onkeydown = function()&#123;    //得到按键的键盘码    var keyCode = event.keyCode;    //console.log(keyCode);    if(keyCode == 13)&#123;        startGame();    &#125;else if(keyCode == 32)&#123;        stopGame();    &#125;&#125;</code></pre></li></ol><h2 id="案例：购物车全选和全不选"><a href="#案例：购物车全选和全不选" class="headerlink" title="案例：购物车全选和全不选"></a>案例：购物车全选和全不选</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkAll(o)&#123;                var cks = document.getElementsByName(&quot;good&quot;);                for(c of cks)&#123;                    c.checked = o.checked;                &#125;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;table border=&quot;1&quot; width=&quot;400&quot;&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=&quot;checkbox&quot; onchange=&quot;checkAll(this)&quot;&gt;&lt;/td&gt;                    &lt;td&gt;商品名称&lt;/td&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;华为手机&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;笔记本电脑&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;                        &lt;input type=&quot;checkbox&quot; name=&quot;good&quot;&gt;                    &lt;/td&gt;                    &lt;td&gt;电脑桌&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="案例：省市级联"><a href="#案例：省市级联" class="headerlink" title="案例：省市级联"></a>案例：省市级联</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        省份：        &lt;select onchange=&quot;getCities(this)&quot;&gt;            &lt;option&gt;请选择&lt;/option&gt;            &lt;option&gt;辽宁&lt;/option&gt;            &lt;option&gt;吉林&lt;/option&gt;            &lt;option&gt;黑龙江&lt;/option&gt;        &lt;/select&gt;        城市：        &lt;select id=&quot;city&quot;&gt;            &lt;option&gt;请选择&lt;/option&gt;        &lt;/select&gt;        &lt;script&gt;            var cities = [];            cities[&quot;辽宁&quot;] = [&quot;沈阳&quot;,&quot;大连&quot;,&quot;锦州&quot;];            cities[&quot;吉林&quot;] = [&quot;长春&quot;,&quot;吉林&quot;,&quot;四平&quot;];            cities[&quot;黑龙江&quot;] = [&quot;哈尔滨&quot;,&quot;齐齐哈尔&quot;,&quot;大庆&quot;];            function getCities(province)&#123;                var provinceName = province.value;                var city = document.getElementById(&quot;city&quot;);                city.options.length = 1;                // var index = province.selectedIndex;                var arr = cities[provinceName];                arr.forEach(function(item,i)&#123;                    var option = new Option(item,i);                    city.options.add(option);                &#125;)            &#125;        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><ol><li><p>定义：在表单提交到服务器之前，对html表单输入的数据进行校验，如果没有错误，就提交，否则，不提交</p></li><li><p>作用：</p><ul><li>在客户端验证，速度快</li><li>减轻服务器压力</li></ul></li><li><p>验证过程</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkForm()&#123;                return checkUsername() &amp;&amp; checkPassword();            &#125;            function checkUsername()&#123;                var username = document.forms[0].username.value;                if(username.length == 0)&#123;                    alert(&quot;用户名不能为空&quot;);                    return false;                &#125;                return true;            &#125;            function checkPassword()&#123;                var password = document.forms[0].password.value;                if(password.length == 0)&#123;                    alert(&quot;密码不能为空&quot;);                    return false;                &#125;                return true;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;login&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p>失去焦点验证：onblur</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function checkForm()&#123;                return checkUsername() &amp;&amp; checkPassword();            &#125;            function checkUsername()&#123;                var username = document.forms[0].username.value;                document.getElementById(&quot;usernameError&quot;).innerHTML=&quot;&quot;;                if(username.length == 0)&#123;                    // alert(&quot;用户名不能为空&quot;);                    document.getElementById(&quot;usernameError&quot;).innerHTML=&quot;用户名不能为空&quot;;                    return false;                &#125;                return true;            &#125;            function checkPassword()&#123;                var password = document.forms[0].password.value;                document.getElementById(&quot;passwordError&quot;).innerHTML=&quot;&quot;;                if(password.length == 0)&#123;                    // alert(&quot;密码不能为空&quot;);                    document.getElementById(&quot;passwordError&quot;).innerHTML=&quot;密码不能为空&quot;;                    return false;                &#125;                return true;            &#125;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;login&quot; method=&quot;post&quot; onsubmit=&quot;return checkForm()&quot;&gt;        &lt;table&gt;            &lt;tr&gt;                &lt;td&gt;用户名：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkUsername()&quot;&gt;                    &lt;span id=&quot;usernameError&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td&gt;密码：&lt;/td&gt;                &lt;td&gt;                    &lt;input type=&quot;password&quot; name=&quot;password&quot; onblur=&quot;checkPassword()&quot;&gt;                    &lt;span id=&quot;passwordError&quot; style=&quot;color: red;&quot;&gt;&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td colspan=&quot;2&quot;&gt;                    &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h2 id="使用JS操作CSS"><a href="#使用JS操作CSS" class="headerlink" title="使用JS操作CSS"></a>使用JS操作CSS</h2><ol><li>使用元素的 style 属性<ul><li>元素.style.color = “red”;</li><li>元素.style.fontSize = “30px”;</li></ul></li><li>使用元素的className属性<ul><li>元素.className = “class1 class2”;</li></ul></li><li>元素.offsetTop:得到元素相对于其父级中已经定位的元素的上偏移量（只读属性，数值）</li><li>元素.style.top:得到元素相对于其父级中已经定位的元素的上偏移量,（字符串类型，可以修改）</li></ol><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><ol><li><p>DOM：文档对象模型</p></li><li><p>当浏览器加载Html网页的时候，会把该网页解析为一颗DOM树，最顶层对象：document</p></li><li><p>解析过程中，会把网页中的所有内容解析为节点（Node）</p><ul><li>文档本身就是一个文档对象（document）</li><li>所有html元素都是元素节点</li><li>所有html属性都是属性节点</li><li>所有html元素中的文本都是文本节点</li></ul></li><li><p>元素对象：代表一个html元素（标签）</p><p>元素对象的子节点可以是：元素节点、文本、注释节点</p></li><li><p>节点类型：12种类型</p><ul><li>元素节点：html元素，nodeType：1</li><li>属性节点：html元素的属性，nodeType：2</li><li>文本节点：html元素中的文本，nodeType:3</li><li>注释节点：nodeType：8</li><li>文档对象节点：document对象，nodeType：9</li><li>文档类型说明节点：<code>&lt;!DOCTYPE html&gt;</code>，nodeType：10</li></ul></li></ol><h3 id="节点对象"><a href="#节点对象" class="headerlink" title="节点对象"></a>节点对象</h3><h4 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h4><ol><li>父节点和子节点</li><li>兄弟节点</li><li>当我们获取其中一个元素节点的时候，就可以使用层次关系来获取其相关层次的节点</li></ol><h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><ol><li>parentNode：获取当前节点的父节点</li><li>childNodes：获取当前节点的所有子节点</li><li>children：获取所有子元素</li><li>firstChild：第一个子节点</li><li>previousElementSibling:前一个同级元素</li><li>innerText:得到或设置当前节点中的文本内容</li></ol><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><ol><li>创建一个元素：document.createElement(“标签名”)</li><li>创建一个文本节点：document.createTextNode(文本节点的内容);</li><li>追加子节点：父节点.appendChild(子节点)</li><li>删除当前元素：当前元素.remove()</li><li>克隆当前元素：当前元素.clone(true)</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ol><li><p>定义：一组有序的键值对，其中键和值可以是任意类型</p></li><li><p>创建、存取操作</p><ul><li>创建：var map = new Map();</li><li>存储：map.set(“键”,值)</li><li>取：map.get(键)，如果没有键，返回 undefined</li></ul></li><li><p>其他方法</p><ul><li>has(key):判断给定的key是否存在</li><li>delete(key):删除元素</li><li>clear():清除所有</li></ul></li><li><p>初始化：参数是一个二维数组</p><pre><code>var map = new Map([    [&quot;name&quot;,&quot;tom&quot;],    [&quot;age&quot;,20]]);console.log(map.get(&quot;name&quot;),map.get(&quot;age&quot;));</code></pre></li></ol></script></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf</title>
      <link href="/2022/052951905.html"/>
      <url>/2022/052951905.html</url>
      
        <content type="html"><![CDATA[<h1 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>模板引擎，类似于JSP</p></li><li><p>动静结合，不破坏文档结构</p><pre><code>//jsp&lt;span&gt;${username}&lt;/span&gt;//thymeleaf&lt;span th:text="${username}"&gt;tom&lt;/span&gt;</code></pre></li><li><p>Thymeleaf可以运行在服务器里面，也可以本地运行，它既可以让美工在浏览器查看页面的静态效果，也可以让开发人员在服务器端看动态数据渲染之后的效果。</p></li><li>Thymeleaf是一个java的模板引擎，是用来显示数据的，Thymeleaf有一个要求，不能直接通过请求访问到Thymeleaf，Thymeleaf在用的时候，要访问Thymeleaf，必须得经过controller，由controller跳转到Thymeleaf，它才能得到一个正确的显示。</li><li>thymeLea支持Spring Expression Language语言作为方言，也就是SpEL，在学习JSP时我们对EL表达式都有一定的认识了，SpEL是可以用于Spring中的一种EL表达式。</li><li>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</li><li>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>导入起步依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>取消缓存</p><pre><code>spring.thymeleaf.cache=false</code></pre></li><li><p>创建页面</p><ul><li><p>在src/main/resources/templates下添加html页面，如：index.html，在idea中，可以直接添加thymeleaf</p></li></ul></li><li><p>从上下文中取值</p><pre><code>&lt;p th:text="${name}"&gt;&lt;/p&gt;</code></pre><pre><code>@RequestMapping("test1")    public String test1(Model model) {        model.addAttribute("title", "&lt;h1&gt;标题&lt;/h1&gt;");        return "index";    }//index.html    &lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p th:utext="${title}"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;</code></pre><ul><li>th:text:进行文本替换，不会解析html（页面与后台设置值一致）</li><li>th:utext:进行文本替换，会解析html（html页面源码与后台设置值一致）</li></ul></li><li><p>拼接字符串（文本替换）</p><pre><code>&lt;p th:text="|欢迎，${name}!!!|"&gt;marry&lt;/p&gt;</code></pre></li><li><p>选择表达式</p><pre><code>&lt;div th:object="${dept}"&gt;           &lt;p th:text="*{deptno}"&gt;&lt;/p&gt;           &lt;p th:text="*{dname}"&gt;&lt;/p&gt;           &lt;p th:text="*{loc}"&gt;&lt;/p&gt;&lt;/div&gt;</code></pre></li><li><p>if</p><pre><code>&lt;p th:if="${user.isVip}" th:text="会员"&gt;&lt;/p&gt;</code></pre></li><li><p>each</p><pre><code>&lt;table border="1" width="400"&gt;       &lt;tbody &gt;           &lt;tr th:each="dept,status : ${depts}" th:object="${dept}"&gt;               &lt;td th:text="*{deptno}"&gt;&lt;/td&gt;               &lt;td th:text="*{dname}"&gt;&lt;/td&gt;               &lt;td th:text="*{loc}"&gt;&lt;/td&gt;               &lt;td th:text="${status.index}"&gt;&lt;/td&gt;               &lt;td th:text="${status.count}"&gt;&lt;/td&gt;               &lt;td th:text="${status.first}"&gt;&lt;/td&gt;               &lt;td th:text="${status.last}"&gt;&lt;/td&gt;               &lt;td th:text="${status.even}"&gt;&lt;/td&gt;               &lt;td th:text="${status.odd}"&gt;&lt;/td&gt;               &lt;td th:text="${status.size}"&gt;&lt;/td&gt;           &lt;/tr&gt;       &lt;/tbody&gt;   &lt;/table&gt;</code></pre></li><li><p>switch</p><pre><code>&lt;p th:switch="${sex}"&gt;       &lt;span th:case="1"&gt;男&lt;/span&gt;       &lt;span th:case="2"&gt;女&lt;/span&gt;       &lt;span th:case="*"&gt;默认&lt;/span&gt;   &lt;/p&gt;</code></pre></li><li><p>引入样式表</p><p>/resources/static/css/style1.css</p><pre><code>&lt;link rel="stylesheet" th:href="@{/css/style1.css}"&gt;</code></pre></li><li><p>javascript</p><pre><code>&lt;script th:inline="javascript" type="text/javascript"&gt;       alert([[${sex}]]);&lt;/script&gt;</code></pre></li><li><p>动态添加样式</p><pre><code>&lt;style&gt;    .active{        color:blue;    }&lt;/style&gt;&lt;p th:text="${sex}" th:classappend="${sex=='3'}?'active'"&gt;&lt;/p&gt;</code></pre></li><li><p>日期格式化</p><pre><code>&lt;p th:text="${#dates.format(hiredate,'yyyy-MM-dd HH:mm:ss')}"&gt;&lt;/p&gt;</code></pre></li><li><p>生成数值序列</p><pre><code>&lt;a href="#" th:each="num : ${#numbers.sequence(1,10)}" th:text="| ${num} |"&gt;&lt;/a&gt;</code></pre></li><li><p>得到请求参数</p><pre><code>//请求参数为数组&lt;p th:text="${param.username[1]}"&gt;&lt;/p&gt;&lt;p th:text="${param.size()}"&gt;&lt;/p&gt;&lt;p th:text="${param.isEmpty()}"&gt;&lt;/p&gt;&lt;p th:text="${param.containsKey('username')}"&gt;&lt;/p&gt;</code></pre></li><li><p>从 HttpServletRequest 和 HttpSession中取值</p><pre><code>&lt;p th:text="${#request.getAttribute('msg')}"&gt;&lt;/p&gt;&lt;p th:text="${#session.getAttribute('msg')}"&gt;&lt;/p&gt;</code></pre></li><li><p>使用外部js</p><pre><code>&lt;script type="text/javascript" th:src="@{/js/script1.js}"&gt;&lt;/script&gt;</code></pre></li><li><p>得到应用程序上下文：contextPath</p><pre><code>&lt;p th:text="${#request.contextPath}"&gt;&lt;/p&gt;&lt;p th:text="${#request.getContextPath()}"&gt;&lt;/p&gt;</code></pre></li><li><p>组件</p><p><code>/resources/templates/component/coms.html</code></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;div th:fragment="com1"&gt;           div1   &lt;/div&gt;   &lt;div id="com2"&gt;           div2   &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>引用组件：</p><pre><code>//~{}:片段表达式&lt;div th:insert="~{/component/coms::com1}"&gt;&lt;/div&gt;&lt;div th:replace="~{/component/coms::com1}"&gt;&lt;/div&gt;&lt;div th:replace="~{/component/coms::#com2}"&gt;&lt;/div&gt;</code></pre><p>Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。它与 JSP，Velocity，FreeMaker 等模板引擎类似，也可以轻易地与 Spring MVC 等 Web 框架集成。与其它模板引擎相比，Thymeleaf 最大的特点是，即使不启动 Web 应用，也可以直接在浏览器中打开并正确显示模板页面 。</p></li></ol><h2 id="1-Thymeleaf-简介"><a href="#1-Thymeleaf-简介" class="headerlink" title="1. Thymeleaf 简介"></a>1. Thymeleaf 简介</h2><p>Thymeleaf 是新一代 Java 模板引擎，与 Velocity、FreeMarker 等传统 Java 模板引擎不同，Thymeleaf 支持 HTML 原型，其文件后缀为“.html”，因此它可以直接被浏览器打开，此时浏览器会忽略未定义的 Thymeleaf 标签属性，展示 thymeleaf 模板的静态页面效果；当通过 Web 应用程序访问时，Thymeleaf 会动态地替换掉静态内容，使页面动态显示。</p><p>Thymeleaf 通过在 html 标签中，增加额外属性来达到“模板+数据”的展示方式，示例代码如下。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:text 为 Thymeleaf 属性，用于在展示文本--&gt;&lt;h1 th:text="迎您来到Thymeleaf"&gt;欢迎您访问静态页面 HTML&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>当直接使用浏览器打开时，浏览器展示结果如下。</p><pre><code>欢迎您访问静态页面HTML</code></pre><p>当通过 Web 应用程序访问时，浏览器展示结果如下。</p><pre><code>迎您来到Thymeleaf</code></pre><h4 id="Thymeleaf-的特点"><a href="#Thymeleaf-的特点" class="headerlink" title="Thymeleaf 的特点"></a>Thymeleaf 的特点</h4><p>Thymeleaf 模板引擎具有以下特点：</p><ul><li>动静结合：Thymeleaf 既可以直接使用浏览器打开，查看页面的静态效果，也可以通过 Web 应用程序进行访问，查看动态页面效果。</li><li>开箱即用：Thymeleaf 提供了 Spring 标准方言以及一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>多方言支持：它提供了 Thymeleaf 标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式；必要时，开发人员也可以扩展和创建自定义的方言。</li><li>与 SpringBoot 完美整合：SpringBoot 为 Thymeleaf 提供了的默认配置，并且还为 Thymeleaf 设置了视图解析器，因此 Thymeleaf 可以与 Spring Boot 完美整合。</li></ul><h2 id="2-Thymeleaf-语法规则"><a href="#2-Thymeleaf-语法规则" class="headerlink" title="2. Thymeleaf 语法规则"></a>2. Thymeleaf 语法规则</h2><p>在使用 Thymeleaf 之前，首先要在页面的 html 标签中声明名称空间，示例代码如下。</p><pre><code>xmlns:th="http://www.thymeleaf.org"</code></pre><blockquote><p>在 html 标签中声明此名称空间，可避免编辑器出现 html 验证错误，但这一步并非必须进行的，即使我们不声明该命名空间，也不影响 Thymeleaf 的使用。</p></blockquote><p>Thymeleaf 作为一种模板引擎，它拥有自己的语法规则。Thymeleaf 语法分为以下 2 类：</p><ul><li>标准表达式语法</li><li>th 属性</li></ul><h3 id="2-1-标准表达式语法"><a href="#2-1-标准表达式语法" class="headerlink" title="2.1 标准表达式语法"></a>2.1 标准表达式语法</h3><p>Thymeleaf 模板引擎支持多种表达式：</p><ul><li>变量表达式：${…}</li><li>选择变量表达式：*{…}</li><li>链接表达式：@{…}</li><li>国际化表达式：#{…}</li><li>片段引用表达式：~{…}</li></ul><h4 id="2-1-1-变量表达式"><a href="#2-1-1-变量表达式" class="headerlink" title="2.1.1 变量表达式"></a>2.1.1 变量表达式</h4><p>使用 ${} 包裹的表达式被称为变量表达式，该表达式具有以下功能：</p><ul><li>获取对象的属性和方法</li><li>使用内置的基本对象</li><li>使用内置的工具对象</li></ul><p>① 获取对象的属性和方法</p><p>使用变量表达式可以获取对象的属性和方法，例如，获取 person 对象的 lastName 属性，表达式形式如下：</p><pre><code>${person.lastName}</code></pre><p>② 使用内置的基本对象</p><p>使用变量表达式还可以使用内置基本对象，获取内置对象的属性，调用内置对象的方法。 Thymeleaf 中常用的内置基本对象如下：</p><ul><li>#ctx ：上下文对象；</li><li>#vars ：上下文变量；</li><li>#locale：上下文的语言环境；</li><li>#request：HttpServletRequest 对象（仅在 Web 应用中可用）；</li><li>#response：HttpServletResponse 对象（仅在 Web 应用中可用）；</li><li>#session：HttpSession 对象（仅在 Web 应用中可用）；</li><li>#servletContext：ServletContext 对象（仅在 Web 应用中可用）。</li></ul><p>例如，我们通过以下 2 种形式，都可以获取到 session 对象中的 map 属性：</p><pre><code>${#session.getAttribute('map')}${session.map}</code></pre><p>③ 使用内置的工具对象</p><p>除了能使用内置的基本对象外，变量表达式还可以使用一些内置的工具对象。</p><ul><li>strings：字符串工具对象，常用方法有：equals、equalsIgnoreCase、length、trim、toUpperCase、toLowerCase、indexOf、substring、replace、startsWith、endsWith，contains 和 containsIgnoreCase 等；</li><li>numbers：数字工具对象，常用的方法有：formatDecimal 等；</li><li>bools：布尔工具对象，常用的方法有：isTrue 和 isFalse 等；</li><li>arrays：数组工具对象，常用的方法有：toArray、length、isEmpty、contains 和 containsAll 等；</li><li>lists/sets：List/Set 集合工具对象，常用的方法有：toList、size、isEmpty、contains、containsAll 和 sort 等；</li><li>maps：Map 集合工具对象，常用的方法有：size、isEmpty、containsKey 和 containsValue 等；</li><li>dates：日期工具对象，常用的方法有：format、year、month、hour 和 createNow 等。</li></ul><p>例如，我们可以使用内置工具对象 strings 的 equals 方法，来判断字符串与对象的某个属性是否相等，代码如下。</p><pre><code>${#strings.equals('编程帮',name)}</code></pre><h4 id="2-1-2-选择变量表达式"><a href="#2-1-2-选择变量表达式" class="headerlink" title="2.1.2 选择变量表达式"></a>2.1.2 选择变量表达式</h4><p>选择变量表达式与变量表达式功能基本一致，只是在变量表达式的基础上增加了与 th:object 的配合使用。当使用 th:object 存储一个对象后，我们可以在其后代中使用选择变量表达式（<em>{…}）获取该对象中的属性，其中，“</em>”即代表该对象。</p><pre><code>&lt;div th:object="${session.user}" &gt;        &lt;p th:text="*{fisrtName}"&gt;firstname&lt;/p&gt;&lt;/div&gt;</code></pre><blockquote><p>th:object 用于存储一个临时变量，该变量只在该标签及其后代中有效，在后面的内容“th 属性”中我详细介绍。</p></blockquote><h4 id="2-1-3-链接表达式"><a href="#2-1-3-链接表达式" class="headerlink" title="2.1.3 链接表达式"></a>2.1.3 链接表达式</h4><p>不管是静态资源的引用，还是 form 表单的请求，凡是链接都可以用链接表达式 （@{…}）。</p><p>链接表达式的形式结构如下：</p><ul><li>无参请求：@{/xxx}</li><li>有参请求：@{/xxx(k1=v1,k2=v2)}</li></ul><p>例如使用链接表达式引入 css 样式表，代码如下。</p><pre><code>&lt;link href="asserts/css/signin.css" th:href="@{/asserts/css/signin.css}" rel="stylesheet"&gt;</code></pre><h4 id="2-1-4-国际化表达式"><a href="#2-1-4-国际化表达式" class="headerlink" title="2.1.4 国际化表达式"></a>2.1.4 国际化表达式</h4><p>消息表达式一般用于国际化的场景。结构如下。</p><pre><code>th:text="#{msg}"</code></pre><p>注意：此处了解即可，我们会在后面的章节中详细介绍。</p><h4 id="2-1-5-片段引用表达式"><a href="#2-1-5-片段引用表达式" class="headerlink" title="2.1.5 片段引用表达式"></a>2.1.5 片段引用表达式</h4><p>片段引用表达式用于在模板页面中引用其他的模板片段，该表达式支持以下 2 中语法结构：</p><ul><li>推荐：~{templatename::fragmentname}</li><li>支持：~{templatename::#id}</li></ul><p>以上语法结构说明如下：</p><ul><li>templatename：模版名，Thymeleaf 会根据模版名解析完整路径：/resources/templates/templatename.html，要注意文件的路径。</li><li>fragmentname：片段名，Thymeleaf 通过 th:fragment 声明定义代码块，即：th:fragment=”fragmentname”</li><li>id：HTML 的 id 选择器，使用时要在前面加上 # 号，不支持 class 选择器。</li></ul><h3 id="2-2-th-属性"><a href="#2-2-th-属性" class="headerlink" title="2.2 th 属性"></a>2.2 th 属性</h3><p>Thymeleaf 还提供了大量的 th 属性，这些属性可以直接在 HTML 标签中使用，其中常用 th 属性及其示例如下表。</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>th:id</td><td>替换 HTML 的 id 属性</td><td><code>&lt;input  id="html-id"  th:id="thymeleaf-id"  /&gt;</code></td></tr><tr><td>th:text</td><td>文本替换，转义特殊字符</td><td><code>&lt;h1 th:text="hello，bianchengbang" &gt;hello&lt;/h1&gt;</code></td></tr><tr><td>th:utext</td><td>文本替换，不转义特殊字符</td><td><code>&lt;div th:utext="'&lt;h1&gt;欢迎来到编程帮！&lt;/h1&gt;'" &gt;欢迎你&lt;/div&gt;</code></td></tr><tr><td>th:object</td><td>在父标签选择对象，子标签使用 *{…} 选择表达式选取值。 没有选择对象，那子标签使用选择表达式和 ${…} 变量表达式是一样的效果。 同时即使选择了对象，子标签仍然可以使用变量表达式。</td><td><code>&lt;div th:object="${session.user}" &gt;    &lt;p th:text="*{fisrtName}"&gt;firstname&lt;/p&gt;&lt;/div&gt;</code></td></tr><tr><td>th:value</td><td>替换 value 属性</td><td><code>&lt;input th:value = "${user.name}" /&gt;</code></td></tr><tr><td>th:with</td><td>局部变量赋值运算</td><td><code>&lt;div th:with="isEvens = ${prodStat.count}%2 == 0"  th:text="${isEvens}"&gt;&lt;/div&gt;</code></td></tr><tr><td>th:style</td><td>设置样式</td><td><code>&lt;div th:style="'color:#F00; font-weight:bold'"&gt;编程帮 www.biancheng.net&lt;/div&gt;</code></td></tr><tr><td>th:onclick</td><td>点击事件</td><td><code>&lt;td th:onclick = "'getInfo()'"&gt;&lt;/td&gt;</code></td></tr><tr><td>th:each</td><td>遍历，支持 Iterable、Map、数组等。</td><td><code>&lt;table&gt;    &lt;tr th:each="m:${session.map}"&gt;        &lt;td th:text="${m.getKey()}"&gt;&lt;/td&gt;        &lt;td th:text="${m.getValue()}"&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></td></tr><tr><td>th:if</td><td>根据条件判断是否需要展示此标签</td><td><code>&lt;a th:if ="${userId == collect.userId}"&gt;</code></td></tr><tr><td>th:unless</td><td>和 th:if 判断相反，满足条件时不显示</td><td><code>&lt;div th:unless="${m.getKey()=='name'}" &gt;&lt;/div&gt;</code></td></tr><tr><td>th:switch</td><td>与 Java 的 switch case语句类似 通常与 th:case 配合使用，根据不同的条件展示不同的内容</td><td><code>&lt;div th:switch="${name}"&gt;    &lt;span th:case="a"&gt;编程帮&lt;/span&gt;    &lt;span th:case="b"&gt;www.biancheng.net&lt;/span&gt;&lt;/div&gt;</code></td></tr><tr><td>th:fragment</td><td>模板布局，类似 JSP 的 tag，用来定义一段被引用或包含的模板片段</td><td><code>&lt;footer th:fragment="footer"&gt;插入的内容&lt;/footer&gt;</code></td></tr><tr><td>th:insert</td><td>布局标签； 将使用 th:fragment 属性指定的模板片段（包含标签）插入到当前标签中。</td><td><code>&lt;div th:insert="commons/bar::footer"&gt;&lt;/div&gt;</code></td></tr><tr><td>th:replace</td><td>布局标签； 使用 th:fragment 属性指定的模板片段（包含标签）替换当前整个标签。</td><td><code>&lt;div th:replace="commons/bar::footer"&gt;&lt;/div&gt;</code></td></tr><tr><td>th:selected</td><td>select 选择框选中</td><td><code>&lt;select&gt;    &lt;option&gt;---&lt;/option&gt;    &lt;option th:selected="${name=='a'}"&gt;        编程帮    &lt;/option&gt;    &lt;option th:selected="${name=='b'}"&gt;        www.biancheng.net    &lt;/option&gt;&lt;/select&gt;</code></td></tr><tr><td>th:src</td><td>替换 HTML 中的 src 属性</td><td><code>&lt;img  th:src="@{/asserts/img/bootstrap-solid.svg}" src="asserts/img/bootstrap-solid.svg" /&gt;</code></td></tr><tr><td>th:inline</td><td>内联属性； 该属性有 text、none、javascript 三种取值， 在 <script> 标签中使用时，js 代码中可以获取到后台传递页面的对象。</td><td><code>&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;    var name = /*[[$&#123;name&#125;]]*/ &#39;bianchengbang&#39;;    alert(name)&lt;/script&gt;</code></td></tr><tr><td>th:action</td><td>替换表单提交地址</td><td><code>&lt;form th:action=&quot;@&#123;/user/login&#125;&quot; th:method=&quot;post&quot;&gt;&lt;/form&gt;</code></td></tr></tbody></table></div><h2 id="3-Thymeleaf-公共页面抽取"><a href="#3-Thymeleaf-公共页面抽取" class="headerlink" title="3. Thymeleaf 公共页面抽取"></a>3. Thymeleaf 公共页面抽取</h2><p>在 Web 项目中，通常会存在一些公共页面片段（重复代码），例如头部导航栏、侧边菜单栏和公共的 js css 等。我们一般会把这些公共页面片段抽取出来，存放在一个独立的页面中，然后再由其他页面根据需要进行引用，这样可以消除代码重复，使页面更加简洁。</p><h3 id="3-1-抽取公共页面"><a href="#3-1-抽取公共页面" class="headerlink" title="3.1 抽取公共页面"></a>3.1 抽取公共页面</h3><p>Thymeleaf 作为一种优雅且高度可维护的模板引擎，同样支持公共页面的抽取和引用。我们可以将公共页面片段抽取出来，存放到一个独立的页面中，并使用 Thymeleaf 提供的 th:fragment 属性为这些抽取出来的公共页面片段命名。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><p>将公共页面片段抽取出来，存放在 commons.html 中，代码如下。</p><pre><code>&lt;div th:fragment=&quot;fragment-name&quot; id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="3-2-引用公共页面"><a href="#3-2-引用公共页面" class="headerlink" title="3.2 引用公共页面"></a>3.2 引用公共页面</h3><p>在 Thymeleaf 中，我们可以使用以下 3 个属性，将公共页面片段引入到当前页面中。</p><ul><li>th:insert：将代码块片段整个插入到使用了 th:insert 属性的 HTML 标签中；</li><li>th:replace：将代码块片段整个替换使用了 th:replace 属性的 HTML 标签中；</li><li>th:include：将代码块片段包含的内容插入到使用了 th:include 属性的 HTML 标签中。</li></ul><p>使用上 3 个属性引入页面片段，都可以通过以下 2 种方式实现。</p><ul><li>~{templatename::selector}：模板名::选择器</li><li>~{templatename::fragmentname}：模板名::片段名</li></ul><blockquote><p>通常情况下，~{} 可以省略，其行内写法为 [[~{…}]] 或 [(~{…})]，其中 [[~{…}]] 会转义特殊字符，[(~{…})] 则不会转义特殊字符。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><p>\1. 在页面 fragment.html 中引入 commons.html 中声明的页面片段，可以通过以下方式实现。</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id&quot;&gt;&lt;/div&gt;</code></pre><p>\2. 启动 Spring Boot，使用浏览器访问 fragment.html，查看源码，结果如下。</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div&gt;    &lt;div id=&quot;fragment-id&quot;&gt;        &lt;span&gt;公共页面片段&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div&gt;    &lt;div id=&quot;fragment-id&quot;&gt;        &lt;span&gt;公共页面片段&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div id=&quot;fragment-id&quot;&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div&gt;    &lt;span&gt;公共页面片段&lt;/span&gt;&lt;/div&gt;</code></pre><h3 id="3-3-传递参数"><a href="#3-3-传递参数" class="headerlink" title="3.3 传递参数"></a>3.3 传递参数</h3><p>Thymeleaf 在抽取和引入公共页面片段时，还可以进行参数传递，大致步骤如下：</p><ol><li>传入参数；</li><li>使用参数。</li></ol><h4 id="3-3-1-传入参数"><a href="#3-3-1-传入参数" class="headerlink" title="3.3.1 传入参数"></a>3.3.1 传入参数</h4><p>引用公共页面片段时，我们可以通过以下 2 种方式，将参数传入到被引用的页面片段中：</p><ul><li>模板名::选择器名或片段名(参数1=参数值1,参数2=参数值2)</li><li>模板名::选择器名或片段名(参数值1,参数值2)</li></ul><blockquote><p>注：</p><ul><li>若传入参数较少时，一般采用第二种方式，直接将参数值传入页面片段中；</li><li>若参数较多时，建议使用第一种方式，明确指定参数名和参数值，。</li></ul></blockquote><p>示例代码如下：</p><pre><code>&lt;!--th:insert 片段名引入--&gt;&lt;div th:insert=&quot;commons::fragment-name(var1=&#39;insert-name&#39;,var2=&#39;insert-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:insert id 选择器引入--&gt;&lt;div th:insert=&quot;commons::#fragment-id(var1=&#39;insert-id&#39;,var2=&#39;insert-id2&#39;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:replace 片段名引入--&gt;&lt;div th:replace=&quot;commons::fragment-name(var1=&#39;replace-name&#39;,var2=&#39;replace-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:replace id 选择器引入--&gt;&lt;div th:replace=&quot;commons::#fragment-id(var1=&#39;replace-id&#39;,var2=&#39;replace-id2&#39;)&quot;&gt;&lt;/div&gt;------------------------------------------------&lt;!--th:include 片段名引入--&gt;&lt;div th:include=&quot;commons::fragment-name(var1=&#39;include-name&#39;,var2=&#39;include-name2&#39;)&quot;&gt;&lt;/div&gt;&lt;!--th:include id 选择器引入--&gt;&lt;div th:include=&quot;commons::#fragment-id(var1=&#39;include-id&#39;,var2=&#39;include-id2&#39;)&quot;&gt;&lt;/div&gt;</code></pre><h4 id="3-3-2-使用参数"><a href="#3-3-2-使用参数" class="headerlink" title="3.3.2 使用参数"></a>3.3.2 使用参数</h4><p>在声明页面片段时，我们可以在片段中声明并使用这些参数，例如：</p><pre><code>&lt;!--使用 var1 和 var2 声明传入的参数，并在该片段中直接使用这些参数 --&gt;&lt;div th:fragment=&quot;fragment-name(var1,var2)&quot; id=&quot;fragment-id&quot;&gt;    &lt;p th:text=&quot;&#39;参数1:&#39;+$&#123;var1&#125; + &#39;-------------------参数2:&#39; + $&#123;var2&#125;&quot;&gt;...&lt;/p&gt;&lt;/div&gt;</code></pre><p>启动 Spring Boot，使用浏览器访问 fragment.html，结果如下图。</p><p>图1：参数传递效果图</p><h2 id="thymeleaf-基本对象"><a href="#thymeleaf-基本对象" class="headerlink" title="thymeleaf 基本对象"></a>thymeleaf 基本对象</h2><h3 id="ctx：上下文对象"><a href="#ctx：上下文对象" class="headerlink" title="#ctx：上下文对象"></a><strong>#ctx：上下文对象</strong></h3><p><strong>thymeleaf context：#ctx 是IContext 对象引用</strong></p><pre class=" language-lang-java"><code class="language-lang-java">public interface IContext &#123;    Locale getLocale();    boolean containsVariable(String var1);    Set getVariableNames();    Object getVariable(String var1);&#125;**********#ctx 使用$&#123;#ctx.locale&#125;$&#123;#ctx.varableNames&#125;</code></pre><p><strong>thymeleaf web context：#ctx 是 IWebContext 对象引用</strong></p><pre class=" language-lang-java"><code class="language-lang-java">public interface IWebContext extends IContext &#123;    HttpServletRequest getRequest();    HttpServletResponse getResponse();    HttpSession getSession();    ServletContext getServletContext();&#125;************#ctx 使用$&#123;#ctx.request&#125;$&#123;#ctx.response&#125;$&#123;#ctx.session&#125;$&#123;#ctx.servletContext&#125;</code></pre><p><strong>说明：#vars、#root 与 #ctx 作用相似，推荐使用 #ctx</strong></p><h3 id="locale：java-util-Locale-对象引用"><a href="#locale：java-util-Locale-对象引用" class="headerlink" title="#locale：java.util.Locale 对象引用"></a><strong>#locale：java.util.Locale 对象引用</strong></h3><hr><p><strong>param、session、application</strong></p><p><strong>WebEngineContext</strong></p><pre class=" language-lang-java"><code class="language-lang-java">public class WebEngineContext extends AbstractEngineContext implements IEngineContext, IWebContext &#123;    private static final String PARAM_VARIABLE_NAME = "param";    private static final String SESSION_VARIABLE_NAME = "session";    private static final String APPLICATION_VARIABLE_NAME = "application";    private final HttpServletRequest request;    private final HttpServletResponse response;    private final HttpSession session;    private final ServletContext servletContext;    private final WebEngineContext.RequestAttributesVariablesMap requestAttributesVariablesMap;    private final Map requestParametersVariablesMap;    private final Map sessionAttributesVariablesMap;    private final Map applicationAttributesVariablesMap;</code></pre><p> <strong>说明：</strong>web 环境中，<strong>param、session、application</strong>以 <strong>map 的形式</strong>存储到<strong>WebEngineContext</strong>中</p><p><strong>param ==&gt; requestParametersVariablesMap</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;param.foo&#125;                  //请求参数foo对应的value$&#123;param.size()&#125;               //请求参数的个数$&#123;param.isEmpty()&#125;            //请求参数是否为空$&#123;param.containsKey('foo')&#125;   //请求参数中是否含有名为foo的参数...</code></pre><p><strong>session</strong> <strong>==&gt; sessionAttributesVariablesMap</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;session.foo&#125;                 //获取session中key：foo的属性值$&#123;session.size()&#125;              //session中键值对个数$&#123;session.isEmpty()&#125;           //session中是否含有键值对$&#123;session.containsKey('foo')&#125;  //session中是否含有key：foo的键值对...</code></pre><p><strong>application</strong> <strong>==&gt;</strong> <strong>applicationAttributesVariablesMap</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;application.foo&#125;                //application 中key：foo的属性值$&#123;application.size()&#125;             //application中存储的键值对的个数$&#123;application.isEmpty()&#125;          //application中是否存储键值对$&#123;application.containsKey('foo')&#125; //application中是否含有key为foo的键值对...</code></pre><p><strong>注意：param、session、application使用时没有 #</strong></p><hr><h3 id="request、-session、-servletContext"><a href="#request、-session、-servletContext" class="headerlink" title="#request、#session、#servletContext"></a><strong>#request、#session、#servletContext</strong></h3><p><strong>#request：javax.servlet.http.HttpServletRequest 对象引用</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;#request.getAttribute('foo')&#125;$&#123;#request.getParameter('foo')&#125;$&#123;#request.getContextPath()&#125;$&#123;#request.getRequestName()&#125;...</code></pre><p><strong>#session：javax.servlet.http.HttpSession 对象引用</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;#session.getAttribute('foo')&#125;$&#123;#session.id&#125;$&#123;#session.lastAccessedTime&#125;...</code></pre><p><strong>#servletContext：javax.servlet.ServletContext</strong></p><pre class=" language-lang-html"><code class="language-lang-html">$&#123;#servletContext.getAttribute('foo')&#125;$&#123;#servletContext.contextPath&#125;...</code></pre><h2 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h2><p>修改须要带实体进行回显，而新增不须要，那么就会出现再新增的状况下Thymeleaf找不到实体对象blog</p><p>使用 ${xxx?.xxx?} 能够判断对象是否为空渲染</p><p>? 号 前的对象或者属性为空那么就再也不进行渲染，并且不会致使出现报错的状况im </p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code>代码示例：    $&#123;#dates.format(dateVar, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.arrayFormat(datesArray, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.listFormat(datesList, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.setFormat(datesSet, &#39;dd/MMM/yyyy HH:mm&#39;)&#125;    $&#123;#dates.createNow()&#125;    $&#123;#dates.createToday()&#125;    $&#123;#strings.isEmpty(name)&#125;    $&#123;#strings.arrayIsEmpty(nameArr)&#125;    $&#123;#strings.listIsEmpty(nameList)&#125;    $&#123;#strings.setIsEmpty(nameSet)&#125;    $&#123;#strings.startsWith(name,&#39;Don&#39;)&#125;                  // also array*, list* and set*    $&#123;#strings.endsWith(name,endingFragment)&#125;           // also array*, list* and set*    $&#123;#strings.length(str)&#125;     $&#123;#strings.equals(str)&#125;    $&#123;#strings.equalsIgnoreCase(str)&#125;    $&#123;#strings.concat(str)&#125;    $&#123;#strings.concatReplaceNulls(str)&#125;    $&#123;#strings.randomAlphanumeric(count)&#125;//产生随机字符串</code></pre><h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><p><a href="https://blog.csdn.net/liuminglei1987/article/details/106692004/">https://blog.csdn.net/liuminglei1987/article/details/106692004/</a></p><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>springboot+thymeleaf+mybatis+mysql</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>实现 emp 的增删改查和分页功能</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p>首页：</p><p>编辑页：</p><p>添加页：</p><p>删除提示：</p><h4 id="mysql数据"><a href="#mysql数据" class="headerlink" title="mysql数据"></a>mysql数据</h4><pre><code>/*MySQL BackupSource Server Version: 5.5.49Source Database: testDate: 2017/9/11 06:52:29*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------  Table structure for `dept`-- ----------------------------DROP TABLE IF EXISTS `dept`;CREATE TABLE `dept` (  `DEPTNO` int(11) NOT NULL,  `DNAME` varchar(14) DEFAULT NULL,  `LOC` varchar(13) DEFAULT NULL,  PRIMARY KEY (`DEPTNO`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------  Table structure for `emp`-- ----------------------------DROP TABLE IF EXISTS `emp`;CREATE TABLE `emp` (  `EMPNO` int(11) NOT NULL,  `ENAME` varchar(10) DEFAULT NULL,  `JOB` varchar(9) DEFAULT NULL,  `MGR` int(11) DEFAULT NULL,  `HIREDATE` date DEFAULT NULL,  `SAL` decimal(7,2) DEFAULT NULL,  `COMM` decimal(7,2) DEFAULT NULL,  `DEPTNO` int(11) DEFAULT NULL,  PRIMARY KEY (`EMPNO`),  KEY `FK_DEPTNO` (`DEPTNO`),  CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`DEPTNO`) REFERENCES `dept` (`DEPTNO`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- ------------------------------  Records -- ----------------------------INSERT INTO `dept` VALUES (&#39;10&#39;,&#39;ACCOUNTING&#39;,&#39;NEW YORK&#39;), (&#39;20&#39;,&#39;RESEARCH&#39;,&#39;DALLAS&#39;), (&#39;30&#39;,&#39;SALES&#39;,&#39;CHICAGO&#39;), (&#39;40&#39;,&#39;OPERATIONS&#39;,&#39;BOSTON&#39;);INSERT INTO `emp` VALUES (&#39;7369&#39;,&#39;SMITH&#39;,&#39;CLERK&#39;,&#39;7902&#39;,&#39;1980-12-17&#39;,&#39;800.00&#39;,NULL,&#39;20&#39;), (&#39;7499&#39;,&#39;ALLEN&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-02-20&#39;,&#39;1600.00&#39;,&#39;300.00&#39;,&#39;30&#39;), (&#39;7521&#39;,&#39;WARD&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-02-22&#39;,&#39;1250.00&#39;,&#39;500.00&#39;,&#39;30&#39;), (&#39;7566&#39;,&#39;JONES&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-04-02&#39;,&#39;2975.00&#39;,NULL,&#39;20&#39;), (&#39;7654&#39;,&#39;MARTIN&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-09-28&#39;,&#39;1250.00&#39;,&#39;1400.00&#39;,&#39;30&#39;), (&#39;7698&#39;,&#39;BLAKE&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-05-01&#39;,&#39;2850.00&#39;,NULL,&#39;30&#39;), (&#39;7782&#39;,&#39;CLARK&#39;,&#39;MANAGER&#39;,&#39;7839&#39;,&#39;1981-06-09&#39;,&#39;2450.00&#39;,NULL,&#39;10&#39;), (&#39;7788&#39;,&#39;SCOTT&#39;,&#39;ANALYST&#39;,&#39;7566&#39;,&#39;1987-06-13&#39;,&#39;3000.00&#39;,NULL,&#39;20&#39;), (&#39;7839&#39;,&#39;KING&#39;,&#39;PRESIDENT&#39;,NULL,&#39;1981-11-17&#39;,&#39;5000.00&#39;,NULL,&#39;10&#39;), (&#39;7844&#39;,&#39;TURNER&#39;,&#39;SALESMAN&#39;,&#39;7698&#39;,&#39;1981-09-08&#39;,&#39;1500.00&#39;,&#39;0.00&#39;,&#39;30&#39;), (&#39;7876&#39;,&#39;ADAMS&#39;,&#39;CLERK&#39;,&#39;7788&#39;,&#39;1987-06-13&#39;,&#39;1100.00&#39;,NULL,&#39;20&#39;), (&#39;7900&#39;,&#39;JAMES&#39;,&#39;CLERK&#39;,&#39;7698&#39;,&#39;1981-12-03&#39;,&#39;950.00&#39;,NULL,&#39;30&#39;), (&#39;7902&#39;,&#39;FORD&#39;,&#39;ANALYST&#39;,&#39;7566&#39;,&#39;1981-12-03&#39;,&#39;3000.00&#39;,NULL,&#39;20&#39;), (&#39;7934&#39;,&#39;MILLER&#39;,&#39;CLERK&#39;,&#39;7782&#39;,&#39;1982-01-23&#39;,&#39;1300.00&#39;,NULL,&#39;10&#39;);</code></pre><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.4.5&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;springbootdemo1&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;springbootdemo1&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.1.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.2.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h3><pre><code>server.port=8089spring.thymeleaf.cache=falseserver.servlet.context-path=/spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root</code></pre><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>包：entity</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class Emp &#123;    private Integer empno;    private String ename;    private String job;    private Integer mgr;    @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)    private Date hiredate;    private Double sal;    private Double comm;    private Dept dept;&#125;</code></pre><pre><code>@Data@NoArgsConstructor@AllArgsConstructorpublic class Dept &#123;    private Integer deptno;    private String dname;    private String loc;&#125;</code></pre><h3 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h3><p>包：mapper</p><pre><code>public interface EmpMapper &#123;    @Insert(&#123;&quot;insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) &quot;,            &quot;values(#&#123;empno&#125;,#&#123;ename&#125;,#&#123;job&#125;,#&#123;mgr&#125;,#&#123;hiredate&#125;,#&#123;sal&#125;,#&#123;comm&#125;,#&#123;dept.deptno&#125;)&quot;&#125;)    public int insert(Emp emp);    @Update(&#123;&quot;update emp set ename = #&#123;ename&#125;,job=#&#123;job&#125;,mgr=#&#123;mgr&#125;,hiredate=#&#123;hiredate&#125;&quot;,            &quot;,sal=#&#123;sal&#125;,comm=#&#123;comm&#125;,deptno=#&#123;dept.deptno&#125;&quot;,            &quot; where empno = #&#123;empno&#125;&quot;&#125;)    public int update(Emp emp);    @Delete(&quot;delete from emp where empno = #&#123;empno&#125;&quot;)    public int delete(Integer empno);    @Select(&quot;select * from emp where empno = #&#123;empno&#125;&quot;)    @Results(id=&quot;basicMap&quot;,value = &#123;@Result(            property = &quot;dept&quot;,            column = &quot;deptno&quot;,            one = @One(select = &quot;com.neu.springbootdemo1.mapper.DeptMapper.getById&quot;)    )&#125;)    public Emp getById(Integer empno);    @Select(&quot;select * from emp&quot;)    @ResultMap(&quot;basicMap&quot;)    public List&lt;Emp&gt; getAll();&#125;</code></pre><pre><code>public interface DeptMapper &#123;    @Select(&quot;select * from dept&quot;)    List&lt;Dept&gt; getAll();    @Select(&quot;select * from dept where deptno = #&#123;deptno&#125;&quot;)    Dept getById(Integer deptno);&#125;</code></pre><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>包：service</p><pre><code>public interface EmpService &#123;    public int insert(Emp emp);    public int update(Emp emp);    public int delete(Integer empno);    public Emp getById(Integer empno);    public List&lt;Emp&gt; getAll();    public PageInfo&lt;Emp&gt; getPaged(int pageNum,int pageSize);&#125;</code></pre><pre><code>public interface DeptService &#123;    List&lt;Dept&gt; getAll();    Dept getById(Integer deptno);&#125;</code></pre><p>实现类：</p><p>包：service.impl</p><pre><code>@Servicepublic class DeptServiceImpl implements DeptService &#123;    @Autowired    private DeptMapper deptMapper;    @Override    public List&lt;Dept&gt; getAll() &#123;        return deptMapper.getAll();    &#125;    @Override    public Dept getById(Integer deptno) &#123;        return deptMapper.getById(deptno);    &#125;&#125;</code></pre><pre><code>@Servicepublic class EmpServiceImpl implements EmpService &#123;    @Autowired    private EmpMapper empMapper;    @Override    public int insert(Emp emp) &#123;        return empMapper.insert(emp);    &#125;    @Override    public int update(Emp emp) &#123;        return empMapper.update(emp);    &#125;    @Override    public int delete(Integer empno) &#123;        return empMapper.delete(empno);    &#125;    @Override    public Emp getById(Integer empno) &#123;        return empMapper.getById(empno);    &#125;    @Override    public List&lt;Emp&gt; getAll() &#123;        return empMapper.getAll();    &#125;    @Override    public PageInfo&lt;Emp&gt; getPaged(int pageNum, int pageSize) &#123;        PageHelper.startPage(pageNum,pageSize);        List&lt;Emp&gt; emps = empMapper.getAll();        PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(emps);        return pageInfo;    &#125;&#125;</code></pre><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><p>包：controller</p><pre><code>@Controller//@RequestMapping(&quot;emp&quot;)public class EmpController &#123;    @Autowired    private EmpService empService;    @Autowired    private DeptService deptService;    @RequestMapping(&#123;&quot;/&quot;,&quot;/emp/getPaged&quot;&#125;)    public String getPaged(@RequestParam(defaultValue = &quot;1&quot;) int pageNum,@RequestParam(defaultValue = &quot;3&quot;) int pageSize, Model model)&#123;        PageInfo&lt;Emp&gt; pageInfo = empService.getPaged(pageNum, pageSize);        model.addAttribute(&quot;pageInfo&quot;,pageInfo);        return &quot;emp/paged&quot;;    &#125;    @RequestMapping(&quot;emp/delete&quot;)    public String delete(Integer empno)&#123;        int n = empService.delete(empno);        return &quot;redirect:/&quot;;    &#125;    @RequestMapping(&quot;emp/edit&quot;)    public String edit(Integer empno,Model model)&#123;        Emp emp = empService.getById(empno);        model.addAttribute(&quot;emp&quot;,emp);        List&lt;Dept&gt; deptList = deptService.getAll();        model.addAttribute(&quot;deptList&quot;,deptList);        return &quot;emp/edit&quot;;    &#125;    @RequestMapping(&quot;emp/update&quot;)    public String update(Emp emp)&#123;        empService.update(emp);        return &quot;redirect:/&quot;;    &#125;    @RequestMapping(&quot;emp/add&quot;)    public String add(Model model)&#123;        List&lt;Dept&gt; deptList = deptService.getAll();        model.addAttribute(&quot;deptList&quot;,deptList);        return &quot;emp/add&quot;;    &#125;    @RequestMapping(&quot;emp/insert&quot;)    public String insert(Emp emp)&#123;        int n = empService.insert(emp);        return &quot;redirect:/&quot;;    &#125;&#125;</code></pre><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><h4 id="源码结构图"><a href="#源码结构图" class="headerlink" title="源码结构图"></a>源码结构图</h4><h4 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h4><p>src/main/resources/templates/component/component1.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;/head&gt;    &lt;tr id=&quot;tfoot&quot;&gt;        &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt;            第&lt;span th:text=&quot;$&#123;pageInfo.pageNum&#125;&quot;&gt;&lt;/span&gt;页/            共&lt;span th:text=&quot;$&#123;pageInfo.pages&#125;&quot;&gt;&lt;/span&gt;页            &lt;a th:if=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateFirstPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;第一页&lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasPreviousPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateFirstPage-1&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;上一页&lt;/a&gt;            &lt;a                 th:href=&quot;$&#123;pageInfo.pageNum == num&#125;?&#39;#&#39;:|@&#123;/emp/getPaged(pageNum=$&#123;num&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;                 th:each=&quot;num:$&#123;pageInfo.navigatepageNums&#125;&quot;                 th:text=&quot;|[$&#123;num&#125;]|&quot;&gt;            &lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasNextPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.nextPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;下一页&lt;/a&gt;            &lt;a th:if=&quot;$&#123;pageInfo.hasNextPage&#125;&quot; th:href=&quot;|@&#123;/emp/getPaged(pageNum=$&#123;pageInfo.navigateLastPage&#125;,pageSize=$&#123;pageInfo.pageSize&#125;)&#125;|&quot;&gt;最后一页&lt;/a&gt;            跳转到：&lt;input type=&quot;text&quot; style=&quot;width:15px;&quot; onkeydown=&quot;goPage(this.value)&quot;&gt;            &lt;select onchange=&quot;changePageSize(this.value)&quot;&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 3&#125;&quot;&gt;3&lt;/option&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 5&#125;&quot;&gt;5&lt;/option&gt;                &lt;option th:selected=&quot;$&#123;pageInfo.pageSize == 10&#125;&quot;&gt;10&lt;/option&gt;            &lt;/select&gt;        &lt;/td&gt;        &lt;script th:inline=&quot;javascript&quot;  &gt;            function del(empno)&#123;                var b = confirm(&quot;是否删除&quot;);                if(b)&#123;                    location.href=[[|@&#123;/emp/delete&#125;?empno=|]]+empno;                &#125;            &#125;            function goPage(num)&#123;                if(event.keyCode == 13)&#123;                    var url = [[@&#123;/emp/getPaged(pageSize=$&#123;pageInfo.pageSize&#125;)&#125;]]+&quot;&amp;pageNum=&quot;+num;                    location.href= url;                &#125;            &#125;            function changePageSize(size)&#123;                var url = [[@&#123;/emp/getPaged?pageNum=1&#125;]]+&quot;&amp;pageSize=&quot;+size;                location.href= url;            &#125;        &lt;/script&gt;    &lt;/tr&gt;    &lt;div id=&quot;com2&quot;&gt;        &lt;p th:text=&quot;$&#123;#ctx.#request.getAttribute(&#39;msg&#39;)&#125;&quot;&gt;&lt;/p&gt;    &lt;/div&gt;&lt;/html&gt;</code></pre><h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>src/main/resources/statis/css/style1.css</p><pre><code>.bg&#123;   background-color:antiquewhite;&#125;</code></pre><h4 id="分页查询页"><a href="#分页查询页" class="headerlink" title="分页查询页"></a>分页查询页</h4><p>位置：/resources/templates/emp/paged.html</p><h5 id="使用组件版"><a href="#使用组件版" class="headerlink" title="使用组件版"></a>使用组件版</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;thymeleaf&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/css/style1.css&#125;&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;a th:href=&quot;@&#123;/emp/add&#125;&quot;&gt;添加员工&lt;/a&gt;    &lt;table width=&quot;1200&quot; border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;岗位&lt;/th&gt;                &lt;th&gt;经理&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪水&lt;/th&gt;                &lt;th&gt;奖金&lt;/th&gt;                &lt;th&gt;部门&lt;/th&gt;                &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr                 th:each=&quot;emp,status:$&#123;pageInfo.list&#125;&quot;                 th:object=&quot;$&#123;emp&#125;&quot;                th:classappend=&quot;$&#123;status.index % 2 == 1?&#39;bg&#39;:&#39;&#39;&#125;&quot;            &gt;                &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;ename&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;job&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;sal&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;comm&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;mgr&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;dept.dname&#125;&quot;&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=&quot;#&quot; th:onclick=&quot;del([[*&#123;empno&#125;]])&quot;&gt;删除&lt;/a&gt;                    &lt;a th:href=&quot;|@&#123;/emp/edit&#125;?empno=*&#123;empno&#125;|&quot;&gt;编辑&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;        &lt;tfoot th:insert=&quot;~&#123;/component/component1 :: #tfoot&#125;&quot;&gt;&lt;/tfoot&gt;    &lt;/table&gt;   &lt;!--  &lt;script th:replace=&quot;~&#123;/component/component1:: #s1&#125;&quot;&gt;            &lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="不使用组件版"><a href="#不使用组件版" class="headerlink" title="不使用组件版"></a>不使用组件版</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;员工信息&lt;/title&gt;    &lt;style&gt;        .tr&#123;            background-color: antiquewhite;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;a th:href=&quot;|$&#123;#request.contextPath&#125;/emp/add|&quot;&gt;添加员工&lt;/a&gt;    &lt;table width=&quot;1200&quot; border=&quot;1&quot;&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;编号&lt;/th&gt;                &lt;th&gt;姓名&lt;/th&gt;                &lt;th&gt;岗位&lt;/th&gt;                &lt;th&gt;经理&lt;/th&gt;                &lt;th&gt;入职日期&lt;/th&gt;                &lt;th&gt;薪水&lt;/th&gt;                &lt;th&gt;奖金&lt;/th&gt;                &lt;th&gt;部门&lt;/th&gt;                &lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &lt;tr th:each=&quot;emp,status : $&#123;pageInfo.list&#125;&quot;                th:object=&quot;$&#123;emp&#125;&quot;                th:classappend=&quot;$&#123;status.odd&#125;?&#39;tr&#39;&quot;            &gt;                &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;ename&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;job&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;mgr&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;sal&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;comm&#125;&quot;&gt;&lt;/td&gt;                &lt;td th:text=&quot;*&#123;dept.dname&#125;&quot;&gt;&lt;/td&gt;                &lt;td&gt;                    &lt;a href=&quot;#&quot; th:onclick=&quot;del([[*&#123;empno&#125;]])&quot;&gt;删除&lt;/a&gt;                    &lt;a href=&quot;#&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/edit?empno=*&#123;empno&#125;|&quot;&gt;编辑&lt;/a&gt;                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tbody&gt;        &lt;tfoot&gt;            &lt;tr&gt;                &lt;td colspan=&quot;9&quot; align=&quot;center&quot;&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isFirstPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=1&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;第一页&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isFirstPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pageNum-1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;上一页&lt;/a&gt;                    &lt;a href=&quot;#&quot;                       th:each=&quot;pageNum : $&#123;#numbers.sequence(1,pageInfo.pages)&#125;&quot;                       th:text=&quot;|[$&#123;pageNum&#125;]|&quot;                       th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageNum&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;                    &gt;&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isLastPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pageNum+1&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;下一页&lt;/a&gt;                    &lt;a th:if=&quot;$&#123; not pageInfo.isLastPage&#125;&quot; th:href=&quot;|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=$&#123;pageInfo.pages&#125;&amp;pageSize=$&#123;pageInfo.pageSize&#125;|&quot;&gt;末页&lt;/a&gt;                    到：&lt;input type=&quot;text&quot; size=&quot;1&quot; id=&quot;pageNum&quot; onkeydown=&quot;goPage()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;go&quot; onclick=&quot;jumpToPage()&quot;&gt;                    &lt;select onchange=&quot;changePageSize(this.value)&quot;&gt;                        &lt;option value=&quot;3&quot; th:selected=&quot;$&#123;pageInfo.pageSize==3&#125;?true:false&quot;&gt;3&lt;/option&gt;                        &lt;option value=&quot;5&quot; th:selected=&quot;$&#123;pageInfo.pageSize==5&#125;?true:false&quot;&gt;5&lt;/option&gt;                        &lt;option value=&quot;8&quot; th:selected=&quot;$&#123;pageInfo.pageSize==8&#125;?true:false&quot;&gt;8&lt;/option&gt;                    &lt;/select&gt;                    总计: &lt;span th:text=&quot;$&#123;pageInfo.total&#125;&quot;&gt;&lt;/span&gt; 行                &lt;/td&gt;            &lt;/tr&gt;        &lt;/tfoot&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&lt;script th:inline=&quot;javascript&quot;&gt;    function jumpToPage() &#123;        let pageNum = document.getElementById(&quot;pageNum&quot;).value;        location.href = [[|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=|]]+pageNum+&quot;&amp;pageSize=&quot;+[[$&#123;pageInfo.pageSize&#125;]];    &#125;    function changePageSize(pageSize) &#123;        location.href = [[|$&#123;#request.contextPath&#125;/emp/getPaged?pageNum=1|]]+&quot;&amp;pageSize=&quot;+pageSize;    &#125;    function goPage() &#123;        if(event.keyCode === 13)&#123;            jumpToPage();        &#125;    &#125;    function del(empno) &#123;        if(confirm(`是否删除id为：$&#123;empno&#125;的员工?`))&#123;            location.href = [[|$&#123;#request.contextPath&#125;/emp/delete?empno=|]]+empno;        &#125;    &#125;&lt;/script&gt;</code></pre><h4 id="编辑页"><a href="#编辑页" class="headerlink" title="编辑页"></a>编辑页</h4><p>位置：/resources/templates/emp/edit.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form th:action=&quot;@&#123;/emp/update(empno=$&#123;emp.empno&#125;)&#125;&quot; method=&quot;post&quot;&gt;    &lt;table th:object=&quot;$&#123;emp&#125;&quot;&gt;        &lt;tr&gt;            &lt;td&gt;员工编号：&lt;/td&gt;            &lt;td th:text=&quot;*&#123;empno&#125;&quot;&gt;&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工姓名：&lt;/td&gt;            &lt;td &gt;                &lt;input type=&quot;text&quot; name=&quot;ename&quot; th:value=&quot;*&#123;ename&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工岗位：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;job&quot; th:value=&quot;*&#123;job&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;入职日期：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;date&quot; name=&quot;hiredate&quot; th:value=&quot;*&#123;#dates.format(hiredate,&#39;yyyy-MM-dd&#39;)&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;经理编号：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;mgr&quot; th:value=&quot;*&#123;mgr&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;薪水：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot;  name=&quot;sal&quot; th:value=&quot;*&#123;sal&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;奖金：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;comm&quot; th:value=&quot;*&#123;comm&#125;&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;部门：&lt;/td&gt;            &lt;td&gt;                &lt;select name=&quot;dept.deptno&quot;&gt;                                    &lt;option                        th:each=&quot;dept:$&#123;deptList&#125;&quot;                        th:object=&quot;$&#123;dept&#125;&quot;                        th:text=&quot;*&#123;dname&#125;&quot;                        th:value=&quot;*&#123;deptno&#125;&quot;                        th:selected=&quot;*&#123;deptno&#125; == $&#123;emp.dept.deptno&#125;&quot;                    &gt;                    &lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="添加页"><a href="#添加页" class="headerlink" title="添加页"></a>添加页</h4><p>位置：/resources/templates/emp/add.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;添加员工&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form th:action=&quot;@&#123;/emp/insert&#125;&quot; method=&quot;post&quot;&gt;    &lt;table&gt;        &lt;tr&gt;            &lt;td&gt;员工编号：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;empno&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工姓名：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;ename&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工岗位：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;job&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工经理：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;mgr&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;入职日期：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;date&quot; name=&quot;hiredate&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工薪水：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;sal&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工奖金：&lt;/td&gt;            &lt;td&gt;                &lt;input type=&quot;text&quot; name=&quot;comm&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;员工部门：&lt;/td&gt;            &lt;td&gt;                &lt;select name=&quot;dept.deptno&quot;&gt;                    &lt;option                            th:each=&quot;dept : $&#123;deptList&#125;&quot;                            th:text=&quot;$&#123;dept.dname&#125;&quot;                            th:value=&quot;$&#123;dept.deptno&#125;&quot;                    &gt;&lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;                &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;            &lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="测试Mapper"><a href="#测试Mapper" class="headerlink" title="测试Mapper"></a>测试Mapper</h3><pre><code>package com.neu.springbootdemo1;import com.neu.springbootdemo1.entity.Dept;import com.neu.springbootdemo1.entity.Emp;import com.neu.springbootdemo1.mapper.DeptMapper;import com.neu.springbootdemo1.mapper.EmpMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import java.util.Date;import java.util.List;@SpringBootTestclass Springbootdemo1ApplicationTests &#123;    @Autowired    private DeptMapper deptMapper;    @Autowired    private EmpMapper empMapper;    @Test    void testEmpGetById()&#123;        Emp emp = empMapper.getById(7566);        System.out.println(emp);    &#125;    @Test    void testEmpGetAll()&#123;        List&lt;Emp&gt; emps = empMapper.getAll();        System.out.println(emps);    &#125;    @Test    void testEmpInsert()&#123;        Emp emp = new Emp(2000,&quot;marry&quot;,&quot;清洁工&quot;,7566,new Date(),3000d,100d,new Dept(10,null,null));        int n = empMapper.insert(emp);        System.out.println(n);    &#125;    @Test    void testEmpUpdate()&#123;        Emp emp = new Emp(2000,&quot;marry&quot;,&quot;清洁工&quot;,7566,new Date(),4000d,200d,new Dept(20,null,null));        int n = empMapper.update(emp);        System.out.println(n);    &#125;    @Test    void testEmpDelete()&#123;        int n = empMapper.delete(2000);        System.out.println(n);    &#125;    @Test    void testDeptGetAll() &#123;        List&lt;Dept&gt; depts = deptMapper.getAll();        System.out.println(depts);    &#125;    @Test    void testDeptGetById()&#123;        Dept dept = deptMapper.getById(10);        System.out.println(dept);    &#125;&#125;</code></pre></script></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Thymeleaf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot</title>
      <link href="/2022/052617366.html"/>
      <url>/2022/052617366.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>起步依赖：告诉springboot需要什么功能，它就能引入需要的库，起步依赖其实就是利用maven传递依赖解析，把常用的库聚合在一起，组成了几个为特定功能而定制的依赖</li><li>自动配置：针对很多spring应用程序常见的功能，spring提供了自动依赖扫描，并进行自动配置</li></ol><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ol><li><p>Spring Initializr（springboot初始化器）</p></li><li><p>选择需要的功能</p><ul><li>Spring Web</li><li>mybatis</li><li>mysql驱动</li><li>lombok</li><li>devtools（开发工具）</li></ul></li><li><p>修改了 application.properties</p><pre><code>#配置web服务器的端口号server.port=8089#配置数据源参数spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/neusoft?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=root#配置视图解析器spring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp</code></pre></li><li><p>添加jsp支持</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><p>idea中解决不能添加jsp文件的问题：</p><img src="/2022/052617366/1.jpg" class=""></li><li><p>添加mapper扫描注解</p><pre><code>@SpringBootApplication@MapperScan(basePackages = "com.neu.mapper")public class SpringbootDemo1Application {    public static void main(String[] args) {        SpringApplication.run(SpringbootDemo1Application.class, args);    }}</code></pre></li></ol><h2 id="Mapper文件相关配置"><a href="#Mapper文件相关配置" class="headerlink" title="Mapper文件相关配置"></a>Mapper文件相关配置</h2><ol><li><p>把mapper.xml放到 resources目录下，与mapper接口对应的文件夹下，如</p><img src="/2022/052617366/2.jpg" class=""></li><li><p>修改pom.xml,并在maven窗口中执行刷新</p><pre><code>&lt;build&gt;       &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;&lt;/build&gt;</code></pre></li></ol><h2 id="mybatis执行时显示sql"><a href="#mybatis执行时显示sql" class="headerlink" title="mybatis执行时显示sql"></a>mybatis执行时显示sql</h2><p>在application.<a href="https://so.csdn.net/so/search?q=properties&amp;spm=1001.2101.3001.7020">properties</a>或application.yml文件中配置对应mapper所在包的日志级别即可。</p><p><strong>示列：com.neu.springbootdemodd.mapper 指向mapper 接口包路径地址</strong></p><pre><code># 日志记录输出配置logging.level.com.neu.springbootdemodd.mapper=debug</code></pre><h2 id="mybatis分页插件"><a href="#mybatis分页插件" class="headerlink" title="mybatis分页插件"></a>mybatis分页插件</h2><ol><li><p>添加依赖</p><pre><code>&lt;!--分页插件 pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>@Test    void testGetPaged(){        PageHelper.startPage(2,3);        List&lt;Dept&gt; list = deptMapper.getAll();        PageInfo&lt;Dept&gt; pageInfo = new PageInfo&lt;&gt;(list);        System.out.println(pageInfo);    }输出：PageInfo{pageNum=2, pageSize=3, size=3, startRow=4, endRow=6, total=11, pages=4, list=Page{count=true, pageNum=2, pageSize=3, startRow=3, endRow=6, total=11, pages=4, reasonable=false, pageSizeZero=false}[Dept(deptno=30, dname=SALES, loc=沈阳), Dept(deptno=33, dname=hr5, loc=南京), Dept(deptno=37, dname=hr, loc=sy)], prePage=1, nextPage=3, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=8, navigateFirstPage=1, navigateLastPage=4, navigatepageNums=[1, 2, 3, 4]}</code></pre></li><li><p>设置（可选）</p><pre><code>#分页pageHelperpagehelper:  helperDialect: mysql  reasonable: true  #为了使用输入页数为负或者超出最大页时候使页数为最小或最大值  supportMethodsArguments: true  params: count=countSql  pageSizeZero: true·helper-dialect:配置使用哪种数据库语言，不配置的话pageHelper也会自动检测·reasonable:配置分页参数合理化功能，默认是false。 #启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;总页数会查询最后一页； #禁用合理化时，如果pageNum&lt;1或pageNum&gt;总页数会返回空数据。·params:为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值; 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。·support-methods-arguments:支持通过Mapper接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。pageSizeZeropageSize=0 or RowBounds.Limit = 0的时候就不适用分页，但是返回对象还是PageInfo</code></pre></li></ol><h2 id="Spring对mybatis事务的支持"><a href="#Spring对mybatis事务的支持" class="headerlink" title="Spring对mybatis事务的支持"></a>Spring对mybatis事务的支持</h2><p>注意：mysql只有InnoDB引擎支持事务</p><pre><code>@Transactionalpublic int insert(Dept dept) {    int n = deptMapper.insert(dept);    deptMapper.insert(dept);    return n;}</code></pre><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ol><li><p>导入jar包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></li><li><p>编写切面类</p><pre><code>@Configuration@EnableAspectJAutoProxy//开启切面自动代理@Component@Aspect//切面public class AOPUtil {    //定义切入点    @Pointcut("execution (* com.neu.controller.*.*(..))")    public void pointcut() {    }    @Before("pointcut()")    public void before() {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        System.out.println(f.format(new Date()));    }}</code></pre></li></ol><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><ol><li>引入配置</li></ol><pre><code>&lt;!-- SpringBoot 热部署组件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ol><li>配置静态自动编译</li></ol><img src="/2022/052617366/3.jpg" class=""><ol><li><p>如何触发<a href="https://so.csdn.net/so/search?q=热部署&amp;spm=1001.2101.3001.7020">热部署</a></p><ol><li><p>虽然idea会自动保存，但是触发时间不确定，可以手动触发保存 Ctrl + S</p></li><li><p>点击idea上面的 小锤子图标，build project也会触发热部署</p></li></ol></li></ol><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol><li><p>编写上传网页</p><pre><code>&lt;form         action="${ pageContext.request.contextPath }/emp/upload"         method="post"        enctype="multipart/form-data"    &gt;        文件名：&lt;input type="file" name="file"&gt;        &lt;input type="submit" value="提交"&gt;    &lt;/form&gt;</code></pre></li><li><p>服务器端</p><pre><code>@RequestMapping("upload")    public void upload(MultipartFile file,HttpServletRequest request, HttpServletResponse response) throws IllegalStateException, IOException {        String path = request.getServletContext().getRealPath("/WEB-INF/upload");        if(file != null &amp;&amp; !file.isEmpty()) {            String filename = file.getOriginalFilename();            File f = new File(path, filename);            //保存            file.transferTo(f);        }        response.setContentType("text/html;charset=utf-8");        response.getWriter().append("文件上传成功！");    }</code></pre></li><li><p>多文件上传</p><pre><code>&lt;form         action="${ pageContext.request.contextPath }/emp/upload"         method="post"        enctype="multipart/form-data"    &gt;        文件名：&lt;input type="file" name="files"&gt;&lt;br&gt;        文件名：&lt;input type="file" name="files"&gt;&lt;br&gt;        文件名：&lt;input type="file" name="files"&gt;&lt;br&gt;        &lt;input type="submit" value="提交"&gt;    &lt;/form&gt;</code></pre><p>```<br>@RequestMapping(“upload”)</p><pre><code>public void upload(@RequestParam("files") MultipartFile[] files,HttpServletRequest request, HttpServletResponse response) throws IllegalStateException, IOException {    String path = request.getServletContext().getRealPath("/WEB-INF/upload");    for(MultipartFile file : files) {        if(file != null &amp;&amp; !file.isEmpty()) {            String filename = file.getOriginalFilename();            File f = new File(path, filename);            //保存            file.transferTo(f);        }    }</code></pre></li></ol><pre><code>       response.setContentType("text/html;charset=utf-8");       response.getWriter().append("文件上传成功！");   }</code></pre><pre><code>4. 设置上传尺寸大小</code></pre><h1 id="每个文件最大尺寸"><a href="#每个文件最大尺寸" class="headerlink" title="每个文件最大尺寸"></a>每个文件最大尺寸</h1><p>   spring.servlet.multipart.max-file-size=5MB</p><h1 id="设置请求最大尺寸"><a href="#设置请求最大尺寸" class="headerlink" title="设置请求最大尺寸"></a>设置请求最大尺寸</h1><p>   spring.servlet.multipart.max-request-size=10MB</p><pre><code>## 全局异常处理1. 意义：更友好和更安全2. 代码：</code></pre><p>   @ControllerAdvice<br>   public class GlobalExceptionHandle {</p><pre><code>   @ExceptionHandler(Exception.class)   @ResponseBody   public String exceptionHandler(Exception ex) {       if(ex instanceof MaxUploadSizeExceededException) {           return "文件超过规定大小";       }       return "服务器错误，请联系管理员！";   }</code></pre><p>   }</p><pre><code>## 输出日志1. 导入依赖</code></pre><pre><code>       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;           &lt;exclusions&gt;               &lt;exclusion&gt;                   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                   &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;               &lt;/exclusion&gt;           &lt;/exclusions&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;           &lt;!-- &lt;version&gt;2.4.6&lt;/version&gt; --&gt;       &lt;/dependency&gt;</code></pre><pre><code>2. 在resources目录下，添加配置文件：log4j2.xml## 拦截器1. 拦截器类似于Ｓｅｒｖｌｅｔ中的过滤器，用于对处理器进行预处理和后处理2. 创建一个拦截器</code></pre><p>   public class LoginCheckInterceptor implements HandlerInterceptor {</p><pre><code>   @Override   public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)           throws Exception {       HttpSession session = request.getSession();       Object username = session.getAttribute("username");       if(username != null) {           //表示放行，不拦截           return true;       }       response.setContentType("text/html;charset=utf-8");       response.getWriter().print("没有权限，不能访问!!!");       return false;   }</code></pre><p>   }</p><pre><code>3. 注册拦截器</code></pre><p>   @Configuration<br>   public class SpringMVCConfig implements WebMvcConfigurer {<br>       @Override<br>       public void addFormatters(FormatterRegistry registry) {</p><pre><code>   }   @Override   public void addInterceptors(InterceptorRegistry registry) {       registry.addInterceptor(new LoginCheckInterceptor())           .addPathPatterns("/**")           .excludePathPatterns("/","/user/login");   }</code></pre><p>   }</p><pre><code>## 注册视图控制器</code></pre><p>@Configuration<br>public class SpringMVCConfig implements WebMvcConfigurer {</p><pre><code>@Overridepublic void addViewControllers(ViewControllerRegistry registry) {    registry.addViewController("/").setViewName("user/login");    registry.addViewController("/emp/getUpload").setViewName("emp/upload");}</code></pre><p>}</p><pre><code>## RESTFul1. 定义：Rest是一种规范，一种编程风格，简单的说，就是利用http协议通过Get、Post、Put、Patch、Delete来操作具有URI标识的服务器资源，返回统一格式的资源信息，包括：JSON、xml等2. JSON：JavaScript对象表示法   - {"name":"tom","age":20}   - [10,true,"tom",{"name":"tom","age":20}]3. 返回JSON数据   -</code></pre><pre><code> @Controller @RequestMapping("emp") public class EmpController {     @RequestMapping("getAll2")     @ResponseBody     public List&lt;Emp&gt; getAll2() {         List&lt;Emp&gt; list = empService.getAll();                 return list;     } } ```</code></pre><ul><li><pre><code>@RestController@RequestMapping("emp")public class EmpController {    @RequestMapping("getAll2")    public List&lt;Emp&gt; getAll2() {        List&lt;Emp&gt; list = empService.getAll();                return list;    }}</code></pre></li></ul><ol><li><p>Http method方法：</p><ul><li>get（select）：从服务器取出资源（一项或多项）</li><li>post(insert)：在服务器新建一个资源</li><li>put（update）：更新服务器资源（完整更新）</li><li>patch（update）：更新服务器资源（有选择更新）</li><li>delete(delete):删除服务器资源</li></ul></li><li><p>get请求</p><pre><code>@RestController@RequestMapping("dept2")public class RestDeptController {    @Autowired    private DeptService deptService;    //dept2/10    @GetMapping("{deptno}")    public Dept getById(@PathVariable("deptno")int deptno) {        return deptService.getById(deptno);    }    @GetMapping    public List&lt;Dept&gt; getAll() {        return deptService.getAll();    }    @GetMapping("{dname}/{loc}")    public List&lt;Dept&gt; getById(@PathVariable("dname") String dname,@PathVariable("loc") String loc) {        System.out.println(dname);        System.out.println(loc);        return deptService.getAll();    }}</code></pre></li><li><p>post请求</p><pre><code>@PostMappingpublic int insert(@RequestBody Dept dept) {    return deptService.insert(dept);}</code></pre></li><li><p>put请求</p><pre><code>@PutMappingpublic int update(@RequestBody Dept dept) {    return deptService.update(dept);}</code></pre></li></ol><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li><p>打 jar 包</p><ul><li>关闭原来的项目</li><li>run as=》maven build =》 clean package</li><li>运行：java -jar jar包路径</li><li>测试：<a href="http://localhost:8089/dept/hr/sy">http://localhost:8089/dept/hr/sy</a></li></ul></li><li><p>打 war 包</p><ul><li><p>修改打包方式：war</p></li><li><p>添加启动配置类</p><pre><code>public class ServletInitializer extends SpringBootServletInitializer {    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {        return application.sources(Springbootdemo2Application.class);    }}</code></pre></li><li><p>run as=》maven build =》clean package</p></li><li><p>把生成的war包拷贝到 tomcat安装目录 /webapps 文件夹下</p></li><li><p>启动 tomcat服务器 ： bin/startup.bat</p></li><li><p>测试：<a href="http://localhost:9000/war包名/资源url">http://localhost:9000/war包名/资源url</a></p></li><li><p>停止tomcat服务</p></li><li><p>删除 war 包</p></li><li><p>可以把war包解压的所有内容剪切到 ROOT 文件夹下，把这个应用作为 根应用 </p></li><li><p>打包问题：</p><p>Invalid bound statement (not found): com.neu.mapper.DeptMapper.getById</p><pre><code>&lt;build&gt;                &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;${project.basedir}/src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;&lt;/build&gt;</code></pre></li></ul></li></ol><h2 id="springboot打成jar包无法访问jsp"><a href="#springboot打成jar包无法访问jsp" class="headerlink" title="springboot打成jar包无法访问jsp"></a>springboot打成jar包无法访问jsp</h2><p>背景<br>以前老项目迁成springboot项目，里面有jsp页面，但是在打成jar包后，使用java -jar xxx.jar 发现并不能访问jsp页面，但其他接口能正常使用。ps：项目如果是直接从启动类main方法启动是可以访问。</p><p>存在问题<br>一、jar包未含jsp文件<br>旧spring mvc项目 jsp 放在webapp目录下，spring-boot-maven-plugin 打包默认是不含该目录的，应在pon文件<build>里指将jsp页面目录加入 <resource>。</resource></build></p><p>二、包含jsp文件仍访问不了<br>需要把spring-boot-maven-plugin 版本改为 1.4.2.RELEASE，其它版本的都不可以。</p><p>详细方案<br>1）检查 pom 文件是否添加已对 jsp 页面的依赖：</p><pre><code>&lt;!-- tomcat JSP 的支持.--&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;</code></pre><p>2）对jar包进行解压，进入解压目录查看是否有jsp页面，命令如下：</p><p>unzip xxx.jar<br>如果发现目录下没有jsp页面，则需要在pon文件<build>里指将jsp页面目录加入到 <resource>。</resource></build></p><p>3）指定 spring-boot-maven-plugin 版本为 1.4.2.RELEASE，其它版本的都不可以，具体原因不详，据说是个bug。</p><p>设置 targetPath 只能是 META-INF/resources。然后用这个版本最好指定一下启动类main函数<mainclass>，否则当你项目里面存在多个main方法就会报错不知道用哪个。</mainclass></p><pre><code>&lt;!-- jsp加入resources，指定插件版本--&gt;&lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;                &lt;configuration&gt;                    &lt;mainClass&gt;com.xxx.xxx.SpringbootApplication&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/webapp&lt;/directory&gt;            &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;            &lt;includes&gt;                &lt;include&gt;**/**&lt;/include&gt;            &lt;/includes&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;</code></pre><p>4）在配置文件中加入前缀、后缀，这样项目启动就能正常访问到 jsp 页面了，此处项目目录为：</p><pre><code>spring:  mvc:    servlet:      load-on-startup: 1    view:      suffix: .jsp      prefix: /WEB-INF/views/ps：本地开发修改页面实时生效的配置：server:  port: 8181  servlet:    jsp:      init-parameters:        development: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2022/05254780.html"/>
      <url>/2022/05254780.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>问题：</p><ol><li>一个Servlet处理一个请求</li><li>请求参数获取与转换</li><li>硬编码了视图结果</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>是spring框架一个模块，与Spring无缝集成（SSH，Struts2）</li><li>是基于MVC设计模式实现的</li><li>是目前最流行的MVC框架</li><li>Spring3.0之后，全面超越了Struts2</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>导入jar</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>添加了一个SpringMVC组件配置类</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = "com.neu.controller")public class SpringMVCConfig {}</code></pre></li><li><p>修改了web初始化器</p><p>Servlet 3.0 之后，web容器启动后会调用 META-INF/services/javax.servlet.ServletContainerInitializer文件中的类</p><p>在Tomcat8以上版本支持一个配置启动的东西，意思就是tomcat启动时会自动去扫描所有 jar 中目录为「 META-INF/services/ 」中是否有个名字是「javax.servlet.ServletContainerInitializer」的配置文件，然后根据里面内容反编译启动等等一系列操作</p><img src="/2022/05254780/1.jpg" class=""><p><strong>如上图配置后tomcat启动时就会自动生成HelloServlet了，大概原理就这样，不过SpringMVC已经把上图中的基本配置已经搞定直接使用即可</strong></p><p>在 spring-web的jar包中查看</p><pre><code>org.springframework.web.SpringServletContainerInitializer</code></pre></li></ol><pre><code>   public class WebInitializer implements WebApplicationInitializer {       @Override       public void onStartup(ServletContext servletContext) throws ServletException {           //创建spring容器           AnnotationConfigWebApplicationContext c =                    new AnnotationConfigWebApplicationContext();           //注册配置类           c.register(DBConfig.class);           c.register(MybatisConfig.class);           c.register(MybatisMapperScannerConfig.class);           //把spring容器的引用放到ServletContext           servletContext.addListener(new ContextLoaderListener(c));           //创建SpringMVC组件的容器（子容器，可以访问父容器）           AnnotationConfigWebApplicationContext childContext =                   new AnnotationConfigWebApplicationContext();           childContext.register(SpringMVCConfig.class);           Dynamic servlet = servletContext.addServlet("dispatcher", new DispatcherServlet(childContext));           servlet.addMapping("/");           //在启动web服务器的时候，直接创建这个前端控制器           servlet.setLoadOnStartup(1);       }   }</code></pre><ol><li><p>配置了一个视图解析器</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = "com.neu.controller")public class SpringMVCConfig {    //物理路径：/WEB-INF/jsp/hello.jsp    ///WEB-INF/jsp/hello.jsp    @Bean    public InternalResourceViewResolver viewResolver() {        InternalResourceViewResolver r = new InternalResourceViewResolver();        //设置前缀        r.setPrefix("/WEB-INF/jsp/");        //设置后缀        r.setSuffix(".jsp");        return r;    }}</code></pre></li><li><p>创建业务逻辑控制器和处理器方法</p><pre><code>@Controllerpublic class HelloController {    @RequestMapping("hello")    public String hello() {        System.out.println("hello!");        return "hello";    }}</code></pre></li></ol><h2 id="SpringMVC详细配置"><a href="#SpringMVC详细配置" class="headerlink" title="SpringMVC详细配置"></a>SpringMVC详细配置</h2><ol><li><p>@RequestMapping</p><ul><li><p>既可以添加到类上，也可以添加到处理器方法上</p><ul><li>添加到类上的时候，提供初步的请求映射，路径相对于web应用程序根目录</li><li>添加到方法上，提供进一步的细分映射信息，相对于类定义处的url，若类定义处没有注解，则相对于web应用根目录</li></ul></li><li><p>method：表示能处理的请求方法，默认能处理get和post请求</p><pre><code>@RequestMapping(value="insert",method = {RequestMethod.POST,RequestMethod.GET})    public String insert() {        return "dept/getAll";    }</code></pre></li><li><p>value:指定请求的url，默认属性</p></li><li><p>params:指定请求中必须包含某些请求参数或参数值</p><pre><code>@RequestMapping(value="insert",params = {"deptno=1","dname"})    public String insert() {        return "dept/getAll";    }</code></pre></li></ul></li><li><p>GetMapping:只处理get请求</p></li><li>PostMapping：只处理post请求</li><li>请求参数绑定<ul><li>定义：把请求参数的key/value绑定到处理器方法的形参上，默认形参名与请求参数名相同，就会自动绑定</li><li>@RequestParam：手工映射请求参数<ul><li>value：请求参数名，默认属性</li><li>required：必须的，默认为：true,</li><li>defaultValue:默认值</li></ul></li></ul></li></ol><h2 id="请求参数中文处理"><a href="#请求参数中文处理" class="headerlink" title="请求参数中文处理"></a>请求参数中文处理</h2><ol><li><p>get</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;path&gt;/&lt;/path&gt;        &lt;port&gt;8089&lt;/port&gt;        &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre></li><li><p>post:修改web初始化器</p><pre><code>//注册编码过滤器javax.servlet.FilterRegistration.Dynamic filter             = servletContext.addFilter("charsetFilter", new CharacterEncodingFilter("utf-8"));filter.addMappingForUrlPatterns(null, false, "/*");</code></pre></li></ol><h2 id="日期格式处理"><a href="#日期格式处理" class="headerlink" title="日期格式处理"></a>日期格式处理</h2><ol><li><p>定义了一个转换器</p><pre><code>public class DateConverter implements Converter&lt;String, Date&gt; {    @Override    public Date convert(String source) {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd");        Date date = null;        try {            date = f.parse(source);        } catch (ParseException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return date;    }}</code></pre></li><li><p>注册转换器</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = "com.neu.controller")public class SpringMVCConfig implements WebMvcConfigurer {    @Override    public void addFormatters(FormatterRegistry registry) {        //注册日期转换器                registry.addConverter(new DateConverter());    }}</code></pre><h2 id="跳转到其他请求的方式"><a href="#跳转到其他请求的方式" class="headerlink" title="跳转到其他请求的方式"></a>跳转到其他请求的方式</h2><pre><code>//请求转发//        return "forward:/dept/getAll";//重定向return "redirect:/dept/getAll";</code></pre></li></ol><h2 id="处理器形参"><a href="#处理器形参" class="headerlink" title="处理器形参"></a>处理器形参</h2><ol><li><p>HttpServletRequest</p><pre><code>@Controllerpublic class HelloController {    @RequestMapping("hello")    public String hello(HttpServletRequest request) {        String name = request.getParameter("name");        System.out.println(name);        return "hello";    }}</code></pre></li><li><p>HttpServletResponse</p><pre><code>@Controllerpublic class HelloController {    @RequestMapping("hello")    public void hello(HttpServletRequest request,HttpServletResponse response) throws IOException {        String name = request.getParameter("name");        System.out.println(name);        response.getWriter().append(name);//        return "hello";    }    }</code></pre></li><li><p>HttpSession</p><pre><code>@Controllerpublic class HelloController {    @RequestMapping("/")    public String getLogin() {        return "login";    }    @RequestMapping("login")    public String login(String username,String password,HttpSession session) {        if("admin".equals(username) &amp;&amp; "111".equals(password)) {            session.setAttribute("username", username);            return "forward:/dept/getAll";        }else {            return "redirect:/";        }    }    }</code></pre></li></ol><h2 id="分页：使用Mybatis分页插件"><a href="#分页：使用Mybatis分页插件" class="headerlink" title="分页：使用Mybatis分页插件"></a>分页：使用Mybatis分页插件</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.1.10&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在mybatis配置类中，注册分页插件（拦截器）</p><pre><code>@Configuration@ComponentScan(basePackages = {"com.neu.mapper","com.neu.service","com.neu.utils"})public class MybatisConfig {    @Autowired    private DataSource dataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception {        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();        factory.setDataSource(dataSource);        //创建一个分页拦截器        PageInterceptor interceptor = new PageInterceptor();        Properties prop =factory new Properties();        interceptor.setProperties(prop);        //注册拦截器        factory.setPlugins(new Interceptor[] {interceptor});        return factory.getObject();    }}</code></pre></li><li><p>修改业务逻辑类</p><pre><code>@Override    public PageInfo&lt;Dept&gt; getPaged(int pageNum, int pageSize) {        //分页方法，该方法会拦截该语句后的第一个查询，对该查询进行分页操作        PageHelper.startPage(pageNum, pageSize);        List&lt;Dept&gt; list = deptMapper.getAll();        PageInfo&lt;Dept&gt; pageInfo = new PageInfo&lt;Dept&gt;(list);        return pageInfo;    }</code></pre></li><li><p>控制器</p><pre><code>@RequestMapping("getPaged")    public String getPaged(@RequestParam(defaultValue = "1") int pageNum,@RequestParam(defaultValue = "3") int pageSize,Model model) {        PageInfo&lt;Dept&gt; pageInfo = deptService.getPaged(pageNum, pageSize);        System.out.println(pageInfo);        model.addAttribute("pageInfo", pageInfo);        return "dept/paged";    }</code></pre></li><li><p>jsp</p><pre><code>&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    用户名：${ username }&lt;br&gt;    &lt;a href="${ pageContext.request.contextPath }/dept/getinsertpage"&gt;添加部门&lt;/a&gt;    &lt;form action="${ pageContext.request.contextPath }/dept/batchDelete" method="post"&gt;    &lt;input type="submit" value="批量删除"&gt;    &lt;table border="1" width="900"&gt;        &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;&amp;nbsp;&lt;/th&gt;&lt;th&gt;编号&lt;/th&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;            &lt;/tr&gt;        &lt;/thead&gt;        &lt;tbody&gt;        &lt;c:forEach items="${ pageInfo.list }" var="dept"&gt;        &lt;tr&gt;            &lt;td&gt;                &lt;input type="checkbox" name="deptno" value="${ dept.deptno }"&gt;            &lt;/td&gt;            &lt;td&gt;${ dept.deptno }&lt;/td&gt;            &lt;td&gt;${ dept.dname }&lt;/td&gt;            &lt;td&gt;${ dept.loc }&lt;/td&gt;            &lt;td&gt;                &lt;a href="${ pageContext.request.contextPath }/dept/delete?deptno=${ dept.deptno }"&gt;删除&lt;/a&gt;                &lt;a href="${ pageContext.request.contextPath }/dept/getById?deptno=${ dept.deptno }"&gt;编辑&lt;/a&gt;            &lt;/td&gt;        &lt;/tr&gt;        &lt;/c:forEach&gt;        &lt;/tbody&gt;        &lt;tfoot&gt;            &lt;td colspan="5"&gt;                共${ pageInfo.total }记录                第 ${ pageInfo.pageNum } 页/共${ pageInfo.pages }页                &lt;c:if test="${ !pageInfo.isFirstPage }"&gt;                    &lt;a href="${ pageContext.request.contextPath }/dept/getPaged?pageNum=1&amp;pageSize=${pageInfo.pageSize}"&gt;第一页&lt;/a&gt;                    &lt;a href="${ pageContext.request.contextPath }/dept/getPaged?pageNum=${pageInfo.pageNum-1}&amp;pageSize=${pageInfo.pageSize}"&gt;上一页&lt;/a&gt;                &lt;/c:if&gt;                &lt;c:forEach items="${ pageInfo.navigatepageNums }" var="num"&gt;                    &lt;c:if test="${ num == pageInfo.pageNum }"&gt;                        &lt;a&gt;[${ num }]&lt;/a&gt;                    &lt;/c:if&gt;                    &lt;c:if test="${ num != pageInfo.pageNum }"&gt;                        &lt;a href="${ pageContext.request.contextPath }/dept/getPaged?pageNum=${ num }&amp;pageSize=${pageInfo.pageSize}"&gt;[${ num }]&lt;/a&gt;                    &lt;/c:if&gt;                                    &lt;/c:forEach&gt;                &lt;c:if test="${ pageInfo.hasNextPage }"&gt;                    &lt;a href="${ pageContext.request.contextPath }/dept/getPaged?pageNum=${pageInfo.pageNum+1}&amp;pageSize=${pageInfo.pageSize}"&gt;下一页&lt;/a&gt;                &lt;/c:if&gt;                &lt;c:if test="${ !pageInfo.isLastPage }"&gt;                    &lt;a href="${ pageContext.request.contextPath }/dept/getPaged?pageNum=${pageInfo.navigateLastPage}&amp;pageSize=${pageInfo.pageSize}"&gt;最后一页&lt;/a&gt;                &lt;/c:if&gt;                跳转到&lt;input type="text" style="width:25px;" id="page"&gt;页                &lt;input type="button" value="go" onclick="goPage()"&gt;                &lt;select onchange="changePageSize()" id="pageSize"&gt;                    &lt;option ${ pageInfo.pageSize == 3?"selected":"" }&gt;3&lt;/option&gt;                    &lt;option ${ pageInfo.pageSize == 5?"selected":"" }&gt;5&lt;/option&gt;                    &lt;option ${ pageInfo.pageSize == 10?"selected":"" }&gt;10&lt;/option&gt;                &lt;/select&gt;            &lt;/td&gt;        &lt;/tfoot&gt;    &lt;/table&gt;    &lt;/form&gt;    &lt;script type="text/javascript"&gt;        function goPage(){            //得到文本框的值            var pageNum = document.getElementById("page").value;            //修改地址栏地址            location.href = "${ pageContext.request.contextPath }/dept/getPaged?pageNum="+pageNum;        }        function changePageSize(){            var pageSize = document.getElementById("pageSize").value;            location.href = "${ pageContext.request.contextPath }/dept/getPaged?pageNum=1&amp;pageSize="+pageSize;        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><h2 id="请求参数验证"><a href="#请求参数验证" class="headerlink" title="请求参数验证"></a>请求参数验证</h2><ol><li><p>JSR303是JavaBean数据合法性验证标准框架</p></li><li><p>Hibernate Validator 是JSR303的标准的实现</p></li><li><p>导入包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml&lt;/groupId&gt;    &lt;artifactId&gt;classmate&lt;/artifactId&gt;    &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>在实体类的属性上添加验证注解</p><pre><code>@Data@AllArgsConstructor@NoArgsConstructorpublic class Dept {    @NotNull(message = "部门编号不能为空")    private Integer deptno;    private String dname;    private String loc;}</code></pre></li><li><p>在控制器中的处理器方法的形参前添加@Valid注解</p><pre><code>@RequestMapping("insert")public String insert(@Valid Dept dept,Errors errors,Model model) {    if(errors.hasErrors()) {        model.addAttribute("errorList", errors.getAllErrors());        return "dept/insert";    }    //。。。}</code></pre></li><li><p>jsp页面显示错误消息</p><pre><code>&lt;c:if test="${ !(empty errorList) }"&gt;    &lt;c:forEach items="${ errorList }" var="error"&gt;        ${ error.defaultMessage }&lt;br&gt;    &lt;/c:forEach&gt;        &lt;/c:if&gt;</code></pre></li><li><p>验证注解</p><ul><li>@NotNull：不能为空，能验证任何对象</li><li>@NotBlank：表示注解的属性不能为null和空串，只能验证字符串</li><li>@Size（min=2,max=10,message=””):验证字符串的长度</li><li>@Email：验证邮箱</li><li>@Post():必须是一个过去的日期</li><li>@Futrue：必须是一个未来的日期</li><li>@Min():最小值</li><li>@Max（）：最大值</li><li><code>@Pattern(regexp="^\\d{3,8}$")</code>：使用正则表达式验证</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok</title>
      <link href="/2022/052426635.html"/>
      <url>/2022/052426635.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Lombok项目是一个<a href="https://baike.baidu.com/item/Java/85979">Java</a>库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@<a href="https://baike.baidu.com/item/Data/7096603">Data</a>)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在开发工具中安装lombok插件</li><li>在项目中引入lombok.jar包</li><li>使用lombok注解（生成特定的代码）</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>作用在类上，是以下注解的集合：@ToString、@EqualsAndHashCode、@Getter、@Setter、@RequiredArgsConstructor</p><pre><code>@Data@AllArgsConstructorpublic class Student {    private Integer id;    private String name;    private Integer age;    private String schoolName ;}</code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ol><li>@NoArgsConstructor：生成无参数构造方法</li><li>@AllArgsConstructor：生成全参数的构造方法</li><li>@RequiredArgsConstructor：生成包含final和@NonNull注解成员变量的构造方法</li></ol><pre><code>//@NoArgsConstructor@AllArgsConstructor//生成包含final和@NonNull注解成员变量的构造方法@RequiredArgsConstructorpublic class Student {    @NonNull    private Integer id;    private String name;    private Integer age;    private final String schoolName ;}</code></pre><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><ul><li>这个注解可以用在成员方法或者构造方法的参数前面，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，举个例子来看看：</li></ul><pre><code>//成员方法参数加上@NonNull注解public String getName(@NonNull Person p){    return p.getName();}</code></pre><p>实际效果相当于：</p><pre><code>public String getName(@NonNull Person p){    if(p==null){        throw new NullPointerException("person");    }    return p.getName();}</code></pre><ul><li><p>用在成员变量上面，可以在生成Setter方法和构造方法的时候，检查对应形参是否为空</p><pre><code>@Datapublic class User {    @NonNull    private Integer id;    private String name;    private Integer age;}</code></pre></li></ul><h3 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter"></a>@Getter/@Setter</h3><ul><li><p>作用在类上，生成所有成员变量的getter/setter方法</p></li><li><p>作用在成员变量上，生成该成员变量的getter/setter方法</p></li><li><p>可以设定访问权限</p></li></ul><pre><code>@Setter@Getter(value = AccessLevel.PROTECTED)public class Student {    private Integer id;    private String name;    private Integer age;    }</code></pre><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>作用在类上，覆盖默认的toString()方法，可以通过 of 属性限定显示某些字段，通过 exclude 属性排除某些字段</p><pre><code>@ToString(exclude = {"age"},of = {"id","name"})public class Student {    private Integer id;    private String name;    private Integer age;    }</code></pre><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>作用在类上，覆盖默认的equals和hashCode方法，可以通过 of 属性限定比较某些字段，通过 exclude 属性排除某些字段</p><pre><code>@EqualsAndHashCode(of = {"id"})public class Student {    private Integer id;    private String name;    private Integer age;    }</code></pre><h2 id="Lombok实现原理"><a href="#Lombok实现原理" class="headerlink" title="Lombok实现原理"></a>Lombok实现原理</h2><p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”（插件化注解处理API）规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p><p>Lombok就是一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p><hr><ol><li><p>javac对源代码进行分析，生成一棵抽象语法树(AST)</p></li><li><p>javac编译过程中调用实现了JSR 269的Lombok程序</p></li><li><p>此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树    (AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</p></li><li><p>javac使用修改后的抽象语法树(AST)生成字节码文件</p></li></ol><h2 id="Eclipse安装Lombok插件"><a href="#Eclipse安装Lombok插件" class="headerlink" title="Eclipse安装Lombok插件"></a>Eclipse安装Lombok插件</h2><p>1、下载lombok.jar，lombok.jar官方下载地址：<a href="https://projectlombok.org/download">https://projectlombok.org/download</a></p><p>2、双击下载好的lombak.jar，安装步骤如下：</p><p>2-1.关闭弹出的警告窗口，点击 Specify location..</p> <img src="/2022/052426635/1.jpg" class=""><p>2-2.选择eclipse的安装目录（确保该路径中不能有中文）</p> <img src="/2022/052426635/2.jpg" class=""><p>2-3.点击Install / Update</p> <img src="/2022/052426635/3.jpg" class=""><p>2-4.点击Quit Installer，完成安装</p> <img src="/2022/052426635/4.jpg" class=""><p>3、安装完成之后，请确认eclipse安装路径下是否多了一个lombok.jar包，并且其<br>   配置文件eclipse.ini中是否 添加了如下内容:-javaagent:D:\build-env\eclipse\lombok.jar</p> <img src="/2022/052426635/5.jpg" class=""> <img src="/2022/052426635/6.jpg" class=""><p>4、重启eclipse或myeclipse</p><p>5、测试，建立如下类：</p><p>import lombok.Data;  </p><p>@Data<br>public class DataObject {<br>   private String id;<br>   private String name;<br>   private String userId;<br>   private String password;<br>}<br>备注：如过安装成功但是@Data等注解无效，可能是由于你的eclipse版本是新版本，你的lombok.jar版本太旧。那么请下载最新的lombok.jar再进行安装。</p><p>6、lombok注解介绍请参看：<a href="http://blog.csdn.net/sunsfan/article/details/53542374">http://blog.csdn.net/sunsfan/article/details/53542374</a></p>]]></content>
      
      
      <categories>
          
          <category> Lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2022/052313919.html"/>
      <url>/2022/052313919.html</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>软件的半成品</p><h2 id="Mybatis概述"><a href="#Mybatis概述" class="headerlink" title="Mybatis概述"></a>Mybatis概述</h2><p>是一个持久层框架，使用sql语句将实体类映射到数据表，是一个半自动的ORM实现</p><p>O：对象</p><p>R：关系型数据库</p><p>M：映射（自动映射）</p><p>Hibernate：全自动的ORM实现</p><p>SSH：Struts2、Spring，Hibernate</p><p>SSM：SpringMVC、Spring、MyBatis</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>最早是apache的一个开源项目iBatis，2010年更名为mybatis</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>外部化sql语句：把sql语句与java代码分离</p><p>封装化sql语句：把sql语句封装到单独的文件总，方便管理</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>创建一个maven项目</p></li><li><p>配置 pom.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;org.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;                    &lt;/plugins&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li><li><p>在resources目录下，添加SqlMapConfig.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置一个环境，一个环境对应着一个数据库，default为某一个环境的id --&gt;    &lt;environments default="mysql"&gt;        &lt;environment id="mysql"&gt;            &lt;!-- 事务管理器，jdbc/managed(由外部容器管理，自己什么也不做) --&gt;            &lt;transactionManager type="jdbc"&gt;&lt;/transactionManager&gt;            &lt;!-- 数据源，unpooled、pooled、jndi --&gt;            &lt;dataSource type="pooled"&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"/&gt;                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="root"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;package name="com.neu.mapper"&gt;&lt;/package&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li><li><p>Mapper映射文件</p><ul><li><p>编写实体类</p></li><li><p>创建一个包：com.neu.mapper</p></li><li><p>在Mapper包下，创建接口：DeptMapper，在该接口中添加增删改查的方法</p></li><li><p>使用mybatis mapper向导，生成接口的配置映射文件：配置文件的名与接口名相同</p></li><li><p>在生成的映射文件中（DeptMapper.xml）,namespace的名称为对应的接口的完全限定名（包名+接口名）</p></li><li><p>statement的id与接口中的方法名相同</p></li><li><p>如果statement为select类型，必须添加一个 resultType 或 resultMap 属性，resultType的值必须为方法返回值中实体类型名</p></li><li><p>注册 mapper（SqlMapConfig.xml）</p><pre><code>&lt;mappers&gt;        &lt;!-- &lt;mapper resource="com/neu/mapper/DeptMapper.xml" /&gt;     --&gt;        &lt;!-- &lt;mapper class="com.neu.mapper.DeptMapper"/&gt; --&gt;        &lt;package name="com.neu.mapper"&gt;&lt;/package&gt;&lt;/mappers&gt;</code></pre></li></ul></li><li><p>改进后的测试代码</p><pre><code>package com.neu.test;import java.io.IOException;import java.io.InputStream;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.neu.mapper.DeptMapper;import com.neu.po.Dept;public class DeptMapperTest {    private DeptMapper deptMapper;    private SqlSession sqlSession;    @Before    public void setup() throws IOException {        //读取SqlMapConfig.xml文件        InputStream resource = Resources.getResourceAsStream("SqlMapConfig.xml");        //创建SqlSessionFactory        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource);        //得到Sqlsession对象（相当于数据库连接）        sqlSession = sqlSessionFactory.openSession();        //得到DeptMapper接口的实现类        deptMapper = sqlSession.getMapper(DeptMapper.class);    }    @After    public void after() {        //关闭sqlSession，把连接放回到连接池        sqlSession.close();    }    @Test    public void testInsert() throws IOException {                int n = deptMapper.insert(new Dept(66,"hr","sy"));        System.out.println(n);        //提交事务        sqlSession.commit();            }    @Test    public void testUpdate() throws IOException {            int n = deptMapper.update(new Dept(66,"hr","nj"));        System.out.println(n);        //提交事务        sqlSession.commit();            }    @Test    public void testDelete() throws IOException {            int n = deptMapper.delete(66);        System.out.println(n);        //提交事务        sqlSession.commit();            }    @Test    public void testGetById() throws IOException {            Dept dept = deptMapper.getById(10);        System.out.println(dept);                }    @Test    public void testGetAll() throws IOException {            List&lt;Dept&gt; list = deptMapper.getAll();        System.out.println(list);                }}</code></pre></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>实现 Emp 的增删改查方法</p><h2 id="使用log4j生成日志"><a href="#使用log4j生成日志" class="headerlink" title="使用log4j生成日志"></a>使用log4j生成日志</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>&lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>拷贝log4j.properties配置文件到resources下</p><pre><code># Global logging configuration#\u751F\u4EA7\u73AF\u5883\u914D\u7F6Einfo   ERRORlog4j.rootLogger=DEBUG,stdout# MyBatis logging configuration...log4j.logger.org.mybatis.example.BlogMapper=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n</code></pre><h2 id="多参数的处理"><a href="#多参数的处理" class="headerlink" title="多参数的处理"></a>多参数的处理</h2><ol><li><p>使用参数名：arg0、arg1…</p><pre><code>&lt;select id="search" resultType="com.neu.po.Dept"&gt;        select * from dept where dname = #{arg0} and loc = #{arg1}&lt;/select&gt;</code></pre></li><li><p>使用参数名：param1、param2</p><pre><code>&lt;select id="search" resultType="com.neu.po.Dept"&gt;        select * from dept where dname = #{param1} and loc = #{param2}&lt;/select&gt;</code></pre></li><li><p>使用@Param注解（推荐）</p><pre><code>接口：List&lt;Dept&gt; search(@Param("dname") String dname,@Param("loc") String loc);mapper:select * from dept where dname = #{dname} and loc = #{loc}</code></pre></li><li><p>使用实体类封装多个参数</p><pre><code>接口：List&lt;Dept&gt; search2(Dept dept);mapper:select * from dept where dname = #{dname} and loc = #{loc}测试代码：List&lt;Dept&gt; list = deptMapper.search2(new Dept(null,"hr","sy"));</code></pre></li><li><p>使用map集合，封装多个参数（很灵活）</p><pre><code>接口：List&lt;Dept&gt; search3(Map&lt;String, String&gt; map);mapper：select * from dept where dname = #{dname} and loc = #{loc}测试代码：Map map = new HashMap&lt;&gt;();map.put("dname", "hr");map.put("loc", "sy");List&lt;Dept&gt; list = deptMapper.search3(map);</code></pre></li></ol><h2 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h2><ol><li><h1 id="使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用"><a href="#使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用" class="headerlink" title="{}:使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用"></a>{}:使用占位符的方式生成sql语句，sql语句中列名为变量的时候，不能使用</h1></li><li><p>${}:使用拼接字符串的方式生成sql语句，参数为列名的时候，可以使用</p><pre><code>接口：//根据参数列名来排序List&lt;Dept&gt; order(String columnName);mapper:select * from dept order by ${columnName}</code></pre></li><li><p>模糊查询</p><ul><li><p>使用#{}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like #{dname}测试代码：List&lt;Dept&gt; list = deptMapper.search4("%h%");</code></pre></li><li><p>使用${}</p><pre><code>接口：List&lt;Dept&gt; search4(String dname);mapper:select * from dept where dname like '%${dname}%'测试代码：List&lt;Dept&gt; list = deptMapper.search4("h");</code></pre></li></ul></li></ol><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><ol><li><p><code>&lt;if test="表达式"&gt;sql片段&lt;/if&gt;</code></p><p>当表达式为true的时候，输出sql片段，否则不输出</p><pre><code>List&lt;Dept&gt; find(Dept dept);mapper:&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         where 1 = 1        &lt;if test="deptno != null"&gt;            and deptno = #{deptno}        &lt;/if&gt;        &lt;if test="dname != null"&gt;            and dname = #{dname}        &lt;/if&gt;        &lt;if test="loc != null"&gt;            and loc = #{loc}        &lt;/if&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;trim prefix="前缀" prefixOverrides="被覆盖的前缀" suffixOverrides="被覆盖的后缀"&gt;&lt;/trim&gt;</code></p><p>prefix:如果trim标签中内容不为空串，则添加该前缀，如果内容为空串，则不添加</p><p>prefixOverrides：如果trim标签内容最前面的部分是该属性的内容，则覆盖掉</p><p>suffixOverrides：如果trim标签内容最后面的部分是该属性的内容，则覆盖掉</p><pre><code>&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         &lt;trim prefix="where" prefixOverrides="and"&gt;            &lt;if test="deptno != null"&gt;                and deptno = #{deptno}            &lt;/if&gt;            &lt;if test="dname != null"&gt;                and dname = #{dname}            &lt;/if&gt;            &lt;if test="loc != null"&gt;                and loc = #{loc}            &lt;/if&gt;        &lt;/trim&gt;&lt;/select&gt;&lt;update id="update2"&gt;        update dept         &lt;trim prefix="set" suffixOverrides=","&gt;            &lt;if test="dname != null" &gt;                dname = #{dname},            &lt;/if&gt;            &lt;if test="loc != null" &gt;                loc = #{loc}            &lt;/if&gt;        &lt;/trim&gt;        where deptno = #{deptno}    &lt;/update&gt;</code></pre></li><li><p><code>&lt;where&gt;&lt;/where&gt;</code>，相当于：<code>&lt;trim prefix="where" prefixOverrides="and"&gt;</code></p><pre><code>&lt;select id="find" resultType="com.neu.po.Dept"&gt;        select * from dept         &lt;where&gt;            &lt;if test="deptno != null"&gt;                and deptno = #{deptno}            &lt;/if&gt;            &lt;if test="dname != null"&gt;                and dname = #{dname}            &lt;/if&gt;            &lt;if test="loc != null"&gt;                and loc = #{loc}            &lt;/if&gt;        &lt;/where&gt;&lt;/select&gt;</code></pre></li><li><p><code>&lt;set&gt;&lt;/set&gt;</code>相当于：<code>&lt;trim prefix="set" suffixOverrides=","&gt;</code></p><pre><code>&lt;update id="update2"&gt;        update dept         &lt;set&gt;            &lt;if test="dname != null" &gt;                dname = #{dname},            &lt;/if&gt;            &lt;if test="loc != null" &gt;                loc = #{loc}            &lt;/if&gt;        &lt;/set&gt;        where deptno = #{deptno}&lt;/update&gt;</code></pre></li><li><p><code>&lt;foreach&gt;&lt;/foreach&gt;</code>:用来处理集合和数组</p><p>collection：list|conllection|array</p><p>item：引用集合或数组中的当前遍历元素</p><p>separator:分隔符</p><pre><code>接口：int batchInsert(List&lt;Dept&gt; list);mapper:&lt;insert id="batchInsert"&gt;        insert into dept values        &lt;foreach collection="list" item="dept" separator=","&gt;            (#{dept.deptno},#{dept.dname},#{dept.loc})        &lt;/foreach&gt;&lt;/insert&gt;</code></pre><p>open:要添加的开始字符串</p><p>close：要添加的结束字符串</p><pre><code>接口：int batchDelete（int[] ids）;mapper:&lt;delete id="batchDelete"&gt;        delete from dept where deptno in        &lt;foreach collection="array" item="deptno" separator="," open="(" close=")"&gt;            #{deptno}        &lt;/foreach&gt;&lt;/delete&gt;</code></pre><p>练习：编写Emp的动态sql</p></li></ol><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ol><li><p>定义：用来定义可以重复使用的sql代码段，可以包含在其他sql语句中</p></li><li><p>使用：</p><ul><li><p>定义sql片段</p><pre><code>&lt;sql id="selectAll"&gt;    select * from dept&lt;/sql&gt;</code></pre></li><li><p>引用sql片段</p><pre><code>&lt;include refid="selectAll"&gt;&lt;/include&gt;</code></pre></li></ul></li></ol><h2 id="得到插入的主键值"><a href="#得到插入的主键值" class="headerlink" title="得到插入的主键值"></a>得到插入的主键值</h2><p><code>&lt;selectKey&gt;</code>:</p><ul><li><p>order:决定了查询语句执行的先后</p><ul><li>after：先执行插入语句，后执行查询主键的sql语句（mysql）</li><li>before：先执行查询（生成）主键值的语句，再执行插入语句（oracle）</li></ul></li><li><p>keyProperty：键属性名，查询得到的主键值放到形参的哪个属性中</p></li><li>resultType：查询的主键值的类型</li></ul><p>使用：</p><pre><code>&lt;insert id="insert"&gt;        &lt;selectKey order="AFTER" keyProperty="deptno" resultType="int"&gt;            select last_insert_id()        &lt;/selectKey&gt;        insert into dept values(null,#{dname},#{loc})&lt;/insert&gt;</code></pre><h2 id="查询返回简单数据类型"><a href="#查询返回简单数据类型" class="headerlink" title="查询返回简单数据类型"></a>查询返回简单数据类型</h2><p>简单数据类型：基本数据类型（8种）、对应的包装类、String</p><pre><code>接口：//根据部门编号得到部门名称String getDname(int deptno);mapper:&lt;select id="getDname" resultType="string"&gt;        select dname from dept where deptno = #{deptno}&lt;/select&gt;</code></pre><pre><code>//得到部门总数int count();&lt;select id="count" resultType="int"&gt;    select count(*) from dept&lt;/select&gt;</code></pre><p>返回boolean类型：如果查询的记录数&gt;0,返回：true，等于0，返回：false</p><pre><code>//判断名称为参数执行的部门是否存在boolean exist(String dname);&lt;select id="exist" resultType="boolean"&gt;    select count(*) from dept where dname = #{dname}&lt;/select&gt;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code>//pageNum:第几页，pageSize：每页最多有多少行List&lt;Dept&gt; getPaged(@Param("pageNum") int pageNum,@Param("pageSize") int pageSize);&lt;select id="getPaged" resultType="com.neu.po.Dept"&gt;    select * from dept     limit ${(pageNum - 1) * pageSize},#{pageSize}&lt;/select&gt;</code></pre><h2 id="列名与属性名不一致"><a href="#列名与属性名不一致" class="headerlink" title="列名与属性名不一致"></a>列名与属性名不一致</h2><ol><li><p>在sql语句中，为列起别名，别名与属性名一致</p><pre><code>select deptno,dname dname2,loc from dept</code></pre></li><li><p>使用<code>&lt;resultMap&gt;</code>来进行映射</p><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;!-- &lt;id column="deptno" property="deptno"/&gt; --&gt;        &lt;result column="dname" property="dname2"/&gt;        &lt;!-- &lt;result column="loc" property="loc"/&gt; --&gt;&lt;/resultMap&gt;&lt;select id="getById" resultMap="basicMap"&gt;        &lt;include refid="selectAll"&gt;&lt;/include&gt; where deptno = #{no}&lt;/select&gt;</code></pre><p><code>&lt;id&gt;</code>:用来映射标识列（数据库中的主键）</p><p><code>&lt;result&gt;</code>：用来映射普通的结果（非主键）</p><p>column：列名</p><p>property：属性名</p></li></ol><h2 id="实体关联"><a href="#实体关联" class="headerlink" title="实体关联"></a>实体关联</h2><p><code>&lt;association&gt;</code>:关联（实体），表示一对一的关系（emp=》dept）</p><pre><code>//Emp实体类...Dept dept;</code></pre><pre><code>mapper:&lt;mapper namespace="com.neu.mapper.EmpMapper"&gt;    &lt;resultMap type="com.neu.po.Emp" id="basicMap"&gt;        &lt;id column="empno" property="empno" &gt;&lt;/id&gt;        &lt;result column="ename" property="ename"/&gt;        &lt;result column="job" property="job"/&gt;        &lt;result column="hiredate" property="hiredate"/&gt;        &lt;result column="sal" property="sal"/&gt;        &lt;result column="mgr" property="mgr"/&gt;        &lt;result column="comm" property="comm"/&gt;        &lt;association property="dept" javaType="com.neu.po.Dept"&gt;            &lt;id column="deptno" property="deptno"/&gt;            &lt;result column="dname" property="dname2"/&gt;            &lt;result column="loc" property="loc"/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        SELECT e.*,dname,loc         FROM dept d JOIN emp e         ON d.deptno = e.deptno        where empno = #{empno}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;id column="deptno" property="deptno" /&gt;        &lt;result column="dname" property="dname1"/&gt;        &lt;result column="loc" property="loc"/&gt;        &lt;collection property="emps" ofType="com.neu.po.Emp"&gt;            &lt;id column="empno" property="empno"/&gt;            &lt;id column="ename" property="ename"/&gt;            &lt;id column="job" property="job"/&gt;            &lt;id column="hiredate" property="hiredate"/&gt;            &lt;id column="sal" property="sal"/&gt;            &lt;id column="comm" property="comm"/&gt;            &lt;id column="mgr" property="mgr"/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        select d.dname,d.loc,e.* from dept d left join emp e         on d.deptno = e.deptno          WHERE e.deptno = #{deptno}    &lt;/select&gt;</code></pre><p>实体关联的第二种实现方法：再执行一次查询，根据已有的列查询出需要的对象</p><pre><code>&lt;mapper namespace="com.neu.mapper.EmpMapper"&gt;    &lt;resultMap type="com.neu.po.Emp" id="basicMap"&gt;                &lt;!-- column的值为emp表中的列名 --&gt;        &lt;association property="dept" column="deptno" select="com.neu.mapper.DeptMapper.getById"&gt;                    &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id="getById" resultMap="basicMap"&gt;        SELECT * FROM emp where empno = #{empno}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="关联集合"><a href="#关联集合" class="headerlink" title="关联集合"></a>关联集合</h2><p><code>&lt;collection&gt;</code>:关联集合，表示一对多的关系（dept=》List<emp>）</emp></p><pre><code>&lt;resultMap type="com.neu.po.Dept" id="basicMap"&gt;        &lt;id column="deptno" property="deptno"/&gt;        &lt;result column="dname" property="dname2"/&gt;        &lt;!-- &lt;result column="loc" property="loc"/&gt; --&gt;        &lt;!-- column列的值为：Dept表中的deptno --&gt;        &lt;collection property="emps" column="deptno" select="com.neu.mapper.EmpMapper.getByDeptno"&gt;&lt;/collection&gt;&lt;/resultMap&gt;</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><pre><code>CREATE TABLE role(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL) CHARSET=utf8;INSERT INTO role VALUES(1,'管理员');INSERT INTO role VALUES(2,'普通用户');CREATE TABLE myuser(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(30) NOT NULL,    roleId INT NOT NULL) CHARSET=utf8;INSERT INTO myuser VALUES(1,'tom',1);INSERT INTO myuser VALUES(2,'scott',2);INSERT INTO myuser VALUES(3,'marry',2);</code></pre><p>功能：</p><ol><li>查询所有用户的信息（包括用户的角色信息）</li><li>根据角色名称查询该角色的信息及该角色下的所有用户信息</li></ol><h2 id="使用注解替代Mapper文件"><a href="#使用注解替代Mapper文件" class="headerlink" title="使用注解替代Mapper文件"></a>使用注解替代Mapper文件</h2><ol><li><p>使用注解</p><pre><code>@Update("update dept set dname = #{dname2} ,loc = #{loc} where deptno = #{deptno}")int update(Dept dept);</code></pre></li><li><p>长sql语句的写法</p><pre><code>@Update("update dept set dname = #{dname2} ,loc = #{loc} "+        "where deptno = #{deptno}")int update(Dept dept);@Update({"update dept set dname = #{dname2} ,loc = #{loc} ",          "where deptno = #{deptno}"})int update(Dept dept);</code></pre></li><li><p>ResultMap（mybatis 3.5.4）</p><pre><code>@Select("select * from dept where deptno = #{deptno}")@Results(id = "basicMap",value= {            @Result(column = "deptno",property = "deptno",id = true),            @Result(column = "dname",property = "dname2",id = false),            @Result(column = "loc",property = "loc",id = false),            @Result(column = "deptno",property = "emps",many=@Many(select = "com.neu.mapper.EmpMapper.getByDeptno"))    })Dept getById(int deptno);</code></pre></li></ol><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ol><li><p>定义：在数据与对象进行mapping操作时，只有在真正使用该对象的时候，才进行mapping操作，以减少数据库开销，从而提高系统性能</p></li><li><p>默认情况下，mybatis没有开启延迟加载功能，如果要开启，需要配置SqlMapConfig.xml文件</p><pre><code>&lt;settings&gt;        &lt;!-- 开启延迟加载 --&gt;        &lt;setting name="lazyLoadingEnabled" value="true"/&gt;        &lt;!-- 取消积极加载 --&gt;        &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt;</code></pre></li></ol><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li><p>定义：是一种“以空间换时间”的设计理念，利用内存或硬盘空间来提高数据检索速度的有效手段之一。</p></li><li><p>一级缓存：默认开启，把数据缓存到当前会话中（SqlSession）</p><pre><code>@Testpublic void testGetById() throws IOException {        Dept dept = deptMapper.getById(10);    System.out.println(dept.getDname2());    dept = deptMapper.getById(10);    System.out.println(dept.getDname2());}</code></pre></li><li><p>二级缓存：默认没有开启，需要手工开启，修改SqlMapConfig.xml文件，把数据缓存到SqlSessionFactory中</p><pre><code>&lt;!-- 开启二级缓存 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt;</code></pre><p>在需要缓存的mapper文件中：</p><pre><code>&lt;cache&gt;&lt;/cache&gt;</code></pre><p>注意：缓存对象要实现可序列化接口（Serializable）</p></li></ol><h2 id="MBG"><a href="#MBG" class="headerlink" title="MBG"></a>MBG</h2><ol><li><p>定义：是一个MyBatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;  &lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;    &lt;jdbcConnection connectionURL="jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=utf8" driverClass="com.mysql.jdbc.Driver" password="root" userId="root" /&gt;    &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="mybatisdemo2" /&gt;    &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="mybatisdemo2"&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="mybatisdemo2" type="XMLMAPPER" /&gt;       &lt;table schema="root" tableName="dept"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li></ul></li></ol><p>排序：</p><pre><code>example.setOrderByClause("ename desc");</code></pre><h2 id="Example练习"><a href="#Example练习" class="headerlink" title="Example练习"></a>Example练习</h2><ol><li>查询员工姓名等于“smith”并且sal大于等于3000的员工信息</li><li>查询员工编号为：7783和7876的员工信息</li><li>查询奖金（comm）不是null的所有员工信息</li><li>更新员工编号为7783的薪水，薪水增加200元</li><li>查询工资小于2000元或部门编号为10的所有员工信息</li><li>根据部门名称查询该部门所有员工（组合DeptExample和EmpExample查询）</li></ol><h2 id="Idea-中使用-Free-mybatis-plugin"><a href="#Idea-中使用-Free-mybatis-plugin" class="headerlink" title="Idea 中使用 Free mybatis plugin"></a>Idea 中使用 Free mybatis plugin</h2><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><ol><li><p>在idea中连接数据库</p><ul><li><p>添加数据源，选mysql</p><img src="/2022/052313919/1.jpg" class=""></li><li><p>配置数据库连接参数</p><img src="/2022/052313919/2.jpg" class=""></li><li><p>在Advanced 中 配置 serverTimezone：Asia/Shanghai</p><img src="/2022/052313919/3.jpg" class=""></li><li><p>测试连接</p><img src="/2022/052313919/4.jpg" class=""></li><li><p>查看数据表</p><img src="/2022/052313919/5.jpg" class=""></li></ul></li></ol><h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><ol><li><p>选择表</p><img src="/2022/052313919/6.jpg" class=""></li><li><p>输入参数</p><img src="/2022/052313919/7.jpg" class=""></li></ol><h2 id="Idea环境中pom-xml"><a href="#Idea环境中pom-xml" class="headerlink" title="Idea环境中pom.xml"></a>Idea环境中pom.xml</h2><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;maven-demo3&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;!--&lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;--&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;        &lt;!--&lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;/resource&gt;        &lt;/resources&gt;--&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.18.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j&lt;/artifactId&gt;            &lt;version&gt;1.2.17&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h2 id="Idea中代码生成"><a href="#Idea中代码生成" class="headerlink" title="Idea中代码生成"></a>Idea中代码生成</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>创建 maven 项目，导入依赖和插件</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.neu&lt;/groupId&gt;    &lt;artifactId&gt;mbgdemo&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--&lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.22&lt;/version&gt;        &lt;/dependency&gt;--&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;!--mybatis-generator插件--&gt;            &lt;plugin&gt;                &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                    &lt;configurationFile&gt;src/main/resources/generatorConfig.xml&lt;/configurationFile&gt;                    &lt;verbose&gt;true&lt;/verbose&gt;                    &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;/configuration&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                        &lt;version&gt;1.3.2&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></li><li><p>在 src/main/resources/ 创建文件：generatorConfig.xml</p><p>```<br>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE generatorConfiguration PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN” “<a href="http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;>">http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</a><br><generatorconfiguration><br>  <classpathentry location="D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar"><br>  <context id="context1" targetruntime="Mybatis3"></context></classpathentry></generatorconfiguration></p><pre><code>&lt;jdbcConnection     connectionURL="jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"     driverClass="com.mysql.cj.jdbc.Driver"     password="root"     userId="root" &gt;    &lt;property name="nullCatalogMeansCurrent" value="true"/&gt;&lt;/jdbcConnection&gt;&lt;!-- 实体类 --&gt;&lt;javaModelGenerator targetPackage="com.neu.po" targetProject="src/main/java" /&gt;&lt;!-- 生成Mapper.xml --&gt;&lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="src/main/resources"&gt;&lt;/sqlMapGenerator&gt;&lt;!-- java的Mapper接口 --&gt;&lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="src/main/java" type="XMLMAPPER" /&gt;</code></pre></li></ol><pre><code>   &lt;table schema="root" tableName="role"&gt;       &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;         &lt;/table&gt;     &lt;!--     &lt;table schema="root" tableName="user"&gt;         &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;         &lt;columnOverride column="useType" property="role" javaType="Role" /&gt;     &lt;/table&gt;     --&gt;   &lt;!--&lt;table schema="root" tableName="Department" domainObjectName="Department"&gt;       &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;         &lt;columnOverride column="DeptCode" property="deptCode"&gt;&lt;/columnOverride&gt;       &lt;columnOverride column="DeptName" property="deptName"&gt;&lt;/columnOverride&gt;       &lt;columnOverride column="DeptCategoryID" property="deptCategory" javaType="ConstantItem"&gt;&lt;/columnOverride&gt;       &lt;columnOverride column="DeptType" property="deptType" javaType="ConstantItem"&gt;&lt;/columnOverride&gt;       &lt;columnOverride column="DelMark" property="delMark"&gt;&lt;/columnOverride&gt;   &lt;/table&gt;--&gt; &lt;/context&gt;</code></pre><p>   &lt;/generatorConfiguration&gt;</p><pre><code>3. 生成代码   {% asset_img 8.jpg  %}### 方法二1. 使用 `MyBatisCodeHelpPro` 插件，生成 xml配置文件   {% asset_img 9.jpg  %}2. 修改 xml 配置文件，内容同方法一一样</code></pre><p>   &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>   &lt;!DOCTYPE generatorConfiguration<br>       PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN”<br>       “<a href="http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;>">http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</a></p><p>   <generatorconfiguration><br>       <classpathentry location="D:\mavenrepository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar"></classpathentry></generatorconfiguration></p><pre><code>   &lt;context id="Mybatis3Context" targetRuntime="MyBatis3"&gt;       &lt;property name="javaFileEncoding" value="UTF-8"/&gt;       &lt;jdbcConnection               connectionURL="jdbc:mysql://localhost:3306/his_java15?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;serverTimezone=Asia/Shanghai"               driverClass="com.mysql.cj.jdbc.Driver"               password="root"               userId="root" &gt;           &lt;property name="nullCatalogMeansCurrent" value="true"/&gt;       &lt;/jdbcConnection&gt;       &lt;javaTypeResolver&gt;           &lt;property name="forceBigDecimals" value="false"/&gt;       &lt;/javaTypeResolver&gt;       &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="src/main/java"&gt;           &lt;property name="enableSubPackages" value="true"/&gt;           &lt;property name="trimStrings" value="true"/&gt;       &lt;/javaModelGenerator&gt;       &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="src/main/resources"&gt;           &lt;property name="enableSubPackages" value="true"/&gt;       &lt;/sqlMapGenerator&gt;       &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.neu.mapper" targetProject="src/main/java"&gt;           &lt;property name="enableSubPackages" value="true"/&gt;       &lt;/javaClientGenerator&gt;       &lt;table schema="root" tableName="role"&gt;           &lt;generatedKey column="id" sqlStatement="mysql" identity="true"/&gt;       &lt;/table&gt;   &lt;/context&gt;</code></pre><p>   &lt;/generatorConfiguration&gt;</p><pre><code>3. 修改 pom.xml文件，添加 maven 插件</code></pre><p>   &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>   <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>       <modelversion>4.0.0</modelversion></project></p><pre><code>   &lt;groupId&gt;com.neu&lt;/groupId&gt;   &lt;artifactId&gt;mgb2&lt;/artifactId&gt;   &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   &lt;build&gt;       &lt;plugins&gt;           &lt;!--mybatis-generator插件--&gt;           &lt;plugin&gt;               &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;               &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;               &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;               &lt;version&gt;1.3.2&lt;/version&gt;               &lt;configuration&gt;                   &lt;!--配置文件的位置  一定要改成配置文件的位置--&gt;                   &lt;configurationFile&gt;src/main/resources/MybatisGenerator.xml&lt;/configurationFile&gt;                   &lt;verbose&gt;true&lt;/verbose&gt;                   &lt;overwrite&gt;true&lt;/overwrite&gt;               &lt;/configuration&gt;               &lt;executions&gt;                   &lt;execution&gt;                       &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;                       &lt;goals&gt;                           &lt;goal&gt;generate&lt;/goal&gt;                       &lt;/goals&gt;                   &lt;/execution&gt;               &lt;/executions&gt;               &lt;dependencies&gt;                   &lt;dependency&gt;                       &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;                       &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;                       &lt;version&gt;1.3.2&lt;/version&gt;                   &lt;/dependency&gt;               &lt;/dependencies&gt;           &lt;/plugin&gt;       &lt;/plugins&gt;   &lt;/build&gt;</code></pre><p>   &lt;/project&gt;</p><pre><code>4. 生成代码（同方法一）# Idea中生成Mapper1. 在 mapper 接口上 alt + enter   {% asset_img 10.jpg  %}2. 选择：Generate mapper of xml3. 选择mapper 位置   {% asset_img 11.jpg  %}# MyBatis中TypeHandler在Mybatis中可以定义一个TypeHandler类型，通过它可以实现Java类型跟数据库类型的相互转换。需求：把java实体类中的String[],转换为数据库中的varchar类型（例如保存用户的多个爱好）　1. 数据库</code></pre><p>   CREATE TABLE myuser(<br>       id INT PRIMARY KEY AUTO_INCREMENT,<br>       username VARCHAR(30) NOT NULL,<br>       PASSWORD VARCHAR(30) NOT NULL,<br>       interests VARCHAR(100)<br>   )</p><pre><code>2. 实体类</code></pre><p>   @Data<br>   @AllArgsConstructor<br>   @NoArgsConstructor<br>   public class MyUser {<br>       private int id;<br>       private String username;<br>       private String password;<br>       private String[] interests;<br>   }</p><pre><code>3. 类型转换器</code></pre><p>   package com.neu.util;</p><p>   import java.sql.CallableStatement;<br>   import java.sql.PreparedStatement;<br>   import java.sql.ResultSet;<br>   import java.sql.SQLException;<br>   import java.util.Date;</p><p>   import org.apache.ibatis.type.BaseTypeHandler;<br>   import org.apache.ibatis.type.JdbcType;<br>   import org.apache.ibatis.type.MappedJdbcTypes;<br>   import org.apache.ibatis.type.MappedTypes;</p><p>   @MappedJdbcTypes(JdbcType.VARCHAR)<br>   @MappedTypes(String[].class)<br>   public class StringArrayTypeHandler extends BaseTypeHandler<string[]> {</string[]></p><pre><code>   private String[] getStringArray(String columnValue) {      if (columnValue == null)          return null;      return columnValue.split(",");   }   @Override   public String[] getNullableResult(ResultSet rs, String columnName)          throws SQLException {      return getStringArray(rs.getString(columnName));   }   @Override   public String[] getNullableResult(ResultSet rs, int columnIndex)          throws SQLException {      return this.getStringArray(rs.getString(columnIndex));   }   @Override   public String[] getNullableResult(CallableStatement cs, int columnIndex)          throws SQLException {      return this.getStringArray(cs.getString(columnIndex));   }   @Override   public void setNonNullParameter(PreparedStatement ps, int i,          String[] parameter, JdbcType jdbcType) throws SQLException {      //由于BaseTypeHandler中已经把parameter为null的情况做了处理，所以这里我们就不用再判断parameter是否为空了，直接用就可以了      StringBuffer result = new StringBuffer();      for (String value : parameter)          result.append(value).append(",");      result.deleteCharAt(result.length()-1);      ps.setString(i, result.toString());   }</code></pre><p>   }</p><pre><code>   1.@MappedJdbcTypes定义是JdbcType类型，必须要是枚举类org.apache.ibatis.type.JdbcType所枚举的数据类型   2.@MappedTypes定义的是JavaType的数据类型，描述哪些Java类型可被拦截。    3.在我们启用了自定义的这个TypeHandler之后，数据的读写都会被这个类所过滤    4.在setNonNullParameter方法中，重新定义要写往数据库的数据。    5.在另外三个方法中我们将从数据库读出的数据类型进行转换。4. 注册 TypeHandler（SqlMapConfig.xml）</code></pre><p>   <typehandlers><br>      <package name="com.neu.util">   </package></typehandlers><br>   或<br>   <typehandlers><br>      <typehandler handler="com.neu.util.StringArrayTypeHandler">   </typehandler></typehandlers></p><pre><code>5. 接口</code></pre><p>   public interface MyUserMapper {<br>       MyUser getById(int id);</p><pre><code>   int insert(MyUser user);   int update(MyUser user);</code></pre><p>   }</p><pre><code>5. mapper（可以不配置 typeHandler 属性，由mybatis自动选择）</code></pre><p>   &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>   &lt;!DOCTYPE mapper PUBLIC “-//mybatis.org//DTD Mapper 3.0//EN” “<a href="http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;>">http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</a><br>   <mapper namespace="com.neu.mapper.MyUserMapper"><br>       <resultmap type="com.neu.po.MyUser" id="basicMap"><br>           <result column="interests" property="interests" typehandler="com.neu.util.StringArrayTypeHandler">       </result></resultmap><br>       <!-- 可以使用 resultMap 进行手工映射 --><br>       <select id="getById" resulttype="com.neu.po.MyUser">           select * from myuser where id = #{id}       </select></mapper></p><pre><code>   &lt;insert id="insert"&gt;       insert into myuser values(           #{id},           #{username,javaType=String,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.StringTypeHandler},           #{password},#{interests,typeHandler=com.neu.util.StringArrayTypeHandler}       )   &lt;/insert&gt;   &lt;update id="update"&gt;       update myuser set username = #{username},password= #{password},interests=#{interests}       where id = #{id}   &lt;/update&gt;</code></pre><p>   &lt;/mapper&gt;</p><pre><code>6. 测试代码</code></pre><p>   public class MyUserMapperTest {<br>       private SqlSession session;<br>       private MyUserMapper myuserMapper;</p><pre><code>   @Before   public void setup() throws IOException {       //ctrl+2 L       //读取配置文件       InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");       //创建SqlSessionFactory       SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);       //创建连接，相当于Connection       session = sessionFactory.openSession();       //返回DeptMapper接口的实现类       myuserMapper = session.getMapper(MyUserMapper.class);   }   @After   public void after() {       //关闭会话       session.close();   }   @Test   public void testInsert() {       int n = myuserMapper.insert(new MyUser(33,"tom","111",new String[]{"游泳","爬山"}));               System.out.println(n);       session.commit();   }   @Test   public void testGetById() {       MyUser user = myuserMapper.getById(10);       System.out.println(user);   }   @Test   public void testUpdate() {       int n = myuserMapper.update(new MyUser(33,"marry","222",new String[]{"游泳","爬山","钓鱼"}));               System.out.println(n);       session.commit();   }</code></pre><p>   }</p><pre><code>mybatis中 在  `TypeHandlerRegistry` 注册内置拦截器</code></pre><p>public TypeHandlerRegistry(Configuration configuration) {<br>    this.unknownTypeHandler = new UnknownTypeHandler(configuration);</p><pre><code>register(Boolean.class, new BooleanTypeHandler());register(boolean.class, new BooleanTypeHandler());register(JdbcType.BOOLEAN, new BooleanTypeHandler());register(JdbcType.BIT, new BooleanTypeHandler());register(Byte.class, new ByteTypeHandler());register(byte.class, new ByteTypeHandler());register(JdbcType.TINYINT, new ByteTypeHandler());register(Short.class, new ShortTypeHandler());register(short.class, new ShortTypeHandler());register(JdbcType.SMALLINT, new ShortTypeHandler());register(Integer.class, new IntegerTypeHandler());register(int.class, new IntegerTypeHandler());register(JdbcType.INTEGER, new IntegerTypeHandler());register(Long.class, new LongTypeHandler());register(long.class, new LongTypeHandler());register(Float.class, new FloatTypeHandler());register(float.class, new FloatTypeHandler());register(JdbcType.FLOAT, new FloatTypeHandler());register(Double.class, new DoubleTypeHandler());register(double.class, new DoubleTypeHandler());register(JdbcType.DOUBLE, new DoubleTypeHandler());register(Reader.class, new ClobReaderTypeHandler());register(String.class, new StringTypeHandler());register(String.class, JdbcType.CHAR, new StringTypeHandler());register(String.class, JdbcType.CLOB, new ClobTypeHandler());register(String.class, JdbcType.VARCHAR, new StringTypeHandler());register(String.class, JdbcType.LONGVARCHAR, new StringTypeHandler());register(String.class, JdbcType.NVARCHAR, new NStringTypeHandler());register(String.class, JdbcType.NCHAR, new NStringTypeHandler());register(String.class, JdbcType.NCLOB, new NClobTypeHandler());register(JdbcType.CHAR, new StringTypeHandler());register(JdbcType.VARCHAR, new StringTypeHandler());register(JdbcType.CLOB, new ClobTypeHandler());register(JdbcType.LONGVARCHAR, new StringTypeHandler());register(JdbcType.NVARCHAR, new NStringTypeHandler());register(JdbcType.NCHAR, new NStringTypeHandler());register(JdbcType.NCLOB, new NClobTypeHandler());register(Object.class, JdbcType.ARRAY, new ArrayTypeHandler());register(JdbcType.ARRAY, new ArrayTypeHandler());register(BigInteger.class, new BigIntegerTypeHandler());register(JdbcType.BIGINT, new LongTypeHandler());register(BigDecimal.class, new BigDecimalTypeHandler());register(JdbcType.REAL, new BigDecimalTypeHandler());register(JdbcType.DECIMAL, new BigDecimalTypeHandler());register(JdbcType.NUMERIC, new BigDecimalTypeHandler());register(InputStream.class, new BlobInputStreamTypeHandler());register(Byte[].class, new ByteObjectArrayTypeHandler());register(Byte[].class, JdbcType.BLOB, new BlobByteObjectArrayTypeHandler());register(Byte[].class, JdbcType.LONGVARBINARY, new BlobByteObjectArrayTypeHandler());register(byte[].class, new ByteArrayTypeHandler());register(byte[].class, JdbcType.BLOB, new BlobTypeHandler());register(byte[].class, JdbcType.LONGVARBINARY, new BlobTypeHandler());register(JdbcType.LONGVARBINARY, new BlobTypeHandler());register(JdbcType.BLOB, new BlobTypeHandler());register(Object.class, unknownTypeHandler);register(Object.class, JdbcType.OTHER, unknownTypeHandler);register(JdbcType.OTHER, unknownTypeHandler);register(Date.class, new DateTypeHandler());register(Date.class, JdbcType.DATE, new DateOnlyTypeHandler());register(Date.class, JdbcType.TIME, new TimeOnlyTypeHandler());register(JdbcType.TIMESTAMP, new DateTypeHandler());register(JdbcType.DATE, new DateOnlyTypeHandler());register(JdbcType.TIME, new TimeOnlyTypeHandler());register(java.sql.Date.class, new SqlDateTypeHandler());register(java.sql.Time.class, new SqlTimeTypeHandler());register(java.sql.Timestamp.class, new SqlTimestampTypeHandler());register(String.class, JdbcType.SQLXML, new SqlxmlTypeHandler());register(Instant.class, new InstantTypeHandler());register(LocalDateTime.class, new LocalDateTimeTypeHandler());register(LocalDate.class, new LocalDateTypeHandler());register(LocalTime.class, new LocalTimeTypeHandler());register(OffsetDateTime.class, new OffsetDateTimeTypeHandler());register(OffsetTime.class, new OffsetTimeTypeHandler());register(ZonedDateTime.class, new ZonedDateTimeTypeHandler());register(Month.class, new MonthTypeHandler());register(Year.class, new YearTypeHandler());register(YearMonth.class, new YearMonthTypeHandler());register(JapaneseDate.class, new JapaneseDateTypeHandler());// issue #273register(Character.class, new CharacterTypeHandler());register(char.class, new CharacterTypeHandler());</code></pre><p>  }</p><pre><code>mybatis 类型别名 注册：TypeAliasRegistry</code></pre><p>说明：<a href="https://blog.csdn.net/lgl782519197/article/details/109066243">https://blog.csdn.net/lgl782519197/article/details/109066243</a></p><pre><code></code></pre><p>public TypeAliasRegistry() {<br>    registerAlias(“string”, String.class);</p><pre><code>registerAlias("byte", Byte.class);registerAlias("long", Long.class);registerAlias("short", Short.class);registerAlias("int", Integer.class);registerAlias("integer", Integer.class);registerAlias("double", Double.class);registerAlias("float", Float.class);registerAlias("boolean", Boolean.class);registerAlias("byte[]", Byte[].class);registerAlias("long[]", Long[].class);registerAlias("short[]", Short[].class);registerAlias("int[]", Integer[].class);registerAlias("integer[]", Integer[].class);registerAlias("double[]", Double[].class);registerAlias("float[]", Float[].class);registerAlias("boolean[]", Boolean[].class);registerAlias("_byte", byte.class);registerAlias("_long", long.class);registerAlias("_short", short.class);registerAlias("_int", int.class);registerAlias("_integer", int.class);registerAlias("_double", double.class);registerAlias("_float", float.class);registerAlias("_boolean", boolean.class);registerAlias("_byte[]", byte[].class);registerAlias("_long[]", long[].class);registerAlias("_short[]", short[].class);registerAlias("_int[]", int[].class);registerAlias("_integer[]", int[].class);registerAlias("_double[]", double[].class);registerAlias("_float[]", float[].class);registerAlias("_boolean[]", boolean[].class);registerAlias("date", Date.class);registerAlias("decimal", BigDecimal.class);registerAlias("bigdecimal", BigDecimal.class);registerAlias("biginteger", BigInteger.class);registerAlias("object", Object.class);registerAlias("date[]", Date[].class);registerAlias("decimal[]", BigDecimal[].class);registerAlias("bigdecimal[]", BigDecimal[].class);registerAlias("biginteger[]", BigInteger[].class);registerAlias("object[]", Object[].class);registerAlias("map", Map.class);registerAlias("hashmap", HashMap.class);registerAlias("list", List.class);registerAlias("arraylist", ArrayList.class);registerAlias("collection", Collection.class);registerAlias("iterator", Iterator.class);registerAlias("ResultSet", ResultSet.class);</code></pre><p>  }</p><pre><code># 使用注解替代mapper文件1. 使用注解</code></pre><p>   @Select(“select * from dept”)<br>   List<dept> getAll();</dept></p><p>   @Insert(“insert into dept values(#{deptno},#{dname},#{loc})”)<br>   int insert(Dept dept);</p><pre><code>2. 长 SQL 语句的写法</code></pre><p>   @Select(“select * from dept “+<br>           “where deptno = #{deptno}”)<br>   Dept getById(int deptno);</p><p>   @Select({“select * from dept “,<br>            “where deptno = #{deptno}”})<br>   Dept getById(int deptno);</p><pre><code>3. ResultMap   - 直接在接口方法上添加@Results注解</code></pre><pre><code> //mybatis的版本号：3.5.4，支持@Results中的id属性 @Select({"select * from dept ",             "where deptno = #{deptno}"})     @Results(id="basicMap", value= {             @Result(column = "deptno",property = "deptno",id = true),             @Result(column = "dname",property = "dname"),             @Result(column = "loc",property = "loc"),             @Result(property = "emps",column = "deptno",many = @Many(select = "com.neu.mapper.EmpMapper.getByDeptno"))     })     Dept getById(int deptno); @Select("select * from emp where empno = #{empno}")     @Results(value= {             @Result(                     property = "dept",                     column = "deptno",                     one = @One(select = "com.neu.mapper.DeptMapper.getById"             ))     })     Emp getById(int empno); ```</code></pre><ul><li><p>使用@ResultMap注解，引用@Results</p><pre><code>//basicMap可以是@Results的id或对应mapper.xml文件中&lt;resultMap&gt;的id属性@Select("select * from dept")@ResultMap("basicMap")List&lt;Dept&gt; getAll();</code></pre></li></ul><ol><li><p>得到自增主键值</p><pre><code>@Insert("insert into dept values(null,#{dname},#{loc})")    @SelectKey(        statement = "select last_insert_id()",        resultType = Integer.class,        keyProperty = "deptno",        before = false    )    int insert(Dept dept);</code></pre></li></ol><h1 id="查询补充"><a href="#查询补充" class="headerlink" title="查询补充"></a>查询补充</h1><pre><code>//接口List&lt;Map&lt;String,Object&gt;&gt; report();//mapper&lt;select id="report" resultType="map"&gt;        select ename,job,hiredate,dname,loc        from emp e join dept d        on e.deptno = d.deptno&lt;/select&gt;</code></pre><h1 id="MBG-Mybatis-Generator"><a href="#MBG-Mybatis-Generator" class="headerlink" title="MBG(Mybatis Generator)"></a>MBG(Mybatis Generator)</h1><ol><li><p>定义：是一个Mybatis的代码生成器，是根据已经创建的数据库表生成实体类、mapper接口、sql映射文件</p></li><li><p>操作过程</p><ul><li><p>使用向导生成配置文件：generatorConfig.xml</p></li><li><p>修改模板：</p><ul><li><p>改为使用“简单模板”</p><pre><code>&lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;</code></pre></li><li><p>使用默认模板</p><pre><code>&lt;context id="context1" &gt;</code></pre></li></ul></li><li><p>修改配置</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;  &lt;context id="context1" targetRuntime="Mybatis3Simple"&gt;    &lt;jdbcConnection connectionURL="jdbc:mysql://localhost:3306/mydb?useUnicode=true&amp;amp;characterEncoding=utf8" driverClass="com.mysql.jdbc.Driver" password="root" userId="root" /&gt;    &lt;javaModelGenerator targetPackage="com.neu.po" targetProject="mybatismbg" /&gt;    &lt;sqlMapGenerator targetPackage="com.neu.mapper" targetProject="mybatismbg"&gt;&lt;/sqlMapGenerator&gt;    &lt;javaClientGenerator targetPackage="com.neu.mapper" targetProject="mybatismbg" type="XMLMAPPER" /&gt;    &lt;table schema="root" tableName="dept"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;    &lt;table schema="root" tableName="emp"&gt;      &lt;!-- &lt;columnOverride column="???" property="???" /&gt; --&gt;    &lt;/table&gt;  &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre></li><li><p>生成代码（配置文件右键）</p></li><li><p>如果有实体关联，修改xml配置文件</p><ul><li><p>修改生成xml配置文件</p><pre><code>//generatorConfig.xml&lt;table schema="root" tableName="emp"&gt;    &lt;columnOverride column="deptno" property="dept" javaType="com.neu.po.Dept" /&gt;&lt;/table&gt;</code></pre></li><li><p>修改生成的mapper文件</p><pre><code>&lt;!-- &lt;result column="deptno" jdbcType="INTEGER" property="dept" /&gt; --&gt;&lt;association property="dept" column="deptno" select="com.neu.mapper.DeptMapper.selectByPrimaryKey"&gt;&lt;/association&gt;</code></pre><p>修改 dept =》 dept.deptno(注意：别修改列名)</p></li></ul></li></ul><ol><li><p>使用Mybatis3模板</p><ul><li><p>生成的接口中有11个方法</p><ul><li>方法名中包含 primaryKey：根据主键进行相应的操作</li><li>方法名中包含example：根据Example生成where语句来操作</li><li>方法名中包含Selective：对部分列进行有选择操作（动态sql）</li></ul></li><li><p>Example的作用：生成where语句</p><pre><code>@Test    public void testGetByExample() throws IOException {        EmpExample example = new EmpExample();//        example.or().andEnameEqualTo("SMITH").andSalGreaterThan(new BigDecimal(700));//        example.or().andEnameLike("%S%");//        example.or().andSalBetween(new BigDecimal(1500), new BigDecimal(2000));//        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//        list.add(7369);//        list.add(7499);//        //        example.or().andEmpnoIn(list);        Dept dept = new Dept();        dept.setDeptno(10);        example.or().andDeptEqualTo(dept);        List&lt;Emp&gt; list2 = empMapper.selectByExample(example);        System.out.println(list2);    }//修改EmpExamplepublic Criteria andDeptEqualTo(Dept value) {   addCriterion("deptno =", value.getDeptno(), "dept");   return (Criteria) this;}</code></pre></li></ul><p>练习：</p><ol><li>生成Role和MyUser实体类、接口、mapper文件</li><li>根据角色Id查询该角色的所有用户信息</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统输入/输出管理</title>
      <link href="/2022/052237860.html"/>
      <url>/2022/052237860.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入-输出管理管理"><a href="#输入-输出管理管理" class="headerlink" title="输入-输出管理管理"></a>输入-输出管理管理</h1><img src="/2022/052237860/1.jpg" class="">  <h2 id="IO管理概述"><a href="#IO管理概述" class="headerlink" title="IO管理概述"></a>IO管理概述</h2><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>IO设备按照使用特性分为以下类型：<br>人机交互类外部设备：打印机，显示器，键鼠等。数据交换速度慢，通常以字节为单位数据交换。<br>存储设备：磁盘，光盘等。用于数据交换，速度快，通常以多字节组成的块为单位数据交换。<br>网络通信设备：网络接口等。速度介于前两者之间，用于远程设备通信。<br>除了以上分类方式，还可以按照以下方法分类：</p><ul><li>按传输速率分类：<br>①低速设备：键鼠等。<br>②中速：打印机等。<br>③告诉：磁带机，光盘机，磁盘机等。  </li><li>按信息交换的单位分类：<br>①块设备：属于有结构设备，如磁盘，基本特征就是传输速率高，可寻址即随机读写。<br>②字符设备：用于IO的设备，传输基本单位是字符，无结构类型，如打印机等，基本特征是传输速率低，不可寻址，IO采用中断驱动方式。  <h3 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h3>外围设备和内存之间IO控制方式有4种。  </li><li>程序直接控制方式：<br>计算机从外部设备读取数据到存储区，每次读取一个字的数据，每个字CPU都需要对于外设状态进行循环检查，由于CPU的高速性和IO设备的低速性，使得CPU绝大多数时间等待IO设备完成循环测试。该方法易于实现，但CPU利用率低。  </li><li>中断驱动方式：<br>允许IO设备主动打断CPU运行并请求服务，从而“解放”CPU，使其向IO控制器发送读指令后可以继续做其他有用工作。从IO设备角度看，IO设备从CPU接收一个读指令，从外围设备读取数据，一旦数据读入该IO控制器的数据寄存器，便使得通过控制线给CPU发出一个中断信号，表示数据已经准备好等待CPU请求数据，然后收到CPU发出的取数据请求之后，把数据放到数据总线上，传到CPU的寄存器中。而CPU角度看，CPU发出读指令，保存当前程序上下文，转去执行其他程序，接到IO设备中断时，CPU保存其他程序的上下文，转去执行中断处理程序，这时CPU从IO控制器读取一个字的数据传送到寄存器。中断驱动的方法比直接控制有效，但由于数据的每个字在存储器与IO控制器之间的传输都必须经过CPU，导致CPU时间依然被大量浪费。  </li><li>DMA方式:<br>在IO设备与内存之间开辟直接的数据交换通路，彻底解放CPU。特点如下：①基本单位是数据块。②所传送的数据是从设备直接送入内存的（或相反）。③仅在数据块传送的开始和结束，才需要CPU的干预，整块数据的传送时在DMA控制器的控制下完成的。<br>工作过程就是：CPU接到IO设备请求，给IO设备控制器发送一条指令，启动DMA控制器，然后继续其他工作。之后CPU把控制操作委托给DMA控制器，其直接与存储器交互，传送整个数据块，每次传送一个字，过程不需要CPU参与，完成之后DMA控制器发送一个中断信号给CPU。  <img src="/2022/052237860/2.jpg" class="">  </li><li>通道控制方式：<br>IO通道是专门负责IO的处理机，是DMA的发展，进一步减少CPU干预。CPU只需要向IO通道发送一条IO指令，给出其所要执行的通道程序的首地址和要访问的IO设备，通道程序即可执行CPU指定任务，数据传送结束时间向CPU发中断请求。<br>IO通道与一般处理机区别是：通道指令类型单一，没有自己内存，通道执行的程序放在主机内存中。<br>IO通道和DMA区别是：DMA方式需要CPU来控制传输数据块大小，传输内存位置，而通道中这些信息由通道控制的。  <img src="/2022/052237860/3.jpg" class="">   <h3 id="IO子系统的层次结构"><a href="#IO子系统的层次结构" class="headerlink" title="IO子系统的层次结构"></a>IO子系统的层次结构</h3>IO软件涉及面很广，跟硬件，用户都由直接交互，与进程管理，存储管理等都有联系，他们都可能需要IO软件来实现IO操作。IO软件普遍采用层次式结构，每层利用下层服务，完成某些功能，并屏蔽细节向上层提供服务。  <img src="/2022/052237860/4.jpg" class="">   </li><li>用户层IO软件：用户交互的接口，用户直接调用。  </li><li>设备独立性软件：用户程序与设备驱动器的统一接口，设备命令，设备保护，设备分配和释放等。设备独立性也称无关性，使得应用程序独立于使用物理设备，为实现设备独立性而引入了逻辑设备和物理设备这两个概念。应用程序中，使用逻辑设备名来请求某类设备，实际执行时必须把逻辑设备名改为物理设备名使用。  </li><li>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动IO设备工作的驱动程序。 </li><li>中断处理程序：保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完并且恢复被中断进程的现场，返回到被中断环境。  </li><li>硬件设备：IO设备通常包括一个机械部件和电子部件。  <h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><h3 id="IO子系统概述"><a href="#IO子系统概述" class="headerlink" title="IO子系统概述"></a>IO子系统概述</h3>由于IO设备种类繁多，功能和传输速率差异巨大，因此需要多种方法来进行设备控制，这些方法共同组成了OS内核的IO子系统，把内核的其他方面从繁重的IO设备管理中解放，其中IO核心子系统提供的服务主要有IO调度，缓冲与高速缓存，设备分配和回收，假脱机，设备保护和差错处理等。  <h3 id="IO调度概念"><a href="#IO调度概念" class="headerlink" title="IO调度概念"></a>IO调度概念</h3>IO调度就是确定一个好的顺序执行这些IO请求，来改善系统整体性能，使得进程之间公平的共享设备访问，减少IO完成的时间。OS通过为每个设备维护一个请求队列来实现调度，当一个应用程序执行阻塞IO系统调用时，该请求就添加到相应设备的队列上，IO调度会重新安排队列顺序，以改善系统总体效率和平均响应时间。  <h3 id="高速缓存和缓冲区"><a href="#高速缓存和缓冲区" class="headerlink" title="高速缓存和缓冲区"></a>高速缓存和缓冲区</h3></li><li>磁盘高速缓存：<br>OS中使用磁盘高速缓存技术来提高磁盘IO速度，对于高速缓存复制的访问比原始数据访问更高效，例如：正在运行的进程的指令既存储在磁盘上，又存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。  </li><li>缓冲区Buffer：<br>设备管理子系统中引入缓冲区的目的是：<br>①缓和CPU与IO设备之间速度不匹配的矛盾。<br>②减少对CPU的中断频率，放款对CPU中断响应时间的限制。<br>③解决基本数据单元大小不匹配的问题。<br>④提高CPU和IO设备之间的并行性。<br>缓冲区的特点：缓冲区的数据非空时不能往中冲入数据，智能把缓冲区把数据传输，为空时可以冲入数据，但必须充满之后才能把数据传出。  </li><li>高速缓存和缓冲区的对比：  <img src="/2022/052237860/5.jpg" class="">   <h3 id="设备分配和回收"><a href="#设备分配和回收" class="headerlink" title="设备分配和回收"></a>设备分配和回收</h3></li><li>设备分配概述：<br>根据用户的IO请求分配所需的设备，原则就是充分发挥设备的使用效率，尽可能让设备忙碌起来，又要避免由于不合理分配方法造成进程死锁，从设备特性分三类：<br>①独占式设备：比如打印机。<br>②分时式共享设备：设备没有独占要求时，可以通过分时共享使用提高利用率。<br>③以SPOOLing方式使用外部设备：SPOOLing技术即假脱机IO技术，用于对设备的操作，实质上就是对IO操作进行批处理，实质上是空间换时间的技术。（而页置换就是时间换空间）  </li><li>设备分配的数据结构：<br>主要有设备控制表DCT，控制器控制表COCT，通道控制表CHCT，系统设备表SDT。<br>①设备控制表DCT：一个表代表一个设备，表项就是设备各属性：  <img src="/2022/052237860/6.jpg" class="">  ②现在IO控制都采用通道控制。设备控制器控制设备与内存交换数据，而设备控制器有需要请求通道为它服务，因此每个COCT必定有一个表项存放指向相应通道控制表CHCT的指针，而一个通道可以为多个设备控制器服务，因此CHCT中必然有一个指针指向一个表，这个表上的信息表达的是CHCT提供服务的几个设备控制器。CHCT和COCT是一对多的关系。<br>③系统设备表SDT：系统只有一张，记录所有设备情况，每个表目代表一个设备。  <img src="/2022/052237860/7.jpg" class="">   由于系统中进程大于资源数目，引起资源竞争，因此要有一套合理的分配原则，主要考虑因素是：IO设备固有属性，分配算法，安全性，独立性。  </li><li>设备分配的策略：<br>①原则：根据设备特性，用户要求和系统配置情况。总原则就是：既要充分发挥设备使用效率，又要避免造成进程死锁，还要把用户程序和具体设备隔离开。<br>②分配方式：动态和静态分配。<br>静态分配主要是独占是设备分配，在作业执行前系统一次性分配该作业要求全部设备，一旦分配就不可更改，分配方式不会出现死锁，但设备使用效率低。<br>动态分配在进程执行过程中根据执行需要进行，当进程需要设备时，通过系统调用命令向系统提出设备请求，根据策略给其分配设备，用完立即释放，动态分配有利于提高设备的利用率，若分配算法使用不当有可能造成死锁。<br>③设备分配算法：<br>主要是先请求先分配和优先级高者优先。  </li><li>设备分配安全性：<br>指的是设备分配中应防止发生进程死锁。<br>①安全分配方式：进程发出IO请求便进入阻塞态，直到IO请求完成才被唤醒。所以一旦进程获得某种设备后便进入阻塞，不请求任何资源。优点就是设备分配安全，缺点就是CPU和IO设备是串行工作的。<br>②不安全分配方式：进程在发出IO请求后继续发出第二个等，仅当进程请求设备已被另一个进程占用时才进入阻塞态，优点就是一个进程可以同时操作多个涉笔，缺点就是可能死锁。  </li><li>逻辑设备名到物理设备名的映射：<br>为了提高设备分配灵活性和设备利用率，方便实现IO重定向，引入了设备独立性（应用程序独立于具体使用的物理设备），为了实现特性系统中设置了一张逻辑设备表LUT，用于把逻辑设备名映射到物理设备名。LUT表项包括逻辑设备名，物理设备名，设备驱动程序入口地址，进程用逻辑设备名请求设备时，系统分配相应物理设备，并且在LUT建立表项，以后系统在利用逻辑设备名时查找LUT即可找到相应物理设备和驱动程序。可以整个系统一张LUT（单用户系统），也可以一个用户一张LUT。  <h3 id="SPOOLing技术（假脱机技术）"><a href="#SPOOLing技术（假脱机技术）" class="headerlink" title="SPOOLing技术（假脱机技术）"></a>SPOOLing技术（假脱机技术）</h3>为了缓和CPU高速性和IO设备低速性之间的矛盾，引入了脱机IO技术，该技术利用专门的外围控制机，把低速IO设备上的数据传送到高速磁盘上，或相反。SPOOLing的意思就是外部设备同时联机操作，又称假脱机IO操作，是一种把独占设备改为共享设备的技术。  <img src="/2022/052237860/8.jpg" class="">   ①输入井和输出井：<br>输入井模拟脱机输入时的磁盘，用于收容IO设备输入的数据。<br>输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。<br>②输入缓冲区和输出缓冲区：<br>输入缓冲区暂存输入设备送来的数据，以后再传送到输入井。<br>输出缓冲区暂存从输出井传来的数据，以后再传送到输出设备。<br>③输入进程和输出进程：<br>输入进程模拟脱机输入时的外围控制机，把用户要求数据从输入机通过输入缓冲区送到输入井，当CPU需要输入数据时，直接把输入井数据读入内存。<br>输出进程模拟脱机输出时的外围控制机，把用户要求输出数据从内存送到输出井，待输出设备空闲时，再输出井中数据经过输出缓冲区送到输出设备。<br>共享打印机就是一个SPOOLing的一个实例。特点就是：提高IO速度，把独占设备改造成共享设备，实现了虚拟设备功能。（CPU要向打印机输出要打印的数据之后，去做其他事情，若此时打印机被占用则SPOOLing系统就把这个打印请求挂到等待队列上，待打印机有空再打印出来，向磁盘输出数据速度比向打印机输出数据速度快，因此节约了时间）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统文件管理</title>
      <link href="/2022/052139833.html"/>
      <url>/2022/052139833.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><img src="/2022/052139833/1.jpg" class="">   <h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><h3 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h3><ul><li>文件的定义：<br>以计算机硬盘为载体的存储在计算机上的信息集合。系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入输出中，则以文件为基本单位。当用户把文件用于用户程序的输入输出时，希望还可以访问，修改，保存文件等，实现对于文件的维护管理，需要OS中的文件系统。<br>文件由存储空间中的数据，分类和索引信息，访问权限信息组成。用户通过文件系统建立文件，提供程序的输入输出，对资源进行管理，首先了解文件结构，通过自底向上的方式来定义：<br>①数据项：文件系统中最低级的数据组织形式，分为基本数据项（描述一个对象某个值，是数据中可命名的最小逻辑数据单元，即原子数据）和组合数据项（由多个基本数据项组成）。<br>②记录：一组相关数据项集合，描述一个对象在某方面的属性（考生信息一系列域）。<br>③文件：指由创建者所定义的一组相关信息集合，逻辑上分为有结构文件（文件由一组相似记录组成，又叫记录式文件）和无结构文件（视为一个字符流，又称流式文件）。     </li><li>文件的属性：<br>系统不同属性也不同，但通常包括：<br>①名称：文件名称唯一，以易读取形式保存。<br>②标识符：标识文件系统内文件的唯一标签，通常为数字，对人不可读。<br>③类型：被支持不同类型的文件系统所使用。<br>④位置：指向设备和设备上文件的指针。<br>⑤大小：文件当前大小，也可包括文件允许的最大值。<br>⑥保护：对文件进行保护的访问控制信息。<br>⑦时间，日期和用户标识：文件创建，上次修改，上次访问的相关信息，用于保护跟踪文件使用。<br>所有文件的信息都保存在目录结构中，目录结构保存在外存中，文件信息需要时才调入内存，通常，目录条目包括文件名称以及唯一标识符，二标识符定位其他属性信息。  </li><li>文件的基本操作：<br>OS提供系统调用，对文件进行创建，写，读，重定位，删除，截断等操作。（基本操作组合可以执行其他文件操作）<br>①创建文件：①文件系统为文件找到空间。②目录中为文件创建新条目，记录文件名称和标识符等其他信息。<br>②写文件：执行系统调用，指明文件名称和要写内容，系统维护一个写位置的指针，写操作时更新写指针。<br>③读文件：执行系统调用，指明文件内容和要读文件快的内存位置，系统维护一个读位置的指针，读操作时更新读指针，读写使用同一个指针。<br>④文件重定位：按照某条件搜索目录，把当前文件位置设置为给定值，并且不会读写文件。<br>⑤删除文件：从目录找出删除文件的目录项，实质称为空项目，回收文件存储空间。<br>⑥截断文件：允许文件所有属性不变，并删除文件内容，即长度设置为0并释放其空间。     </li><li>文件打开和关闭：<br>许多系统要求首次使用文件时，系统调用open将指明文件的属性从外存复制到内存，打开文件表的一个条目，把表目编号返回给用户，OS维护一个包含所有打开文件信息的表（打开文件表），需要文件操作时可以通过该表的一个索引指定文件，省略搜索环境，不再使用可以关闭它，OS打开文件表删除这个条目。open会根据文件名搜索牡蛎，并把目录条目复制到打开文件表，open返回一个指向打开文件表中的一个条目的指针，通过这个指针进行所有IO操作，之后对于文件任何操作不需要文件名字，只需要open调用返回的指针。<br>通常OS还用一个文件打开计数器Open Count，记录多少进程打开了该文件，打开计数器为0标识不再使用，系统回收系统资源。若文件被修改过，文件写回外存，并把打开文件表相应条目删除，最后释放文件的文件控制块FCB。<br>每个打开文件都有相关关联信息：<br>①文件指针：文件当前位置的指针，打开文件某个进程是唯一的。<br>②文件打开计数：上文解释过。<br>③文件磁盘位置：绝大数文件操作要求改变文件，该信息保存在内存中，以免每个操作都从磁盘中获取。<br>④访问权限：每个进程打开文件都要有访问模式（创建，只读，读写等），该信息保存在进程打开文件表中，以便OS可以允许/拒绝IO请求。   <h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3></li><li>逻辑结构就是用户观点看到的文件组织形式。物理结构则是实现观点出发看到的文件在外存上的存储组织形式。逻辑结构上，文件划分无结构文件和有结构文件两种：</li><li>无结构文件（流式文件）：<br>最简单的文件组织形式，把数据按照顺序组织成记录并积蓄保存，它是有序相关信息项的集合，以字节为单位。记录访问只能穷举搜索，适用于对基本信息单位操作不多的文件（如源程序文件，目标代码文件等）  </li><li>有结构文件（记录式文件）：<br>按照记录的组织形式可以分为：<br>①顺序文件：记录顺序排列，通常是定长的，可以顺序/链式存储，访问时顺序搜索文件。有两种结构：第一种是串结构：存入时间先后排列。第二种是顺序结构：按照关键字顺序排列。对于记录批量操作时，顺序文件操作效率最高，此外也只有顺序文件才能存在磁带上，但对于单条记录操作就比较困难。<br>②索引文件：对于定长记录文件和可变长记录文件，查找第i条记录地址不一样。变长记录文件只能顺序查找，系统开销大，为此可以建立一张索引表加速检索。  <img src="/2022/052139833/2.jpg" class="">   ③索引顺序文件：顺序和索引两种组织形式结合，把顺序文件所有记录分为若干组，建立一张索引表，表为每组第一个记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。同一组的关键字可以无序，但组索引必须有序，先找到组再顺序查找。  <img src="/2022/052139833/3.jpg" class="">   提高了查找效率，但配置索引表增加了存储空间。<br>④直接文件/散列文件（Hash File）：给定记录的键值/通过散列函数转换的键值直接决定记录的物理地址，没有顺序的特性，有很高的存取速度但有冲突。  <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3></li><li>包含文件信息，这些信息由OS管理。用户角度：目录需要在文件名和文件之间有映射，目录存取效率直接影响系统性能，所以要提高用户检索速度，共享系统中，目录还需要提供用于控制访问文件的信息，重名也是合理的要求，通过树形结构来解决和实现。  </li><li>文件控制块和索引结点：<br>为了实现目录管理，OS引入了文件控制块的数据结构。<br>①文件控制块FCB，用来存放控制文件所需要各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项，创建新文件则分配一个FCB并存放在文件目录中，成为目录项。主要包括：基本信息（名字，物理位置，逻辑结构等），存取控制信息（文件存取权限等），使用信息（创建修改时间等）。<br>②索引结点：检索目录文件过程中，只用到了文件名，仅当找到一个目录项时，才需要从该目录读取其物理地址，也就是其他描述信息没用到，所以有的OS采用文件名和描述分开方法，描述信息单独形成一个称为索引结点的数据结构，在文件目录中每个目录项仅由文件名和指向该文件的所对应i结点的指针构成。存放在磁盘上的索引结点称为磁盘索引结点，UNIX每个文件都由一个唯一的磁盘索引结点，主要包括：文件主标识符，文件类型，文件存取权限，文件物理地址，文件长度（以字节为单位），文件链接计数（指向该文件的指针计数），文件存取时间。<br>文件被打开时，磁盘索引结点复制到内存的索引结点以便于使用，在内存索引节点又增加了内容：索引结点编号（标识内存索引结点），状态（结点是否上锁或修改），访问计数，逻辑设备号，链接指针。  </li><li>目录结构：<br>考虑目录层次的操作:搜索，创建文件，删除文件，显示目录，修改目录。考虑以下几种目录结构：<br>①单级目录结构：<br>整个文件系统只有一个目录表，每个文件占一个目录项。  <img src="/2022/052139833/4.jpg" class="">   访问文件，先按照文件名找到对应FCB，创建文件必须检索所有目录项以确保没有重名，删除文件回收存储空间再清楚目录项。单级目录实现了“按名存取”，但速度慢，无重名，不便于用户共享。<br>②两级目录结构：<br>把文件目录分为主文件目录MFD和用户文件目录UFD。  <img src="/2022/052139833/5.jpg" class="">   主文件目录记录用户名和相应文件目录所在存储位置，而用户文件目录记录相应用户文件目录的FCB信息，当用户相对其文件访问时只需要搜索该用户对应的UFD，解决了重名问题，保证安全，但缺乏灵活性，不能对文件分类。<br>③多级目录结构（树形目录结构）：<br>用户访问某个文件，用文件路径名标识文件，用“/”分隔开，从根目录出发的路径为绝对路径。而从当前目录出发到所找文件通路的路径为相对路径。  <img src="/2022/052139833/6.jpg" class="">   很方便对于文件分配，层次清晰，但查找时需要逐次访问中间结点，增加磁盘访问次数，影响速度。<br>④无环图目录结构：<br>树形结构不利于文件共享，所以在树形结构基础上增加指向同一结点的有向边，使得整个目录成为一个有向无环图，为了实现文件共享。  <img src="/2022/052139833/7.jpg" class="">   <h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3>使多个用户共享同一个文件，系统只需要保留一个副本。常用两种方法：  </li><li>基于索引结点的共享方式（硬链接）：<br>在树形结构目录中，当两个或多个用户要共享一个子目录/文件时，必须把共享文件或子目录链接到这些用户目录中，才能方便找到该文件。<br>文件的其他信息都放在索引结点中，而目录中只有文件名和指向相应索引节点的指针，索引节点还有count来计数链接到本索引结点的用户目录项数。  <img src="/2022/052139833/8.jpg" class="">   </li><li>利用符号链实现文件共享（软链接）：<br>系统创建一个LINK类型的新文件，写入共享用户B的目录中，实现B的目录与文件F的链接，新文件中只包含被链接文件的路径名，这种方法称为符号链接。新文件中的路径名视为符号链，根据路径名读取文件，从而实现对文件的共享。<br>在利用符号链方式实现文件共享时，只有文件拥有者才拥有指向其索引节点的指针，而共享该文件的其他用户只有该文件的路径名。但仍然有一点问题，删除该文件且再次创建一样文件，软链接仍然有效。有个优点就是网络共享只需要提供该文件所在及其的网络地址及该及其中的文件路径。  <h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读，写，执行的许可问题，为此必须在文件系统中建立相应的文件保护机制。文件保护通过口令保护，加密保护，访问控制等方式实现，其中口令和加密为了防止用户文件被他人存取或窃取，而访问控制用于控制用户对于文件访问方式。  </li><li>访问类型：<br>读，写，执行（文件装入内存并执行），添加，删除，列表清单（列出文件名和属性），还有其他高级操作（通过掉哟个底层系统调用来实现）。</li><li>访问控制：<br>最常用方法就是根据用户身份进行控制，为每个文件增加一个访问控制列表ACL，以规定每个用户名及其所允许的访问类型，精简的访问列表有：拥有者（创建文件用户），组（一组内需要共享文件且具有类似访问的用户），其他（系统内的所有其他用户）。用三个域列出访问表三类用户访问权限。<br>口令和密码时另外两种访问控制：<br>①口令指用户建立一个文件时提供一个口令，系统为其建立FCB时附上口令，且告诉共享文件的其他用户，用户请求访问时必须提供相应口令，缺点是口令存在系统内部不安全。<br>②密码则是对文件加密，访问需要密钥，保密性强但编码和译码需要花费时间。<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统层次结构"><a href="#文件系统层次结构" class="headerlink" title="文件系统层次结构"></a>文件系统层次结构</h3>现代OS有很多种文件系统类型，因此文件系统层次结构也不尽相同。  <img src="/2022/052139833/9.jpg" class="">   </li><li>用户调用接口：<br>文件系统为用户提供与文件及目录有关的调用。此层由若干程序模块组成，每个模块对应一条系统调用，用户发出一条调用，控制即转入相应的模块。  </li><li>文件目录系统：<br>管理文件目录，任务有管理活跃文件目录表，管理读写状态信息表，打开文件表，管理与组织存储设备上的文件目录结构，调用下一级存取控制模块。  </li><li>存取控制验证模块：<br>实现文件保护主要由该级软件完成，把用户访问和FCB中访问控制权限进行比较，确认合法性。  </li><li>逻辑文件系统和文件信息缓冲区：<br>根据文件逻辑把用户读写的记录转换成文件逻辑结构内相应块号。  </li><li>物理文件系统：<br>把逻辑记录所在的相对块号转换成实际物理地址。  </li><li>辅助分配模块：<br>管理辅存空间。  </li><li>设备管理程序模块：<br>分配设备，分配设备读写缓冲区，磁盘调度，启动设备，处理设备中断等。  <img src="/2022/052139833/10.jpg" class="">   <h3 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h3>常用基本方法是线性列表和哈希表两种，目录实现的目的就是为了查找，因此对应线性查找和哈希查找。查询通过磁盘反复搜索完成的，开销大，复制进内存降低磁盘操作次数，提高系统速度。    </li><li>线性列表：<br>使用存储文件名和数据块指针的线性表。  </li><li>哈希表：<br>根据文件名得到值，返回一个指向线性列表中元素的指针。  <h3 id="文件实现——文件分配方式"><a href="#文件实现——文件分配方式" class="headerlink" title="文件实现——文件分配方式"></a>文件实现——文件分配方式</h3>文件分配对应文件的物理结构，如何为文件分配磁盘块，常见分配有连续分配，链接分配，索引分配。文件分配方式——对于磁盘非空闲块的管理。</li><li>连续分配：<br>要求每个文件在磁盘上占有一组连续的块，磁盘地址定义了磁盘上的一个线性排序，这种排序使得作业访问磁盘需要的寻道数和时间最小。一个文件目录条目包括开始的块的地址和长度。连续分配支持顺序访问和直接访问，优点就是实现简单，存取速度快，缺点就是文件长度不宜动态增加，反复增删产生外部碎片。  <img src="/2022/052139833/11.jpg" class="">   </li><li>链接分配：<br>离散分配的方式，消除外部碎片，增删改查方便，分为隐式链接和显式链接两种形式：<br>①隐式链接：<br>每个文件对应一个磁盘块链表，每个盘块都有指向下一个盘块的指针，这些指针对用户是透明的，目录包括文件的第一块指针和最后一块指针。创建新文件时，目录中增加一个新条目，每个目录项都有指向文件首块的指针，该指针初始化为NULL以表示空文件，写文件会同空闲空间管理系统找到空闲块，把该块链接到文件尾部，读文件则通过块间指针顺序读块。缺点就是无法直接访问，只能顺序访问，且软件/硬件错误导致指针丢失也会使得数据丢失。  <img src="/2022/052139833/12.jpg" class="">   ②显式链接指把用于连接文件各物理块的指针，从物理块末尾提取出来放在链接表中，仅一张称为文件分配表FAT，每个表项存放对应块的下一块指针，即下一个块号，第一个块号存在目录中，后续通过FAT查找得到。用-1表示文件最后一块，-2表示这个磁盘块是空闲的。因此FAT不仅记录了文件各块先后关系，还标记了空闲磁盘块。FAT在系统启动的时候就被读入内存，因此查找FAT是在内存中进行的，不仅显著提高了检索速度，而且减少了访问磁盘次数。  <img src="/2022/052139833/13.jpg" class="">   </li><li>索引分配：<br>链接分配不能解决直接访问，而索引分配解决了这个问题，它把每个文件所有盘块号都集中放在一起形成索引块。每个文件都由其索引块，这是一个磁盘块地址的数组，目录条目包括索引块的地址，第i块就是第i个条目的指针来查找和读入所需的块。创建文件时，所有索引块的指针都设置为空，首次写入第i块时需要从空闲空间中取得一个块，然后把其地址写入索引块的第i个条目。    <img src="/2022/052139833/14.jpg" class="">   索引块大小很重要，每个文件必须有一个索引块，尽可能小，但太小无法支持大文件，采用以下机制解决问题：<br>①链接方案：多个索引块链接起来处理大文件。<br>②多层索引：第一层索引指向第二次，以此类推。<br>③混合索引：多种索引分配方式结合的分配方式</li><li>三种文件分配方式比较：  <img src="/2022/052139833/15.jpg" class="">   <h3 id="文件实现——文件存储空间管理"><a href="#文件实现——文件存储空间管理" class="headerlink" title="文件实现——文件存储空间管理"></a>文件实现——文件存储空间管理</h3></li><li>文件存储器空间的划分与初始化：<br>一般来说，一个文件存储在一个文件卷中，文件卷可以是物理盘一部分，也可以是整个物理盘。一个文件卷中，文件数据信息的空间和存放文件控制信息FCB的空间时分离的。  <img src="/2022/052139833/16.jpg" class="">   </li><li>文件存储器空间管理：<br>文件存储设备分成大小相同的物理块，并以块为单位交换信息，因此文件存储设备的管理实质上是对空闲块的组织和管理，包括空闲块的组织，分配，回收等问题。  </li><li>空闲表法：<br>连续分配方式，为每个文件分配一块连续的内存空间，系统为外存的所有空闲区建立一张空闲盘块表，每个空闲区对应一个空闲表项，包括表项序号，该空闲区第一个盘块好，块数等信息，再递增排列。空闲盘区的分配和内存动态分配类似，同样采用首次适应算法/循环首次适应算法等。系统对用户释放的存储空间进行回收时，也采取类似用于内存回收的方法，考虑回收区是否和空闲表中插入点的前区和后区相邻接，对相邻接者予以合并。    <img src="/2022/052139833/17.jpg" class="">   </li><li>空闲链表法：<br>所有空闲盘区拉成一条空闲链，根据构成链所有基本元素不同，分为两种形式：空闲盘块链和空闲盘区链。<br>①空闲盘块链：把磁盘上所有空闲空间以盘块为单位拉成一条链，当用户因为创建文件而请求分配存储空间时，从链首开始一次摘下合适数目空闲盘块分配给用户，删除则把回收盘块放在链末尾。<br>②空闲盘区链：把磁盘上所有空闲空间以盘区为单位拉成一条链，盘区含有指向下一个盘区指针和盘区大小信息，分配和内存动态分配一样，采用首次适应算法，回收时也是把回收区和相邻接的空闲盘区合并。  </li><li>位示图法：<br>利用二进制的一位表示磁盘中的一个盘块的使用情况，0表示空闲，1表示已分配。分配和回收只需要修改二位数组的1/0即可。  <img src="/2022/052139833/18.jpg" class="">   </li><li>成组链接法：<br>UNIX使用，结合空闲表和空闲链表，克服表太大的缺点。思想:顺序的n个空扇区地址保存在第一个空扇区中，其后一个空闲扇区则保存另一个顺序空闲扇区的地址，之后一个空闲扇区内则保存另一个顺序空闲扇区的地址，如此继续，直到所有空闲扇区链接完成。  <img src="/2022/052139833/19.jpg" class="">   <h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><img src="/2022/052139833/20.jpg" class="">   <h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3>一次磁盘读写操作时间由寻道时间，旋转延迟时间，传输时间决定。  </li><li>寻道时间，活动头磁盘读信息之前，把磁头移动到指定磁道所需要的时间，这个时间除了跨越n条道的时间外，还包括启动磁臂的时间。  </li><li>旋转延迟时间，磁头定位到某磁道的扇区需要时间，设磁盘旋转速度为r，则t=1/2r。  </li><li>传输时间，从磁盘读出或向磁盘写入数据经历的时间，取决于每次读写字节数b和磁盘旋转速度t=b/rN。<br>其中寻道时间和磁盘调度算法相关，而其他都与磁盘旋转速度有关。以下几种磁盘调度算法：  </li><li>先来先服务FCFS：<br>按照先后顺序进行访问磁盘调度。  </li><li>最短寻找时间优先算法SSTF：<br>与当前磁道最近的磁道优先调度，但会产生“饥饿现象”。  </li><li>扫描算法SCAN：<br>在当前移动方向上寻找与当前磁头最近的对象，就是SSTF基础上规定了磁头运动方向。  </li><li>循环扫描算法C-SCAN：<br>扫描算法基础上规定磁头单项移动来提供服务，返回直接快速移动到起始端而不服务请求。</li><li>LOOK算法：<br>扫描算法就是磁头严格一个方向从一端到另一端，而改进之后磁头移动只需要到达最远端而不需要到达磁盘端点，这就是LOOK算法。（默认SCAN为LOOK算法）</li><li>C-LOOK算法：<br>对应C-SCAN类似，到达最远端点之后直接移动到起始端点而不提供服务请求。（默认C-SCAN为C-LOOK算法）</li><li>算法比较：  <img src="/2022/052139833/21.jpg" class="">   <h3 id="磁盘的管理"><a href="#磁盘的管理" class="headerlink" title="磁盘的管理"></a>磁盘的管理</h3></li><li>磁盘初始化：<br>磁盘存储数据之前，必须分成扇区以便磁盘控制器能进行读和写的操作，这个过程称为低级格式化。低级格式化为磁盘的每个扇区采用特别的数据结构，每个扇区的数据结构通常由头，数据区域，尾部组成。为了使得磁盘存储文件，OS还需要把自己的数据结构记录在磁盘上，第一步把磁盘分为由一个或多个柱面组成的分区（C盘，D盘等），第二部对物理分区进行逻辑格式化（创建文件系统），OS把初始文件系统数据结构存储在磁盘上，这些数据结构包括空闲和已分配空间及一个初始为空的目录。  </li><li>引导块：计算机启动时运行初始化程序，初始化各类资源等，接着就启动OS。引导的这个自举程序的磁盘围殴启动磁盘/系统磁盘。    </li><li>坏块：硬件故障，OS处理不了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/052018155.html"/>
      <url>/2022/052018155.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>MVC设计模式：当拿到任何一个需求的时候，都可以从MVC三个方面进行拆分</p><ul><li><p>M：Model，模型，处理数据</p></li><li><p>V：View，视图，接收和显示数据</p></li><li><p>C：Controller，控制器，由谁来接收和显示数据，有谁来处理数据</p></li></ul><p>三层结构：企业级应用的要求</p><ul><li>表示层</li><li>业务逻辑层</li><li>数据访问层</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>spring是一个开源框架，是为了解决企业级应用开发的复杂性而设计的</li><li>spring最根本的使命：全方位的简化java开发</li><li>核心思想：<ul><li>IoC：控制反转，就是把依赖对象创建的控制权交给第三方（Spring容器）来管理</li><li>DI：依赖注入，组件之间的依赖关系，在程序运行期间，由第三方动态注入</li></ul></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>添加 spring 依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>添加spring容器的配置类，并添加组件</p><pre><code>@Configurationpublic class AppConfig {    @Bean(name = {"empDao1","empDao2"})    public EmpDao empDao() {        return new EmpDaoImpl();    }}</code></pre></li><li><p>测试</p><pre><code>public class EmpDaoTest {    @Test    public void testInsert() {        //启动容器        ApplicationContext c =                new AnnotationConfigApplicationContext(AppConfig.class);        //得到组件        //EmpDao empDao = c.getBean(EmpDao.class);        //通过组件名得到组件,默认是方法名        EmpDao empDao = (EmpDao)c.getBean("empDao2");        //调用业务方法        empDao.insert();        //关闭容器        ((AnnotationConfigApplicationContext)c).close();    }}</code></pre></li><li><p>组件装配</p><pre><code>@Getter@Setterpublic class EmpServiceImpl implements EmpService {    private EmpDao empDao ;    @Override    public int insert() {        return empDao.insert();    }}</code></pre><p>属性注入：</p><pre><code>@Configurationpublic class AppConfig {    @Bean(name = {"empDao1","empDao2"})    public EmpDao empDao() {        return new EmpDaoImpl();    }    @Bean    public EmpService empService() {        EmpServiceImpl service = new EmpServiceImpl();        //依赖注入        service.setEmpDao(empDao());        return service;    }}</code></pre><p>构造注入：</p><pre><code>@Getter@Setterpublic class EmpServiceImpl implements EmpService {    public EmpServiceImpl() {    }    public EmpServiceImpl(EmpDao empDao) {        this.empDao = empDao;    }    private EmpDao empDao ;    @Override    public int insert() {        return empDao.insert();    }}</code></pre><pre><code>@Bean    public EmpService empService() {        EmpServiceImpl service = new EmpServiceImpl(empDao());        return service;    }</code></pre><p>依赖注入三种方式：</p><ul><li>属性注入</li><li>构造注入</li><li>接口注入（Spring不支持该方式）</li></ul></li></ol><h2 id="Bean说明"><a href="#Bean说明" class="headerlink" title="Bean说明"></a>Bean说明</h2><ol><li><p>@Scope:作用域（单例：singleton（默认的），原生：prototype）</p><pre><code>@Bean@Scope("prototype")public EmpService empService() {    EmpServiceImpl service = new EmpServiceImpl(empDao());    return service;}</code></pre></li><li><p>@Lazy：懒加载（延迟加载，在getBean()的时候再加载），默认值@Lazy（false）</p><p>注意：在@Scope(“prototype”)的时候，一定是懒加载的</p><pre><code>    @Bean//    @Scope("prototype")    @Lazy(true)    public EmpService empService() {        EmpServiceImpl service = new EmpServiceImpl(empDao());        return service;    }</code></pre></li><li><p>组件扫描</p><ul><li><p>在配置类上添加组件扫描注解</p><pre><code>@Configuration@ComponentScan(basePackages = {"com.neu.dao","com.neu.service"})public class AppConfig {}</code></pre></li><li><p>在需要成为组件的类上添加@Component注解（组件默认名字为：类名首字母小写）</p><pre><code>//组件@Componentpublic class EmpDaoImpl implements EmpDao {}</code></pre></li></ul></li><li><p>自动装配</p><pre><code>//默认按照类型装配@Autowiredprivate EmpDao empDao ;</code></pre></li><li><p>解决自动装配冲突（使用组件名装配）</p><pre><code>@Autowired@Qualifier("empOracleDaoImpl")//注解参数就是组件名，默认为类名首字母小写private EmpDao empDao ;</code></pre></li><li><p>修改组件的默认名</p><pre><code>@Component(value = "oracleemp")public class EmpOracleDaoImpl implements EmpDao {}</code></pre></li></ol><h2 id="使用Spring的测试模块"><a href="#使用Spring的测试模块" class="headerlink" title="使用Spring的测试模块"></a>使用Spring的测试模块</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>测试</p><pre><code>//设置配置文件@ContextConfiguration(classes = {AppConfig.class})//相当于测试框架与Spring的一个接口@RunWith(SpringJUnit4ClassRunner.class)public class EmpTest {    @Autowired    private EmpService empService;    @Test    public void testInsert() {        empService.insert();    }}</code></pre></li></ol><h2 id="Spring对持久层的支持"><a href="#Spring对持久层的支持" class="headerlink" title="Spring对持久层的支持"></a>Spring对持久层的支持</h2><h3 id="在Spring中使用数据库连接池"><a href="#在Spring中使用数据库连接池" class="headerlink" title="在Spring中使用数据库连接池"></a>在Spring中使用数据库连接池</h3><ol><li><p>导入连接池及数据库驱动</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.22&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;    &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义一个属性文件（db.properties）,在其中配置数据库连接池需要的参数</p><pre><code>jdbc.username=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/neusoft?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.driverClassName=com.mysql.cj.jdbc.Driverjdbc.maxActive=20jdbc.maxWait=2000jdbc.maxIdle=5</code></pre></li><li><p>定义一个配置类，读取数据库连接属性文件</p><pre><code>package com.neu;import javax.sql.DataSource;import org.apache.commons.dbcp.BasicDataSource;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;@Configuration//配置属性源文件@PropertySource("classpath:db.properties")public class DBConfig {    @Value("${jdbc.username}")    private String username;    @Value("${jdbc.password}")    private String password;    @Value("${jdbc.url}")    private String url;    @Value("${jdbc.driverClassName}")    private String driverClassName;    @Value("${jdbc.maxActive}")    private int maxActive;    @Value("${jdbc.maxWait}")    private int maxWait;    @Value("${jdbc.maxIdle}")    private int maxIdle;    @Bean    public DataSource dataSource() {        BasicDataSource ds = new BasicDataSource();        ds.setUsername(username);        ds.setPassword(password);        ds.setUrl(url);        ds.setDriverClassName(driverClassName);        ds.setMaxActive(maxActive);        ds.setMaxIdle(maxIdle);        ds.setMaxWait(maxWait);        return ds;    }}</code></pre></li><li><p>测试</p><pre><code>@ContextConfiguration(classes = {AppConfig.class,DBConfig.class})//相当于测试框架与Spring的一个接口@RunWith(SpringJUnit4ClassRunner.class)public class EmpTest {    @Autowired    private EmpService empService;    @Autowired    private DataSource dataSource;    @Test    public void testDataSource() throws SQLException {        Connection connection = dataSource.getConnection();        System.out.println("连接成功！");        connection.close();    }    @Test    public void testInsert() {        empService.insert();    }}</code></pre><h2 id="Spring与Mybatis集成"><a href="#Spring与Mybatis集成" class="headerlink" title="Spring与Mybatis集成"></a>Spring与Mybatis集成</h2><ol><li><p>导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置SqlSessionFactory</p><pre><code>@Configuration@ComponentScan(basePackages = {"com.neu.service","com.neu.mapper"})public class MybatisConfig {    @Autowired    private DataSource dataSource;    @Bean    public SqlSessionFactory sqlSessionFactory() throws Exception {        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();        factory.setDataSource(dataSource);        return factory.getObject();    }}</code></pre></li><li><p>配置 mapper 扫描</p><pre><code>@Configurationpublic class MybatisMapperScannerConfig {    @Bean    public MapperScannerConfigurer mapperScannerConfigurer() {        MapperScannerConfigurer c = new MapperScannerConfigurer();        c.setSqlSessionFactoryBeanName("sqlSessionFactory");        c.setBasePackage("com.neu.mapper");        return c;    }}</code></pre></li></ol></li></ol><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ol><li>spring+mybatis实现如下功能（使用单元测试，业务逻辑层+数据访问层）：<ul><li>查询所有员工信息</li><li>添加员工</li><li>删除员工</li><li>分页查询员工（每页显示3条记录，打印第2页数据）</li></ul></li></ol><h2 id="Spring-Mybatis-Servlet"><a href="#Spring-Mybatis-Servlet" class="headerlink" title="Spring+Mybatis+Servlet"></a>Spring+Mybatis+Servlet</h2><ol><li><p>修改打包方式：war</p></li><li><p>导入相关web依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ol><li><p>定义：面向切面编程，模块化横切关注点（把相同的代码加到关注的方法上）</p></li><li><p>导入包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;    &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;    &lt;version&gt;1.7.3&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>定义一个类，实现切面的功能（类定义在com.neu.utils包下，要把该包添加到组件的扫描路径中）</p><pre><code>@Configuration@EnableAspectJAutoProxy//开启切面自动代理@Component@Aspect//切面public class AOPUtil {    //切点(切入点):加入相同代码的一组关注点(连接点)    @Pointcut("execution (* com.neu.mapper.*.*(..))")    public void pointcut() {    }    //通知    @Around("pointcut()")    public Object around(ProceedingJoinPoint p) throws Throwable {        long startTime = System.nanoTime();        //调用代理的方法        Object object = p.proceed();        long m = System.nanoTime() - startTime;        System.out.println(m);        return object;    }}</code></pre><ul><li>连接点（joinPoint)：程序执行过程中的特定点</li><li>通知（Advice）：在特定连接点加入的代码</li><li>切入点（pointcut）：加入相同通知的一组连接点</li><li>切面（aspect）：通知与切入点的组合</li></ul></li><li><p>前置通知</p><pre><code>@Before("pointcut()")    public void before() {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String format = f.format(new Date());        System.out.println("开始执行方法："+format);    }</code></pre></li><li><p>返回后通知：执行了return语句后执行的代码</p><pre><code>@AfterReturning("pointcut()")    public void afterReturning() {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String format = f.format(new Date());        System.out.println("方法正常结束："+format);    }</code></pre></li><li><p>异常通知：</p><pre><code>@AfterThrowing("pointcut()")    public void afterThrowing() {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String format = f.format(new Date());        System.out.println("抛出异常："+format);    }</code></pre></li><li><p>最终通知</p><pre><code>@After("pointcut()")    public void after() {        SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");        String format = f.format(new Date());        System.out.println("方法最终结束时间："+format);    }</code></pre></li><li><p>环绕通知</p><pre><code>@Around("pointcut()")    public Object around(ProceedingJoinPoint p) throws Throwable {        long startTime = System.nanoTime();        //调用代理的方法        Object object = p.proceed();        long m = System.nanoTime() - startTime;        System.out.println(m);        return object;    }</code></pre></li></ol><h2 id="Spring对事务的支持"><a href="#Spring对事务的支持" class="headerlink" title="Spring对事务的支持"></a>Spring对事务的支持</h2><ol><li><p>添加事务管理器</p><pre><code>@Beanpublic PlatformTransactionManager transactionManager() {    return new DataSourceTransactionManager(dataSource());}</code></pre></li><li><p>启用事务管理器</p><pre><code>@Configuration//配置属性源文件@PropertySource("classpath:db.properties")@EnableTransactionManagement//启用事务管理器public class DBConfig {}</code></pre></li><li><p>在业务逻辑类上或方法上添加@Transactional</p><p>当添加了事务注解的方法中，抛出异常，则回滚事务，否则，提交事务</p><pre><code>@Transactional    public int insert(Dept dept) {        deptMapper.insert(dept);        return deptMapper.insert(dept);    }</code></pre></li></ol><h2 id="使用静态资源"><a href="#使用静态资源" class="headerlink" title="使用静态资源"></a>使用静态资源</h2><ol><li><p>在 webapp 目录下，新建一个文件夹：staitc，在其中放入静态资源（css、js）</p><p>例如：/webapp/static/css/style1.css</p></li><li><p>配置资源注册</p><pre><code>@Configuration@EnableWebMvc//启用mvc注解驱动@ComponentScan(basePackages = "com.neu.controller")public class SpringMVCConfig implements WebMvcConfigurer {    @Override    public void addResourceHandlers(ResourceHandlerRegistry registry) {        registry.addResourceHandler("/static/**").addResourceLocations("/static/");//访问的静态资源    }}</code></pre></li><li><p>在 jsp 中引入css</p><pre><code>&lt;link rel="stylesheet" href="${ pageContext.request.contextPath }/static/css/style1.css"&gt;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理</title>
      <link href="/2022/05198490.html"/>
      <url>/2022/05198490.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><img src="/2022/05198490/1.jpg" class="">   <h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h3 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><ul><li>内存是存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理。内存中有程序段和数据段，也就是指令和数据。一个内存地址对应一个存储单元，存储单元大小由计算机编址决定。    <img src="/2022/05198490/101.jpg" class="">   </li><li>尽管内存不断增大，但仍然不可能把所有用户进程和系统所需要的全部程序与数据放入主存，因此OS必须对内存空间进行合理划分和有效动态分配。<br>定义：OS对内存的划分和动态分配。  </li><li>功能有：<br>①内存空间的分配和回收：OS完成主存空间分配和管理，使人工不负责分配。<br>②地址转换：把程序逻辑地址转换为物理地址。<br>③内存空间的扩充：利用虚拟存储技术/自动覆盖技术，逻辑上扩充内存。<br>④存储保护：保证各作业在各自内存空间内运行，互不干扰。  </li><li>在具体内存管理之前，首先要了解进程运行基本原理和要求：<br>①程序装入和链接：  <img src="/2022/05198490/102.jpg" class="">   创建进程首先要将程序和数据装入内存，把用户源程序变成内存中执行程序：<br>Ⅰ编译：编译程序把用户源代码编译成若干目标模块。<br>Ⅱ链接：链接程序把编译好的一组目标模块以及所需要的库函数链接在一起，形成一个完整装入模块。<br>Ⅲ装入：装入程序将装入模块装入内存中。   <img src="/2022/05198490/2.jpg" class="">   程序链接有三种方式：<br>Ⅰ静态链接：程序运行之前，各模块及所需库函数链接成一个完整可执行程序，不再拆开。<br>Ⅱ装入时动态链接：把用户源程序编译后得到一组目标模块，装入时采用边装边链接。<br>Ⅱ运行时动态链接：对于某些目标模块的链接是在程序执行中需要该目标模块时才进行的，优点就是便于修改更新，便于实现对于目标模块的共享。<br>内存的装入也有三种方式：<br>Ⅰ绝对装入：编译时若知道程序所留内存位置，则编译程序之间产生绝对地址目标代码，装入模块中地址，且程序中逻辑地址和实际地址完全相同，因此不需要对于程序和数据的地址进行修改。绝对装入方式只适合于单道程序环境。  <img src="/2022/05198490/103.jpg" class="">     Ⅱ可重定位装入：多道程序环境下，多个目标模块的起始地址通常从0开始，程序中的其他地址都是相对于起始地址的，此时应该采用可重定位装入方式，根据内存当前情况装入适当位置，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成，又称静态重定位，特点就是一个作业装入内存时必须有所需全部内存空间，否则不能装入该作业，一旦进入内存，整个运行期间不能移动，也不能再申请内存空间。  <img src="/2022/05198490/104.jpg" class="">   Ⅲ动态运行时装入：也是动态重定位，程序在内存中若发生移动，则需要采用动态装入方式，装入内存后不立马把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行，因此钻杆如内存后所有地址为相对地址，需要要一个重定位寄存器支持。特点：可以把程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。   <img src="/2022/05198490/3.jpg" class="">   <img src="/2022/05198490/105.jpg" class="">   ②逻辑地址空间与物理地址空间：<br>编译后，每个目标模块都从0开始编址，称为该目标模块的相对地址（逻辑地址），当链接程序链接成一个完整可执行程序时，链接程序顺序依次按照各个模块的相对地址构成统一的0号单元开始编址的逻辑地址空间。<br>而物理地址空间指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后通过物理地址从主存中获取，当装入程序将可执行代码装入内存时必须把逻辑地址转换为物理地址，这个过程称为重定位。<br>③内存保护：<br>内存分配前，保护OS不受用户进程影响，同时保护用户进程不受其他进程影响：<br>Ⅰ在CPU中设置上，下限寄存器，存放用户作业在主存中的上下限地址，每当CPU访问地址分别和上下限对比，判断是否越界。  <img src="/2022/05198490/106.jpg" class="">   Ⅱ采用重定位寄存器和界地址实现保护：重定位寄存器含最小物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。  <img src="/2022/05198490/4.jpg" class="">   <h3 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h3>多道程序环境下扩充内存的两种方法。</li><li>覆盖：由于程序运行时不是任何时候都需要访问程序和数据各个部分，所以把用户空间分成一个固定区和若干覆盖区，活跃部分放在固定区，其余部分按照调用关系进行分段，把即将访问的段放入覆盖区，其他段放入外存，需要调用再调入覆盖区，替换覆盖区中原有段。<br>特点就是打破了全部信息装入内存后才能运行的限制，但同时运行代码大于主存的时候仍然不能运行，此外内存更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。  <img src="/2022/05198490/107.jpg" class="">     </li><li>交换：把处于等待状态的程序从内存转到辅存，把内存空间腾出来，称为换出。把准备竞争CPU运行的程序从辅存移动到内存，这一过程又称为换入。（中级调度就是交换技术）PCB仍然在内存中<br>特点就是主要在不同进程之间进行，而覆盖是同一个进程中。   <h3 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h3></li><li>指为一个用户程序分配一个连续的内存空间，包括单一连续分配和固定分区分配和动态分区分配。  </li><li>单一连续分配：系统分为系统区和用户区，系统区仅仅让OS使用，通常在低地址部分。这种方式无须内存保护，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。优点就是简单，无外部碎片，可以用覆盖技术。缺点是只用于单道程序系统。  <img src="/2022/05198490/108.jpg" class="">  </li><li>固定分区分配：最简单的多道程序存储管理方式，把用户内存空间划分为若干固定大小区域，每个分区只装入一道作业，当有空闲分区时便可以再从后备作业队列选择适当大小作业装入分区，而划分分区还有两种方法：①分区大小相等②分区大小不等（多个小分区，适量中分区，少量大分区）<br>为了便于内存分配，通常按分区大小排队，建立分区说明表（包括每个分区起始地址，大小，状态是否分配）  <img src="/2022/05198490/5.jpg" class="">   问题：程序可能大到任何分区装不下。且主存利用率低，当程序小于固定分区大小的时候也浪费了分区空间（称为内部碎片）。  <img src="/2022/05198490/109.jpg" class="">  <img src="/2022/05198490/110.jpg" class="">  </li><li>动态分区分配：进程装入内存时根据内存大小动态建立分区，使得分区大小合适进程。分区的大小和数目都是可变的。开始分配时是好的，但随着分配进行会产生若干小的内存块，这些小的内存块称为外部碎片，为了克服外部碎片通过“紧凑”技术来解决（OS对于进程的移动和整理）<br>记录空闲分区：  <img src="/2022/05198490/111.jpg" class="">  分配空闲分区：<br>首次进程装入主存，OS确定分配哪个内存块给进程使用，分配策略算法：<br>①首次适应算法（First Fit）：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到第一个大小满足要求的第一个空闲分区。<br>②最佳适应算法（Best Fit）：空闲分区按照容量递增形成分区链，找到第一个满足要求的空闲分区。会产生越来越多外部碎片。<br>③最坏适应算法（Worst Fit）：空闲分区按照容量递减形成分区链，找到第一个满足要求的空闲分区。大进程到来的时候没有空间存放。<br>④邻近适应算法（Next Fit）：由首次适应算法演变而来，分配内存时从上次查找结束的位置开始继续查找。<br>！！！首次适应算法效果最好！！！<img src="/2022/05198490/113.jpg" class="">  <img src="/2022/05198490/6.jpg" class="">   <img src="/2022/05198490/112.jpg" class="">  <h3 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h3></li><li>允许一个程序分散装入不相邻的内存区，也根据分区大小是否固定，分为分页存储管理方式和分段存储管理方式。</li><li>分页存储模式又根据运行作业时是否把作业所有页面都撞入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式，只介绍基本分页存储管理方式。<br>①基本分页存储管理方式：<br>固定分区产生内部碎片，动态分区产生外部碎片，内存利用率都比较低。为了避免碎片产生，引入分页思想：把主存空间划分为大小相等且固定的块，作为主存的基本单位，进程也以块为单位进行划分，进程在执行以块为基本单位逐个申请主存中的块空间。<br>类似于固定分区，但本质不同：块大小比分区小很多，而且进程也按照块进行划分，所以即使有内部碎片也是很小的（页内碎片）。<br>—几个基本概念：<br>Ⅰ页面和页面大小：进程中的块称为“页”，内存中的块称为“页帧Page Frame”。外存也以同样的单位进行划分，直接称为块Block，进程执行需要申请主存空间，即要为每个页面分配主存中可用页帧，产生了页和页帧的一一对应。为了方便地址转换，页面大小应该是2的整数幂，大小适中。页面太小会使得进程页面数过多，页表过长，占用大量内存，增加硬件地址转换的开销，降低页面转入转出的效率。页面过大又会使页内碎片增多，降低内存利用率，所以大小应该适中，要在空间效率和时间效率间抉择。  <img src="/2022/05198490/114.jpg" class="">  Ⅱ地址结构：页号P和页内偏移量W。地址长度为32位，0-11为页内地址，每页大小为4KB，12-31位为页号，地址空间最多允许2的20次方页。  <img src="/2022/05198490/115.jpg" class="">   <img src="/2022/05198490/116.jpg" class="">  Ⅲ页表：为了便于内存中查找进程每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，页表一般放在内存中。页表由页表项组成的，第一部分是页号，第二部分与地址结构的第二部分共同组成物理地址。配置页表之后，进程执行时，通过查找该表，找到每页在内存中的物理块号。  <img src="/2022/05198490/9.jpg" class="">   <img src="/2022/05198490/117.jpg" class="">  —基本地址变换机构：<br>地址变换机构的任务是将逻辑地址转换为内存中的物理地址，地址变换是借助页表实现的。页表寄存器（存放页表起始地址，存放页表长度）  <img src="/2022/05198490/7.jpg" class="">   每次访问存储操作都需要从逻辑地址到物理地址，转换地址过程必须足够快，否则访问速度会降低。每个进程引入页表，用户存储映射机制，页表不能太大否则内存利用率降低。  <img src="/2022/05198490/118.jpg" class=""> —具有快表的地址变换机构：<br>局部性原理：  <img src="/2022/05198490/119.jpg" class="">  若页表全部放在内存中，存取一个数据/指令至少访问两次内存，第一次是访问页表获取物理地址，第二次是存取数据/指令，显然比通常执行指令慢了一半。<br>为此增设了一个并行查找能力的告诉缓冲存储器——快表，又称TLB，用来存放当前访问的若干页表项，加速地址变化的过程，而主存中的页表常称为慢表。  <img src="/2022/05198490/8.jpg" class="">   <img src="/2022/05198490/120.jpg" class="">   —两级页表：<br>整个页表需要连续存储内存中，但一级页表可能太大了，所以定义了两级页表。<br>逻辑结构是一级页号+二级页号+页内偏移。为了压缩页表，进一步延申页表映射的思想。  <img src="/2022/05198490/121.jpg" class="">  ②基本分段存储管理方式：<br>分页管理目的为了提高内存利用率，通过硬件实现。而分段提出考虑了用户和程序员，满足方便编程，信息保护和共享，动态增长，等多方面需要。  <img src="/2022/05198490/122.jpg" class="">  Ⅰ分段：按照用户进程中的自然段划分逻辑空间。每段从0开始编址，并且分配一段连续的地址空间，其逻辑地址由段号S和段内偏移量W两部分组成。段号16为，偏移量16位，一个作业最多2的16次方=65536段，最大段长为64KB。（页系统的S和W对于用户透明，而端系统则是由用户提供的）  <img src="/2022/05198490/10.jpg" class="">   <img src="/2022/05198490/123.jpg" class="">  Ⅱ段表：每个进程都有一个逻辑空间与内存空间映射的段表。  <img src="/2022/05198490/11.jpg" class="">   配置表之后，执行中的进程可以通过查找段表，找到每段所对应的内存区。  <img src="/2022/05198490/12.jpg" class="">   <img src="/2022/05198490/124.jpg" class="">  Ⅲ地址变换机构：实现进程从逻辑地址到物理地址的变换功能，再系统设置了段表寄存器，用于存放段表起始位置F和段表长度M。段表寄存器（段表起始地址，段表长度）   <img src="/2022/05198490/13.jpg" class="">   <img src="/2022/05198490/125.jpg" class="">   Ⅳ段的共享和保护：通过两个作业的段表中响应表项指向被共享的段的同一个物理副本来实现的，不能修改的数据和代码可以共享。  </li><li>分段分页对比：  <img src="/2022/05198490/126.jpg" class="">   ③段页式管理方式：<br>作业地址空间首先分成若干逻辑段，每段都有自己段号，段分成若干大小固定的页，内存仍然分成和页面大小相同的块。   <img src="/2022/05198490/127.jpg" class="">   <img src="/2022/05198490/128.jpg" class="">  <img src="/2022/05198490/129.jpg" class="">   <h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h3 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h3></li><li>传统存储方式特征：①一次性：作业一次性装入内存，才可以运行，但如果作业大无法装入，且大量作业同时运行无法满足只能少部分作业先运行，多道程序度降低。②驻留性：作业装入之后不换出 ，可能长期等待状态。  </li><li>局部性原理：高速缓存依赖的就是局部性原理，有两方面：①时间局部性：程序中指令和数据可能大量循环执行。②空间局部性：程序访问某个存储单元，不久之后附近的存储单元也将被访问，即程序一段时间内访问的地址可能是集中在一定范围内。<br>时间局部性通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存层次结构实现。空间局部性通常使用较大的高速缓存，并把预处理机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了“内存-外存”的两级存储器机构，利用局部性原理实现高速缓存。  <img src="/2022/05198490/130.jpg" class="">   </li><li>虚拟存储器的定义和特征：<br>基于局部性原理，程序装入时，把程序的一部分装入内存，其余部分留在外存，就可以启动程序运行。在程序执行过程中，当所访问信息不在内存时，由OS将所需的部分调入内存继续执行程序，OS把不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这时系统好像为用户提供了一个比实际内存大得多的存储器称为虚拟存储器。<br>只是由于系统提供了部分装入，请求调出和置换功能之后，给用户感觉像存在一个比实际内存大得多的存储器。大小由计算机地址结构决定，并不是内存+外存，特征有：①多次性：作业无须一次性全部装入内存，允许多次调入内存运行。②对换性：作业无须一直等待在内存中， 允许换进换出。③虚拟性：逻辑上扩充内存容量。  </li><li>虚拟内存技术实现：<br>允许一个作业多次调入内存，所以采用连续分配方式时使得相当一部分内存处于空闲，所以需要建立在离散分配的内存管理方式的基础上。<br>有三种方式：请求分页存储管理，请求分段存储管理，请求段页式存储管理。但无论哪种方式都需要硬件支持：一定容量内存和外存，页表机制，中断机构，地址变换机构。<h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3></li><li>建立在基本分页系统基础上，为了支持虚拟存储区功能而增加了“请求调页”和“页面置换”功能，也是最常用的方法。请求分页管理方式中：只要求让当前需要的一部分页面装入内存便可开始运行作业，当访问页面内存中不存在时，再通过调页功能将其调入，同时还可以通过页置换功能把暂时不用的页面换出到外存，腾出内存空间。  </li><li>页表机制：  <img src="/2022/05198490/14.jpg" class="">  比基本分页管理中页表项多个4个字段：<br>①状态位P：用于指示该页是已经调入内存。<br>②访问字段A：记录本页一段时间内被访问次数（页置换时使用）。<br>③修改位M：标识该页调入内存中是否被修改过。<br>④外存地址：该页外存上的地址，通常是物理块号。   <img src="/2022/05198490/131.jpg" class="">   </li><li>缺页中断机构：<br>访问页面不在内存中，便产生缺页中断，请求操作系统把所缺少的页调入内存，此时应该把缺页的进程阻塞，若内存有空闲块，则分配一个块，把调入的页传入该块，并修改页表中相应页表项，无空闲块则要淘汰某页（淘汰的页如果修改过则要写回外存）。<br>缺页中断作为中断，同样经历中断的几个步骤，但有两个明显区别：①在指令执行期间而非之后产生和处理中断信号，属于内部中断。②一条指令执行期间，可能产生多次缺页中断。  </li><li>地址变换机构：<br>是在分页系统地址变换机构的基础上，为实现虚拟内存，增加了某些功能而形成的。地址变换时，先检索快表。  <img src="/2022/05198490/15.jpg" class="">   <img src="/2022/05198490/132.jpg" class="">   <h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3></li><li>进程运行访问页面不在内存中而需要把它调入，但内存已无空闲空间，就需要从内存中调出一页程序或数据送入磁盘的对换区。选择调出的页面算法就是页置换算法，好的页置换算法应该有较低的页面置换频率。追求最少的缺页率！！！      </li><li>最佳置换算法OPT：<br>选择淘汰的页面是以后永不使用的页面，或是在最长时间内不再访问的页面，以保证最低的缺页率（但未知进程下不知道哪个是最长不被访问的，所以无法实现），但可以用作评价其他置换算法。  <img src="/2022/05198490/16.jpg" class="">   </li><li>先进先出页面置换算法FIFO：<br>优先淘汰先进入内存的页面，即留在内存最长时间的页面，但算法跟实际运行规律不符。<br>而且FIFO算法还会产生所分配的物理块增大而页故障数不减反增的异常现象（Belady异常），而LRU和OPT算法不会出现Belady异常。   <img src="/2022/05198490/17.jpg" class="">   </li><li>最近最久未使用置换算法LRU：<br>选择最长时间为访问过的页面淘汰，过去时间未访问过的页面将来也不会访问。OPT是向后看，而LRU是向前看。LRU性能较好。   <img src="/2022/05198490/18.jpg" class="">   </li><li>时钟置换算法CLOCK：<br>LRU实现困难，开销大，且性能接近OPT。因此试图使用较小的开销但性能接近LRU的算法，都是CLOCK的变体。简单CLOCK算法给每帧关联一个附加位，称为使用位。当该页首次装入主存，使用位为1，随后再次被访问到时也为1。用于替换的候选帧集合视为一个循环缓冲区，并有一个指针与之关联，当某页被替换时该指针被设置指向缓冲区的下一帧，当需要替换一页时，OS把该位重新置为0。若开始过程时，缓冲区所有帧为0，则选择遇到第一个帧替换，若全为1，则指针在缓冲区完整循环一周，把所有使用位置为0，并停留在最初的位置，替换该帧的页，又称为最近未用算法(NRU)。<br>通过增加使用位数目，可以使得CLOCK算法更高效，再增加一个修改位，得到改进型CLOCK置换算法，则出现四种情况：<br>①最近未被访问，也未被修改（u=0，m=0）<br>②最近被访问，但也未被修改（u=1，m=0）<br>③最近未被访问，但被修改（u=0，m=1）<br>④最近被访问，也被修改（u=1，m=1）<br>算法步骤如下：<br>①指针从当前位置开始，扫描帧缓冲区，对使用位不作任何修改，选择遇到的第一个帧（u=0，m=0）用于替换。<br>②若①失败，则重新扫描，查找（u=0，m=1）的帧，选择第一个这样的帧替换，对于每个跳过的帧，使用位都设置为0.<br>③若②失败，则指针回到最初位置，且集合中所有帧使用位为0，重复①，若有必要重复②。  <h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3></li><li>“调多少，啥时候调，哪里调”</li><li>驻留集大小：给进程分配的物理块集合<br>对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程所有页读入主存，因此OS决定读取多少页，即决定给特定的进程分配几个页框，就是这个进程的驻留集，考虑以下几点：<br>①分配给一个进程存储量越小，任何时候驻留在主存中的进程数越多，提高处理机时间利用率。<br>②一个进程主存中页数过少，则尽管有局部性原理，但页错误率仍然较高。<br>③页数过多，则局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显影响。  </li></ul><p>基于这些因素，OS常采用三种策略：<br>①固定分配局部置换：物理块数量固定，数目不好确定，太少频繁缺页中断，太多资源利用率下降。<br>②可变分配全局置换：易实现，进程分配一定物理块，OS内也有空间物理块，发生缺页就去拿一个物理块给进程，并调页进其中，更加灵活。但盲目加物理块导致多道程序并发能力下降。<br>③可变分配局部置换：从该进程在内存的页面中选出一页换出，频繁换页则分配物理块，若缺页率低则减少物理块。不仅动态增加，还能减少，保证系统均衡。  </p><ul><li><p>调入页面时机：<br>两种策略：<br>①预调页策略：根据局部性定理，一次调入若干页可能比逐次搞笑，但调入很多未访问则是低效。所以预测为基础的预调页策略，预计不久之后被访问的页面预先调入内存。<br>②请求调页策略：进程运行中需要请求调页。缺点就是一次只能调一页。<br>实际上预调页就是运行前调入，请求调页就是运行期间调入，一般两种策略同时使用。  </p></li><li><p>从何处调入页面：<br>请求分页系统中的外存分为两部分：用于存放文件的文件去和用于存放兑换页面的对换区。对换区常用连续分配方式，文件区用离散分配方式，因此对换区IO速度比文件区更快，有三种情况：<br>①系统拥有足够对换区空间：可以全部从对换区调入页面，提高调页速度，所以进程运行前把所有的所需文件从文件区复制到对换区。<br>②系统缺少足够对换区空间：凡是不会被修改的文件都直接从文件区调入，修改的部分需要调入对换区，再从对换区调入内存。<br>③UNIX方式：与进程有关文件都放在文件区，因此未运行过的页面都在文件区调入，曾经运行过的放在对换区，因此下次调入时应从对换区调入。  </p><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>页面置换时一种最糟糕情形是刚刚换出页面马上换入主存，频繁的页面调入行为就是抖动/颠簸，若一个进程在换页时间多于执行时间，则这个进程就在颠簸。主要原因就是，某个进程频繁访问的页面数目高于可用的物理页帧数（分配的物理块不够，太多降低并发度）。  </p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>指某段时间间隔内，进程要访问的页面集合，可用最近访问过的页面确定工作集。一般说，工作集W可由时间t和工作窗口大小来确定。   </p><img src="/2022/05198490/19.jpg" class="">   <img src="/2022/05198490/133.jpg" class="">   <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/05198490/20.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2022/051838008.html"/>
      <url>/2022/051838008.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li><p>Apache Maven是一个（特别是Java编程）项目管理及自动构建工具，由Apache软件基金会所提供。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p></li><li><p>项目管理工具：编译、测试、运行、打包（jar、war）、部署</p></li><li><p>依赖管理</p></li><li><p>下载</p><p>地址：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><img src="/2022/051838008/1.jpg" class="">   </li><li><p>安装、配置</p><ul><li>直接解压即可</li><li><p>配置环境变量：</p><ul><li>M2_HOME=&gt;maven解压目录</li><li>修改 path=》添加 %M2_HOME%\bin</li></ul></li><li><p>测试：mvn -v</p></li></ul></li><li><p>maven仓库</p><ul><li>本地仓库：本地的一个文件夹</li><li>中央仓库：世界唯一，由maven社区维护（网站）</li><li>远程仓库：是位于web服务器上的一个私有仓库，由自己公司创建和维护</li><li>镜像仓库：是中央仓库的镜像（副本），目的是加快依赖jar包的下载速度</li></ul></li><li><p>修改maven配置</p><ul><li><p>修改：maven安装目录下的 conf/settings.xml</p><ul><li><p>修改本地仓库位置：</p><pre><code>&lt;localRepository&gt;D:\mavenrepository&lt;/localRepository&gt;</code></pre></li><li><p>配置阿里云镜像</p></li></ul><pre><code>&lt;mirrors&gt;    &lt;mirror&gt;        &lt;id&gt;nexus-aliyun&lt;/id&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        &lt;name&gt;Nexus aliyun&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;&lt;/mirrors&gt;</code></pre></li></ul></li><li><p>在 Idea 中配置</p><ul><li><p>进入 settings</p><img src="/2022/051838008/2.jpg" class="">   </li><li><p>配置maven</p><img src="/2022/051838008/3.jpg" class="">   </li></ul></li></ol><ol><li><p>Eclipse配置配置</p><ul><li><p>配置maven位置：</p><img src="/2022/051838008/4.jpg" class="">   </li><li><p>配置maven的配置文件：</p><p>首选项=》maven=》User settings =》选择settings.xml文件</p><img src="/2022/051838008/5.jpg" class="">   </li></ul></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>maven的目录结构</p><p>src：源程序目录</p><p>​    main：源程序</p><p>​        java：程序</p><p>​        resources：资源文件(配置文件)</p><p>​        webapp:web项目（不是web项目没有）</p><p>​    test：测试代码</p><p>target：项目生成的结果</p></li><li><p>创建maven项目</p><ul><li><p>maven project 向导</p></li><li><p>配置三个坐标（定位唯一的jar包）</p><ul><li>groupId：组织或公司的域名</li><li>artifactId：组件名（项目名）</li><li>version：版本号</li></ul></li><li><p>打包方式</p><ul><li>jar（默认打包方式，控制台项目或window项目）</li><li>war（web项目）</li><li>pom（maven的管理项目）</li></ul></li><li><p>配置 pom.xml</p><pre><code>&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.neu&lt;/groupId&gt;  &lt;artifactId&gt;test3&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;jar&lt;/packaging&gt;  &lt;build&gt;        &lt;plugins&gt;            &lt;!-- 资源文件拷贝插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;                &lt;version&gt;2.7&lt;/version&gt;                &lt;configuration&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- java编译插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;configuration&gt;                    &lt;path&gt;/&lt;/path&gt;                    端口号                    &lt;port&gt;8089&lt;/port&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;            &lt;!-- &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                &lt;version&gt;2.1.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;webResources&gt;                        &lt;resource&gt;                            &lt;excludes&gt;                                &lt;exclude&gt;**/WEB-INF/web.xml&lt;/exclude&gt;                            &lt;/excludes&gt;                            &lt;directory&gt;src/main/webapp&lt;/directory&gt;                        &lt;/resource&gt;                    &lt;/webResources&gt;                   &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;                &lt;/configuration&gt;            &lt;/plugin&gt; --&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;!-- 依赖 --&gt;    &lt;dependencies&gt;        &lt;!-- 单元测试 --&gt;        &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;        &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api --&gt;        &lt;!-- &lt;dependency&gt;            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;            &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;            &lt;version&gt;2.2&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt; --&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre></li></ul><ol><li><p>端口号冲突，解决方法</p><ul><li><p>把原来使用该端口的程序关闭</p><ul><li>在eclipse中关闭</li><li>在任务管理器中关闭 java 进程 或 javaw进程</li></ul></li><li><p>修改当前tomcat服务的端口号，改成与之前冲突不一样即可</p><pre><code>&lt;port&gt;8089&lt;/port&gt;</code></pre></li></ul></li><li><p>web项目</p><ul><li><p>打包方式</p><pre><code>&lt;packaging&gt;war&lt;/packaging&gt;</code></pre></li><li><p>idea中运行</p><ul><li>maven面板中，选中项目</li><li>在 plugins 中选择 tomcat7 =》tomcat7：run=》右键=》Run Maven Build</li></ul></li><li><p>eclipse中运行</p><p>maven build</p><pre><code>tomcat7:run</code></pre></li><li><p>配置 tomcat插件</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;    &lt;version&gt;2.2&lt;/version&gt;    &lt;configuration&gt;        &lt;path&gt;/&lt;/path&gt;        &lt;!-- 端口号 --&gt;        &lt;port&gt;8089&lt;/port&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre></li></ul><ol><li><p>从maven仓库中搜索并添加jar包</p><ul><li>进入maven中央仓库网站（<a href="https://mvnrepository.com/）">https://mvnrepository.com/）</a></li><li>在搜索栏中输入关键字</li><li>在列表中查找需要的版本</li><li>拷贝“maven”中内容到pom.xml的 <dependencies>中</dependencies></li></ul></li><li><p>使用 JSTL</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;jstl&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;taglibs&lt;/groupId&gt;    &lt;artifactId&gt;standard&lt;/artifactId&gt;    &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.taglibs&lt;/groupId&gt;    &lt;artifactId&gt;taglibs-standard-impl&lt;/artifactId&gt;    &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>测试：</p><pre><code>&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    你好！    &lt;c:forEach begin="1" end="10" var="pageNum"&gt;        ${pageNum}    &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol></li></ol></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p>clean：清除先前构建的artifacts（在maven中，把由项目生成的包都叫作artifact）。 </p></li><li><p>validate：验证工程是否正确，所有需要的资源是否可用。 </p></li><li><p>compile：编译项目的源代码。</p></li><li><p>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 </p></li><li><p>Package：把已编译的代码打包成可发布的格式，比如jar。</p></li><li><p>integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。</p></li><li><p>verify：运行所有检查，验证包是否有效且达到质量标准。</p></li><li><p>install：把包安装在本地的repository中，可以被其他工程作为依赖来使用。</p></li><li><p>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 </p></li><li><p>site：为项目生成文档站点。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程管理</title>
      <link href="/2022/051537005.html"/>
      <url>/2022/051537005.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><img src="/2022/051537005/1.jpg" class="">  <h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程的概念和特征"><a href="#进程的概念和特征" class="headerlink" title="进程的概念和特征"></a>进程的概念和特征</h3><ul><li>进程的概念：多道程序环境下，允许多个程序并发执行，此时他们失去封闭性，并且具有间断性及不可再现性。为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</li><li>为了使参与并发执行的程序能独立运行，必须为之配备一个专门的数据结构称为进程控制块PCB，描述进程的基本情况和运行状态，进而控制和管理进程，由程序段，相关数据段和PCB三部分组成了进程映像。所谓创建进程，实质上是创建进程映像中的PCB，而撤销进程实际上也是撤销PCB，即PCB是进程存在的唯一标志。</li><li>定义：进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个单位。就是“时间片”分配的独立单位。  </li><li>组织：  <img src="/2022/051537005/101.jpg" class="">  </li><li>特征：进程是由多道程序的并发执行引出的，它和程序完全不同：<br>①动态性：进程是程序的一次执行，有着创建，活动，暂停，终止等过程，有生命周期，动态性是其最基本特征。<br>②并发性：指多个进程同时存在内存中，可以同时运行。<br>③独立性：指进程实体是一个能够独立运行，获得资源和接收调度的基本单位，必须有PCB。<br>④异步性：由于进程相互制约，进程具有执行的间断性，即按照各自独立不可预知的速度前进，异步性导致结果不可再现性，为此必须配置相应的进程同步性。<br>⑤结构性：每个进程都配置一个PCB进行描述，结构上看进程实体由程序段，数据段，PCB组成。  <h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3></li><li>三种基本状态：  <img src="/2022/051537005/102.jpg" class="">  </li><li>进程动态性，环境动态性，通常5种状态：<br>①运行态：正在运行单处理机环境下，只有一个进程处于运行状态。<br>②就绪态：进程已经获得了除处理机外所有资源，一旦得到处理机可以立即执行，通常有多个就绪进程为就绪队列。<br>③阻塞态/等待态：进程等待某个事件，即使处理机空闲也无法执行。<br>④创建态：正在被创建：首先申请PCB，向PCB填写一些控制和管理进程的信息，然后由系统为该进程分配运行时必要资源，最后把该进程转成就绪态。<br>⑤结束态：进程正在消失，可能是进程正常结束或其他原因中断退出运行。先置为结束态再释放资源和回收等工作。</li><li>五种状态转换：<br>①就绪态-&gt;运行态：就绪态进程被调度指挥，获得处理机资源进入运行态。<br>②运行态-&gt;就绪态：时间片用完了，让出处理机转为就绪态，还有可能是更高优先级的进程就绪的时候抢占处理机。<br>③运行态-&gt;阻塞态：进程请求某资源的使用和分配或等待某事件发生时，从运行态变为阻塞态。<br>④阻塞态-&gt;就绪态：进程等待的事件到来，只等处理机了。  <img src="/2022/051537005/2.jpg" class="">  <img src="/2022/051537005/103.jpg" class="">  <h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3></li><li>主要功能就是对系统中所有进程有效管理，具有创建，撤销，状态转换等功能。一般进程控制的程序段称为原语，特点就是原子性，不可分割的基本单位。  <img src="/2022/051537005/104.jpg" class="">   </li><li>如何实现控制：  <img src="/2022/051537005/105.jpg" class="">   <img src="/2022/051537005/106.jpg" class="">   使用原语只做三件事情：更新PCB信息，把PCB插入合适队列，分配/回收资源</li><li>进程创建：<br>允许一个进程创建另一个，父子进程。子进程继承父进程的资源，撤销时归还给父进程，撤销父进程时撤销所有子进程。过程：<br>①为新进程分配一个唯一进程标识号，申请空白PCB。PCB申请失败则创建失败。<br>②为进程分配资源，必要的内存，若资源不足，进程进入阻塞态等待内存资源。<br>③初始化PCB，包括初始化标志信息，初始化处理机状态信息，控制信息，进程优先级等。<br>④若进程就绪队列能够接纳新进程，就插入就绪队列等待被调度运行。  <img src="/2022/051537005/107.jpg" class="">   </li><li>进程终止：<br>引起终止的事件有：①正常结束。②异常结束（非法指令，运行超时，IO故障）。③外界干扰（外界请求终止，人工干预/父进程撤销等），过程：<br>①根据进程标识符，检索PCB，读出进程状态。<br>②若处于执行状态，立即终止，把资源分配给其他进程。<br>③若有子孙进程，全部终止。<br>④把所有资源，归还给父进程或OS。<br>⑤把PCB删除。  <img src="/2022/051537005/108.jpg" class="">   </li><li>进程阻塞和唤醒：<br>阻塞（主动）就是运行态中等待某事件发生，调用原语Block，过程：<br>①找到进程标识号和PCB。<br>②若执行态则保护现场，转为阻塞态。<br>③把该PCB插入相应事件的等待队列，把处理机分配给其他进程。<br>等待事件发生，调用原语Awake，过程：<br>①找到进程标识号和PCB。<br>②从等待队列移除，变为就绪态。<br>③把该PCB插入就绪队列，等待调度程序调度。  <img src="/2022/051537005/109.jpg" class="">   </li><li>进程切换：<br>处理机从一个进程运行转到另一个进程运行，过程：<br>①保存处理机上下文，包括程序计数器和其他寄存器。<br>②更新PCB信息。<br>③把进程的PCB移入相应队列，如就绪队列，等待队列等。<br>④选择另一个进程执行，更新其PCB。<br>⑤更新内存管理的数据结构。<br>⑥恢复处理机上下文。  <img src="/2022/051537005/110.jpg" class="">   <h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3></li><li>PCB：进程存在唯一标志，通过PCB管理控制进程。  <img src="/2022/051537005/3.jpg" class="">  ①进程描述信息：进程标识符（标识各个进程，唯一），用户标识符（标识进程归属用户）<br>②进程控制和管理信息：进程当前状态（状态信息，作为分配调度的依据），进程优先级。<br>③资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的IO设备信息。<br>④处理机相关信息：主要处理处理机中各寄存器值，当进程切换时，处理机状态信息必须保存在PCB中，重新执行可以从断点继续执行。  </li><li>程序段：能够被进程调度程序调度到CPU执行的程序代码段，多个程序可能有同一个代码段。  </li><li>数据段：可以是进程对应程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。  <h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3></li><li>定义：进程之间信息交换。<br>高级通信方法有三类：共享存储，消息传递，管道通信。  </li><li>共享存储：  <img src="/2022/051537005/111.jpg" class="">   </li><li>管道通信：  <img src="/2022/051537005/112.jpg" class="">   </li><li>消息传递：  <img src="/2022/051537005/113.jpg" class="">   <h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3></li><li>线程的基本概念：<br>引入进程目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量。而引入线程的目的是减小程序在并发执行时所付出的时空开销，提高OS的并发性能。线程最直接的理解就是轻量级“进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID，程序计数器，寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调用和分派的基本单位，线程自己不具有系统资源，只拥有一点运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程中的全部资源，一个线程可以创建/撤销另一个线程，也可以并发执行，也有三种状态：就绪，阻塞和运行。引入线程之后，进程只作为CPU之外系统资源分配单元，而线程是处理机分配单元，由于一个进程内部多个线程，则线程切换开销小。   <img src="/2022/051537005/114.jpg" class="">    </li><li>比较：<br>①调度：线程是独立调度的基本单位，进程是拥有资源的基本单位。<br>②拥有资源：进程是拥有资源的基本单位，而线程没有，但可以访问隶属进程的资源，提出线程就是为了切换线程时开销小，否则没有意义。<br>③并发性：进程线程均可以并发执行，使得操作系统更好的并发性，提高系统吞吐量。<br>④系统开销：由于进程增删，系统都要分配回收资源，开销远大于线程增删。进程切换的时候，涉及当前执行进程的CPU环境保存和新调度进程CPU环境读取，线程切换只需要保存和设置少量寄存器内容，开销很小。且线程同步与通信很容易实现。<br>⑤地址空间和其他资源：进程的地址空间相互独立，而同一个进程内线程共享。<br>⑥通信方面：进程之间通过线程同步和互斥手段辅助，而线程之间读写进入程序数据段来通信。  </li><li>线程的属性：<br>多线程OS把线程作为独立运行的基本单位，此时进程不是基本可执行实体，但仍然具有执行状态，所谓的“执行”状态，就是其中线程在执行，线程主要属性如下：<br>①线程是一个情形实体，不拥有系统资源，但每个线程有唯一标识符和线程控制块（记录线程执行的寄存器和栈等现场状态）<br>②不同线程可以执行相同程序，即同一个程序不同用户调用也是不同线程。<br>③同一个进程中各个线程资源共享。<br>④线程是处理机的独立调度基本单位，多个线程可以并发执行。<br>⑤线程创建之后开启生命周期，直至终结。  <img src="/2022/051537005/115.jpg" class="">    </li><li>线程的实现方式：<br>两类实现方式用户级线程（ULT），内核级线程（KLT）。<br>①用户级线程：有关线程管理的工作都应用程序完成，内核意识不到线程存在，应用程序可以通过使用线程库设计成多线程程序，通常应用程序从单线程程序开始，在该线程中运行，运行任何时刻都可以调用线程库中创建新线程。<br>②内核级线程：线程管理所有工作都由内核完成，应用程序通过调用接口。内核为进程及其内部的每个线程维护上下文信息，调用也在内核基于线程构架基础上完成。<br>③组合方式：线程创建，调度，同步在用户空间，映射到一些内核级线程上。  <img src="/2022/051537005/4.jpg" class="">  </li><li>多线程模型：<br>有些系统同时支持用户线程和内核线程，由此产生了不同的多线程模型，即实现用户级线程和内核级线程的联机方式。<br>①多对一模型：多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见。<br>②一对一模型：每个用户级线程映射到一个内核级线程。<br>③多对多模型：把n个用户级线程映射到m个内核级线程。m小于等于n。  <img src="/2022/051537005/116.jpg" class="">    <h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h3 id="调度的概念"><a href="#调度的概念" class="headerlink" title="调度的概念"></a>调度的概念</h3></li><li>基本概念：从就绪队列中按照一定算法选择一个进程并把处理机分配给它运行，以实现进程并发地执行。  </li><li>调度的层次：一个作业从提交到开始，往往经历三级调度：<br>①作业调度：又称高级调度，其主要任务是按一定的原则从外存上处于后备的作业中挑选作业给他们分配资源，建立相应的进程，使得他们获得竞争处理机的机会，就是内存与辅存之间的调度。执行频率低，几分钟一次。<br>②中级调度：又称内存调度，其作用是提高内存利用率和系统吞吐量，为此应将那些暂时不能运行的进程调至外存等待，此时进程状态为挂起态，当他们已经具备运行条件且内存又稍有空闲的时候，由中级调度决定把外存上那些就绪进程调入内存，修改其状态为就绪态，在就绪队列上等待。<br>④进程调度：又称低级调度，主要任务就是按照某些策略从就绪队列中选取一个进程分配处理机，频率很高，几十毫秒一次。  <img src="/2022/051537005/5.jpg" class="">   </li><li>三种调度联系：<br>作业调度从外存的后备队列选择一批作业进入内存，为他们建立进程，送入就绪队列，进程调度从就绪队列选出一个进程运行，把CPU分配给它。而中级调度是为了提高内存利用率，系统将那些暂时不运行的进程挂起来，当内存宽松的时候，通过中级调度选择具备运行条件的进程唤醒。（进程调度不可或缺，最基本的）  <img src="/2022/051537005/117.jpg" class="">    <h3 id="调度的时机，切换和过程"><a href="#调度的时机，切换和过程" class="headerlink" title="调度的时机，切换和过程"></a>调度的时机，切换和过程</h3></li><li>进程调度和切换程序是OS内核程序，现代OS中不可以进行进程调度和切换的情况有：<br>①处理中断过程中。<br>②进程在OS内核程序临界区中，临界区独占式访问共享数据，并行程序无法进入。<br>③其他需要完全屏蔽中断的原子操作过程中。  </li><li>应发生调度和切换的情况有：<br>①发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换，非剥夺调度。<br>②中断处理结束或trap处理结束，返回被中断进程的用户态程序执行现场签，可以马上进行进程调度和切换，剥夺调度。  <img src="/2022/051537005/118.jpg" class="">    <h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3>指当某个进程正在处理机上执行，若有更重要的进程需要处理，则优先权更高的进程进入就绪队列，此时应该如何分配处理机，通常两种方式：<br>①非抢占方式：正在执行任务执行完再给更重要的任务配分。即一旦把CPU分配给一个进程，就会保持CPU直到终结或等待态。优点就是实现简单，开销小，适用于大多数批处理系统，单不用于分时系统和大多数实时系统。<br>②抢占方式：立即暂停正在执行进程，把处理机给更重要的进程。对于提高系统吞吐量和响应效率都有益处，但必须有原则地进行抢占。  <h3 id="调度的基本准则-评价指标"><a href="#调度的基本准则-评价指标" class="headerlink" title="调度的基本准则/评价指标"></a>调度的基本准则/评价指标</h3>调度算法考虑的评价准则，主要考虑以下几种：<br>①CPU利用率：使CPU尽可能忙。<br>②系统吞吐量：单位时间内CPU完成作业数量，长作业需要长时间处理，降低系统吞吐量，而短作业提高吞吐量，所以不同调度方式对于吞吐量影响大。<br>③周转时间：指从作业提交到完成经历时间，是作业等待，在就绪队列排队和处理机上运行及IO花费时间总和。<br>④等待时间：指进程处于等待处理机时间之和，单纯考虑等待时间即可评判算法好坏。<br>⑤响应时间：指从用户提交请求到系统首次响应所用的时间。<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3>—————-早期批处理系统—————-   </li><li>先来先服务调度算法FCFS：<br>最简单的算法，最先进入队列的作业调入内存分配资源，创建进程并放入就绪队列。  <img src="/2022/051537005/6.jpg" class="">   属于非抢占算法，所有作业公平，但长作业会使得后边的短作业等待时间过长，所以不能作为分时系统和实时系统的策略，但常跟其他策略结合。算法简单，效率低，有利于CPU繁忙型作业，不利于IO繁忙型作业。  <img src="/2022/051537005/119.jpg" class="">    </li><li>短作业优先调度算法SJF：<br>从后备队列中选择若干运行时间短的作业把处理机分配给它，使之立即执行，直到完成/发生某事件而阻塞时才释放处理机。（抢占式和非抢占式，默认非抢占式）  <img src="/2022/051537005/7.jpg" class="">  该算法对于长作业不利，长作业出现可能长期都不被调度的“饥饿”现象。而且完全不考虑作业紧迫程度。作业时长是估计的并不准确，有可能长作业缩短很多，并不一定做到最短优先。  <img src="/2022/051537005/120.jpg" class="">    </li><li>高响应比优先调度算法：<br>对于FCFC和SJF的平衡，考虑每个作业的等待时间和估计的运行时间。每次进行作业调度时先计算后备队列中每个作业响应比，找出最高的投入运行。响应比Rp=（等待时间+要求服务时间）/要求服务时间。<br>则作业等待时间相同的时候短作业有利，要求服务时间相同时先来先服务有利，对于长作业等待时间增大响应比就可以增大到很大，克服了“饥饿”现象。  <img src="/2022/051537005/121.jpg" class="">    —————-交互式操作系统—————-</li><li>时间片轮转调度算法：<br>主要适用分时系统，系统把所有就绪进程按到达时间排列FCFS，但仅仅有一个时间片，使用完时间片就让下一个进程使用。时间片大小对于系统性能影响很大，时间片很大所有进程都能在一个时间片内完成，则就是FCFS算法，时间片很小则处理机在进程之间频繁切换，使得开销增大，真正用于运行用户进程的时间减少，因此时间片大小应该选择适当。  <img src="/2022/051537005/122.jpg" class="">    </li><li>优先级调度算法：<br>优先级就是作业紧迫程度。从后备队列中选择优先级最高的若干作业调入内存，分配资源创建进程放入就绪队列，每次只分配给当前优先级最高的作业处理机。<br>根据是否能抢占，又分为两种：非剥夺式优先级调度算法和剥夺式优先级调度算法，且进程优先级是否可以改变又把进程优先级分为两种：静态优先级（不改变，但确定优先级需要根据进程类型，对资源要求等）和动态优先级（改变，确定根据进程占有CPU时间长短，就绪过程等待CPU长短等）。<br>一般来说，进程优先级设置参照原则：<br>①系统进程&gt;用户进程。<br>②交互式进程&gt;非交互式进程。<br>③IO型进程&gt;计算型进程。  <img src="/2022/051537005/123.jpg" class="">    </li><li>多级反馈队列调度算法（UNIX使用）：<br>融合了时间片轮转法和优先级调度算法，通过动态调整优先级和时间片大小。  <img src="/2022/051537005/8.jpg" class="">   思想：<br>①设计多个就绪队列，每个队列不同优先级，优先级逐次降低。<br>②赋予各个队列进程执行时间片大小各不相同，优先级越高的队列时间片越小，时间片成1倍线性增长.<br>③一个新进程进入内存之后，首先把它放入第1级队列末尾，按照FCFS原则排队等待，若时间片内完成则撤离系统否则进入第2级队列末尾，同样进行下去。<br>④仅当第1级队列为空时，才调度第2级队列进行，若处理机正在第i级队列处理进程，1-i-1的队列加入优先级高的队列就会抢占当前处理机。<br>优点：<br>①终端型作业用户：短作业优先。<br>②短批处理作业用户：周转时间短。<br>③长批处理作业用户：经过前几个队列得到部分执行，不会出现“饥饿”现象。   <img src="/2022/051537005/124.jpg" class="">   <h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h3></li><li>异步性：各并发执行的进程以各自独立，不可预知的速度向前推进。为了解决异步，所以产生同步。    </li><li>多道程序环境下，进程是并发的，不同进程之间存在制约关系，为了协调进程之间的制约关系，所以出现了同步。（2+3*1，一定要让加法发生在乘法之后）  </li><li>同步：<br>同步亦称直接制约关系，指的是为了完成某种任务而建立起的若干进程，需要在某些位置上协调他们的工作次序而等待，传递信息所产生的制约关系。  </li><li>互斥：<br>互斥是间接制约关系，当一个进程进入临界区另一个就需要等待。  <img src="/2022/051537005/125.jpg" class="">   </li><li>临界资源：<br>多个进程可以共享系统资源，但许多资源只能有一个进程独占，我们把一次仅允许一个进程使用的资源称为临界资源。（许多物理设备和变量数据）对于临界资源的访问必须互斥地进行，每个进程中访问临界资源的那段代码称为临界区，把访问临界资源分为四个部分：<br>①进入区：进入临界区使用临界资源，检查是否可以进，能进则设置正在访问标志，阻止其他进程访问临界区。<br>②临界区：访问临界资源的代码，又称临界段。<br>③退出区：把正在访问临界区的标志删除。<br>④剩余区：代码其余部分。   <img src="/2022/051537005/9.jpg" class="">   <h3 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h3></li><li>软件检查法：在进入区设置并检查一些标志来表明是否有进程在临界区，若有则循环检查进行等待，进程离开临界区后则在退出区修改标志。<br>①单标志法：设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。即turn=0，允许P0进入临界区，每次只有一个进程进入临界区，而且两个进程必须交替进入，否则另一个进程也无法进入临界区，因为标志一直不变了。（违背“空则让进”）  <img src="/2022/051537005/10.jpg" class="">   ②双标志先检测法：每个进程访问临界区之前，先查看临界资源是否被访问，正在访问则等待，否则可以进入临界区，设置flag[i]，false标识Pi未进入临界区，true标识进入临界区。（违背“忙则等待”）  <img src="/2022/051537005/11.jpg" class="">   ③双标志后检测法：先检测可能同时进入，所以先把自己设置为true，再检测对方的状态，对方为true则等待，否则进入临界区。（违背“空则让进”）  <img src="/2022/051537005/12.jpg" class="">   ④Peterson算法：防止两个进程为了进入临界区无期限等待，设置turn，每个进程先设置自己标志再设置turn，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时想进入临界区时只有一个能进入。设置自己flag为true，把turn设置为其他进程，然后检测是否其他进程为true，是则等待，否则进入临界区。利用flag解决临界资源的互斥访问，利用turn解决“饥饿”现象，但有“忙等”现象！！！。   <img src="/2022/051537005/13.jpg" class="">      </li><li>硬件实现方法：通过硬件支持实现临界问题的方法称为低级方法/元方法，三种方法都有“忙等”现象！！！。<br>①中断屏蔽方法：当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入就禁止一切中断发生，或称之为屏蔽中断，关中断（CPU只在中断的时候进行进程切换）<img src="/2022/051537005/14.jpg" class="">   <img src="/2022/051537005/126.jpg" class="">   ②硬件指令方法：  <img src="/2022/051537005/127.jpg" class="">   <img src="/2022/051537005/128.jpg" class="">   <img src="/2022/051537005/15.jpg" class="">   ③硬件方法优点：任意数目进程都可以，简单，支持进程多个临界区。  <h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3></li><li>为了操作一气呵成不被打断，使用一对原语来实现进程互斥和同步。  </li><li>用来解决互斥问题的，只能被两个标准原语wait（S）和signal（S）访问，也就是P操作（占用资源）和V操作（释放资源）。原语是指完成某种功能且不被分割，不被中断执行的操作序列，通常硬件实现，<br>①整形信号量：仍然有“忙等”现象！！！wait——当s&lt;=0则陷入循环，否则自减，signal——自增。<br>②记录型信号量：解决“忙等”现象！！！，wait——当s.value&lt;=0则资源分配完毕，自我阻塞block，否则自减，分配资源。而signal——自增，释放一个资源wakeup，资源数增加1。<br>③利用信号量实现同步（信号量初始为0先V后P），互斥（信号量初始为1先P后V），前驱关系（先V后P）：设置一个进程公用的信号量S，并且根据需求进行初始化，V加P减，举例如下：  <img src="/2022/051537005/16.jpg" class="">   <h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3>重在理解，信号量和缓冲区的运用。</li><li>生产者-消费者问题（多生产者-多消费者问题）  </li><li>读者-写者问题 </li><li>哲学家就餐问题  </li><li>吸烟者问题<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3></li><li>大量分散的同步操作麻烦且容易死锁，所以产生进程同步工具——管程，保证了进程互斥，无须人工实现，降低死锁发生可能性，同时提供了条件变量，程序员灵活实现同步。  </li><li>定义：系统中硬软件资源均可用数据结构描述其资源特性，对该结构实施的操作定义为一组过程。进程对共享资源的申请，释放等操作都通过这组过程实现，还可以根据资源情况或接收阻塞进程访问，确保每次仅有一个进程使用共享资源，这就可以统一管理共享资源访问，实现进程互斥，这个资源管理程序，就是管程。定义了一个数据结构和能为并发进程所执行的一组操作，能够同步进程和改变管程中的数据。  </li><li>组成：名称，局部与管程内部的共享数据结构说明，操作的一组过程，初始化语句。  </li><li>管程很像一个类CLASS，能够把共享资源封装起来，且每次允许一个进程进入管程，从而实现互斥。  <img src="/2022/051537005/129.jpg" class="">   <img src="/2022/051537005/130.jpg" class="">  <h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3></li><li>定义：多个进程并发执行带来死锁这个问题，多个进程因竞争资源而造成的相互等待的僵局。  </li><li><img src="/2022/051537005/131.jpg" class="">  </li><li>产生原因：<br>①系统资源的竞争：<br>通常是系统中不可剥夺资源，数量不足需求，比如打印机。（不剥夺资源竞争不会死锁）<br>②进程推进顺序非法：<br>进程运行中请求和释放资源顺序不当，也会死锁（两个进程各自占着对面需要的资源），信号量也会产生死锁。（两个进程等待对方发来的消息）<br>③信号量使用不当也会造成死锁</li><li>死锁产生必要条件：<br>产生死锁必须同时满足4个条件：<br>Ⅰ：互斥条件：只有一个进程能够拥有该资源。<br>Ⅱ：不剥夺条件：资源未使用完不可被剥夺。<br>Ⅲ：请求并保持条件：进程至少已经保持了一个资源，并且提出了请求资源（该资源已被占有），此时请求失败，但还不放弃自己已经得到的资源。<br>Ⅳ：循环等待条件：存在一种进程资源的循环等待链，相当于一个环（12345，1的请求资源被2占有。。。5的资源被1占有）（循环等待存在不一定死锁，同类资源大于一个就不会死锁）  <img src="/2022/051537005/17.jpg" class="">   <h3 id="死锁处理策略："><a href="#死锁处理策略：" class="headerlink" title="死锁处理策略："></a>死锁处理策略：</h3></li><li>死锁预防：设置某些限制条件，破坏4个必要条件，防止发生死锁。  </li><li>避免死锁：动态分配资源中，使用某种方法防止进入不安全状态，进而避免死锁。  </li><li>死锁检测和解除：允许死锁，及时检测并且接触即可。  <img src="/2022/051537005/18.jpg" class="">   <h3 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h3></li><li>破坏互斥条件：不可行（肯定有资源是互斥的，有的可以，比如SPOOLing技术）  </li><li>破坏不剥夺条件：一个保持资源的进程得不到需要的资源就把拥有的全部资源释放。  </li><li>破坏请求并保持条件：设备申请就申请所有需要的资源，也就是说没有资源才可以申请。  </li><li>破坏循环等待条件：给系统中资源编号，每个进程必须按照递增顺序请求资源，即申请大于自己编号的资源。  <h3 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h3></li><li>系统安全状态：系统能够按照某种进程的推进顺序为每个进程分配所需资源，直到满足每个进程对于资源的最大需求，使每个进程都顺序完成，此时进程序列为安全序列，若系统中没有一个安全序列，则系统是不安全状态。并非不安全状态就是死锁状态，只是有可能是死锁状态，但只要是安全状态，系统就可以避免死锁状态。</li><li>银行家算法：最著名的死锁避免算法：三个矩阵一个向量（可用资源向量Available，最大需求矩阵Max，分配矩阵Allocation，需求矩阵Need，其中Need=Max-Allocation），先分配资源，检查是否处于安全状态（安全性算法，求一个安全序列），安全则确定分配，不安全则取消分配。一定掌握！！！  <h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3></li><li>资源分配图：圆圈代表进程，框代表资源，其中从进程到资源的有向边称为请求边，反向则是分配边。  </li><li>死锁定理：<br>简化资源分配图就可以检测系统状态S是否为死锁，不可完全简化就是死锁的。（依次消除不阻塞进程结点所有边，完全简化只有孤点则无死锁）  <img src="/2022/051537005/19.jpg" class="">    </li><li>死锁解除：<br>①资源剥夺法：挂起死锁进程，抢占其资源，把资源分配给其他死锁进程。<br>②撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源，撤销原则按照优先级和撤销进程代价高低进行。<br>③进程回退法：让一个/多个进程回退到足够避免死锁的地步，要求系统保持历史状态，设置还原点。  <img src="/2022/051537005/132.jpg" class="">  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li><img src="/2022/051537005/20.jpg" class="">   </li><li>进程同步和互斥：<br>并发进程执行会产生相互制约的关系：一种是进程之间竞争使用临界资源，但只有一个能用，这是互斥，是竞争关系。而进程之间协同完成任务，某点上进程需要等待另一个进程发来的消息，以便协同一致，是一种协作关系。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统计算机系统概述</title>
      <link href="/2022/051418462.html"/>
      <url>/2022/051418462.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><img src="/2022/051418462/5.jpg" class="">  <h2 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><ul><li>软件是计算机系统的灵魂，而软件核心是操作系统。  </li><li>计算机系统从上到下分四个部分：硬件，操作系统，应用程序，用户。</li><li>操作系统管理各种计算机硬件，并且为应用程序提供基础，充当计算机硬件与用户之间的中介。</li><li>硬件比如：CPU，内存，IO设备等提供基本计算资源。应用程序如：字处理程序，编译器，浏览器等规定按照何种方式来使用这些计算资源解决用户的计算问题。操作系统就负责控制和协调各个用户的应用程序对硬件的分配和使用。  </li><li>定义：OS就是控制和管理整个计算机系统硬件与软件资源，合理组织和调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的集合，也是计算机系统中最基本的系统软件。 <h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3></li><li>OS是一种系统软件，但与其他系统软件和应用软件有很大不同，它有自己的特殊性即基本特征：并发，共享，虚拟，异步。（并发和共享是OS最基本特征，相互依赖，互为存在条件，没有共享性则不可能实现并发性，没有并发性则就没有共享性）   </li><li>并发Concurrence：<br>两个或多个事件在同一个时间间隔内发生，OS具有处理和调度多个程序同时执行的能力，同时引入进程的目的就是让程序可以并发执行。<br>注意同一时间间隔（并发）和同一时刻（并行）的区别：单个时刻单处理机环境下实际只能有一个程序执行，因此微观上这些程序仍然是分时交替执行的，OS的并发性也是通过分时实现的。  <img src="/2022/051418462/105.jpg" class="">   </li><li>共享sharing：<br>即资源共享，系统中资源可以供内存中多个并发执行的进程共同使用，分两种方式：<br>①互斥共享方式：<br>系统中某些资源某段时间内只允许一个进程访问资源。把这种资源成为临界资源/独占资源。计算机系统大多物理设备及某些软件中的栈，变量，表格都是临界资源，只允许一个正在使用的进程。<br>②同时访问方式：<br>宏观上是“同时”，微观上进程可能是交替地对资源进行访问即“分时共享”的，可供多个进程“同时”访问的资源是磁盘设备。  <img src="/2022/051418462/106.jpg" class="">   </li><li>虚拟virtual：<br>把物理上的实体变成若干逻辑上的对应物，技术成为虚拟技术，OS利用多种虚拟技术实现虚拟处理器，虚拟内存，虚拟外部设备等。<br>虚拟处理器技术通过多道程序设计技术，采用让多道程序并发执行的方法，分时使用一个处理器，一个物理CPU虚拟成为多个逻辑的CPU，成为虚拟处理器。（同理虚拟内存，虚拟外部设备）<br>虚拟技术归纳为时分复用技术，空分复用技术。  <img src="/2022/051418462/107.jpg" class="">   </li><li>异步asynchronism：<br>多道程序允许多个程序并发执行，但资源有限，进程执行并不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性。  <img src="/2022/051418462/108.jpg" class="">   </li><li>小结：  <img src="/2022/051418462/109.jpg" class="">   <h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3></li><li>OS应该具有以下功能：处理机管理，存储器管理，设备管理， 文件管理，且必须向用户提供接口。  </li><li>操作系统作为计算机系统资源的管理者：<br>①处理机管理：<br>处理机分配和运行都以进程为基本单位，也就是对进程的管理：主要包括进程控制，进程同步，进程通信，进程通信，死锁处理，处理机调度等。<br>②存储器管理：<br>给多道程序运行提供环境，方便用户使用及提高内存利用率，包括内存分配和回收，地址映射，内存保护和共享，内存扩充等功能。<br>③文件管理：<br>信息都以文件形式存储，负责管理文件部分为文件系统，包括文件存储空间管理，目录管理，文件读写管理和保护。<br>④设备管理：<br>设备管理主要任务是完成用户的I/O请求，方便用户使用各种设备，提高设备利用率，包括缓冲管理，设备分配，设备处理，虚拟设备等。  <img src="/2022/051418462/101.jpg" class="">  </li><li>操作系统作为用户与计算机硬件系统之间的接口：<br>两类接口：<br>①命令接口：用户利用命令组织控制作业的执行。两种控制作业的方式为联机控制方式和脱机控制方式，所以把接口分为联机命令接口和脱机命令接口。<br>联机命令接口：又叫交互式命令接口，适用分时/实时系统的接口。（多次输入命令逐次处理）<br>脱机命令接口：又叫批处理命令接口，适用于批处理系统的接口。（一次输入逐次处理）<br>②程序接口：编程人员使用他们请求操作系统服务。由一组系统调用组成，用户通过程序中使用这些系统调用来请求OS服务，比如GUI。  <img src="/2022/051418462/102.jpg" class="">  </li><li>操作系统作为扩充机器：<br>没有任何软件支持计算机成为裸机，为物理基础，而实际应该使用OS把裸机改造成功能更强，使用更方便的机器，因此覆盖了软件的机器称为扩充机器/虚拟机。  <img src="/2022/051418462/103.jpg" class="">  </li><li>小结：  <img src="/2022/051418462/104.jpg" class="">   <h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h3></li><li>计算机计算过程需要人工干预，缺点：①用户独占全机，资源利用率低。②CPU等待手工操作，CPU利用率低。  <h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a>批处理阶段</h3></li><li>为了解决人际矛盾及CPU和IO设备矛盾，出现了批处理系统，分为单道批处理系统和多道批处理系统。  </li><li>单道批处理系统：（监督程序——OS雏形）<br>①自动性：作业自动逐行运行，无须人工干预。<br>②顺序性：作业完成顺序就是进入内存顺序，先进入先完成。<br>③单道性：内存中只有一道程序运行，结束才让其他程序进入。<br>④但高速CPU仍然等待低速I/O完成状态。  </li><li>多道批处理系统：（OS正式诞生）<br>允许多个程序同时进入内存，允许他们在CPU交替运行，共享系统资源。一道程序因为I/O请求等待，CPU就可以处理其他程序，使得资源利用率提高。<br>①多道：计算机内存中同时存多道程序。<br>②宏观上并行：同时进入内存的程序都处于运行中，但实际是先后运行。<br>③微观上串行：内存中多道程序轮流占用CPU，交替执行。<br>④优点是资源利用率高，系统吞吐量大，资源保持忙碌状态。<br>⑤缺点是用户响应时间长，没有人机交互。<h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h3>分时技术：把处理器运行时间分为时间片，轮流分配给作业使用，作业只利用自己的时间片完成计算，没有完成的也停止，也支持多道程序，但是包括人机交互的。<br>①同时性：允许多个终端用户同时使用计算机。<br>②交互性：用户通过终端采用人机对话方式控制程序<br>③独立性：多个用户彼此独立操作互不干扰。<br>④及时性：短时间内响应用户请求，一个计算机服务多个终端，所以响应及时。<br>⑤尽管解决了人机交互问题，但短时间反映问题还需要处理，所以出现实时操作系统。  <h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3></li><li>某个时间限制内完成某些紧急任务而不需要时间片排队，分两种情况：<br>①硬实时系统：某个动作必须绝对在规定时刻发生，则称为硬实时系统。（飞行器控制系统）<br>②软实时系统：能够接收偶尔违反实践规定且不会引起永久性损害。（飞机订票系统）  <h3 id="网络操作系统和分布式计算机系统"><a href="#网络操作系统和分布式计算机系统" class="headerlink" title="网络操作系统和分布式计算机系统"></a>网络操作系统和分布式计算机系统</h3></li><li>网络操作系统是把计算机网络各台计算机有机结合起来，提供一对一，经济有效的使用各台计算机方法，实现各台计算机之间数据的互相传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。  </li><li>分布式计算机系统组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息，每台计算机地位平等，资源所有用户共享，任意计算机都可以构成一个子系统，任何工作都可以分布在几台计算机上，由他们并行工作，协同完成。系统称为分布式计算机系统，特点就是分布性和并行性。  <h3 id="个人计算机操作系统"><a href="#个人计算机操作系统" class="headerlink" title="个人计算机操作系统"></a>个人计算机操作系统</h3>目前最广泛的操作系统，如Windows，Linux等<img src="/2022/051418462/1.jpg" class="">   </li><li>小结：  <img src="/2022/051418462/110.jpg" class="">   <h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h3></li><li>预备知识：<br>指令：就是CPU能识别和执行的最基本的命令，分为特权指令和非特权指令。为了识别特权指令，所以CPU有两种状态，用户态和核心态。所以分为两种程序：内核程序和应用程序。  <img src="/2022/051418462/111.jpg" class="">   </li><li>计算机系统中，CPU通常执行两种不同性质的程序：一种是OS内核程序，一种是用户自编程序（应用程序）。对于OS来说前者是后者的管理者，因此需要特权指令比如：IO指令，置中断指令等指令。实现上把CPU划分为用户态（只能执行非特权指令）和核心态（可以执行特权指令），应用程序运行在用户态，而OS内核程序运行在核心态。  </li><li>内核是计算机最底层软件，是计算机功能延申，不同系统对于内核定义不同，但大多包括4方面内容：<br>①时钟管理：<br>时钟是最关键的设备，第一功能是计时，向用户提供标准系统时间。通过时钟中断的管理实现进程切换（时间片轮转等），因此系统依赖时钟。<br>②中断机制：<br>引入中断目的是提高多道程序运行环境中的CPU的利用率，逐步发展形成多种类型，成为OS各项操作的基础。例如：键鼠信息输入，进程调度，设备驱动等。现代OS就是靠中断驱动的软件。<br>③原语：<br>OS底层一些可以被调用的小程序，各自完成一定操作，特点：①处于OS最底层，最接近硬件的部分。②程序具有原子性。③运行时间短，而且调用频繁。<br>具有这些特点的程序就是原语，定义原语的直接方法就是关闭中断，让所有动作不可分割完成之后再中断，系统中的设备驱动，CPU切换，进程通信等过程就是原语，成为内核组成部分。<br>④系统控制的数据结构和处理：<br>系统中登记状态信息的数据结构很多，如作业控制块，进程控制块PCB，设备控制块，各类链表，消息队列，缓冲区，空闲区登记表，内存分配表等，常见操作有：进程管理，存储器管理，设备管理。  <img src="/2022/051418462/112.jpg" class="">   <img src="/2022/051418462/113.jpg" class="">   <h3 id="中断和异常的概念"><a href="#中断和异常的概念" class="headerlink" title="中断和异常的概念"></a>中断和异常的概念</h3></li><li>为了多道程序并发执行，发明了OS，引入中断机制。本质上就是发生中断意味着需要OS介入开始管理工作（CPU从用户态转换为核心态，中断是唯一途径。而核心态转换为用户态则通过执行一个特权指令，把程序状态字PSW的标志位设置为“用户态”）。  </li><li>中断和异常的定义：<br>中断Interruption，也称外中断，来自CPU执行指令以外的事情发生（IO设备中断表示输入输出完毕发生下一个请求；时钟中断表示固定时间片到期），通常是指与当前指令无关的事件。<br>异常Exception，也称内中断，例外，陷入trap。指源自CPU指令内部的事情引起的事件（算术溢出，地址越界，非法操作等），对异常处理一般要依赖当前程序运行现场，且异常不能被屏蔽，一旦出现必须处理。<br>分辨两种中断：<br>信号来源不同：外中断信号来自CPU外部，与当前执行指令无关。而内中断来自CPU内部，与当前执行指令有关。  <img src="/2022/051418462/2.jpg" class="">   <img src="/2022/051418462/116.jpg" class="">   </li><li>中断处理过程：  <img src="/2022/051418462/3.jpg" class="">   <img src="/2022/051418462/117.jpg" class="">   <h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3></li><li>指用户在程序调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统内各种共享资源都有OS掌管，在用户程序中，凡是跟资源有关操作都需要系统调用的方式向OS提出服务请求，请OS代为完成，通常这种指令有很多条，分为几大类：设备管理，文件管理，进程控制，进程通信，内存管理。  <img src="/2022/051418462/118.jpg" class="">   </li><li>系统调用相关功能涉及系统资源管理，进程管理等操作，需要特权指令，所以系统调用处理需要由操作系统欸和程序负责完成运行在核心态。用户程序可以执行trap命令发起系统调用，请求OS服务，相当于把CPU使用权交给OS内核程序。用户程序不能直接执行对系统影响很大的操作，必须通过系统调用的方式请求OS执行，以便保证系统稳定性和安全性，防止用户程序随意更改/访问重要的系统资源，影响其他进程执行。  </li><li>OS运行环境理解为：用户通过OS上层程序，而这个程序依赖OS底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序，也可能是程序运行出现异常情况，被动需要管理程序服务，通过异常处理来进入核心态，管理程序运行结束时，用户程序需要继续运行，此时通过响应的保存的程序现场退出中断处理程序/异常处理程序，返回断点处继续执行。  <img src="/2022/051418462/4.jpg" class="">  <h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><h3 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h3></li><li>大内核：把OS主要模块作为一个紧密相连的整体运行在核心态，从而为应用提供高性能的系统服务，因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以性能有优势。</li><li>微内核：随着功能需求不断增多，大内核难以维护，所以出现微内核。它把内核中最基本的功能保留在内核，而那些不需要在核心态执行的功能移到用户态执行，从而减低了内核设计的复杂性，那些移出内核的OS的代码根据分层的原则被划分成若干服务程序，它们执行相互独立，交互则都借助于微内核进行通信。有效分离了内核与服务，服务与服务，接口更清晰，维护代价降低，各部分都可以独立优化和演进，保证了OS可靠性。但问题就是因为频繁在核心态和用户态之间切换，OS执行开销相当大。  <img src="/2022/051418462/114.jpg" class="">   <img src="/2022/051418462/115.jpg" class="">   </li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2022/050732155.html"/>
      <url>/2022/050732155.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络应用层"><a href="#计算机网络应用层" class="headerlink" title="计算机网络应用层"></a>计算机网络应用层</h1><img src="/2022/050732155/1.jpg" class="">  <h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><h3 id="客户-服务器类型"><a href="#客户-服务器类型" class="headerlink" title="客户/服务器类型"></a>客户/服务器类型</h3><ul><li>C/S模型中，一个总是打开的主机为服务器，服务于其他称为客户机的主机请求，工作流程如下：<br>①服务器处接收请求状态。<br>②客户机发出服务请求，并等待结果。<br>③服务器收到请求之后，分析请求，进行必要的处理，得到结果并发送给客户机。  </li><li>客户程序必须知道服务器程序的地址，服务器程序不用知道客户程序的地址。主要特征就是客户是服务请求方，服务器是服务提供方，典型应用包括：Web，文件传输协议FTP，远程登陆TELNET，电子邮件E-mail。  </li><li>主要特点还有：<br>①网络中计算机地位不平等。<br>②客户机之间不能直接通信。<br>③可扩展性不佳。  <h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3></li><li>思想是整个网络中传输内容不在中心服务器上，而是每个结点都有下载，上传的功能，任意一对计算机称为对等方Peer，可以直接通信，典型应用包括：PPLive，Bittorrent和电驴等。  </li><li>相比C/S，主要优点是：<br>①减轻服务器计算压力，消除了对某个服务器完全依赖，任务分配在各个结点上，大大提高系统效率和资源利用率。<br>②多个客户机共享文档。<br>③可扩展性号，传统服务器有响应和带宽，因此只能接收一定数量请求。<br>④网络健壮性强，一个结点失效不会影响其他结点。  </li><li>也有缺点：获取服务的时候也要给其他结点服务，占用较多内存，影响整机速度。    <img src="/2022/050732155/2.jpg" class="">  <h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2></li><li>因特网使用的命名系统，用来把便于人们记忆具有特定含义的主机名转化为便于机器处理的IP地址，使用C/S，运行在UDP之上，使用53号端口。分为三部分：层次域名空间，域名服务器，解析器。    <h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3></li><li>采用层次树状命名方法，任何一个连接到因特网的主机或路由器都有一个唯一层次标识，即域名。域是名字空间中可以被管理的部分。域还可以划分子域，还能继续划分，形成了顶级域，二级域，三级域等。每个域名都有由标号序列组成，各个标号都由.隔开。  <img src="/2022/050732155/3.jpg" class="">  </li><li>注意点：<br>①标号中英文不区分大小写。<br>②标号中除了-之外不能使用其他符号。<br>③每个标号不超过63字符，多标号不超过255字符。<br>④级别最低域名在最左边，最高在最右边。  </li><li>顶级域名TLD有三类：<br>①国家顶级域名：“.cn”表示中国。<br>②通用顶级域名：“。com”表示公司。<br>③基础结构域名：这种顶级域名只有一个arpa，用于反向域名解析，又称反向域名。    </li><li>国家下的二级域名由该国家自行确定，展示树状结构：  <img src="/2022/050732155/4.jpg" class="">  </li><li>每个域名可以由不同组织进行管理组织也可以再分成一定数目的子域去管理。  <h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3></li><li>因特网的域名系统被设计成一个联机分布式服务器，用C/S模型，域名到IP地址解析是用由运行在域名服务器上的程序完成的，一个服务器负责管辖称为区，每个区都有响应权限域名服务器，用来保存该区所有主机的域名到IP地址的映射。每个域名服务器不但能够映射IP地址，还能连接其他域名服务器，当自己不能够映射出IP地址的时候找其他域名服务器。DNS使用大量域名服务器，以层次方式组织，所有映射分布在所有的DNS上，主要有4种类型域名服务器：<br>①根域名服务器：<br>最高层次域名服务器，所有根域名服务器都知道所有的顶级域名服务器的IP地址，共有13个，通常它不把域名直接转换成IP地址，而是告诉本地域名服务器下一步应该找哪个顶级域名服务器。<br>②顶级域名服务器：<br>负责管理在该顶级域名服务器注册的所有二级域名，收到DNS查询请求的时候给出相应应答（有可能是结果，也有可能是下一步找哪个域名服务器的IP地址）<br>③授权域名服务器（权限域名服务器）：<br>每台主机必须在授权域名服务器处登记，为了更可靠工作，一台主机最好有至少两个。<br>④本地域名服务器：<br>每个ISP/大学/院系甚至都有一个本地域名服务器，当一个主机发送DNS请求的时候，这个查询请求报文发送给该主机的本地域名服务器。  <img src="/2022/050732155/5.jpg" class="">   <h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3></li><li>把域名解析成IP地址为正向解析，或者反向解析。客户机需要域名解析的时候，通过本机DNS构造一个DNS请求报文以UDP数据报形式发往本地域名服务器。  </li><li>域名解析有两种方式：递归查询和迭代与递归结合查询。  <img src="/2022/050732155/6.jpg" class="">    <img src="/2022/050732155/7.jpg" class="">    <h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h3 id="FTP工作原理"><a href="#FTP工作原理" class="headerlink" title="FTP工作原理"></a>FTP工作原理</h3></li><li>FTP是因特网是商用最广泛的文件传输协议，提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限，适合在异构网络任意计算机之间传送文件。  </li><li>提供以下功能：<br>①提供不同种类主机系统之间的文件传输能力。<br>②以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力。<br>③以匿名FTP的方式提供公用文件共享的能力。  </li><li>使用TCP，C/S模型，一个FTP服务器进程可同时为多个客户进程提供服务，FTP服务器进程由两大部分组成：一个主进程负责接收新请求，若干从属进程，负责处理单个请求。  </li><li>工作步骤：<br>①打开熟知端口21，使得客户进程能够连接上。<br>②等待客户进程发来连接请求。<br>③启动丛书进程处理客户进程发来的请求，主进程和从属进程并发执行，从属进程对客户进程的请求处理完毕后终止。<br>④回到等待状态，继续接收其他客户进程的请求。</li><li>FTP服务器必须在整个会话期间保留用户的状态信息，特别是必须把指定用户和控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。  <h3 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h3></li><li>FTP工作使用两个并行TCP，一个控制连接（端口21），一个数据连接（端口20），使用两个不同端口使得协议更加简单和容易实现。  </li><li>控制连接：<br>21端口，等待客户连接，建立在这个端口上称为控制连接，用来传输控制信息（连接请求，传送请求等），不用来传送文件，一直保持打开状态。  </li><li>数据连接：<br>20端口，服务器端的控制进程在接收到FTP客户发来的文件传输请求之后，创建“数据传送进程”和“数据连接”，数据连接来连接C和S的数传送进程，而进程实际完成文件的传送，结束关闭“数据传送连接”并结束运行。<br>数据连接两种模式：主动PORT，被动PASV。<br>①PORT工作原理：客户端连接到21，登陆成功读取数据时，客户端随机开一个端口，并发送命令告知服务器，服务器收到PORT命令和端口号，通过20端口和客户端开放的端口号连接，发送数据。<br>②PASV不同点是：客户端读取数据，发送PASV到服务器，服务器随机开一个端口告知客户端，客户端再连接到服务器开放的端口进行书传书。<br>但两种模式，选择权都在客户端，主动模式就是服务器连接到客户端端口，被动模式就是客户端连接到服务器端口。  <h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3></li><li>一个电子邮件系统最主要三个组成构件：用户代理，邮件服务器，电子邮箱使用的协议（如SMTP，POP3或IMAP）等。  </li><li>用户代理：用户与电子邮件系统的接口，用户代理给用户提供一个友好接口发送接收邮件，通常情况下就是一个运行在PC上的程序，比如Foxmail等。  </li><li>邮件服务器：功能就是收发邮件，同时向发信人报告邮件传送情况，采用C/S模型工作，但它必须都能充当C和S。  </li><li>邮件发送协议和读取协议：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP。邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3。且SMTP用的是PUSH的方式，即用户代理向邮件服务器发送邮件以及邮件服务器之间转发邮件时，SMTP客户把邮件”推“向服务器，而POP3则是”拉“（PULL），读取邮件，用户代理向服务器发出请求，拉取用户邮箱中的邮件。  <img src="/2022/050732155/8.jpg" class="">   <h3 id="电子邮箱格式与MIME"><a href="#电子邮箱格式与MIME" class="headerlink" title="电子邮箱格式与MIME"></a>电子邮箱格式与MIME</h3></li><li>电子邮箱格式：<br>分为信封和内容两大部分，内容又分为首部和主题两部分。RFC 822规定了邮件的首部格式，而邮件的主题部分则让用户自由撰写。用户写好首部之后，邮件系统自动地把信封所需的信息提取出来写在信封上，用户不需要亲自填写信封上的信息。<br>邮件内容首部包含一些首部行，每个首部行由一个关键字后跟冒号再根值组成，有些关键字必须的，有些则是可选的，最重要的是To：，Subject：。<br>To是必须关键字，后面填入一个/多个收件人电子邮件，规定格式为：收件人邮件名@邮件所在主机域名。Subject是可选关键字，是邮件主题，反映了邮件主要内容。From也是必须，但它通常被邮件系统自动填入，从上到下Form，To，Subject，组成了首部。  </li><li>多用途网际邮件扩充MIME：<br>SMTP只能传送一定长度的ASCII码，许多非英语国家文字无法传送，且无法传送可执行文件及其他二进制对象，一次提出了MIME。MIME并非取代SMTP或改动它，而是增加了邮件主题的结构，定义了传送非ASCII码的编码规则。  <h3 id="SMTP和POP3"><a href="#SMTP和POP3" class="headerlink" title="SMTP和POP3"></a>SMTP和POP3</h3></li><li>SMTP:<br>简单邮件传输协议SMTP，可靠有效的电子邮件传输协议，控制两个相互通信的SMTP进程交换信息，由于SMTP使用C/S模型，因此负责发送邮件的SMTP进程就是SMTP客户，负责接收的SMTP进程就是SMTP服务器，用TCP连接，端口号为25。有三个阶段：<br>①连接建立：<br>发件人邮件发送到发送方邮件服务器邮件缓存中，SMTP每个一段时间骚猫一次，有邮件则用25端口与接收方邮件的SMTP服务器建立TCP连接，之后接收方服务器发出220 Service ready，然后SMTP客户向SMTP服务器发出HELO指令，附上发送方的主机名。<br>②邮件传送：<br>连接建立之后，开始传送邮件，邮件从MAIL命令开始，若SMTP服务器已经准备好接收邮件，则回答250 OK，接着SMTP客户端发送一个或多个RCPT命令，格式为RCPT TO&lt;收件人地址&gt;，每发送一个RCPT命令，都应有相关信息从STMP服务器返回，如250 OK或者550 No such user here。（RCPT命令作用是先弄清服务器是否已经做好接收邮件准备，再发送邮件，不至于白发送错误地址）。<br>获取OK回答之后，客户端使用DATA命令，表示要开始传输邮件的内容，正常SMTP服务器回复信息是354 Start mail input;end with CRLF.CRLF。此时SMTP客户端就可以开始传送邮件内容。<br>③连接释放：<br>SMTP客户应发送QUIT命令，服务器返回221，表示SMTP同意释放连接。  </li><li>POP3和IMAP：<br>POP3：邮局协议POP是一个简单但功能有限的邮件读取协议，采用PULL的方式，用户读取邮件则向服务器发出请求，拉取用户邮箱中的邮件。也是用C/S模型，使用TCP，端口110。有两种运行方式：”下载并保留“和”下载并删除“。<br>IMAP：它比POP复杂很多，为用户提供了创建文件夹，不同文件夹移动邮件等命令，为此IMAP服务器维护了会话用户的状态信息。IMAP另一个特性就是允许用户代理只读部分内容。  <h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="WWW的概念与组成结构"><a href="#WWW的概念与组成结构" class="headerlink" title="WWW的概念与组成结构"></a>WWW的概念与组成结构</h3></li><li>万维网是一个分布式，联机式的信息存储空间，万物有一个全域同一资源定位符URL标识，资源通过超文本传输协议HTTP传送给使用者，后者通过单机链接获取资源。万维网的内核部分由三个标准组成：<br>①统一资源定位符URL：标识万维网上各种文档，且每个都有URL。<br>②超文本传输协议HTTP：使用TCP链接，万维网客户程序和服务器程序之间交互必须遵循的规则。<br>③超文本标记语言HTML：一种文档结构标记语言，使用一些约定的标记对页面信息，格式进行描述。  </li><li>URL格式：协议：//主机：端口/路径。  </li><li>万维网以C/S方式工作，浏览器是在用户主机上的万维网客户程序，而万维网文档所驻留的主机则是运行服务器程序，称为万维网服务器，工作流程是：<br>①Web用户使用浏览器指定URL与Web服务器建立连接，并发送浏览请求。<br>②Web服务器把URL转换为文件路径，并返回给Web浏览器。<br>③通信完成，关闭连接。<br>万维网是无数个网站和网页集合，构成了因特网最主要的部分。   <h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2></li><li>HTTP定义浏览器怎么向万维网服务器请求万维网文档，以及服务器怎么把文档传给浏览器，是面向事务的应用层协议。  </li><li>HTTP操作过程：<br>浏览器访问WWW服务器，首先完成对WWW域名解析获得IP地址，通过TCP向服务器发送连接。大致工作过程：每个万维网站点有一个服务器进程，不断监听TCP端口80，监听到连接请求就建立连接，然后，浏览器通过向服务器发送请求获取某个Web页面的HTTP请求，服务器返回Web页面必须信息，通过HTTP响应返回给浏览器，浏览器再进行信息解释，然后把Web页面显示给用户，最后TCP连接释放。  <img src="/2022/050732155/9.jpg" class="">    </li><li>HTTP特点：<br>①使用TCP保证可靠传输。<br>②HTTP无状态，服务器不记住HTTP状态，但可以通过Cookie加数据库的方式来跟踪用户活动。<br>③HTTP既可以使用非持久连接，也可以使用持久连接。<br>对于非持久连接，每个网页对象都需要单独TCP连接，万维网服务器负担重。<br>对于持久连接，万维网服务器发送响应之后仍然保持这链接，同一个客户和该服务器可以继续在这条连接上 传送后续HTTP请求和响应报文。  <img src="/2022/050732155/10.jpg" class="">     </li><li>HTTP报文结构：<br>①面向文本的，每个字段都是ASCII码串，每个字段长度不固定，有两类:请求报文（客户向服务器发）和响应报文（服务器到客户的回答）。<br>②HTTP两个报文都是三部分组成：开始行，首部行，实体主体<img src="/2022/050732155/11.jpg" class="">  </li><li>常见应用层协议小结：  <img src="/2022/050732155/12.jpg" class="">  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>互联网，因特网，万维网：<br>互联网：泛指多个计算机网络按照一定通信协议相互连接而成的一个大型计算机网络。<br>因特网：世界最大全球性互联网络，最大的互联网。<br>万维网：无数网站和网页集合，构成因特网最主要部分。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络传输层</title>
      <link href="/2022/05076519.html"/>
      <url>/2022/05076519.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络传输层"><a href="#计算机网络传输层" class="headerlink" title="计算机网络传输层"></a>计算机网络传输层</h1><img src="/2022/05076519/1.jpg" class="">  <h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><h3 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h3><ul><li>传输层向应用层提供通信服务，属于面向通信的最高层，也是用户功能的最低层。它为运行在不同主机的进程之间提供了逻辑通信，而网络层则是不同主机之间的网络通信，即使网络层协议不可靠，传输层同样能为应用程序提供给可靠的服务。   </li><li>网络边缘部分的两台主机使用网络核心部分的功能进行端到端通信，只有主机的协议栈才有传输层和应用层，而路由器转发分组用了下三层的功能，如图：   <img src="/2022/05076519/2.jpg" class="">  </li><li>功能：<br>①传输层提供应用进程之间的逻辑通信，而网络层提供主机之间的逻辑通信。（应用进程之间的通信实际是“端到端的逻辑通信”，实际上逻辑通信就是好像沿着水平方向传输数据，但物理上并没有一条物理连接。）<br>②复用和分用：复用指的是发送方不同应用进程都可以使用同一个传输层协议传输数据。分用指的是接收方的传输层剥去报文的首部之后能够把这些数据正确交付到目的应用进程。（网络层也有复用分用，复用是把发送方不同协议数据都可以封装成IP数据报发送出去，分用是把接收方的网络层剥去首部后把数据交付给相应协议。）<br>③传输层还要对收到的报文进行差错检测（首部和数据部分），而网络层只监测IP数据报的首部，不检查数据部分。<br>④提供两种不同协议UDP和TCP，而网络层无法同时实现两种协议。（要么面向连接虚电路，要么无连接数据报。）  <h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h3></li><li>端口的作用：<br>①端口可以让应用层的各个应用进程将其数据通过该端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层的相应进程。端口就是传输层服务访问点（TSAP），它在传输层作用类似于IP地址在网络层/MAC地址在数据链路层，只不过IP/MAC标记的是主机，而端口标识的是主机中的应用进程。<br>②硬件端口是不同硬件设备进行交互的端口，软件端口是应用层各种协议进程与传输实体进行层间交互的一种地址。   </li><li>端口号：<br>应用进程之间通过端口号进行标识，长度为16比特，能够标识2的16次方个进程，只有本地意义，即端口号只标记本计算机应用层的各种进程，分两类：<br>①服务器端使用的端口号，又分为两类：一类是熟知端口号，0——1023，派发给最重要的应用程序，另一类是等级端口号，1024——49151，提供给其他应用程序使用。<br>一些熟知端口号：FTP——21，TELNET——23，SMTP——25，DNS——53，TFTP——69，HTTP——80，SNMP——161。<br>②客户端使用的端口号，49152——65535。由于这类端口号仅在客户进程运行时才动态选择，又称为短暂端口号，通信结束后更用过的客户端端口号不复存在，该端口就可以重新使用。  </li><li>套接字：<br>IP标识不同主机，端口号标识不同进程，则端口号拼接到IP地址即套接字。<br>socket=（IP地址：端口号）  <h3 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h3></li><li>TCP是面向连接的服务，在传送数据之前必须建立连接，数据传送结束后释放连接，不提供组播/广播，不可避免的增加许多开销（确认，流量控制，计时器，连接管理），适用于可靠性更重要的场合，如：文件传输协议FTP，超文本传输协议HTTP，远程登录TELNET等。  </li><li>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查。IP知道投放哪个主机但不知道哪个进程。UDP比较简单，因此执行速度快，实时性好，如：小文本传送协议TFTP，DNS，SNMP，实时传输协议RTP等。</li><li>IP数据报和UDP数据报区别：IP数据报在网络层要经过路由存储转发，而UDP数据报在传输层端到端的逻辑信道中传输，封装成IP数据报在网络层传输时对外不可见。  </li><li>TCP和网络层虚电路区别：TCP报文在传输层抽象的逻辑信道中传输，对路由器不可见，虚电路经过交换节点必须保存虚电路状态信息，则网络层使用虚电路则无法提供无连接服务，而传输层采用TCP不影响网络层提供无连接服务。  <h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="UDP数据报"><a href="#UDP数据报" class="headerlink" title="UDP数据报"></a>UDP数据报</h3></li><li>UDP概述：<br>UDP是无连接的非可靠传输层协议，它在IP上仅附加两个服务：多路复用和对数据的错误检查，应用程序几乎直接与IP打交道。<br>优点：<br>①无须连接，没有建立连接时延。<br>②无连接状态，不跟踪确认等参数，因此使用UDP的时候可以支持更多的活动客户机。<br>③分组首部开销小，TCP有20B的首部开销，UDP只有8B的开销。<br>④应用层更好控制要发送的数据和发送时间。<br>⑤支持1-1，1-N，N-1，N-N的服务。<br>常用于一次性传输较少的网络应用，如DNS，SNMP等，如果用TCP则开销大（数据少性价比低）。UDP常用于多媒体应用等，因为可靠性不是最重要的，实时性才是。<br>UDP不保证可靠传输，不意味着应用对于数据要求是不可靠的，维护可靠性工作交给应用层来做。<br>UDP是面向报文的，发送方UDP对应用层交下来的报文，在添加首部之后就向下交付给IP层，一次发送一个报文，不合并不拆分，保留报文边界。一次交付一个完整报文，因此报文不可分割，是UDP数据报的最小单位。因此应用程序必须选择大小合适的报文，太长则会分片，太短则首部相对太长，两者都会降低IP层的效率。  </li><li>UDP首部格式：<br>首部有8B，四个字段组成，每个长为2B：<br>①源端口：源端口号，需要对方回信的时候，不需要可以为0。<br>②目的端口：目的端口号，在终点交付报文时必须用到。<br>③长度：UDP数据报长度，最小数8（仅有首部，没有数据）。<br>④校验和：监测UDP数据报传输中是否出错，出错丢弃，当不想校验时可使字段为0。  <img src="/2022/05076519/3.jpg" class="">    当传输层从IP获得UDP数据报的时候，就根据首部中目的端口号传送给相应端口进行分用。如果UDP发现收到端口号不正确，则丢弃该报文且由ICMP发送“端口不可达”给发送方。  <h3 id="UDP校验："><a href="#UDP校验：" class="headerlink" title="UDP校验："></a>UDP校验：</h3>计算校验和时，需要在UDP首部加上12B伪首部，得到一个临时UDP数据报，单纯为了计算校验和。检查首部和数据部分。<img src="/2022/05076519/4.jpg" class="">     计算过程：<br>发送方把全0放入校验和字段并添加伪首部，把UDP数据报视为许多16位字符串连接起来，若UDP数据报数据部分不是偶数个字节，需要填充一个全0字节（但不发送），按照二进制反码运算16位字的和，把此和的二进制反码写入校验和字段并发送。<br>接收方收到UDP数据报加上伪首部后，按二进制反码求16位字的和，无差错则全是1，否则有差错丢弃数据报。  <img src="/2022/05076519/5.jpg" class="">   注意：<br>校验时，若UDP数据报数据部分长度不是偶数，则填充一个偶数字节。<br>这种检错能力不强，但优点是简单，处理速度快。  <h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a>TCP协议特点</h3></li><li>TCP在不可靠IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠，有序，无丢失，不重复，特点如下：<br>①TCP是面向连接的。<br>②每条TCP只有两个端点，只能是点对点的。<br>③TCP传输的可靠，有序，无丢失，不重复。<br>④TCP提供全双工通信，两端都有发送和接收缓存，临时存放双向通信的数据。<br>其中发送缓存存放的是：①发送应用程序传送给发送发TCP准备发送的数据。②TCP以发送但尚未收到确认的数据。<br>接收缓存存放的是：①按序到达但未被接收应用程序读取的数据。②不按序到达的数据。<br>⑤TCP是面向字节流的，虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅视为玉莲船的无结构的字节流。  </li><li>TCP和UDP在发送报文时采用的方式完全不同，UDP报文的长度由发送应用程序决定，而TCP报文长度则根据接收方给出的窗口值和当前网络拥塞程度来决定。如果应用程序传送到TCP缓存数据块太长了，TCP就把它划分短一些再传送，太短也可以积累到组成够多字节再组成报文段发送出去。  <h3 id="TCP报文段"><a href="#TCP报文段" class="headerlink" title="TCP报文段"></a>TCP报文段</h3></li><li>TCP传送的数据单元是报文段，既可以来运送数据，又可以建立连接，释放连接和应答。一个TCP报文段分为首部，数据两部分，整个TCP报文段作为IP数据报的数据部分。首部前20B都是固定的，最短20B。  <img src="/2022/05076519/6.jpg" class="">  </li><li>各个字段意义：<br>源端口和目的端口：各占2B，端口是运输层和应用层的服务接口，运输层的复用和分用都需要通过端口实现。<br>序号：占4B，一共2的32次方个序号，TCP面向字节流，所以每个字节都需要按顺序编号，指的是本报文段所发送的数据的第一个字节的序号。<br>确认号：占4B，期望收到对方下一个报文段的第一个数据字节的序号，若确认号为N，咋表明N-1的所有数据都已经正确收到。<br>数据偏移：占4位，指出TCP报文段数据起始位置距离TCP报文段的起始处有多远。单位是32位，因此字段为15的时候，TCP首部最大长度是60B.<br>保留：占6位，保留位今后使用，先置为0.<br>紧急位URG：为1时标识紧急指针字段有效，告诉系统此报文段由紧急数据，应尽快传送，但需要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。<br>确认位ACK：仅当ACK=1时确认号字段才有效，当为0的时候，确认号无效。TCP规定，连接建立之后所有报文段都是ACK=1。<br>推送位PSH：接收方TCP收到PSH=1的报文段，尽快把它交付给应用程序，不等到缓存充满再交付。<br>复位位RST：RST=1时表明TCP连接中出现严重差错，必须释放连接，然后再重新连接。<br>同步位SYN：SYN=1时表明这是一个连接请求，当SYN=1且ACK=0的时候表明这是一个请求连接报文，对方同意连接则响应报文中SYN=1，ACK=1。<br>终止位FIN：释放一个连接，当FIN=1，表明此报文段的发送方的数据以及发送完毕，并要求释放连接。<br>窗口：占2B，指出现允许对方发送的数据量，接收方的数据缓存有限，因此用窗口值作为接收方让发送方设置其发送窗口的依据。（设为1000，说明接收缓存空概念还有1000字节数据）<br>校验和：占2B，校验和检验数据部分和首部，和UDP一样，加入12B的伪首部。<br>紧急指针：占2B，紧急指针仅在URG=1时有意义，指出在本报文段中紧急数据共多少字节。<br>选项：长度可变，TCP最初只规定了一个选项，即最大报文长度MSS。（数据部分最大长度）<br>填充：为了使得整个首部长度是4B的整数倍。  <h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3></li><li>三个阶段：连接建立，数据传送，连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。  </li><li>TCP连接建立过程，解决三个问题：<br>①使得每一方都能够确知对方存在。<br>②允许双方协商一些参数。<br>③能够对运输实体资源进行分配。<br>TCP连接两端的端口为套接字socket或插口，每条TCP被唯一的两个套接字确定，采用C/S方式，主动发起连接建立的应用进程称为客户Client，而被动等待连接建立的应用进程称为服务器Server。  </li><li>TCP连接建立：“三次握手”  <img src="/2022/05076519/7.jpg" class="">  连接建立之前，服务器进程属于LISTEN状态等待客户连接请求。<br>①客户机的TCP首先向服务器的TCP发送连接请求报文段，这个特殊报文段的首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不可以携带数据，但要消耗掉一个序号。这时，TCP客户端进程进入SYN-SENT状态。<br>②服务器的TCP收到连接请求报文段后，如果同意连接，则向客户机发挥确认，并为该TCP连接分配缓存和变量。在确认报文段中，把SYN和ACK都置为1，确认号是ack=x+1，同时也为字节选择的一个初始序号seq=y。注意，确认报文段不能携带数据，但也消耗一个序号。这时，TCP服务器进程进入SYN-RCVD状态。<br>③当客户机收到确认报文的时候，还要向服务器给出确认，并且为该TCP分配缓存和变量，确认报文段的ACK为1，确认号ack=y+1，序号为seq=x+1。该报文段可以携带数据，若不携带数据则不消耗序号。这时TCP客户进程进入了ESTABLISHED状态。<br>之上三步就连理了TCP连接，接下来就可以传送应用层数据了，全双工通信。值得注意的是：服务器端分配资源是在第二次握手的时候分配的，客户端的资源是在第三次握手时分配的。  </li><li>TCP连接的释放：“四次挥手”  <img src="/2022/05076519/8.jpg" class="">   ①客户机打算关闭连接，向TCP发送连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文端的终止位FIN=1，序号seq=u，它等于前面已经传送过的数据的最后一个字节的序号+1，FIN报文段即使不携带数据，也消耗掉一个序号。这时，TCP客户进程进入FIN-WAIT-1状态，但TCP全双工，即一条TCP连接上有两条数据通路，发送FIN的一端不可以发送数据，即关闭了一条数据通路，但对面还可以发送数据。<br>②服务器收到连接释放报文段后即发出确认，确认号ack=u+1，序号seq=v，等于前面已经传送过的数据的最后一个字节的序号+1，然后服务器进入CLOSE-WAIT状态，此时从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态，但服务器若发送数据，客户机仍要接受，即从服务器到客户机这个方向的连接并未关闭。<br>③若服务器已没有要向客户机发送的数据，就通知TCP释放连接，此时发出FIN=1的连接释放报文段，设该报文段的序号为w，还须重复上次已经发送的确认号ack=u+1。这时服务器进入LAST-ACK状态。<br>④客户机收到连接释放报文段之后，必须发出确认，把确认报文段中的确认位ACK置为1，确认号ack=w+1，序号seq=u+1.此时TCP连接还未释放，必须经过时间等待计时器设置的时间为2MSL（最长报文段寿命）后，客户机才进入CLOSED状态。  </li><li>总结：  <img src="/2022/05076519/9.jpg" class="">    <h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3>保证接收方进程从缓存区读取的字节流和发送方发出的字节流完全一致。使用了校验，序号，确认，重传的机制来达到这个目的（校验和UDP一样，不赘述）。  </li><li>序号：<br>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。每个字节都有编号，但序号字段指的是本报文所发送的数据的第一个字节的序号。  </li><li>确认：<br>TCP首部的确认号是期望收到对方下个报文段的数据的第一个字节的序号，TCP默认使用累计确认，即只确认数据流中至第一个丢失字节为止的字节。（即使已经收到了6-7字节，但3字节丢失，确认号仍然是3）  </li><li>重传：<br>有两种事件导致TCP对报文段进行重传：超时和冗余ACK。<br>①超时：<br>TCP每发送一个报文段，就会设置一次计时器，重传时间到期仍未收到确认就重传。<br>由于路由选择变化大，时延方差很大，所以为了计算重传时间，TCP使用自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间（RTT），保留RTT加权平均往返时间RTTs，随着样本变化而变化，显然超时计时器设置的超时重传时间RTO应该略大于RTTs，但也不能太多，否则丢失时不能很快重传，导致数据传输时延过大。<br>②冗余ACK：<br>超时重传存在问题就是超时周期太长。但发送方可以在超时事件发生前通过注意所谓的荣誉ACK来较好地监测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方已经受到过该报文段的确认。TCP规定每当比期望序号大的失序报文段到达的时候，就发送i给冗余ACK，指明下一个期待字节的序号。当收到同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失，这属于快速重传技术。  <h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3></li><li>TCP流量控制来消除发送方使接收方缓冲区溢出的可能性，因此可以说流量控制是一个速度匹配服务。提供一种基于滑动窗口协议的流量控制机制，在通信过程中，接收方根据字节接收缓存的大小，动态调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，限制发送方向网络注入报文速率，同时发送方根据对齐当前网络拥塞程度估计而确定窗口值，称为拥塞窗口cwnd，其大小与网络带宽和时延密切相关。   <img src="/2022/05076519/10.jpg" class="">     </li><li>传输层和数据链路层的流量控制区别：<br>传输层定义端到端之间的流量控制，数据链路层定义两个中间相邻结点之间的流量控制，且数据链路层滑动窗口协议的窗口大小不能动态变化，而传输层的可以动态变化。  <h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3></li><li>拥塞控制是防止过多的数据注入网络，保证网络中的路由器/链路不至于过载。</li><li>拥塞控制与流量控制区别：拥塞控制让网络能够承受现有的网络负荷，是一个全局性过程，涉及所有的主机，路由器，以及与降低网络传输性能有关的所有因素，相反，流量控制则是点对点通信量控制，是端到端的维妮塔，只要抑制发送方速率以便于接收方来得及接收。  </li><li>因特网定义了拥塞控制的4种算法：慢开始，拥塞避免，快重传，快恢复。  </li><li>发送方确定发送报文段速率的时候，既要根据接收方接收能力，又要全局考虑不要使网络发生拥塞，因此TCP协议要求发送方维护以下两个窗口：<br>①接收窗口rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量，由接收方根据其放在TCP报文的首部窗口字段通知发送方。<br>②拥塞窗口cwnd，发送方根据自己估算的拥塞程度而设置的窗口值，反映当前容量，只要网络未出现拥塞，就可以把拥塞窗口再增大一些，以便把更多的分组发送出去，但只要网咯出现拥塞，拥塞窗口就减小一些。<br>③发送窗口上限=两者中小的那个。  </li><li>慢开始：<br>当TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd=1，即一个最大报文段长度MSS，每收到一个对新报文段的确认cwnd就加一。这个慢开始的“慢”并不是cwnd增加速度慢，而是开始先发送第一个报文段，然后开始逐渐增大cwnd，这对防止网络出现拥塞是一个非常有力的措施。使用慢开始算法后，每经历一个RTT，cwnd都会加倍，即指数型增长，这样，慢开始增到一个规定的慢开始门限ssthresh，然后改用拥塞避免算法。  </li><li>拥塞避免算法：<br>思路就是让拥塞窗口cwnd缓慢增大，具体做法是，没经历一个RTT，要把发送方的拥塞窗口+1，而不是加倍，线性缓慢增长，根据cwnd大小执行不同算法，可归纳如下：<br>①cwnd小于ssthresh，使用慢开始算法。<br>②cwnd大于ssthresh，停止使用慢开始算法改用拥塞避免算法。<br>③cwnd等于ssthresh，两者均可以使用，通常使用拥塞避免算法。 </li><li>网络拥塞处理：<br>无论慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（未按时收到通知），就要把慢开始门限ssthresh设置为拥塞发送方的cwnd值的一半，然后把cwnd重新设置为1，执行慢开始算法，目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。  <img src="/2022/05076519/11.jpg" class="">     拥塞控制不能完全避免，是使网络不容易出现拥塞。  </li><li>快重传：<br>快重传使用冗余ACK监测丢包发生，而且冗余ACK也用于网络拥塞，当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待报文段重传计时器。  </li><li>快恢复：<br>原理：当发送方连续收到三个重复的ACK报文时，执行“乘法减小”算法，把慢开始门限ssthresh设置为此时发送方cwnd的一半。这是为了预防网络发生拥塞，但放生发认为现在网络没有发生拥塞，否则不会有几个报文段连续到达接收方，也不会连续收到重复确认，因此与慢开始不同的是，它把cwnd值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法（“加法增大”），跳过了从cwnd=1开始过程，所以称为“快恢复”。  <img src="/2022/05076519/12.jpg" class="">    </li><li>总结：TCP建立连接和网络超时时，采用慢开始和拥塞避免，当发送发接收到冗余ACK时，采用快重传和快恢复。快重传和快恢复是对慢开始和拥塞避免的一种改进。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>MSS设置太小，：网络利用率很低，如果TCP报文段只有1B数据，40B首部，则效率小于1/41，到了链路层还要进行开销，利用率进一步降低。<br>MSS设置太大：IP层传输进行分片，终端还要重组，传输有差错还要进行重传，都会增大开销。<br>所以，MSS应该尽量大些，只要到IP层不需要分片就行，最佳MSS很难确定，一般默认536B。  </li><li>最后一次挥手等待2MSL时间：<br>①保证A发送的最后一个确认报文段能够到达B，如果A不等待2MSL，若A返回最后确认报文段丢失，B就不能进入正常关闭状态，而A已经关闭无法重传。<br>②防止出现“已失效的连接请求报文段”，A发送最后一个确认报文段后，经过2MSL保证本连接持续时间内所有报文段从网络中消失。  </li><li>TCP和GBN区别：TCP正确收到但失序的报文不会丢弃而是缓存起来，并且发送冗余ACK指明期望收到的下一个报文段。而GBN就丢弃了。  </li><li>超时时间之后cwnd变为1，是因为拥塞程度更严重。<br>收到3个冗余ACK时cwnd减半，因为拥塞程度不是很严重，能收到冗余ACK。  </li><li>为什么不用“两次握手”建立连接？<br>为了防止两次握手情况下，已经失效的连接请求突然传送到服务器而产生错误。如果客户A向服务器B发出TCP连接请求，第一个连接请求报文长时间滞留，A超时认为丢失则重传，B收到之后建立连接，数据传输完毕断开连接，此时这个丢失的连接请求到达服务器B，而B认为A又发来连接请求，若使用“三次握手”，则B向A返回确认报文段，由于是一个失效的请求，因此A不予理睬，建立连接失败。  </li><li>TCP每次建立连接选择初始序号一定和前面的一些连接所用的序号不同。  </li><li>若网络不发生错误，无差错，TCP是不是多余？<br>不多余！！！<br>①数据到达目的结点会失序。<br>②由于路由计算错误，IP数据报在互联网中转圈，TTL=0，被丢弃。<br>③某个路由器通信量大处理不及时，有的数据报被丢弃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="/2022/050628245.html"/>
      <url>/2022/050628245.html</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>有一个排列P1P2P3PiPjPn，若Pi&gt;Pj，则称Pi和Pj为逆序，一个排列中所有逆序的全体叫做逆序数。<br>  </p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络网络层</title>
      <link href="/2022/05033405.html"/>
      <url>/2022/05033405.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络网络层"><a href="#计算机网络网络层" class="headerlink" title="计算机网络网络层"></a>计算机网络网络层</h1><img src="/2022/05033405/1.jpg" class=""><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p>网络层设计思路就是，向上提供简单灵活，无连接，尽最大努力交付的数据报服务。如果主机中进程之间的通信需要可靠的，可以由更高层的传输层负责。  </p><h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><ul><li>把全球网络互联需要解决不同的问题，网络层任务之一就是互联它们。所谓互联就是把两个及以上计算机网络通过一定方法，用一种/多种通信设备互相连接成为更大的网络系统，中间设备又称为中间系统/中继系统。  </li><li>中继系统分为四种：①物理层中继系统：中继器，集线器。②数据链路层中继系统：网桥，交换机。③网络层中继系统：路由器。④网络层以上的中继系统：网关。</li><li>但物理层的中继系统只是扩大网络，不算是互联，因此网络互联指的是路由器进行网络互连和路由选择。</li><li>由于参加互联的网络都使用相同的网际协议（Internet Protocol,IP）,因此把互联后的计算机网络视为全部连接到一个虚拟的IP网络，看不见网络异构的细节。  <h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3></li><li>路由器珠岙两个功能：路由选择，分组转发。</li><li>路由选择：根据特定路由选择协议构造出路由表，同时经常和相邻路由器交换信息不断更新维护路由表。得到整个网络拓扑变化情况，动态改变所选择路由。  </li><li>分组转发：转发表查询，转发，已经相关队列管理和任务调度等。由转发表把用户IP数据报从合适端口转发出去。</li><li>路由表根据路由选择算法计算出的，而转发表是从路由表得出的，转发表的结构应当使得查找最优化，路由表则需要对网络拓扑变化的计算最优化，往往笼统都是用路由表一词。<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3></li><li>通信子网中过量分组引起网络性能下降称为拥塞。一旦分组到达路由器速率到达带宽附近则时延就急剧增加，且大量分组被丢弃。</li><li>判断是否进入拥塞方法：看网络吞吐量与负载的关系。如果随着网络负载增加，吞吐量明显小于正常，则轻度拥塞，吞吐量减小则可能已经拥塞，吞吐量讲到零则进入死锁状态。</li><li>作用就是：确保子网能够承载所达到的流量，全局性的过程，涉及各方面的行为：主机，路由器及路由器内部的转发处理等过程。单一增加资源并不能解决拥塞控制。</li><li>拥塞控制与流量控制区别：流量是两端点对点通信量的控制，只需要限制发送速率。而拥塞控制必须保证通信子网能够传送待传送的数据，是全局性的，涉及所有主机，路由器以及导致网络传输能力下降的所有因素。</li><li>方法有两种：<br>①开环控制：设计网络前把因素考虑周到，力求网络工作不产生拥塞，这是静态预防的方法，一旦系统启动就不修改。手段包括：何时确定可接收新流量，何时丢弃分组，丢弃哪些分组，确定调度策略等，总之不考虑当前网络状态。静态的方法。<br>②闭环控制：设计网络前不考虑因素，采用监测系统及时监测哪里发生拥塞，把拥塞信息传送到合适地方，调整整个系统运行，动态的方法。<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><h3 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h3></li><li>路由器转发分组通过路由表转发，而表则从算法得到的，路由算法分两类：<br>①静态路由算法（非自适应路由算法）：需要网络管理员手工配置的路由信息，网络拓扑结构或链路状态发生变化的时候，需要手工配置，不能及时更新网络状态，适用于简单小型网络。<br>②动态路由算法（自适应路由算法）：路由器相邻之间彼此交换信息，按照一定比例游湖出来，则这些路由信息在一定时间间隙不断更新，随时获得最优寻路效果。</li><li>静态路由简单开销小，拓扑变化不大的网络效果好。动态路由算法负责增加网络负担，反应太快引起震荡，太慢引起路由不一致。动态有两种方法：距离-向量路由算法，链路状态路由算法。<h3 id="距离-向量路由算法（DV）"><a href="#距离-向量路由算法（DV）" class="headerlink" title="距离-向量路由算法（DV）"></a>距离-向量路由算法（DV）</h3></li><li>所有结点都定期把它的路由选择表传送给所有与之直接相连的结点，路由选择表包括每条路径目的地和代价。所有结点都监听从其他结点传来的路由选择更新信息：<br>①当被通告一条新的路由，该路由在本结点路由表中不存在，此时本地系统加入这条新路由。<br>②当发来的路由信息中有一个到达某个目的地路由更短距离（更小代价）则替代原路由。  </li><li>实质是：迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短通路。但更新信息与子网结点个数成正比。  </li><li>最常见的距离-向量路由算法是RIP算法，采用”跳数“作为距离度量。  <h3 id="链路状态路由算法（LS）"><a href="#链路状态路由算法（LS）" class="headerlink" title="链路状态路由算法（LS）"></a>链路状态路由算法（LS）</h3></li><li>要求每个参与结点都具有完全的网络拓扑信息，执行两步骤：①主动测试所有临界点状态，②定期把链路状态传播给所有其他结点。一个结点检查链路状态，并把状态信息传给全网所有结点（不是相邻结点），每个结点都通过这种方式接收状态信息，通过这些状态信息来更新自己网络拓扑和状态图，一旦链路发生变化，则利用Dijkstra算法重新计算路由，计算单源最短路径。最常用的链路状态路由算法是OSPF算法。</li><li>三个特征：<br>①向本自治系统的所有路由器发送信息，使用泛洪法Flooding，即路由器通过所有端口向相邻路由器发送信息，而接收到之后又重复该过程（但不发给刚才发给自己的那个路由器）。<br>②发送的信息是与路由器相邻的所有路由器的链路状态，所谓”链路状态“就是本路由器与哪些路由器相邻以及链路的”度量“。对于OSPF算法，”度量“则是费用，距离，时延，带宽等。<br>③当链路状态发生改变才发送信息。  </li><li>优点：每个路由都独立计算自己的信息。链路信息不改变进行传播，易于查找故障。当一个结点接到所有其他节点的信息则可以计算自己的信息。<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3></li><li>当网络规模扩大时，路由表成比例扩大，不仅消耗路由器缓冲区空间，而且需要CPU更多时间来扫描路由表，更多带宽交换路由状态信息，因此必须按照层次方式进行。  </li><li>因特网把互联网划分许多小自治系统，每个系统都自主决定系统内采用何种路由选择协议，则两系统间通信就需要协议来屏蔽差异。</li><li>路由选择协议划分两大类：<br>①自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体有RIP和OSPF。<br>②自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也成为域间路由选择，具体有BGP。  </li><li>使用层次路由的时候，OSPF把自治系统再划分若干区域，每个路由器只需要自导自己区域如何路由即可。<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h3></li><li>IPv4即现在普遍使用的IP，IP定义数据传送的基本单元——IP分组以及确切的数据格式，也包括规则，指明分组如何处理，错误如何控制。特别是IP还包含了非可靠投递的思想，以及于此关联的分组路由选择的思想。</li><li>IPv4分组的格式：如图：  <img src="/2022/05033405/11.jpg" class="">  重要字段含义：<br>版本：IP的版本号，通常为4。<br>首部长度：占4位，最大进制15。<br>总长度：占16位，指的是首部和数据之和的长度，单位为字节，因此数据包最大长度为2的16次方-1=65535B，以太网MTU=1500B，因此IP数据报封装成帧的时候一定小于MTU。<br>标识：占16位。它是一个计数器，每产生一个数据报就加1，并且赋值给标识字段，但它并不是序号，因为IP不可靠服务，当一个数据报长度超过网络MTU时，必须分片，此时每个数据报片都需要复制一次标识号，以便能重新组装成原数据报。<br>标志：占3位，标志字段最低位为MF，MF=1表示后面还有分片，MF=0表示是最后一个分片，标志字段中间为DF，当DF为0的时候才允许分片。<br>片偏移：占13位，它指出较长的分组在分片之后，某片在原分组中的相对位置，片偏移以8个字节位偏移单位，每个分片的长度一定是8B的整数倍。<br>生存时间TTL：占8位数据报在网络中可以通过的路由器数量最大值，标识分组在网络中寿命，以确保不会永远在网络中循环。路由器在转发分组前，先把TTL减一，TTL=0丢弃分组。<br>协议：占8位，指出此分组携带的数据使用什么协议，即分组的数据部分应该交给那个传输层协议，如TCP，UDP等，其中值为6表示TCP，17表示UCP。<br>首部校验和：占16位，IP数据报首部校验和只校验分组的首部，不校验数据部分。<br>源地址字段：占4B，发送方IP地址。<br>目的字段：占4B，接收方IP地址。  </li><li>IP数据报分片：<br>①一个数据链路层数据报能承受的最大数据量为MTU，因为IP数据报被封装在链路层数据报中，因此MTU限制着IP数据报的长度。而且在IP数据报目的/源地可能不同的数据链路层协议，有不同的MTU。这时把IP数据报中数据分装在多个小的IP数据报中，称为片。<br>②片在目的地网络层被重新组装，目的主机使用IP首部标识，标志，片偏移字段来重组片，创建一个IP数据报的时候，源主机为该数据报加一个标识号，每个片的表示号一样，目的主机通过标识号来确定哪些片属于原始数据报。而IP首部中的标志位有3比特，但只有后2比特有意义，分别是MF和DF，DF为0时IP数据报才允许分片，MF=0代表后边还有片，MF=1代表是最后一片。目的主机重组的时候通过片偏移来确定数据报的各个片的位置。<br>③计算过程：  <img src="/2022/05033405/2.jpg" class="">   </li><li>网络层转发分组流程：<br>①从数据报首部提取目的主机IP地址D，得出目的网络地址N。<br>②若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这成为路由器的直接交付，否则是间接交付执行③。<br>③若路由器有目的地址为D的特定主机路由，则把数据报交给路由表中指定的下一跳路由器，否则执行④<br>④若路由表中有到达网络N的路由，则把数据报传给路由表中指定的下一跳路由器，否则执行⑤<br>⑤若路由表有一个默认路由，则把数据报传送给默认路由器，否则执行⑥<br>⑥报告转发分组出错。  <h3 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h3></li><li>IPv4地址：<br>①连接到互联网的每台主句都分配了一个32比特的全球唯一标识符，即IP地址，传统IP地址是分类的地址，分为ABCDE五类。由网络号+主机号组成，网络和标志主机所连接到的网络，一个网络号在整个互联网必须是唯一的，主机号标志该主机，主机号在该网络号范围内必须是唯一的，所以整个IP地址就是唯一的。<br>②五类IP地址：  <img src="/2022/05033405/3.jpg" class="">  ③各类IP地址有的不能用：<br>主机号全0表示网络本身，如202.98.174.0<br>主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255<br>127.0.0.0保留为环回自检地址，表示任意主机本身，目的地址为该地址的IP数据报用不会出现网络上。<br>32位全为0，0.0.0.0表示本网络上的本主机。<br>32位全为1，255.255.255.255表示整个TCP/TP网络的广播地址，但由于路由器隔离广播域，则认为它为本网络的广播地址。<br>④常用ABC网络IP地址使用范围：  <img src="/2022/05033405/4.jpg" class="">   ⑤重要特点：<br>IP是分等级的地址结构，好处是：IP地址管理机构分配IP地址时只分配网络号，而主机号由网络自行分配。路由器根据网络号转发分组，不考虑主机号，减小路由器所占存储空间。<br>IP地址标志一条主机和一条链路的接口，当主机同时连接两个网络的时候必须有两个IP地址，则一个路由器必然至少有两个IP地址。<br>IP地址所有分配到网络号的网络都是平等的。  </li><li>网络地址转换：<br>①Network Address Translation，NAT，通过把专用网络地址转换为公用网络地址，对外隐藏内部管理的IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网连通，由于本机IP地址可以重用，大大节省了IP地址消耗，同时隐藏内部网络结构，降低风险。<br>②为了网络安全，画出了部分IP地址为私有，私有IP地址只用于LAN，不用于WANianj，并且允许私有IP地址被LAN重复使用。在因特网中，路由器对于私有地址一律不予转发，称私有地址为专用互联网/本地互联网，<br>③使用NAT需要在专用互联网连接到因特网的路由器上安装NAT软件，NAT路由器至少有i一个有效的外部全球地址，NAT路由器使用NAT转换表把本地地址转换为全球地址或反向，这两个地址在转发表中是映射关系，可以多个私有IP地址映射到同一个全球地址。  <h3 id="子网划分与子网掩码，CIDR："><a href="#子网划分与子网掩码，CIDR：" class="headerlink" title="子网划分与子网掩码，CIDR："></a>子网划分与子网掩码，CIDR：</h3>①子网划分：<br>使得两级IP地址变为三级IP地址。子网划分属于内部事情，对外仍然表现为没有划分子网的网络，从主机号借用若干比特作为子网号，当然主机号也相应减少了相同的比特，三级IP地址=网络号+子网号+主机号。同样的路由器转发分组的时候现根据子网号找子网，再转发给目的主机。<br>注意：子网划分是把主机号再进行划分，不改变网络号。<br>②子网掩码：<br>对ABC类网络进行子网划分，必须使用子网掩码表示对于源网络中主机号的借位。它是一个32比特的二进制串，由一串1和跟随的0组成，1对应IP地址中网络号及其子网号，而0对应主机号，计算机只需要把它的IP地址和其对应的子网掩码逐位“与”就可以得到子网IP地址。未进行划分子网的有默认子网掩码：A类255.0.0.0，B类255.255.0.0，C类255.255.255.0。<br>子网掩码属于重要属性，所以路由器必须在相互交换路由信息的时候必须把自己所在的网络的子网掩码告诉对方，路由器每个条目，除了给出目的网络地址和下一跳地址外，还要给出目的网络的子网掩码。<br>③无分类域间路由选择（CIDR）：<br>无分类域间路由选择是在变长子网掩码基础上提出的一种消除传统ABC类网络划分，并且可以在软件支持下实现超网构造的一种IP地址划分方法。<br>特点：<br>CIDR使用网络前缀+主机号，即变成了无分类的IP地址。使用斜线技法——IP地址/网络前缀所占比特数。把网络前缀相同的连续IP地址组成“CIDR地址块”，一个CIDR地址块可以表示很多地址，称为路由聚合，使得原来多个传统网络分类地址的路由变成现在一个，减少路由器之间的路由选择信息的交换，提高网络性能。<br>优点在于网络前缀长度的灵活性，且使用最长前缀匹配。  <h3 id="ARP，DHCP，ICMP："><a href="#ARP，DHCP，ICMP：" class="headerlink" title="ARP，DHCP，ICMP："></a>ARP，DHCP，ICMP：</h3>①IP地址和硬件地址：<br>IP地址是网络层使用的分层地址。硬件地址则是数据链路层使用的平面式的地址（MAC地址），IP地址放在IP数据报的首部，而MAC地址放在MAC数据帧首部，通过数据封装把IP数据报分组封装成MAC帧之后，数据链路层看不见数据报分组中的IP地址。<br>由于路由器隔离，IP只能通过IP地址寻址，依靠路由表跳转到目标网络，改为在目标LAN中通过数据链路层的MAC地址以广播方式寻址。（路由器只根据目的地IP地址的网络号进行路由选择）<br>在局域网数据链路层只能看见MAC帧，通过路由器转发IP分组的时候，此IP分组在每个网络中都被路由器解封装和重新封装，因此MAC地址不断改变，所以MAC地址无法夸网络通信。<br>②地址解析协议ARP：<br>无论网络层使用什么协议，在实际网络的链路上传送数据帧的时候，最终必须使用硬件地址，所以需要从IP转化为MAC，这就是地址解析协议ARP，每台主机都有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表，使用ARP来动态维护此表。<br>工作在网络层：原理如下：主机A想向B发送数据报，先在其ARP告诉缓存中查看有无主机B的IP地址，有则查其MAC地址，再写入MAC帧，通过局域网发送到此MAC地址。没有则使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并且广播ARP请求分组，使得同一个局域网里所有主机收到ARP请求。主机B收到ARP请求之后向主机A发出响应ARP分组，分组包含B的IP和MAC映射关系，A收到之后写入缓存，然后按照查询的MAC发送分组。（用于解决同一个局域网上的IP与MAC映射关系，不在同一个局域网就要通过ARP找到一个位于本局域网的路由器MAC地址，由这个路由器进行分组转发给下一个网络）<br>③动态主机配置协议（DHCP）：<br>常用给主机动态分配IP地址，提供了即插即用的机制，允许一台计算机加入新网络和获取IP地址而不用手工参与，是应用层协议，基于UDP。<br>工作原理：使用C/S方式，需要IP地址的主机向DHCP服务器广播发送发现报文成为其客户，本地网络上所有主机都能收到此广播报文，但只有DHCP服务器能回复，DHCP服务器在其数据库查找是否有该计算机配置，有则返回信息，无则从服务器IP地址取一个地址分配给该计算机，称为提供报文。<br>DHCP服务器可能多个，客户端只需要挑选一个接收信息即可，通常是最先到达的。且分配的IP地址为临时的，称为租用期，数值应该由DHCP服务器自己决定，DHCP客户也可以进行要求。通过广播方式进行交互，因为客户端不知道服务器IP地址，而客户端没有IP地址，从而必须广播，且为UDP，因为没有IP地址无法使用TCP建立连接。<br>④网际控制报文协议（ICMP）：<br>为了提高IP数据报交付成功的机会，网络层使用ICMP让主机/路由器报告差错和异常情况，ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。有两种：ICMP差错报告报文和ICMP询问报文。  </li><li>差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况，有五类：<br>终点不可达：路由器/主机不能交付数据报时。<br>源点抑制： 路由器/主机由于拥塞丢失数据报，应该把数据报的发送速率降低。<br>时间超过：路由器收到TTL=0的数据报时，除了丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定时间内不能收到一个数据报全部数据报片的时候就把已经收到的全部丢弃，并向源点发送时间超过报文。<br>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确的时候，就丢弃数据报，并向源点发送参数问题报文。<br>改变路由：路由器把改变路由报文发送给主机，让主机知道通过更好路由发送给另外的路由器。    </li><li>询问报文：有四种，回送请求和回答报文，时间戳请求和回答报文，掩码地址请求和回答报文，路由器询问和回答报文。  </li><li>ICMP常见的应用是分组网间探测PING（用来测试两台主机之间连通性）和Traceroute（跟踪分组经过路由），其中PING用了回送请求和回答报文，Traceroute使用了ICMP时间超过报文。PING工作在应用层，直接使用网络层ICMP，而Traceroute工作在网络层。  <h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><h3 id="IPv6的主要特点"><a href="#IPv6的主要特点" class="headerlink" title="IPv6的主要特点"></a>IPv6的主要特点</h3>解决IP耗尽问题有三种：①采用CIDR无类别编址，使得IP地址分配更加合理。②采用网络地址转换NAT方法节省全球IP地址。③采用更大地址空间新版本IPv6。<br>IPv6特点：<br>①有更大地址空间，32位变成128位，字节数16B是4B的平方。<br>②扩展的地址层次。<br>③灵活的首部格式。<br>④改进的选项。<br>⑤允许协议继续扩充。<br>⑥即插即用（自动配置）。<br>⑦支持资源预分配。<br>⑧不允许分片。<br>⑨首部长度为8B的整数倍，而IPv4是4B的整数倍。<br>⑩增大了安全性，身份验证和保密功能是IPv6的整数倍。  <h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3>IPv6的数据报目的地址是：单播（传统点对点），多播（一对多，分组给一组计算机的每个），任播（IPv6增加的类型，数据报只交付给一组计算机的一台最近的计算机）。<br>使用了分级概念，三个等级：公共拓扑，单个场点，单个网络接口。  <h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h3>AS，单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同度量来确定分组在该AS的路由，同时使用一种AS之间的路由选择协议来确定分组在AS之间的路由。一个自治系统的所有网络都由一个单位管线，且所有路由器都联通。  <h3 id="域间路由和域内路由"><a href="#域间路由和域内路由" class="headerlink" title="域间路由和域内路由"></a>域间路由和域内路由</h3>自治系统内部路由选择称为域内路由选择，外部称为域间路由选择。<br>①内部网关协议（Interior Gateway Protocol，IGP）：有RIP和OSPF。<br>②外部网关协议（External Gateway Protocol，EGP）：<br>若源站和目的站处于不同AS，则传送数据报的时候就需要使用一种协议把路由信息传递给另一个系统，这样的协议就是EGP，使用最多的就是BGP-4。  <img src="/2022/05033405/5.jpg" class="">    <h3 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h3>基于距离向量的路由选择协议（DV），最大优点就是简单。<br>①RIP规定：<br>网络中每个路由器都需要维护从它自身到其他每个目的网络的距离记录。<br>距离也称为跳数，每经过一个路由+1。<br>RIP认为好的路由就是跳数小，允许最多15跳，大于15则不可达，所以只使用小型互联网。<br>RIP默认两个使用RIP路由器之间每30s一次广播路由更新信息，以便建立更新维护路由表。<br>②RIP特点：<br>只和自己相邻路由器交换信息。<br>路由器交换信息是当前路由器所知道的全部信息，即自己的路由表。<br>按照固定时间间隔交换路由信息，如每隔30s。<br>③距离向量算法：<br>路由表有三个关键数据：目的网络N，距离d，下一跳路由器地址X。则每个RIP报文执行：  </li><li>地址X相邻路由器发来报文，修改此报文所有项目，把下一跳改为X，距离+1。  </li><li>对于修改后的RIP报文中每个项目要：当前路由表中没有目的网络N，则添加。有目的网络N且下一跳路由器是X则替换。有目的网络N且下一跳路由器不是X且新距离短则替换，距离长则不做改变。  </li><li>若180s没有收到更新路由表，把相邻路由器记作不可达路由器，距离设置为16。   </li><li>返回。<br>④优缺点：<br>优点就是实现简单，开销小，收敛过程快。<br>缺点就是RIP限制网络规模，能够使用最大距离为15。路由器之间交换的是完整路由表，网络规模越大开销越大。网络出现故障的时候出现慢收敛现象。<br>RIP是应用层协议，使用UDP传送数据，路径一定是路由器最少的路径，但不一定是时间最短的路径。  <h3 id="开放最短路径优先协议（OSPF）"><a href="#开放最短路径优先协议（OSPF）" class="headerlink" title="开放最短路径优先协议（OSPF）"></a>开放最短路径优先协议（OSPF）</h3>①OSPF的特点：</li><li>与RIP区别：<br>OSPF使用洪泛法向所有路由器发送信息。而RIP向相邻路由器发送信息。<br>OSPF发送信息是与本路由器相邻所有路由器的链路状态。而RIP是整个路由表。<br>OSPF当链路发生变化的时候才更新路由器。而RIP是定期更新。<br>OSPF是网络层协议，使用IP数据报传送。而RIP是应用层协议，使用UDP传送。  </li><li>OSPF还有自己的特点：<br>OSPF对于不同链路根据IP分组不同服务类型而设置不同代价，因此计算出不同路由，很灵活。<br>如果对同一个目的网络有多条代价相同的路径，则可以把通信量分配给这几条路径，称为多路径之间的负载平衡。<br>所有在OSPF路由器之间的交换分组都有鉴别功能，保证了仅在可信赖路由器之间交换链路状态信息。<br>支持可变长子网划分和无分类编址CIDR。<br>每个链路状态都有自己32位序号，序号越大，状态越新。<br>②OSPF基本原理：<br>各路由器之间频繁交换链路状态，因此都可以建立一个链路状态数据库，就是全网拓扑图，在全网范围内是一致的，然后用Dijkstra计算单源最短路径，构造自己路由表，更新之后继续计算构造新路由表即可。<br>为了使得OSPF能够用于更大的网络，需要把AS再次划分称为更小范围的区域，减小了通信量。<br>③OSPF的五种分组类型：<br>问候分组：用来发现和维持邻站的可达性。<br>数据库描述分组：向邻站给出自己链路状态数据库中信息。<br>链路状态请求分组：向对方请求发送某些链路状态项目的详细信息。<br>链路状态更新分组：用洪泛法对全网更新状态。<br>链路状态确认分组：对链路更新分组的确认。<br>通常10s，两个相邻路由器交换一次问候分组，知道哪些可达。路由器开始工作的时候，OSPF让每个路由器使用数据库描述分组和相邻交换本数据库中的信息，然后路由器使用链路状态请求分组，向对方请求发送自己缺少的某些链路状态项目的详细信息。经过一系列的分组交换，建立全网同步的链路状态数据库。<img src="/2022/05033405/6.jpg" class="">  <h3 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h3></li><li>常用于互联网网关之间，只求能找到一条到达目的网络且较好的路由，并非最佳路由，使用的是路径向量DV，BGP是应用层协议，基于TCP。  </li><li>工作原理如下：每个自治系统管理员选择一个路由器（可以多个）作为发言人，发言人之间交换路由信息（建立TCP连接），当所有的发言人都相互交换信息之后就可以找到各个自治系统的较好路由。  </li><li>特点：<br>AS数量级就是BGP的节点数量级，比AS中的网络数量小很多。<br>发言人数量很少，使得AS间的路由选择不复杂。<br>BGP支持CIDR。  </li><li>BGP一共使用4种报文：<br>①打开报文（Open），用来与相邻的另一个BGP发言人建立关系。<br>②更新报文（Update），用来发送某一路由的信息，以及列出要撤销的多条路由。<br>③保活报文（Keepalive），用来确认打开报文并周期性地证实邻站关系。<br>④通知报文（Notification），用来发送检测到的差错。<h3 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h3><img src="/2022/05033405/7.jpg" class="">  <h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><h3 id="IP组播的概念"><a href="#IP组播的概念" class="headerlink" title="IP组播的概念"></a>IP组播的概念</h3></li><li>让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被他们正确接收。组播一定仅应用于UDP，TCP一对一不适用。让源主机把单个分组发送给一个组播地址，该组播地址标识一组地址，而一个主机可以属于多个组。  </li><li>主机使用IGMP协议加入组播组，它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组愿望。  </li><li>主机组播仅仅发送一份数据，路径分叉的时候才复制，因此大大减轻网络负载和发送者负担，组播需要路由器支持才能实现，能够运行组播协议的路由器称为组播路由器。  </li><li>组播和单播区别：  <img src="/2022/05033405/12.jpg" class="">  <h3 id="IP组播地址"><a href="#IP组播地址" class="headerlink" title="IP组播地址"></a>IP组播地址</h3></li><li>使用D类地址，前四位1110，因此D类范围为224.0.0.0———239.255.255.255，每个IP地址标志一个组播组。  </li><li>组播数据报和IP数据报区别是：前者使用D类IP地址作为目的地址，并且首部协议字段为2，使用IGMP，需要注意的是：<br>①组播数据报是不可靠的，尽最大努力交付的。<br>②组播地址只能用于目的地址，不能用于源地址。<br>③对于组播数据报不产生ICMP差错报文，因此PING命令不响应。<br>④并非所有D类地址都可以是组播地址。  </li><li>组播地址分两种：本局域网内硬件组播，因特网内组播。  <h3 id="IGMP与组播路由算法"><a href="#IGMP与组播路由算法" class="headerlink" title="IGMP与组播路由算法"></a>IGMP与组播路由算法</h3></li><li>要使路由器知道组播成员信息，需要利用因特网组管理协议IGMP，连接到局域网上的组播路由器必须和因特网上其他组播路由器协同工作，以便把组播数据报以最小代价传送给所有组成员，所以使用组播路由选择协议。  </li><li>IGMP不知道IP组播包含的成员，而是让连接在本地局域网上的组播路由器知道主机是否参加/退出了某个组播组。  </li><li>IGMP工作两个阶段：<br>①某台主机加入新组买主机应该向组播组的组播地址发送一个IGMP报文，声明自己要成为成员，本地组播路由器收到以后，把组成员关系转发给因特网上的其他组播路由器。<br>②组成员是动态的，本地组播路由器周期性探询主机，看看是否还是成员。  </li><li>组播路由实际就是找出以源主机为根结点的组播转发树。  <h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><h3 id="移动IP的概念"><a href="#移动IP的概念" class="headerlink" title="移动IP的概念"></a>移动IP的概念</h3></li><li>支持移动性的因特网体系结构与协议称为移动IP，为了满足移动结点在移动中保持连接性而设计的。确切的说，移动IP技术是指移动结点以固定IP地址跨越不同网段的漫游功能，且保证网络权限不发生改变。</li><li>基于IPv4的移动IP定义三种功能实体：<br>①移动结点：具有永久IP地址的移动结点。<br>②本地代理：一个网络环境中一个结点永久的“居所”称为归属网络，在归属网络中代表结点执行移动管理功能的实体为本地代理。<br>③外部代理：外部网络中帮助结点完成移动管理功能的实体为外部代理。  <h3 id="移动IP的通信过程"><a href="#移动IP的通信过程" class="headerlink" title="移动IP的通信过程"></a>移动IP的通信过程</h3></li><li>移动结点本地地址唯一且不变，所以本地网络链路上每个本地结点需要本地代理为它维护当前位置信息，需要引入转交地址。当移动结点连接到外地网络链路上时，转交地址用来标识结点现在所处位置，以便进行路由选择。移动结点本地地址和转交地址的联合称为移动绑定/绑定，当移动结点获得一个新的转交地址，通过绑定向本地代理注册，以便让本地代理了解移动结点所处位置。  </li><li>通信过程如下：<br>①移动结点连接本地网使用传统TCP/IP通信。<br>②漫游到外地网络，需要向本地代理注册当前位置地址，这个位置地址是转交地址。<br>③本地代理接收注册之后，构建一条通向转交地址的隧道，把截获的发给移动结点的分组通过隧道传给转交地址处。<br>④转交地址接触封装，回复原始IP分组，最后送到移动结点。<br>⑤移动结点在外网通过路由器/外部代理向通信对端发送数据包。<br>⑥移动结点来到另一个外网时，需要向本地代理更新注册的转交地址，就可以继续通信。<br>⑦移动结点回到本地网时，移动结点向本地代理注销转交地址，继续以TCP/TP进行通信。  </li><li>移动IP为主机设置两个IP地址，主地址和辅地址（转交地址）。移动结点本地网用主地址，移动另外网络使用临时辅地址，主地址不变。  <h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h3></li><li>路由器是一个具有多个输入/输入端口的专用计算机，任务是连接不同网络并完成路由转发。同一个网络传递无须路由器的参与，而跨网络通信必须通过路由器进行转发。</li><li>从结构上看，路由器由路由选择和分组转发两部分构成，路由器是网络层设备，实现了网络模型的下三层，即物理层，数据链路层，网络层。  <img src="/2022/05033405/8.jpg" class="">   </li><li>路由选择部分也叫控制部分，核心构建是路由选择处理机，其任务是根据所选定的路由选择协议构造出路由表，同时经常或者定期地和相邻路由交换路由信息不断更新维护路由表。  </li><li>分组转发部分由三部分组成：交换结构，一组输入和一组输入端口。输入端口从物理层接收到的比特流中提取出数据链路层的帧，从帧中提取出网络层数据报，输出端口则执行恰好相反的操作。交换结构则是关键部件，根据转发表对分组处理，把某个输入端口进入的分组从一个合适的端口转发出去，有三种常见方法：通过存储器进行交换， 通过总线进行交换，通过互联网络进行交换。  <h3 id="路由表和路由转发"><a href="#路由表和路由转发" class="headerlink" title="路由表和路由转发"></a>路由表和路由转发</h3>标准路由表有四个项目：目的网络IP地址，子网掩码，下一跳IP地址，接口。  <img src="/2022/05033405/9.jpg" class="">  转发表是由路由表得到的，格式不同，含有目的地址和下一跳MAC地址。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>尽最大努力的交付含义：有可能有差错，有可能不按时，有可能不按序，有可能重复，有可能意外丢失数据报。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络数据链路层</title>
      <link href="/2022/050135078.html"/>
      <url>/2022/050135078.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络数据链路层"><a href="#计算机网络数据链路层" class="headerlink" title="计算机网络数据链路层"></a>计算机网络数据链路层</h1><img src="/2022/050135078/1.jpg" class=""> <h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，把其可能出错的物理连接改造为逻辑上无差错的物理链路，使之对于网络层表现为一条无差错的链路。功能如下：</p><ul><li>为网络层提供服务：<br>①对于网络层，链路层基本任务就是把原机器来自网络层数据传输到目的机器网络层，提供三种服务。<br>②无确认的无连接服务：不需要连接，不发送确认，丢失帧不负责，适用于实时性强误码率低的通信信道，如以太网。<br>③有确认的无连接服务：不需要连接，但发送确认，源机器长时间没收到确认就重传帧，适用于误码率高的通信信道，如无线通信。<br>④有确认的面向连接服务：需要建立连接，每个帧都需要确认，适用于通信要求高的场合。<br>⑤有连接一定要有确定，不存在无确认的无连接服务。</li><li>链路管理：<br>数据链路层连接的建立，维持，释放的过程称为链路管理，主要用于面向连接服务，链路两端结点进行通信，必须首先确认对方已处于就绪状态，交换信息对帧序号初始化之后才能建立连接。多个站点公用一个物理信道如何分配和管理信号也属于管理范畴。  </li><li>帧定界，帧同步，透明传输：<br>①主机之间传输信息把网络层分组封装成帧，分别添加首部尾部，都包含很多控制信息，为了确定帧的界限，即帧定界。<br>②帧同步指的是接收方能够从接收到的二进制比特流中区分帧的起止。<br>③为了提高帧传输效率，应该使得数据部分长度尽可能大于首部和尾部，但每个协议都规定数据部分长度上限——最大传送单元MTU。<br>④数据部分恰好出现与帧定界相同的比特组合会误认为结束了，则采用透明传输————不管什么样的数据部分都能在链路上传送。</li><li>流量控制：<br>①由于收发双方各自工作速率和缓存空间差异，可能出现发送能力高于接收能力，如果不调整发送速率会使得未被接收的帧被后来的帧淹没而丢失，因此，流量控制就是限制发送方的数据流量，使得其发送速率不超过接收方的接收能力。<br>②需要反馈机制使得发送方知道接收方能否跟得上自己，需要知道何时才能发送下一帧，何时暂停发送。<br>③流量控制并不是链路层特有的功能，许多高层协议也有该功能，控制对象不同。链路层控制的是两结点之间的数据链路上的流量，运输层是端之间的流量。  </li><li>差错控制：<br>①由于噪声等因素，帧会出错，则用以使得发送方确定接收方是否正确收到其发送的数据的方法为差错控制，错误可以分为位错和帧错。<br>②位错使用循环冗余校验（CRC）的方法，通过自动重传请求（Automatic Repeat reQuest，ARQ）方式进行重传出错的帧。具体做法是：发送方的帧中包含一定CRC冗余码一并发送，接收方根据检错码对帧进行验证，错误就丢弃，发送方超时而重传，这种方法叫ARQ，只需要回复少量的控制信息就可以确定帧是否正确接收。<br>③帧错误包括丢失，重复，失序等，在链路层引入定时器和编号机制，超时或者编号缺少则重传，保证每帧都能传到目的结点。<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2>数据链路层为啥组帧——出错时只重发出错的帧而不是全部数据，提高效率。为了能够监测错误，必须依照一定规则把网络层的分组组帧。组帧解决帧定界，帧同步，透明传输等问题，有四个方法组帧：</li><li>字符计数法：帧头部有一个计数字段，缺点：如果头部出错就失去了帧边界，无法判断结束和下一个帧开始，直接失去同步，造成灾难性后果。</li><li>字符填充的首尾定界法：特殊字符定界开始和结束，数据中如果出现结束符，则在前边加上一个标识符比秒结束，接收方遇见标识符删去即可得到原来数据。 <img src="/2022/050135078/2.jpg" class=""> </li><li>零比特填充的首尾标志法：还能进行透明传输，如图：  <img src="/2022/050135078/3.jpg" class=""> </li><li>违规编码法：物理层进行比特编码的时候常用违规编码法，借用违规的编码序列来标志开始和结尾，不需要任何填充技术，便实现透明传输，只适用于冗余编码的特殊编码环境。  </li><li>目前常用比特填充和违规编码法。<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2>实际通信传输中可能产生比特差错，通常利用编码技术进行差错控制，主要有两类：自动重传请求ARQ和前向纠错FEC。在ARQ中接收端检测出错的时候通知重发直到正确，FEC中可以确定比特串错误位置进行纠正，因此可以分为检错编码和纠错编码。</li><li>检错编码：检错编码都是采用荣誉编码技术，核心思想就是在有效数据发送前按照某种关系附加一定冗余位，构成一个符合某规则的码之后再发送，当发送数据发送变化的时候，相应冗余位也变化，常见的有奇偶校验码和循环冗余码。<br>①奇偶校验码：由n-1位信息元和1位校验元组成，如果是奇校验码则n个码字中1的个数为奇数，偶校验码则为偶数。只能校验是否出错，不知道出错情况。<br>②循环冗余码：CRC，熟练掌握计算过程！！！给定一个m位的帧/报文，发送器生成一个r位的序列称为帧检验序列FCS，形成的帧由m+r位组成，事先双方商定一个G（x）作为检验，可以被整除无余数即可认为无差错。（其实CRC有纠错功能，但链路层没用到）</li><li>纠错编码：最常见的就是海明威码，熟练掌握计算过程！！！原理是有效信息位中加入几个校验位形成海明码，并且把海明码的每个二进制位分配到几个奇偶校验组中，当某一位出错之后会引起有关的几个校验位的值发生变化，不但能发现错位还能找到其位置，为自动纠错提供依据。<h2 id="流量控制与可靠性传输机制"><a href="#流量控制与可靠性传输机制" class="headerlink" title="流量控制与可靠性传输机制"></a>流量控制与可靠性传输机制</h2></li><li>流量控制，可靠传输与滑动窗口机制：<br>①流量控制对帧的发送速率，以便接收方有足够的缓冲空间来接收每个帧。基本方法由接收方控制发送方发送速率，常见方法有两种：停止-等待协议和滑动窗口协议。<br>②停止-等待协议：基本原理就是发送方每发送一帧都要等待接收方应答才发送下一帧，接收方同理，不反馈则会一直等待，因此效率很低。<br>③滑动窗口协议： 在任意时刻，发送方都维持一组连续的允许发送的帧的序号，为发送窗口，同理接收方的接收窗口。而发送窗口大小指的是接收方未发送确认信息前还能发送多少个数据帧。同时接收窗口只有收到数据帧序号落入接收窗口内才能把帧收下，窗口外直接丢弃。同时发送方每收到一个确认帧就前移一个位置，当发送窗口没有可以发送的帧的时候就停止直到收到确认，接收方也是收到数据帧之后前移并发回确认帧。<br>滑动窗口特性：<br>只有接收窗口前移，发送窗口才能前移。<br>接收窗口大小为1的时候可以保证帧的有序接收。<br>窗口大小在传输过程中是固定的。<br>④可靠传输机制：经常使用确认和超时重传两种机制完成，ARQ就是处理差错的方法之一，常见ARQ有：停止等待ARQ，后退N帧ARQ，选择性重传ARQ。在数据链路层中，流量控制和可靠性传输交织在一起。  <img src="/2022/050135078/4.jpg" class="">  <img src="/2022/050135078/5.jpg" class="">  </li><li>单帧滑动窗口和停止等待协议：<br>①停止等待是发送和接收窗口均为1的滑动窗口，单帧。<br>②除了数据帧丢失之外，还存在两种差错：帧遭到破坏和数据帧正确确认帧错误。<br>③帧遭到破坏被检测出来之后丢弃，发送方有计时器，长时间未接到确认就重复发送直到成功。<br>④信道利用率太低，所以产生了后退N帧协议和选择重传协议。<img src="/2022/050135078/6.jpg" class="">  </li><li>多帧滑动窗口和后退N帧协议（GBN）：<br>①发送方无须收到上一个帧确认才发送下一个帧，而是可以连续发送，当接收方检测到失序的帧时要求发送方发送最后一个正确接收的帧和之后的所有未被确定的帧，也就是————接收方只能按照顺序接收帧。<br>②为了节省开销，接收窗口并不是接到一个帧就确认一个，而是几个帧再确认，说明最后一个帧之前的所有帧都收到了。<br>③接收窗口=1，保证按顺序接收帧，提高信道利用率，但重传有时候把自己传输正确的帧也重传了，这种做法又使得传输效率降低，所以信道质量差的时候效率不一定比停止等待协议高。</li><li>多帧滑动窗口和选择重传协议（SR）：<br>①为了提高信道利用率，设法只重传出错的数据帧/计时器超时的数据帧，但必须加大接收窗口大小，以便先收下发送序号不连续但仍在接收窗口中的那些帧，等到所缺的帧收到之后再一并送交主机。<br>②每个发送缓冲区对应一个计时器，超时就会把缓冲区内重传。接收和发送窗口大小均&gt;1，一般来说大小相同，使用累计确认的方法。<br>③SR确实避免了重传正确的帧，但需要在接收方缓冲区存储正确的帧，缓冲区的数目大小等于窗口的大小。</li><li>从滑动窗口概念来看，停止等待协议的发送窗口大小=1，接收窗口大小=1。后退N帧协议的发送窗口大小&gt;1，接收窗口大小=1。选择重传协议的发送窗口大小&gt;1，接收窗口大小&gt;1。 <h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2>介质访问控制为了使用介质每个结点隔离来自同一信道其他结点传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制层子层（Medium Access Control，MAC）。若干结点如果使用同一个信道可能会相互干扰。常见方法有：信道划分介质访问控制（静态划分方法），随机访问介质访问控制（动态划分方法），轮询访问介质访问控制（动态划分方法）。</li><li>信道划分介质访问：<br>①将使用介质的每个设备与其他设备通信隔离开，把时域和频域资源合理分配给网络上设备。<br>②多路复用：当介质带宽超过传输单个信号所需要的带宽时，人们通过在一条介质上传输多个传输信号的方法提高信道利用率。采用多路复用技术可以把多个输入通道信息整合到一个复用通道里，接收端把收到的信息分离出来并传送到对应的输出通道。<img src="/2022/050135078/7.jpg" class="">   ③信道划分的实质是分时，分频，分码等方法把原来的一条广播信道逻辑上分为若干条互不干扰子信道，实际是把广播变成点对点信道。<br>④频分多路复用FDM：把信道总带宽划分为单个信号带宽相同的子信道，每个子信道传输一种信号。每个子信道带宽可以不相同，但总和必须小于总带宽，为了防止相互干扰加入“保护频带”，优点就是充分利用带宽，系统效率搞，技术简单实现容易。<br>⑤时分多路复用TDM：时分多路复用把物理信道按照时间分为若干时间片，轮流分配给多个信号使用，每个时间片由复用的一个信号占用，其中STDM是动态分配信道时间（一个用户可以占用全部时间片，效率加倍）。  <img src="/2022/050135078/8.jpg" class=""> ⑥波分多路复用WDM：即光的频分多路复用，波长（频率）不同，互不干扰。<br>⑦码分多路复用CDM：不同编码区分各路原始信号，举个例子：<br>实际上也叫码分多址CDMA，把比特时间划分为m个端的时间槽，称为码片，通常m为64/128。举例m为8，每个站点被指派了一个唯一的m位的码片序列，发送1时站点发送它的码片序列，0时也方该码片序列的反码，当两个站点同时发送的时候，各路数据在信道中线性相加。为了分理出各路信号，要求各个站点码片序列相互正交。优点：频谱利用率高，抗干扰能力强，保密性强等。<img src="/2022/050135078/9.jpg" class=""> </li><li>随机访问介质访问：<br>不采用集中控制方式解决发送信息次序，所有用户都能偶根据自己意愿随机发送信息，占用信道全部速率。总线型网络中，两个或以上用户发送信息的时候产生冲突，为了解决冲突，每个用户需要按照规则反复重传他的帧，直到无碰撞的通过。常用的协议有：ALOHA，CSMA，CSMA/CD，CSMA/CA，核心思想都是胜利者获得权力发送信息，因此又称为挣用型协议。实质上随机访问介质访问把广播信道转化为了点到点信道。<br>①ALOHA协议：<br>又分为两种——纯ALOHA和时隙ALOHA。<br>纯ALOHA：基本思想时当网络中任何一个站点需要发送数据时，可以不经检测直接发送数据，如果在一段时间内未收到确认，那么该站点就认为传输过程中发生冲突，发送站点需要等待一段时间再发送数据，直至发送成功。重传策略则是各站等待随机时间进行重传。但吞吐量低，改进得到时隙ALOHA。<br>时隙ALOHA：把所有站点时间同步起来，把时间划分为登场时隙SLOT，规定只能在每个时隙开始时发送一个帧，避免随意性，减少冲突可能，提高信道利用率。重传策略和ALOHA相似。吞吐量比ALOHA大一倍。<br>②CSMA协议：<br>如果每个站点发送前都侦听一下信道，空闲再发送就大大减少冲突的可能，从而提高信道利用率，载波侦听多路访问（Carrier Sense Multiple Access，CSMA）就是这个思想，比ALOHA多了一个载波侦听装置。而CSMA又分三种：<br>1-坚持CSMA：侦听到信道空闲则发送，忙则继续侦听直到空闲，如果冲突则随机等待一个时间重复上述过程。但传播延迟使得1-坚持CSMA仍然会发生冲突。<br>非坚持CSMA：侦听到信道空闲则发送，忙则放弃侦听，随机等待一个时间重复过程。侦听到忙碌就放弃了，降低了冲突概率。<br>p-坚持CSMA：用于时分信道，侦听到信道空闲则发送，忙则继续侦听直到空闲，空闲则有p的概率发送给数据，以1-p的概率推迟到下一个时隙，下一个时隙重复该过程。<img src="/2022/050135078/10.jpg" class="">   ③CSMA/CD协议：<br>载波侦听多路访问/碰撞检测（Carrier Sense Multiple Access with Collision Detection，CSMA/CD）是CSMA改进方案，适用于总线型网络/半双工网络，而碰撞监测则是边发送边侦听，判断是否其他站点也在发送数据。工作过程概括为“先听后发，边听边发，冲突停发，随机重发”————只能半双工通信，不能同时收发。<br>为了确保发送数据同时监测是否碰撞，需要发送之前就能收到自己发送出去的数据，即帧传输时延至少两倍于信号在总线上的传播时延，才能保证无碰撞，所以CSMA/CD总线中所有数据帧都需要大于一个最小帧长，小于最小帧长当作无效帧丢弃（非要发就需要填充字段到最小帧长），最小帧长=总传播时延X数据传输速率X2。<br>除此之外，CSMA/CD冲突之后采用退避算法解决碰撞问题，第k次重传，就从0-2的k次方-1之间抽随机数，随机数乘以争用期得到重传的时间。该算法求出的时间随着重传时间增大而增大，降低发生碰撞概率。  <img src="/2022/050135078/11.jpg" class=""> ④CSMA/CA协议：<br>CSMA/CD协议已经成功用于有线连接局域网。无线网中并不适用，所以802.11标准则定义了CSMA/CA，其中CA为Collision Avoidance碰撞避免，尽量避免碰撞发生。为了尽量避免，802.11规定所有站发送完之后必须等一段时间才发送下一帧，称为帧间间隔（InterFrame Space,IFS），其长短取决于帧类型，有三种：SIFS(短IFS)，PIFS（点协调IFS），DIFS（分布式协调IFS）。<br>⑤CSMA/CA与CSMA/CD区别：<br>CSMA/CD可以监测冲突但没法避免，CSMA/CA尽量避免但有可能冲突。<br>传输介质不同：CSMA/CD用于总线型以太网，CSMA/CA用于无线局域网802.11 a/b/g/n等。<br>监测方式不同：CSMA/CD通过电缆中电压变化监测，而CSMA/CA通过能量监测，载波监测，能力载波混合监测三种监测方式。<br>总结：CSMA/CD基本思想先侦后发，边发边侦，而CSMA/CA则是发送前先广播告知其他结点短时间内别发数据，以免出现碰撞。  </li><li>轮询访问介质访问控制：令牌传递协议<br>①用户不能随机发送信息，而是通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道分配，信道只有一个结点使用。 典型的就是令牌传递协议——用于令牌环局域网中。<br>②令牌传递协议中，令牌以固定次序交换，它是一组特殊比特组成的帧。环上的站希望传送帧时必须等令牌，收到令牌即可发送数据。令牌上包括目的地址，标示这哪个站点接收，令牌在环上进行传送。不需要发送数据的时候，令牌就在环形网上游荡，令牌只有一个，不会冲突。网络中物理拓扑不是一个环，逻辑上是一个环，适合负载高的广播信道，用其他的协议则会冲突概率很大，没有共享空间和时间。<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h3>①局域网（Local Area Network，LAN）指的是较小的地理范围内，把各种计算机，外部设备，数据库系统通过双绞线，同轴电缆等介质相互连接起来，组成资源和信息共享的计算机互联网络。<br>②特点：<br>一个单位所拥有，地理范围站点数目有限。<br>所有站点共享较高的总带宽。<br>较低的时延和较低的误码率。<br>各站为平等关系而非主从关系。<br>能进行广播和组播。<br>③拓扑结构，传输介质，介质访问控制方式决定了局域网技术特性。<br>拓扑结构有：星形结构，环形结构，总线型结构，星型和总线型复合结构。<br>传输介质有：双绞线，铜缆，光纤等，双绞线为主流。<br>介质访问控制方式有：CSMA/CD，令牌总线，令牌环，前两种方式用于总线型，后一种为环形局域网。<br>④三种特殊局域网：<br>以太网：目前适用范围最广局域网，逻辑拓扑总线形结构，物理拓扑是星型/拓展星型。<br>令牌环：逻辑拓扑环形结构，物理拓扑是星型。<br>FDDI：逻辑拓扑环形，物理拓扑是双环形。<br>IEEE 802标准把数据链路层拆为两个子层逻辑链路控制层LLC和媒体接入控制层MAC。其中与接入传输媒体有关内容都在MAC，它向上屏蔽物理层访问差异，提供对物理层同意统一接口，主要功能有：组帧和拆卸帧，比特传输差错检测，透明传输，而LLC向网络层提供无确认无连接，有确认无连接，有确认有连接，告诉传送四种不同连接服务。<h3 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h3>以太网采用总线型拓扑结构，所有计算机共享总线，信息以广播形式发送，以太网简化CSMA/CD进行访问控制。802.3局域网简称以太网。以太网采用两种方式简化通信：①采用无连接工作方式，不可靠服务，纠错由上层完成。②使用曼彻斯特编码，每个码元中间出现一次电压转换，利用其提取出来同步信号。<br>①以太网传输介质与网卡：<br>常用传输介质由粗缆，细缆，双绞线，光纤，各种介质适用情况见下表：  <img src="/2022/050135078/12.jpg" class=""> 计算机与局域网连接通过主机箱内插入的一块网络接口板（网络适配器Adapter或网络接口卡NIC），网卡上有处理器和存储器，工作在链路层的组件。网卡不仅实现与传输介质之间的物理连接和电信号匹配，还涉及到帧的发送和接收，帧的封装和拆封，介质访问控制，数据编码与解码，数据缓存等功能。每块网卡有一个独一无二的介质访问控制地址（MAC地址），数据链路层都是用MAC地址。<br>②以太网的MAC帧：<br>也称物理地址，长度为6字节，由12个16进制数表示。由于使用总线广播，则检查MAC帧，符合就接收否则丢弃。帧格式有两种：DIX Ethernet V2标准和IEEE 802.3标准。<br>Ⅰ：DIX Ethernet V2标准：<br>前导码：使接收端和发送端时钟同步，在帧前面插入的8个字节可以再分为两个字段，一个字段7字节为前同步码，第二个是帧开始定界符，表示后边的信息是MAC帧。<br>地址：通常使用6字节地址MAC地址。<br>类型：2字节，指出数据应该用哪个协议实体处理。<br>数据：46-1500字节，包含高层协议信息，由于CSMA//CD协议长度限制最小为64，不够需要填充。（64-18=46，首尾共18字节）<br>填充：0-64字节。<br>校验码FCS：4字节，范围从目的地址段到数据末尾，采用32位CRC码，不但检验MAC帧数据部分，还有目的地址，源地址，类型字段，但不校验前导码。 <img src="/2022/050135078/13.jpg" class="">  Ⅱ：IEEE 802.3标准：不同之处就是长度域代替了DIX帧中的类型域，指出数据域长度。<br>③高速以太网：<br>速度超过100Mb/s的以太网。有三种：<br>Ⅰ： 100BASE-T以太网：双绞线上传送100Mb/s基带信号的星形拓扑结构以太网，使用CSMA/CD协议，全双工/半双工均可，全双工不用CSMA/CD。<br>Ⅱ：吉比特以太网：1G/s下全双工/半双工工作，半双工使用CSMA/CD。<br>Ⅲ：10吉比特以太网：10G/s下使用光纤作为传输媒体，只全双工。  <h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3>无线局域网分为两类：有固定基础设施无线局域网和无固定基础设施移动自组织网络。<br>①有固定基础设施无线局域网：<br>对于有固定基础设施，IEEE指定了802.11系列协议标准。802.11使用星形拓扑，中心称为接入点（Access Point，AP），MAC层使用CSMA/CA协议，又称Wi-Fi。<br>无线局域网最小构件是基本服务集BSS（Basic Service Set，BSS），包括一个基站和若干移动站，BSS内部之间通信，外部则通过基站通信，AP就是基站，安装AP时需要给它分配一个不超过32字节的服务集标识符SSID和一个信道，一个BSS覆盖范围称为一个基本服务区BSA，一般不超过100m。<br>一个基本服务区BSA可以独立，也可以通过AP连接到一个分配系统DS，然后连接到另一个基本服务集，构成扩展的服务集ESS，通过一种叫做Portal（相当于网桥）的设备为无限用户提供有线连接的以太网接入。如图，A想要连接B则经过AP1和AP2即，A-&gt;AP1-&gt;AP2-&gt;B，注意AP1和AP2是有线传输。  <img src="/2022/050135078/14.jpg" class=""> ②无固定基础设施移动自组织网络：<br>又叫做自组网络，一些平等状态的移动站相互动心组成的临时网络，各节点地位平等，中间结点为转发结点，都有路由器的功能。<br>通常可移动设备发现附近有其他可移动设备，要求进行通信，网络中每个移动站都参与其他移动站的路由的维护和发现。  <h3 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h3>令牌环网每一站都通过电缆与环接口干线耦合器TCU连接（TCU为了传递所有经过的帧，为介入站发送接收数据提供接口，有收听状态和发送状态），数据总在一个方向上从一个TCU到另一个TCU传输。只有一个结点独占信道，不发生碰撞，令牌Token就是一个数据帧。<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3>覆盖范围广的长距离网络，是因特网核心部分。因此连接广域网结点的交换机为高速链路，且容量足够大便于以后扩充。广域网不等于互联网（互联网可以连接不同类型网络，使用路由器），广域网是由结点交换机和连接交换机的链路组成。（交换机不是路由器，结点交换机和路由器均转发分组，而交换机在单个网络中转发，路由器则是多个网络构成的互联网中转发），交换机存储转发分组，一个交换机与多个相连。<br>局域网和广域网区别于联系：  <img src="/2022/050135078/15.jpg" class=""> <h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3>①Point-to-Point Protocol,是使用串行线路通信的的面向字节的协议，直接应用在两个结点的链路上，目的通过拨号/专线来建立点对点连接发送数据，使其称为各种主机，网桥，路由器之间简单连接的共同解决方案。<br>②由SLIP协议发展来的，异步同步线路均可，而SLIP主要完成数据包传送，只能传输IP分组，且对于高层应用不支持，为了改进指定了PPP。<br>③三个部分组成：<br>链路控制协议LCP：用于建立，配置，测试，管理数据链路。<br>网络控制协议NCP：PPP允许多种网络层协议，不同网络层协议对应一个不同NCP配置，为网络层协议建立和配置逻辑连接。<br>一个把IP数据包封装到串行链路的方法：IP数据报就是在PPP帧中的信息部分，长度收到MTU限制。<br>④PPP帧格式如图：PPP面向字节的，所以帧长度都是整数个字节。  <img src="/2022/050135078/20.jpg" class="">  ⑤PPP提供差错监测但没有纠错，只保证无差错接收，不可靠的传输协议，不使用序号和确认机制。仅支持点对点链路通信。只支持全双工链路。不同网络协议仍然可以使用一个PPP通信（帧上有协议字段）<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3>①高级数据链路控制协议，是ISO面向比特指定的数据链路层协议，它不依赖任何一种字符集编码，数据包可以透明传输，全双工通信，采用CRC检验，对于信息帧进行顺序编号防止漏发重发。适用于链路的两种配置：非平衡配置（由一个主站控制整个链路）和平衡配置（若干平等站相互传输）。<br>②站：HDLC有三种站类型：主站，从站，复合站。主站负责控制链路，发出的帧为命令帧。从站受控于主站，发出的帧为响应帧。复合站综合二者，发出帧可以是命令也可以是响应帧。<br>③数据操作方式：<br>正常响应方式：非平衡方式，主站传输，从站接收，但从站只有得到主站许可才能进行响应。<br>异步平衡方式：平衡方式，每个复合站都可以对其他站进行传输数据。<br>异步响应方式：非平衡，从站即使未接收主站许可仍然可以进行响应。<br>④HDLC帧：如图：  <img src="/2022/050135078/16.jpg" class=""> ⑤PPP和HDLC帧的区别：<br>PPP面向字节，HDLC面向比特。<br>PPP比HDLC多一个2字节的协议字段，当字段为0x0021时信息字段为IP数据报。<br>PPP不使用序号和确认机制，不可靠，由高层协议负责。而HDLC使用了，可靠。  <h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥概念及其基本原理"><a href="#网桥概念及其基本原理" class="headerlink" title="网桥概念及其基本原理"></a>网桥概念及其基本原理</h3></li><li>两个或者多个以太网通过网桥连接称为一个覆盖更大的以太网，原来一个以太网称为一个网段，网桥工作在MAC子层，可以使得以太网个网段称为隔离开的碰撞域。”隔离开的互不影响“。  （网桥处理帧所以是数据链路层，中继器放大器处理信号所以是物理层）  </li><li>一个网段内部发送帧直接发送，而不同网段才通过网桥，需要验证MAC地址是否是内部。每个网段数据率为10Mb/s，三个网段的最大吞吐量就是30Mb/s，换成放大器就是10Mb/s。  </li><li>基本特点：<br>①具备寻址和路径选择的能力，确定帧传输方向。<br>②从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧。<br>③网桥连接不同网络之间存储并且转发帧，可以使用不同协议，进行协议转换。<br>④网桥对于帧不做修改/少量修改，单纯转发。<br>⑤网桥应该有足够大缓冲空间，因为在短时间内帧到达速率可能高于转发速率。  </li><li>优点：<br>①过滤信息量。<br>②扩大物理范围。<br>③可以使用不同物理层。<br>④可以互联不同局域网。<br>⑤提高可靠性。<br>⑥性能改善。  </li><li>缺点：<br>①增大了时延。<br>②MAC子层没有流量控制功能。<br>③不同MAC子层的网段连接的时候需要进行帧格式转化。<br>④网桥适合用户不多，通信量不大的居于发，否则有可能网络拥塞。</li><li>网桥必须有路径选择功能，选择正确路径，根据路径算法不同分为透明网桥和源路由网桥。<br>①透明网桥：接收每一个帧，若是源LAN和目的LAN一样则丢弃该帧，不一样则转发该帧，若目的LAN位置则扩散该帧（扩散给输入网段外的所有网段）。刚连接进以太网转发表为空，逐渐建立转发表。使用一个生成树算法得到若干路径，但不一定是最佳路由。<br>②源路由网桥：路由选择由发送数据帧的源站负责，网桥只负责接收和转发。而源站通过广播方式向目的站发送一个发现帧，途中每个网桥都转发此帧，最后发现该帧可以从多个途径到达目的站，目的站一一发送应答帧，每个应答帧原路返回，途径网桥把自己标记在应答帧中，然后源站选一个最佳路由。  <h3 id="局域网交换机概念及其基本原理"><a href="#局域网交换机概念及其基本原理" class="headerlink" title="局域网交换机概念及其基本原理"></a>局域网交换机概念及其基本原理</h3></li><li>桥接器主要限制在任意时刻只能执行一个帧的转发操作，则出现了交换机。本质上就是多端口网桥，分隔隔离初多个冲突域，各个网段都有更高带宽。  </li><li>原理：监测源和目的地MAC，然后系统内部动态查找表比较，若不在则加入查找表，并发送给相应端口。</li><li>特点：<br>①每个端口都与单台主机连接，工作方式为全双工。<br>②可以同时连接多对端口，每对主机都像独占信道一样无碰撞交换数据。<br>③以太网即插即用（和透明网桥一样），内部帧转发表也是通过自学习逐渐建立起来的。<br>④交换速率高，独占传输媒体的带宽（传统10Mb/s以太网，有N个用户，有N个端口的交换机的总容量为N*10Mb/s）。</li><li>两种交换模式：<br>①直通式 ；只检查目的地址，立马传出去，这种方式速度快但缺乏智能和安全，无法支持不同速率的端口的交换。<br>②存储转发式：先收到帧缓存到告诉缓存器中，检查是否正确，无误则通过查找表转换成为输出端口转发，有错则丢弃。优点是可靠性高，支持不同速率端口之间的转换，缺点就是延迟大。  <h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>链路与数据链路：<br>链路：是物理线路，无结点，路径的组成部分。<br>数据链路：除了物理线路还有一些通信协议控制数据传输。</li><li>局域网，广域网，因特网总结：<br>广域网视为大局域网，就是交换机连接多个局域网组成广域网，但仍是一个网络。而因特网则是多个网络之间的互联，由广域网和局域网通过路由器相连。</li><li>冲突域和广播域：<br>一块网卡发送信息只要可能与另一个冲突，则可能冲突的网卡构成冲突域，而一块网卡发送广播，所有能接到的网卡就是广播域。一般来说，一个网段就是冲突域，一个局域网就是广播域。  <img src="/2022/050135078/17.jpg" class=""> <img src="/2022/050135078/18.jpg" class=""> <img src="/2022/050135078/19.jpg" class=""> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络物理层</title>
      <link href="/2022/050114293.html"/>
      <url>/2022/050114293.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络物理层"><a href="#计算机网络物理层" class="headerlink" title="计算机网络物理层"></a>计算机网络物理层</h1><img src="/2022/050114293/7.jpg" class=""><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>数据，信号与码元：<br>1.数据指的是传送信息的实体，连续变化的数据为模拟数据，离散的数据为数字数据，且可以并行/串行传输数据。<br>2.信号是数据的电气/电磁表现形式，数据传输过程中表现形式。<br>3.码元是用一个固定时长的信号波形表示一个k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，时长成为码元宽度。</li><li>信源，信道，信宿：<br>1.一个数据通信系统由这三部分组成。<br>2.信源：产生发送数据的源头，<br>3.信宿：接收数据的终点。<br>4.信道：和电路不等同，信道是信号的传输媒介，可以看作线路的逻辑媒介，一般一个通信线路都有一个发送信道和一个接收信道。信道根据传输信号不同分为模拟信道和数字信道，按传输介质不同分为无线和有线信道。<br>5.信道上传输的信号有基带信号和宽带信号之分。<br>基带信号是用1和0不同电压表示，送到数字信道上传输——基带传输。<br>宽带信号是把基带调制形成频分复用模拟信号，送到模拟信道上传输——宽带传输。<br>6.三种通信交互方式：单向通信（一条信道），半双工通信（两条信道，不能同时发送和接收），全双工通信（两条信道，能同时发送和接收）。  <img src="/2022/050114293/1.jpg" class="">  </li><li>速率，波特和带宽：<br>1.速率：数据传输率，单位时间传输数据量，可以用·码元传输速率表示（波特率，单位时间内数字通信系统所传输的码元个数，单位是波特，进制不定），也可用信息传输速率表示（信息速率，比特率，单位时间内数字通信系统所传输的码元个数，二进制）。<br>2.带宽：通信线路所能传输数据的能力，“最大速率”，单位为b/s。<h3 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h3></li><li>奈奎斯特定理：<br>1.具体信道能够通过的频率范围有限，信号中许多高频分量往往不能通过信道，否则传输中会衰弱，导致接收端收到的信号波形失去码元之间的清晰界限，这种现象成为码间串扰。<br>2.奈奎斯特定理规定——理想低通信道中，为了避免码间串扰，极限码元传输速率为2W波特，其中为理想低通信道带宽，若用V表示每个码元离散点评的数量（即多少种不同码元，16个码元就有4个二进制位表示，则数据传输速率是码元的4倍），则极限数据率=2W*log2(V)。<br>结论：<br>①任何信道码元传输速率有上限，超过上限就会出现严重的码间串扰，接收端不能完全正确识别码元。<br>②信道频带越宽，就可以用更高的速率进行码元的有效传输。<br>③奈奎斯特定理给出了码元传输速率限制，但并未对于信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。<br>④所以要使得每个码元带更多的比特量，多元制的调制方法。</li><li>香农定理：<br>1.香农定理给出了带宽受限且有着高斯白噪声干扰的信道的极限数据传输速率，当使用该速率传输时可以不产生误差，则极限数据率=W*log2(1+S/N),W为信道带宽，S为信道传输信号平均功率，N为信道内高斯噪声功率，S/N为信噪比。<br>结论：<br>①信噪比越大，极限传输速率越高，信噪比确定时信息传输速率上限一定。<br>②只要信息传输速率低于上限，就一定有方法实现无差错传输。<br>③香农定理给出的是传输速率上限，实际信道比它低不少。<h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3></li><li>数据无论是数字还是模拟都需要变成信号才能进行传输，则数据变换为模拟信号的过程称为调制，变为数字信号的过程称为编码。  </li><li>数字数据通过数字发送器转换成数字信号，也可通过调制器转换成模拟信号。  </li><li>模拟数据通过POM编码器转换成数字信号，也可通过放大器调制器转换成模拟信号。  </li><li>所以产生了四种编码方式：<br>1.数字数据编码为数字信号：<br>用于基带传输，即不改变信号频率之间传输数字信号，只要把1和0区分开即可，有多种编码方式：①归零编码RZ，②非归零编码NRZ，③反向非归零编码NRZI，④曼彻斯特编码，⑤差分曼彻斯特编码，⑥4B/5B编码。  <img src="/2022/050114293/2.jpg" class="">   2.数字数据调制为模拟信号：<br>数字数据调制技术在发送端把数字信号转换为模拟信号，在接收端将模拟信号还原为数字信号，对应调制解调器的调制和解调过程，基本有如下几种：①幅移键控ASK，②频移键控FSK，③相移键控PSK，④正交振幅调制QAM。<br>3.模拟数据编码为数字信号：<br>经典例子就是音频信号的脉码调制PCM，包括采样，量化，编码三个步骤。<br>4.模拟数据调制为模拟信号：<br>为了实现传输有效性，可能需要较高频率，这种调制方式可以用频分复用FDM。  <h3 id="电路交换，报文交换，分组交换"><a href="#电路交换，报文交换，分组交换" class="headerlink" title="电路交换，报文交换，分组交换"></a>电路交换，报文交换，分组交换</h3></li><li>电路交换：<br>①定义：两节点之间必须建立一条专用的物理通信路径，路径在整个数据传输期间被这两个结点独占，直到通信结束才被释放，因此有三个阶段：连接建立，数据传输，连接释放。以直通的方式发送接收数据，不存在存储转发消耗时间。<br>②优点：<br>通信时延小（线路两节点专享）<br>有序传输<br>没有冲突（各自有不同信道）<br>适用范围广（数字模拟信号均可传输）<br>实时性强（连接建立立即可传输）<br>控制简单<br>③缺点：<br>建立连接时间长<br>线路独占<br>灵活性差<br>难以规格化  </li><li>报文交换：<br>①定义：数据交换单位是报文，带有目标地址，源地址等信息，报文交换在交换节点采用的是存储转发的传输方式。<br>②优点：<br>无须建立连接<br>动态分配线路（发送方把报文交给交换设备，先存储整个报文再选择空闲线路发送报文），提高线路可靠性<br>提高线路利用率<br>提供多目标服务（一个报文多个目的地址）。<br>③缺点：有转发时延（报文先存储再转发）<br>对于报文大小没有限制导致网络节点应该有较大的缓存空间。  </li><li>分组交换：<br>①定义：也是存储转发，但解决了大报文的问题，限制了数据块上限，把大数据块划分成为小数据块加上必要的控制信息（两个地址+编号信息等）构成了分组Packet，中间结点接受分组存储并且排队，根据分组选择下一个结点，直到到达目的结点。<br>②优点：<br>无建立时延<br>线路利用率高<br>简化了存储管理（比报文交换，因为数据块固定所以缓冲区固定，简化了缓冲区的管理）<br>加速传输（分组是逐个传输的，一个分组存储和前一个分组转发是并行的，减少了传输时间）<br>减少出错概率和重发数据量（分组更短，出错概率小，所以重发数据量减少，提高可靠性减少了时延）<br>③缺点：<br>存在传输时延<br>需要传输额外信息量（每个块都有源地址和目的地址，分组编号等，从而构成分组，信息量提高了）<br>当分组交换使用数据报网络的时候可能失序，丢失，重复等，所以分组到达目的地址的时候需要排序等工作，但使用虚电路服务的时候还要建立连接三个过程。</li><li>三个数据交换方式比较：<br>①数据量大且传送时间远远大于建立连接时间的时候使用电路交换。<br>②端到端通路由多段链路组成时，采用分组交换。<br>③报文交换和分组交换的信道利用率高于电路交换，其中分组交换比报文交换时延小，尤其适合计算机之间突发通信。  <img src="/2022/050114293/3.jpg" class="">  <h3 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h3><img src="/2022/050114293/6.jpg" class="">   分组交换进一步分为面向连接的虚电路方式和无连接的数据方式，都由网络层提供。</li><li>数据报：<br>①网络层加上控制信息形成数据报分组，中间结点存储分组之后找到最佳路由，尽快转发分组，分组可以不同路径，也可以不同顺序，只需要找当前状态下分组最合适的路由转发即可。<br>②特点：<br>发送分组之前不需要建立连接。<br>网络尽最大努力交付，不保证可靠性，有可能丢失，乱序。<br>分组要包含发送端和接收端的完整地址，便于独立运输。<br>分组在存储转发过程中需要排队处理，网络拥塞的时候排队的时延大大增加，还可能丢失分组。<br>网络中具有冗余的路径，当某结点/链路发生故障的时候相应更新转发表，从另一条路径转发，对于故障适应性强。<br>存储转发时延一般较小，提高了网络吞吐量。<br>收发双方不独占某条链路，资源利用率高。  <img src="/2022/050114293/4.jpg" class="">  </li><li>虚电路：<br>①虚电路尝试把电路交换和数据报方式结合起来，分组发送之前先建立连接，一旦连接建立，路径就是固定的，总过程还是三个阶段。每次建立虚电路时，选择一个未用过的虚电路号分配，在传送数据的时候，分组不仅要有分组号，校验等控制信息，还要有虚电路号，且虚电路网络中每个结点都有一个虚电路表，包括接收链路，发送链路上的虚电路号，前一个结点和后一个结点的标识。<br>②特点：<br>通信链路建立拆除需要时间开销，短时间浪费，长时间效率高。<br>虚电路路由选择体现在建立链路的时候，建立完成就完成了路由选择，只有一条路径。<br>虚电路可靠，分组正确有序到达，且有流量控制。<br>虚电路路径中某个结点/链路故障时所有经过该结点/链路的虚电路都会被破坏。<br>分组首部不包括目的地址，包含的是虚电路标识符。<br>虚电路中的“虚”体现在，这条物理链路不是独占的，而是逻辑上一条独占的链路，两个端系统之间有不同的进程可能也存在不同的虚电路。 <img src="/2022/050114293/5.jpg" class="">  <h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2>传输介质也叫传输媒体，是数据传输系统中发送设备和接收设备之间的物理通路，分为导向和非导向传输介质。<h3 id="双绞线，同轴电缆，光纤，无线传输介质"><a href="#双绞线，同轴电缆，光纤，无线传输介质" class="headerlink" title="双绞线，同轴电缆，光纤，无线传输介质"></a>双绞线，同轴电缆，光纤，无线传输介质</h3></li><li>双绞线：TP，两根相互校合的铜导线，还有屏蔽双绞线STP，非屏蔽双绞线UTP。价格便宜，局域网和传统电话中常见，带宽取决于铜线粗细和传输距离</li><li>同轴电缆：由内导体，绝缘层，网状编制屏蔽层和塑料外层构成，有50欧的基带同轴电缆——局域网，75欧的宽带同轴电缆——电视。</li><li>光纤：光导纤维传递光脉冲来通信，容量大，传输损耗小，远距离传输经济，抗雷电电磁性能好，无串音干扰，体积小重量轻。  </li><li>无线传输介质：有无线电波（穿透力强，距离长，无需方向对准），微波，红外线，激光<h3 id="物理层接口特征"><a href="#物理层接口特征" class="headerlink" title="物理层接口特征"></a>物理层接口特征</h3></li><li>物理层考虑如何把连接计算机的媒体上传输比特流，而硬件设备和传输介质种类繁多且通信方式也有差异，物理层尽可能屏蔽差异。  </li><li>物理层主要任务是确定与传输媒体的接口有关的特性：<br>①机械特性：指定接口所用接线器形状，尺寸，引脚数量和排列，固定和锁定装置等。<br>②电器特性：指定在接口电缆各条线上出现的电压范围。<br>③功能特性：指定某条线上出现的某一个电平的电压表示何种意义。<br>④过程特性：又称规程特性，指定对于不同功能的各个可能事件的出现顺序。  </li><li>常用的物理层接口标准有：EIA RS-232-C，ADSL，SONET/SDH等<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器repeater"><a href="#中继器repeater" class="headerlink" title="中继器repeater"></a>中继器repeater</h3></li><li>主要功能是把信号整形并放大再转发出去，消除信号经过电缆之后产生的失真和衰弱，使得信号波形和强度达到标准，进而扩大网络传输距离。</li><li>原理是信号再生，有两个端口，一个输入一个输出。而放大器原理是信号放大。</li><li>简单廉价，在物理层工作，中继器两端是同一个局域网，不能连接两个不同速率的局域网。</li><li>理论上中继器无限使用，但现实中不可能，“5-4-3原则”：4个中继器连接5个通信介质中只有3段可以连接计算机。<h3 id="集线器hub"><a href="#集线器hub" class="headerlink" title="集线器hub"></a>集线器hub</h3></li><li>实质是多端口中继器，在网络中只有信号放大和转发作用，目的为了扩大网络的传输范围，而不是信号定向传送，即信号传输的方向固定，是一个标准的共享式设备。  </li><li>集线器不能分割冲突域，所有端口属于一个冲突域，比如10Mb/s带宽的集线器连接8台计算机，每台计算机带宽为10/8=1.25Mb/s。<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li><li>传输媒体不是物理层：传输媒体在物理层下面，传输媒体传输的是信号但不知道信号意味着啥，物理层识别所传送的比特流。</li><li>基带传输：计算机内部/相邻设备之间近距离传输，不经过调制在信道上直接传输称为基带传输，常用于局域网。</li><li>频带传输：数字信号对于特定频率的载波进行调制，变成适合传送的信号再传输，这叫做频带传输。远距离/无线传输时使用。</li><li>宽带传输：借助频带传输（频分复用），把链路容量分解为&gt;=2个信道，每个信道携带不同信号，就叫宽带传输。所有信道互不干扰发送信号，链路容量大大增加。</li><li>同步异步的理解：同步：通信双方必须线建立同步，即时钟调整同一个频率，双方不停的发送接收比特流，两种同步方法：全网同步和准同步。而异步可以理解为非同步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络体系结构</title>
      <link href="/2022/043050802.html"/>
      <url>/2022/043050802.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><img src="/2022/043050802/9.jpg" class=""> <h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><ul><li>计算机网络是一个将分散的，具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><h3 id="共分三类："><a href="#共分三类：" class="headerlink" title="共分三类："></a>共分三类：</h3></li><li>组成部分：硬件，软件，协议。<br>1.硬件：主机（端系统），通信链路（双绞线，光纤），交换设备（路由器，交换机），通信处理机（网卡）<br>2.软件：实现资源共享的软件和方便用户使用的工具软件（邮件收发，聊天程序等）<br>3.协议：计网核心，“交通规则”规定网络传输数据时所遵循的规范  </li><li>工作方式：边缘部分和核心部分<br>1.边缘部分：主机，用来通信和资源共享<br>2.核心部分：网络和连接网络的路由器，为边缘提供连通和交换</li><li>功能组成：通信子网和资源子网<br>1.通信子网：传输介质，通信设备，网络协议。<br>2.资源子网：资源共享的设备及其软件<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2></li><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><h3 id="共分六类："><a href="#共分六类：" class="headerlink" title="共分六类："></a>共分六类：</h3></li><li>分布范围：<br>广域网WAN，城域网MAN，局域网LAN，个人区域网PAN</li><li>传输技术：<br>广播式网络，点对点网络（区别于是否分组存储转发和路由选择机制）</li><li>拓扑结构：<br>总线形，星形，环形，网状（节点与通信链路的几何关系），也可以互联成为更复杂网络结构</li><li>使用者：<br>公用网，专用网</li><li>交换技术：<br>1.电路交换网络：点对点，建立连接，传输数据，断开连接，传统电话网络。优点：数据直接传送，时延小。缺点：线路利用率低，无差错控制。<br>2.报文交换网络：加源地址和目标地址，封装成为报文段传送。也叫存储转发网络，优点：充分利用线路，一对多多对一，差错控制。缺点：资源开销大，缓冲时延，缓冲区难管理。<br>3.分组交换网络：把数据封装成固定长度数据块，块红加上目的地址和源地址等辅助信息成为分组，以存储-转发传输。优点：报文网络优点+缓冲容易管理，包时延小，现在主流网络的选择。</li><li>传输介质：<br>1.有线：双绞线网络，同轴电缆网络等。<br>2.无线：蓝牙，微波，无线电等。  <h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2></li><li>带宽：bandwidth，单位Hz，表示网络通信线路传输数据能力，“最高数据传输速率”。</li><li>时延：delay，端到端传送总时间，总时延=发送时延+传播时延+处理时延+排队时延。</li><li>时延带宽积：传播时延x信道带宽。</li><li>往返时延：round-trip-time”RTT”,从发送端开始到接收到接收端的确认历经总时延。</li><li>吞吐量：throughput，单位时间内通过某个网络数据量。</li><li>速率：speed，计算机网络上主机在数据信道上传送数据的速率，最高速率为带宽，单位为比特/秒，b/s。  </li><li>信道利用率： 有数据通过的时间/有无数据通过的时间。<h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><h3 id="计算机网络的分层结构"><a href="#计算机网络的分层结构" class="headerlink" title="计算机网络的分层结构"></a>计算机网络的分层结构</h3></li><li>计算机网络各层及其协议的集合就是计算机网络的体系结构。</li><li>每层活动元素成为实体，每层传送的数据单位不同，但都有两部分：数据服务单元SDU和协议控制单元PCI，共同组成协议数据单元PDU。</li><li>从上到下包装,从下到上拆解，n-SDU+n-PCI=n-n-PDU=(n-1)-SDU。</li><li>每层使用下层的服务，服务上层：最底层只提供服务，最高层只面向用户服务，中间层既享受服务也服务上层。</li><li>每层只能调用相邻层接口服务。</li><li>两台主机通信的时候对等层有一条直接信道。<h3 id="计算机网络协议，接口，服务"><a href="#计算机网络协议，接口，服务" class="headerlink" title="计算机网络协议，接口，服务"></a>计算机网络协议，接口，服务</h3></li><li>协议：为网络数据交换建立的规则，标准，约定。控制两个/多个对等实体进行通信的规则的集合，是水平的，不对等实体之间没有协议。包括语法，语义，同步。</li><li>接口：同一个结点内相邻层之间交换信息的连接点，系统内部的规定，n+1层通过访问n层的SAP（服务访问点）来获取服务，每个SAP有自己的地址。</li><li>服务：下层为紧邻的上层提供的功能调用，是垂直的。上下层提供服务的时候有四类原语：请求request，指示indication，响应response，证实confirmation。<br>计算机提供的服务有三种：<br>1.面向连接服务和无连接服务：面向连接必须先建立连接分配资源，结束再释放连接和资源，三个阶段，如TCP，无连接服务只需要直接发送数据，把带目的地的包传送在线路上，不可靠的服务，Best-Effort-Delivery，如IP和UDP<br>2.可靠服务和不可靠服务：可靠指的是有纠错，检错，应答机制，保证正确可靠传输数据，而不可靠是尽量正确可靠，尽力而为的服务。<br>3.有应答服务和无应答服务：是否有接受方接收数据之后向发送方发送应答，文件传输服务就是有应答，WWW就是无应答<h3 id="ISO-OSI与TCP-IP模型"><a href="#ISO-OSI与TCP-IP模型" class="headerlink" title="ISO/OSI与TCP/IP模型"></a>ISO/OSI与TCP/IP模型</h3></li><li>OSI模型：七层，从下到上分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br>低三层为通信子网（为了连接网络的通信设备），传输层承上启下，上三层为资源子网（相当于计算机，完成数据处理）。</li><li>TCP/IP模型：四层，从下到上分别为：网络接口层，网际层，传输层，应用层。  </li><li>两者共同点：都采取分层结构。都基于独立协议栈的概念。都可以解决异构网络的互连（不同厂家计算机互联）</li><li>两者不同点：<br>OSI产生服务，协议，接口概念，与面向对象思想吻合。OSI先产生的模型而没有对应协议，TCP/TP先产生了协议再产生的模型。<br>TCP/IP设计之初就考虑了异构网络的问题，并用IP分层，OSI后来才在网络层中产生子层完成类似IP的功能。<br>OSI支持无连接和面向连接服务，但在传输层只有面向连接服务，而TCP/IP认为可靠性是端到端的问题，网际层仅有无连接，传输层支持两种模式。</li><li>我们折中，综合两个模型来划分五层：物理层，数据链路层，网络层，传输层，应用层。发送方用户给出自然语言通过应用层转化为数据，从上到下层层包装数据，接收方从下到上层层逆向拆解数据把数据提交给用户。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown介绍及使用教程</title>
      <link href="/2022/04296929.html"/>
      <url>/2022/04296929.html</url>
      
        <content type="html"><![CDATA[<h2 id="举个例子解释"><a href="#举个例子解释" class="headerlink" title="举个例子解释"></a>举个例子解释</h2><p> 大部分作家都是用 Word 或 Pages 写作，过去的文档也大都以微软的 .doc, .docx 格式或是苹果的 Pages 格式储存。还有人为了保证文稿发给谁都能正常打开，会用 .txt 格式。但是.doc 或 Pages 格式有如下问题：</p><p>1.不一定谁都能打开。用 Windows 的人打不开苹果的 .pages 文件，用旧版 Word 的人不一定能打开你用新版 Word 写的稿子。</p><p>2.对方看到的稿子的样子和你自己看到的可能差别很大。</p><p>3.大部分人电脑上的Office都是盗版的，使用时很容易出问题。</p><p>4.用.txt 写的稿子没有格式，这就给编辑你文章的人带来困扰了。</p><h2 id="这就是-Markdown-登场的时候了"><a href="#这就是-Markdown-登场的时候了" class="headerlink" title="这就是 Markdown 登场的时候了"></a>这就是 Markdown 登场的时候了</h2><p>Markdown 的优点如下： </p><ul><li><p>纯文本，所以兼容性极强，可以用所有文本编辑器打开。<br>兼顾了「什么人都能打开」和「样式」。Markdown 就是纯文本，就是 .txt，所以什么人都能打开。而如上所述，你可以用它来标记文本的样式，而且语法非常简单。<br>由于是纯文本，Markdown 文稿也不会因为未来软件升级而产生不同版本之间的兼容问题，即，不会出现「我这篇稿子是用旧版 Word 写的，你用新版 Word 看可能格式会有点问题」的情况。</p></li><li><p>让你专注于文字而不是排版。</p></li><li><p>格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。</p></li><li><p>Markdown 转 HTML 非常方便。HTML 是整个万维网（web）的标记语言，但更重要的是，它也是目前主流电子书格式所用的标记语言。无论是 EPUB, mobi，还是 Kindle 用的专有格式 .azw，都只是把一堆 HTML 文件打包而已。如果你写的是书，用 Markdown 标注格式之后，可以很方便地转为以上格式（当然这个转换工作不需要由你来做）；如果你写的是单篇的文章（例如新闻报道或专栏），未来也不排除结集出书的可能。若采用 Markdown，对于日后的文件转换工作也大有裨益。如何开始用 Markdown？继续用你习惯的写作软件即可。记事本、Word、Pages 都没问题，但请记得存成纯文本格式。就这么简单。</p></li><li><p>Markdown 的标记语法有极好的可读性。</p></li></ul><p>插入链接: </p><ul><li><a href="https://www.jianshu.com/p/7771794c88a1?msclkid=1fb103a8c7b611eca8bd8cd73728089a#%E8%BD%AC%E6%8D%A2%E4%B8%BA-HTML-%E6%96%87%E6%A1%A3">Markdown介绍及使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/265077468?msclkid=7f270e55c7bd11ec9e490cd5ce2b3b96">hexo博客如何插入图片</a><br>插入图片：  </li><li><img src="https://th.bing.com/th/id/OIP.AjQfAi88wTpfm3XCNHUYogAAAA?pid=ImgDet&amp;rs=1" alt="">  </li><li><img src="/2022/04296929/1.jpg" class=""></li><li><img src="/2022/04296929/2.jpeg" class=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/2022/042843699.html"/>
      <url>/2022/042843699.html</url>
      
        <content type="html"><![CDATA[<p>临近保研和课程实训，需要大量复习的专业课和学习新技术，就在此记录我的近期学习计划。</p><h2 id="计算机科学与技术："><a href="#计算机科学与技术：" class="headerlink" title="计算机科学与技术："></a>计算机科学与技术：</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h3><h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h3><h3 id="3-计算机网络"><a href="#3-计算机网络" class="headerlink" title="3.计算机网络"></a>3.计算机网络</h3><h3 id="4-计算机组成原理"><a href="#4-计算机组成原理" class="headerlink" title="4.计算机组成原理"></a>4.计算机组成原理</h3><h3 id="5-计算机科学基本理论"><a href="#5-计算机科学基本理论" class="headerlink" title="5.计算机科学基本理论"></a>5.计算机科学基本理论</h3><h3 id="6-数据库系统"><a href="#6-数据库系统" class="headerlink" title="6.数据库系统"></a>6.数据库系统</h3><h2 id="软件工程："><a href="#软件工程：" class="headerlink" title="软件工程："></a>软件工程：</h2><h3 id="1-软件工程理论"><a href="#1-软件工程理论" class="headerlink" title="1.软件工程理论"></a>1.软件工程理论</h3><h3 id="2-软件测试与质量保证"><a href="#2-软件测试与质量保证" class="headerlink" title="2.软件测试与质量保证"></a>2.软件测试与质量保证</h3><h3 id="3-软件需求分析与系统设计"><a href="#3-软件需求分析与系统设计" class="headerlink" title="3.软件需求分析与系统设计"></a>3.软件需求分析与系统设计</h3><h3 id="4-软件项目管理与过程改进"><a href="#4-软件项目管理与过程改进" class="headerlink" title="4.软件项目管理与过程改进"></a>4.软件项目管理与过程改进</h3><h3 id="5-面向对象基本理论"><a href="#5-面向对象基本理论" class="headerlink" title="5.面向对象基本理论"></a>5.面向对象基本理论</h3><h3 id="6-程序设计基本理论"><a href="#6-程序设计基本理论" class="headerlink" title="6.程序设计基本理论"></a>6.程序设计基本理论</h3><h2 id="数学："><a href="#数学：" class="headerlink" title="数学："></a>数学：</h2><h3 id="1-高等数学"><a href="#1-高等数学" class="headerlink" title="1.高等数学"></a>1.高等数学</h3><h3 id="2-离散数学"><a href="#2-离散数学" class="headerlink" title="2.离散数学"></a>2.离散数学</h3><h3 id="3-概率论"><a href="#3-概率论" class="headerlink" title="3.概率论"></a>3.概率论</h3><h3 id="4-线性代数"><a href="#4-线性代数" class="headerlink" title="4.线性代数"></a>4.线性代数</h3><h2 id="技术："><a href="#技术：" class="headerlink" title="技术："></a>技术：</h2><h3 id="1-springboot"><a href="#1-springboot" class="headerlink" title="1.springboot"></a>1.springboot</h3><h3 id="2-vue"><a href="#2-vue" class="headerlink" title="2.vue"></a>2.vue</h3><h3 id="3-springcloud"><a href="#3-springcloud" class="headerlink" title="3.springcloud"></a>3.springcloud</h3><h3 id="4-redis"><a href="#4-redis" class="headerlink" title="4.redis"></a>4.redis</h3><h3 id="5-部署服务器"><a href="#5-部署服务器" class="headerlink" title="5.部署服务器"></a>5.部署服务器</h3><h2 id="（未完待续）"><a href="#（未完待续）" class="headerlink" title="（未完待续）"></a>（未完待续）</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
